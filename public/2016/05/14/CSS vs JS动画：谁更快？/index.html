<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>my theme</title>
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link type="text/css" href="/css/index.css" rel="stylesheet" />
</head>
<style type="text/css">

</style>
<body>
  <div class="container-fluid">
    <div class="row">
    <div class="col-sm-12">
        <div class="row box-wrapper">
            <div class="col-sm-2 box-date">
                <p>14</p>
                <p>05/2016</p>
            </div>
            <div class="col-sm-10 box-content">
                <h3>
                  <a href="/2016/05/14/CSS vs JS动画：谁更快？/" target="_blank">
                    CSS vs JS动画：谁更快？
                  </a>
                </h3>

                <p>
                  
                      css
                  
                      javascript
                  
                      jquery
                  
                </p>

                <blockquote>
<p>这篇文章翻译自 Julian Shapiro 的 <a href="http://davidwalsh.name/css-js-animation" target="_blank" rel="external">CSS vs. JS Animation: Which is Faster?</a>。Julian Shapiro 也是 <a href="http://julian.com/research/velocity/" target="_blank" rel="external">Velocity.js</a> 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。</p>
</blockquote>
<p>Javascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？</p>
<p>这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。</p>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：</p>
<ul>
<li>jQuery 不能避免<a href="http://wilsonpage.co.uk/preventing-layout-thrashing/" target="_blank" rel="external">layout thrashing</a>（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。</li>
<li>jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易<a href="http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html" target="_blank" rel="external">让动画卡住</a>。</li>
<li>jQuery使用了<code>setInterval</code>而不是 <code>reqeustAnimationFrame(RAF)</code>，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）</li>
</ul>
<p>注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。</p>
<h3 id="实现样例"><a href="#实现样例" class="headerlink" title="实现样例"></a>实现样例</h3><p>为了避免layout thrashing，我们需要批量访问和更新DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentTop,currentLeft; <span class="comment">/* 有 layout thrashing. */</span></span><br><span class="line"></span><br><span class="line">currentTop = element.style.top; <span class="comment">/* 访问 */</span></span><br><span class="line">element.style.top = currentTop + <span class="number">1</span>; <span class="comment">/* 更新 */</span> </span><br><span class="line"></span><br><span class="line">currentLeft = element.style.left; <span class="comment">/* 访问 */</span></span><br><span class="line">element.style.left = currentLeft + <span class="number">1</span>; <span class="comment">/* 更新 */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 没有 layout thrashing. */</span></span><br><span class="line">currentTop = element.style.top; <span class="comment">/* 访问 */</span></span><br><span class="line">currentLeft = element.style.left; <span class="comment">/* 访问 */</span> </span><br><span class="line"></span><br><span class="line">element.style.top = currentTop + <span class="number">1</span>; <span class="comment">/* 更新 */</span></span><br><span class="line">element.style.left = currentLeft + <span class="number">1</span>; <span class="comment">/* 更新 */</span> |</span><br></pre></td></tr></table></figure>
<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>
<p>类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startingTop = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">	<span class="comment">/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */</span>    </span><br><span class="line">	element.style.top = (startingTop += <span class="number">1</span>/<span class="number">60</span>);&#125;, <span class="number">16</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span> (<span class="params"></span>) </span>&#123;    </span><br><span class="line">	element.style.top = (startingTop += <span class="number">1</span>/<span class="number">60</span>);</span><br><span class="line">&#125; </span><br><span class="line">	</span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(tick);</span><br></pre></td></tr></table></figure>
<p>你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。</p>
<h3 id="CSS-Transition"><a href="#CSS-Transition" class="headerlink" title="CSS Transition"></a>CSS Transition</h3><p>CSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：</p>
<ol>
<li>通过优化 DOM 操作，避免内存消耗来减少卡顿</li>
<li>使用与 RAF 类似的机制</li>
<li>强制使用硬件加速 （通过 GPU 来提高动画性能）</li>
</ol>
<p>然而实际上Javascript也可以使用这些优化。<a href="http://www.greensock.com/gsap-js/" target="_blank" rel="external">GSAP</a> 已经做这些优化很久了。<a href="http://velocityjs.org/" target="_blank" rel="external">Velocity.js</a> 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。</p>
<p>面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！</p>
<p>让我们来看看CSS动画库的缺陷吧：</p>
<ul>
<li>Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的<a href="http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/" target="_blank" rel="external">博客</a>谈到过这个问题。</li>
<li>IE 10以下的浏览器不支持transition。而目前IE8和IE9还是<a href="http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share" target="_blank" rel="external">很流行</a>的。</li>
<li>transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。</li>
</ul>
<p>反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。</p>
<blockquote>
<p>我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是<a href="https://github.com/rstacruz/jquery.transit" target="_blank" rel="external">Transit</a>。</p>
</blockquote>
<h3 id="Javascript动画"><a href="#Javascript动画" class="headerlink" title="Javascript动画"></a>Javascript动画</h3><p>所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个<a href="http://julian.com/research/velocity/demo.html" target="_blank" rel="external">3D 动画的demo</a>，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个<a href="http://julian.com/research/velocity/playground.html" target="_blank" rel="external">多媒体小动画</a>，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个<a href="http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs" target="_blank" rel="external">虚拟世界</a>，通常需要canvas才能完成。</p>
<p>为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的<a href="http://velocityjs.org/" target="_blank" rel="external">官方文档</a>。</p>
<p>之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：</p>
<ul>
<li>同步DOM -&gt;在整个动画链中微调堆栈以达到最小的layout thrashing。</li>
<li>缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）</li>
<li>在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）</li>
<li>忽略那些变动小到根本看不出来的DOM更新</li>
</ul>
<p>让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$element  </span><br><span class="line">	<span class="comment">/* Slide the element down into view. */</span> </span><br><span class="line">	.velocity(&#123; opacity: <span class="number">1</span>, top: <span class="string">"50%"</span> &#125;)</span><br><span class="line">	<span class="comment">/* After a delay of 1000ms, slide the element out of view. */</span>    </span><br><span class="line">	.velocity(&#123; opacity: <span class="number">0</span>, top: <span class="string">"-50%"</span> &#125;, &#123; delay: <span class="number">1000</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。</p>
<p>浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。</p>
<p>最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。</p>
<ul>
<li>GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。</li>
<li>GSAP需要<a href="http://www.greensock.com/licensing/" target="_blank" rel="external">付费</a>才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。</li>
<li>性能方面，两者几乎相当，很难区分胜负。</li>
</ul>
<blockquote>
<p>我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。</p>
</blockquote>
<h3 id="Velocity-js"><a href="#Velocity-js" class="headerlink" title="Velocity.js"></a>Velocity.js</h3><p>之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。</p>
<p>简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。</p>
<p>更进一步从易用性的角度来讲，Velocity使用了jQuery的<code>$.queue()</code>方法，因此可以无缝过渡到jQuery的<code>$.animate()</code>、<code>$.fade()</code>和<code>$.delay()</code>方法。并且Velocity的语法和<code>$.animate()</code>一摸一样，所以我们根本不需要修改页面的现有代码。</p>
<p>让我们快速过一下Velocity.js的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$element   </span><br><span class="line">	.delay(<span class="number">1000</span>)    </span><br><span class="line">	<span class="comment">/* Use Velocity to animate the element's top property over a duration of 2000ms. */</span>    </span><br><span class="line">	.velocity(&#123; top: <span class="string">"50%"</span> &#125;, <span class="number">2000</span>)    </span><br><span class="line">	<span class="comment">/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */</span>    </span><br><span class="line">	.fadeOut(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$element    </span><br><span class="line">	<span class="comment">/* Scroll the browser to the top of this element over a duration of 1000ms. */</span>    </span><br><span class="line">	.velocity(<span class="string">"scroll"</span>, <span class="number">1000</span>)    </span><br><span class="line">	<span class="comment">/* Then rotate the element around its Y axis by 360 degrees. */</span>    </span><br><span class="line">	.velocity(&#123; rotateY: <span class="string">"360deg"</span> &#125;, <span class="number">1000</span>); |</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Velocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往<a href="http://velocityjs.org/" target="_blank" rel="external">VelocityJS.org</a>了解。</p>
<p>在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：</p>
<ul>
<li><a href="http://www.youtube.com/watch?v=n8ep4leoN9A" target="_blank" rel="external">Jank Free</a></li>
<li><a href="http://www.youtube.com/watch?v=cmZqLzPy0XE" target="_blank" rel="external">Rendering Without Lumps</a></li>
<li><a href="http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance" target="_blank" rel="external">Faster Websites</a></li>
</ul>
<p>转载整理：<a href="http://web.jobbole.com/86121/" target="_blank" rel="external">http://web.jobbole.com</a></p>

            </div>
        </div>
    </div>
</div>
  </div>
  <div class="footer">
  <p>感谢hexo(https://hexo.io)提供技术支持</p>
  <p>2010-2016</p>
  </div>
  <script src="https://cdn.bootcss.com/jquery/1.12.1/jquery.min.js"></script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</body>

</html>
