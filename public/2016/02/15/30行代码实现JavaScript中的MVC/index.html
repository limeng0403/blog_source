<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>my theme</title>
  <link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link type="text/css" href="/css/index.css" rel="stylesheet" />
</head>
<style type="text/css">

</style>
<body>
  <div class="container-fluid">
    <div class="row">
    <div class="col-sm-12">
        <div class="row box-wrapper">
            <div class="col-sm-2 box-date">
                <p>15</p>
                <p>02/2016</p>
            </div>
            <div class="col-sm-10 box-content">
                <h3>
                  <a href="/2016/02/15/30行代码实现JavaScript中的MVC/" target="_blank">
                    30行代码实现JavaScript中的MVC
                  </a>
                </h3>

                <p>
                  
                      javascript
                  
                </p>

                <p>从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。</p>
<p>很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。</p>
<p>这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。</p>
<h3 id="1-MVC的基础是观察者模式，这是实现model和view同步的关键"><a href="#1-MVC的基础是观察者模式，这是实现model和view同步的关键" class="headerlink" title="1. MVC的基础是观察者模式，这是实现model和view同步的关键"></a>1. MVC的基础是观察者模式，这是实现model和view同步的关键</h3><p>为了简单起见，每个model实例中只包含一个primitive value值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Model(value) &#123;</span><br><span class="line">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class="line">    this._listeners = [];</span><br><span class="line">&#125;</span><br><span class="line">Model.prototype.set = function (value) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    self._value = value;</span><br><span class="line">    // model中的值改变时，应通知注册过的回调函数</span><br><span class="line">    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数</span><br><span class="line">    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        self._listeners.forEach(function (listener) &#123;</span><br><span class="line">            listener.call(self, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.watch = function (listener) &#123;</span><br><span class="line">    // 注册监听的回调函数</span><br><span class="line">    this._listeners.push(listener);</span><br><span class="line">&#125;;</span><br><span class="line">// html代码：</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 逻辑代码：</span><br><span class="line">(function () &#123;</span><br><span class="line">    var model = new Model();</span><br><span class="line">    var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class="line">    model.watch(function (value) &#123;</span><br><span class="line">        div1.innerHTML = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    model.set(&apos;hello, this is a div&apos;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？</p>
<h3 id="2-实现bind方法，绑定model和view"><a href="#2-实现bind方法，绑定model和view" class="headerlink" title="2. 实现bind方法，绑定model和view"></a>2. 实现bind方法，绑定model和view</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Model.prototype.bind = function (node) &#123;</span><br><span class="line">    // 将watch的逻辑和通用的回调函数放到这里</span><br><span class="line">    this.watch(function (value) &#123;</span><br><span class="line">        node.innerHTML = value;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">// html代码：</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 逻辑代码：</span><br><span class="line">(function () &#123;</span><br><span class="line">    var model = new Model();</span><br><span class="line">    model.bind(document.getElementById(&apos;div1&apos;));</span><br><span class="line">    model.bind(document.getElementById(&apos;div2&apos;));</span><br><span class="line">    model.set(&apos;this is a div&apos;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？</p>
<h3 id="3-实现controller，将绑定从逻辑代码中解耦"><a href="#3-实现controller，将绑定从逻辑代码中解耦" class="headerlink" title="3. 实现controller，将绑定从逻辑代码中解耦"></a>3. 实现controller，将绑定从逻辑代码中解耦</h3><p>细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。</p>
<p>如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Controller(callback) &#123;</span><br><span class="line">    var models = &#123;&#125;;</span><br><span class="line">    // 找到所有有bind属性的元素</span><br><span class="line">    var views = document.querySelectorAll(&apos;[bind]&apos;);</span><br><span class="line">    // 将views处理为普通数组</span><br><span class="line">    views = Array.prototype.slice.call(views, 0);</span><br><span class="line">    views.forEach(function (view) &#123;</span><br><span class="line">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class="line">        // 取出或新建该元素所绑定的model</span><br><span class="line">        models[modelName] = models[modelName] || new Model();</span><br><span class="line">        // 完成该元素和指定model的绑定</span><br><span class="line">        models[modelName].bind(view);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 调用controller的具体逻辑，将models传入，方便业务处理</span><br><span class="line">    callback.call(this, models);</span><br><span class="line">&#125;</span><br><span class="line">// html:</span><br><span class="line">&lt;div id=&quot;div1&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;div2&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 逻辑代码：</span><br><span class="line">new Controller(function (models) &#123;</span><br><span class="line">    var model1 = models.model1;</span><br><span class="line">    model1.set(&apos;this is a div&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。</p>
<p>整理后去掉注释的”框架”代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function Model(value) &#123;</span><br><span class="line">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class="line">    this._listeners = [];</span><br><span class="line">&#125;</span><br><span class="line">Model.prototype.set = function (value) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    self._value = value;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        self._listeners.forEach(function (listener) &#123;</span><br><span class="line">            listener.call(self, value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.watch = function (listener) &#123;</span><br><span class="line">    this._listeners.push(listener);</span><br><span class="line">&#125;;</span><br><span class="line">Model.prototype.bind = function (node) &#123;</span><br><span class="line">    this.watch(function (value) &#123;</span><br><span class="line">        node.innerHTML = value;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">function Controller(callback) &#123;</span><br><span class="line">    var models = &#123;&#125;;</span><br><span class="line">    var views = Array.prototype.slice.call(document.querySelectorAll(&apos;[bind]&apos;), 0);</span><br><span class="line">    views.forEach(function (view) &#123;</span><br><span class="line">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class="line">        models[modelName] = models[modelName] || new Model();</span><br><span class="line">        models[modelName].bind(view);</span><br><span class="line">    &#125;);</span><br><span class="line">    callback.call(this, models);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h3><p>笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。</p>
<p>如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：</p>
<ol>
<li>实现对input类标签的双向绑定</li>
<li>实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树</li>
<li>实现view层有关dom node隐藏/显示、创建/销毁的逻辑</li>
<li>集成virtual dom，增加dom diff的功能，提高渲染效率</li>
<li>提供依赖注入功能，实现控制反转</li>
<li>对innerHTML的赋值内容进行安全检查，防止恶意注入</li>
<li>实现model collection的逻辑，这里每个model只有一个值</li>
<li>利用es5中的setter改变set方法的实现，使得对model的修改更加简单</li>
<li>在view层中增加对属性和css的控制<br>10.支持类似AngularJS中双大括号的语法，只绑定部分html<br>……</li>
</ol>
<p>一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈</p>
<p><a href="http://www.codeceo.com/article/30-line-javascript-mvc.html" target="_blank" rel="external">转载地址</a></p>

            </div>
        </div>
    </div>
</div>
  </div>
  <div class="footer">
  <p>感谢hexo(https://hexo.io)提供技术支持</p>
  <p>2010-2016</p>
  </div>
  <script src="https://cdn.bootcss.com/jquery/1.12.1/jquery.min.js"></script>
  <script src="https://cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</body>

</html>
