{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/my_theme/source/css/index.css","path":"css/index.css","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030901.png","path":"resource/2016030901.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030902.png","path":"resource/2016030902.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030903.png","path":"resource/2016030903.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030904.png","path":"resource/2016030904.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030905.png","path":"resource/2016030905.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016030906.png","path":"resource/2016030906.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031101.png","path":"resource/2016031101.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031102.png","path":"resource/2016031102.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031103.png","path":"resource/2016031103.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031105.png","path":"resource/2016031105.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031104.png","path":"resource/2016031104.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031106.png","path":"resource/2016031106.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031107.png","path":"resource/2016031107.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031108.png","path":"resource/2016031108.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031110.png","path":"resource/2016031110.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031109.png","path":"resource/2016031109.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031111.png","path":"resource/2016031111.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031112.png","path":"resource/2016031112.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031113.png","path":"resource/2016031113.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031114.png","path":"resource/2016031114.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031115.png","path":"resource/2016031115.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031116.png","path":"resource/2016031116.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031117.png","path":"resource/2016031117.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031118.png","path":"resource/2016031118.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031119.png","path":"resource/2016031119.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031120.png","path":"resource/2016031120.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031121.png","path":"resource/2016031121.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031122.png","path":"resource/2016031122.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031123.png","path":"resource/2016031123.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031124.png","path":"resource/2016031124.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031125.png","path":"resource/2016031125.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031126.png","path":"resource/2016031126.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031127.png","path":"resource/2016031127.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031128.png","path":"resource/2016031128.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031129.png","path":"resource/2016031129.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031130.png","path":"resource/2016031130.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031131.png","path":"resource/2016031131.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031132.png","path":"resource/2016031132.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031133.png","path":"resource/2016031133.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031135.png","path":"resource/2016031135.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031134.png","path":"resource/2016031134.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031136.png","path":"resource/2016031136.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031137.png","path":"resource/2016031137.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031138.png","path":"resource/2016031138.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/2016031139.png","path":"resource/2016031139.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/README.md","path":"resource/README.md","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-001.png","path":"resource/css-ju-zhong-001.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-002.png","path":"resource/css-ju-zhong-002.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-003.png","path":"resource/css-ju-zhong-003.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-004.png","path":"resource/css-ju-zhong-004.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-005.png","path":"resource/css-ju-zhong-005.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-006.png","path":"resource/css-ju-zhong-006.png","modified":1,"renderable":1},{"_id":"themes/my_theme/source/resource/css-ju-zhong-007.png","path":"resource/css-ju-zhong-007.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/12个非常有用的JavaScript技巧.md","hash":"d87e93a6f165f390073965bbe8cc7a3ac8f18c75","modified":1471414939846},{"_id":"source/_posts/12个CSS高级技巧汇总.md","hash":"c42af1a076e7d65f9fce7b19acbdcbe60e818f70","modified":1471414939845},{"_id":"source/_posts/12种不宜使用的Javascript语法.md","hash":"9c83f0c22eb9e234d0f393e97587ca6c1194341f","modified":1471414939846},{"_id":"source/_posts/44个JavaScript变态题解析.md","hash":"d65daac008f0f53d7fb1bb6837f31549433f3581","modified":1471414939848},{"_id":"source/_posts/200个纯CSS3写的图标 支持复制代码.md","hash":"31e95932aa1390b3f8acc8eab0af75ab6774e1dd","modified":1471414939846},{"_id":"source/_posts/30行代码实现JavaScript中的MVC.md","hash":"2d3ccb85400d0e7d2a9112f80c96b6c1f1f6c6a9","modified":1471414939847},{"_id":"source/_posts/59条令人捧腹但真实的程序员编程语录.md","hash":"6adde4c285507866f13e1287bcdd563876830c53","modified":1471414939849},{"_id":"source/_posts/5个经典的前端面试问题.md","hash":"2709e5ced0a5081f5f79205b99a38ad25e3fcfcd","modified":1471414939849},{"_id":"source/_posts/AngularJS开发人员最常犯的10个错误.md","hash":"56db9a74a519799706aaa5fb8d8f05f993b10929","modified":1471414939850},{"_id":"source/_posts/AngularJS指令实践.md","hash":"431fead1d88bf3f1ea2912749ff424e38386fc7a","modified":1471414939851},{"_id":"source/_posts/7个你可能不认识的CSS单位.md","hash":"69a2ea5c68b4818efe5ad44d40782e01377e562a","modified":1471414939849},{"_id":"source/_posts/Angularjs知识点1.md","hash":"88e593225c798c76252e91aad5aaf72a51ae1d0a","modified":1471414939851},{"_id":"source/_posts/Angularjs知识点2.md","hash":"64ff78623db75b91ddd85bb2b8eb98034ebd4d71","modified":1471414939851},{"_id":"source/_posts/Angularjs轻松实现表格按指定列排序.md","hash":"1294e6e577185b24214ef6f11f82f1d835efb973","modified":1471414939851},{"_id":"source/_posts/Array.prototype.reduce函数.md","hash":"770a4361d2a65e00d90c838449b62604363a3af6","modified":1471414939852},{"_id":"source/_posts/CSS“隐藏”元素的几种方法的对比.md","hash":"15aefbf3ad51c8f89b65287bb5bcb83b34282119","modified":1471414939853},{"_id":"source/_posts/CSS vs JS动画：谁更快？.md","hash":"5267c39f5c67867a741b67fcd009eb9143572a71","modified":1471414939852},{"_id":"source/_posts/CSS实现垂直居中的常用方法.md","hash":"15a7633a508524ca538e212a68f06cf0926e479c","modified":1471414939853},{"_id":"source/_posts/CentOS6.6升级gcc4.8教程.md","hash":"6a61e91a413889165fd3b61396231eaec69c5ca3","modified":1471414939853},{"_id":"source/_posts/GET和POST有什么区别？及为什么网上多数答案都是错的.md","hash":"45ddff6b4aaa7c7daa6f936295c8150d70f818ec","modified":1471414939854},{"_id":"source/_posts/Git详解之Git分支.md","hash":"e35d24396e09a6d6a0823006a833da71edd6b7ae","modified":1471414939854},{"_id":"source/_posts/HTML5可互动的可视化图表js插件库.md","hash":"5d36898ed0cbdd5038c839c65403b842553e35da","modified":1471414939855},{"_id":"source/_posts/How can i use iptables on centos 7.md","hash":"67892f044009488839e88fc5717e718f799250f3","modified":1471414939855},{"_id":"source/_posts/JavaScript总结几个提高性能知识点.md","hash":"acbba1a1f8b847f0f7ac18d2299b07d60ff367cb","modified":1471414939855},{"_id":"source/_posts/Mac中自定义文件夹中文名.md","hash":"11a7dea308557a95d80cd9eda86d089626cb9058","modified":1471414939856},{"_id":"source/_posts/Nodejs学习笔记1——socket.io模块、url模块.md","hash":"715a2f4bd0fcb98926bf45b391dfc8837464e055","modified":1471414939856},{"_id":"source/_posts/Nodejs学习笔记2——文件上传.md","hash":"e97fa89f099d000c91f90ad7ef5f74d47d477162","modified":1471414939856},{"_id":"source/_posts/Nodejs学习笔记3——基础路由的实现.md","hash":"a5ffb444504279c8396df3eff7d282f28f34be64","modified":1471414939857},{"_id":"source/_posts/Nodejs模板引擎关联扩展名.md","hash":"2edcc76ef91025bb534d0199900e554033d97512","modified":1471414939857},{"_id":"source/_posts/SVN的Hooks功能——强制添加注释.md","hash":"24dd7ece3f02735b78f2c7cb4e8dfd6ab2634c5d","modified":1471414939857},{"_id":"source/_posts/Unslider较完美支持bootstrap 3.3.0样式方案.md","hash":"40afac077711261e78fce9b39f5b529a38fb7618","modified":1471414939858},{"_id":"source/_posts/expressjs 4.x增加对上传文件获取的支持.md","hash":"2dc2b69eb52e7ce8e3f73c820359678b1311a069","modified":1471414939859},{"_id":"source/_posts/Web前端面试题目及答案汇总.md","hash":"1ca75133a4bea1db1b8862e45bc9b6aecbb9def4","modified":1471414939858},{"_id":"source/_posts/getJSON在PHP环境下实现跨域数据加载.md","hash":"7c2835b33aeafda24b8fdd0a1cc75249065c825f","modified":1471414939859},{"_id":"source/_posts/jQuery animate scrollTop not working in IE 7.md","hash":"4de1cd534ffe2ce17edd17bc4da9759f00307bcf","modified":1471414939859},{"_id":"source/_posts/jQuery.each()的5个案例.md","hash":"fe2653d72a58496b91b256475814c3ff96acaf72","modified":1471414939860},{"_id":"source/_posts/jQueryMobile笔记.md","hash":"ba046ad7cdee3db1a1c261a01f08e04b3c369545","modified":1471414939860},{"_id":"source/_posts/javascript深入理解js闭包.md","hash":"68f3bc70692a0c567803335888d3c43f77a68c76","modified":1471414939860},{"_id":"source/_posts/linux下查看和添加PATH环境变量.md","hash":"4df95fd4f2dda12814eccb845178ae9da3577040","modified":1471414939861},{"_id":"source/_posts/linux 下如何启动SVN服务.md","hash":"5be389ad0372881331ac2bed2efae160e3d08142","modified":1471414939861},{"_id":"source/_posts/mongoDB设置数据库并启动.md","hash":"a4321765e14dffb74a8d44291ad922ca832055e2","modified":1471414939861},{"_id":"source/_posts/new的返回值.md","hash":"ae32bb429f7122e14d9c92fa54cc768b949f4881","modified":1471414939862},{"_id":"source/_posts/mongodb3.03开启认证.md","hash":"c9e0db63cca7f6cbf41b443e28a35bc4ceaf2eb8","modified":1471414939862},{"_id":"source/_posts/nodejs+express.md","hash":"570eeafe4f07b74a678dfbd2db39e98c26c6b6be","modified":1471414939862},{"_id":"source/_posts/prop和attr的区别.md","hash":"1dbd6a02091d991b416af77f30ef4a94e8491be2","modified":1471414939862},{"_id":"source/_posts/viewport详解.md","hash":"d6efd927722367e7d5f37461ee04bffaef4c9f98","modified":1471414939863},{"_id":"source/_posts/webpack入门指南.md","hash":"537b20a647ca2a8f0bcf07db65acd1614f3ead02","modified":1471414939863},{"_id":"source/_posts/【Angularjs文档翻译及实例】DOM事件.md","hash":"f613818aaabbb8dc67b2f18504321df11136c9c8","modified":1471414939864},{"_id":"source/_posts/了解Javascript传值机制.md","hash":"57950294d58c9df0d942ef3610959b8b60ae3d61","modified":1471414939864},{"_id":"source/_posts/人人必知的10个jQuery小技巧.md","hash":"d7068600f8d8cae4781b838503398b480b36da4a","modified":1471414939865},{"_id":"source/_posts/从本质认识JavaScript的原型继承和类继承.md","hash":"26229ab466c75357318d1743631be103eba17df2","modified":1471937086192},{"_id":"source/_posts/使用Flexbox的六个理由.md","hash":"ac0c4a03a62d3896fafff14f2a0cb3b24de5f71c","modified":1471414939866},{"_id":"source/_posts/使用Git时，怎么忽略不想上传的文件.md","hash":"21271c3cf7ccb3746dba13dd559f348d491ea398","modified":1471414939866},{"_id":"source/_posts/使用JSON.Stringify.md","hash":"49c91b930d80ea6887278677cb6d2f624a8a3792","modified":1471414939867},{"_id":"source/_posts/使用QUnit进行JavaScript单元测试.md","hash":"6f87f0e88e4f0046899ec3422c801adecf078567","modified":1471414939867},{"_id":"source/_posts/使用git pull文件时和本地文件冲突怎么办？.md","hash":"e39ef125e83bfad1475d24fbf7f390c946de6c29","modified":1471414939868},{"_id":"source/_posts/使用ajax和history.pushState无刷新改变页面URL.md","hash":"897dbadb95aac867be118f113cc90c6fa28ec921","modified":1471414939867},{"_id":"source/_posts/使用nginx搭建https服务器.md","hash":"4148c64c6489e2d8a5436f6172fc0e7f7cceb17c","modified":1471414939868},{"_id":"source/_posts/俞敏洪：我和马云就差了8个字.md","hash":"d7093a49cf1594b5e30e839e1f2ff885d3eabad2","modified":1471414939868},{"_id":"source/_posts/修改ubuntu DNS的步骤.md","hash":"3b10ec030e5451fba09a07c62061d4fb95d9d7dc","modified":1471414939869},{"_id":"source/_posts/减少HTTP请求（大型网站优化技术）.md","hash":"1983255bb935c99d9b70e8acb0afeb463edd9670","modified":1471414939869},{"_id":"source/_posts/别人家的面试题：统计“1”的个数.md","hash":"91fc3347171d8866325528516f0d4aa12bae8e61","modified":1471414939870},{"_id":"source/_posts/切片式图片切换效果.md","hash":"a65e0155ed52c6dd267016b73eeabbd5f23da08a","modified":1471414939870},{"_id":"source/_posts/前端开发指南.md","hash":"ff215abbe28056fb2dca3673b7cb5efff1fb3b48","modified":1471414939870},{"_id":"source/_posts/取得文件扩展名.md","hash":"ea1c01c7b95e6fec9f4d86b853558a001334cfdf","modified":1471414939871},{"_id":"source/_posts/善用meta.md","hash":"bc99caac47e75fba8767c6b0a67941746bc0a43f","modified":1471414939871},{"_id":"source/_posts/在Ubuntu上安装PPTP的VPN服务.md","hash":"e89e503886cc63fce0b75820b8649aa482f90595","modified":1471414939871},{"_id":"source/_posts/如何正确配置Nginx+PHP.md","hash":"3575c359ebd1a2ce294cae35c864e7bee01fd4e1","modified":1471414939872},{"_id":"source/_posts/学习并运用JavaScript的原生函数.md","hash":"91463e32c084bc2875cd44c9cee451eebe730efd","modified":1471414939872},{"_id":"source/_posts/学会享受孤独是通往成功的第一步.md","hash":"0cb5bbf8900eb42aaa99100f2c193f81355c60e7","modified":1471414939873},{"_id":"source/_posts/安装VirtualBox增强功能（命令行）.md","hash":"0cec3d0fcf59d62f0a52533f8acb755eea515d3f","modified":1471414939873},{"_id":"source/_posts/开发者必须知道的HTML5十五大新特性.md","hash":"fd206b14ff2dd8d44102b7a610f455b5e744b01e","modified":1471414939873},{"_id":"source/_posts/有趣的JavaScript原生数组函数.md","hash":"f044e9cbe1ada9574a6acfbc7a41def45a57f465","modified":1471414939874},{"_id":"source/_posts/毁灭程序员的15个障碍.md","hash":"6d337e6f1c883cd7ba61198c57dea860743949b8","modified":1471414939874},{"_id":"source/_posts/深入理解HTML5标签.md","hash":"5348f0106bb9ef4ba6218a2e4be52740f2e73619","modified":1471414939874},{"_id":"source/_posts/用数组建立一个简单的循环.md","hash":"dbc4e85847eec65f487064fc0e4dd72f982b43ff","modified":1471414939875},{"_id":"source/_posts/界面切换 jQuery 插件：Animate Transition.md","hash":"deda914c79b55188eadfe0018d1acc8a25542e9e","modified":1471414939875},{"_id":"source/_posts/移动网页开发总结.md","hash":"5ef237c69610a0a4749d4820028f9495ab1f5c71","modified":1471414939875},{"_id":"source/_posts/程序员累了怎么办？.md","hash":"6378b2568d7694f763f9183d42bf3ed2e61ae42d","modified":1471414939876},{"_id":"source/_posts/简单监听DOM事件.md","hash":"79ac62d86f6cdd621950bc21994f2bdd77cc2df2","modified":1471414939877},{"_id":"source/_posts/突袭HTML5.md","hash":"a4cdb3f3ed17c73b8a5d143d7ab5af198fbe603b","modified":1471414939877},{"_id":"source/_posts/糟糕程序员的编程风格.md","hash":"05990d8bf3752eb7a27ea6e11d22f12b4122e172","modified":1471414939877},{"_id":"source/_posts/网页字体设置你了解吗.md","hash":"e5f608f949b6ae49f24de521271f3da2f00aef14","modified":1471414939878},{"_id":"source/_posts/解决IE下a标签点击有虚线边框的问题.md","hash":"ef99e9a3744c3f689488215e3c41a621b5e8aa5d","modified":1471414939878},{"_id":"source/_posts/让ubuntu 终端显示英文提示，而桌面环境显示中文的方法.md","hash":"a76ca143a9124636a2edc38bdeab4636a76ee15d","modified":1471414939879},{"_id":"source/_posts/解决g++command not found.md","hash":"5a00924baba7279a66bf3164271951f6a6485e4b","modified":1471936729555},{"_id":"source/_posts/记一次淘宝首页奇葩的渲染问题.md","hash":"c45a42df158c99db30eba52bc6a0835f1311b7ee","modified":1471414939879},{"_id":"source/_posts/详解Javascript的继承实现.md","hash":"a292dfb95321a3244acf0094d5d486bb8d18928c","modified":1471414939880},{"_id":"source/_posts/轻量级Modal模态框插件cta.js.md","hash":"0a2519ca1c87e5813da4ac1f0f248c148d3f1f33","modified":1471414939880},{"_id":"source/_posts/重写js中的window.alert函数.md","hash":"6d14bf2daf7f9a54b00c9da2c693cbc99f342a5f","modified":1471414939880},{"_id":"themes/my_theme/layout/archive.ejs","hash":"4846e5ddf47e2885384081b44c44fa2efd678f66","modified":1471414939920},{"_id":"themes/my_theme/layout/index.ejs","hash":"5c2e3eade32fdb07b8f3c1d9a19c2f0acb870615","modified":1471414939921},{"_id":"themes/my_theme/layout/layout.ejs","hash":"d4cb617380ed0cc11e2de3cb482c35dd6a05105d","modified":1471414939921},{"_id":"themes/my_theme/layout/post.ejs","hash":"5cd6d7768a08195d234c37529c806214b0d1cb5e","modified":1471506738876},{"_id":"source/_posts/使用ES6写更好的JavaScript.md","hash":"f356e6d3508ee5c4347700ba2856c2243c37fbfe","modified":1471937094937},{"_id":"themes/my_theme/source/css/index.css","hash":"8352d51f4d5aab9d3878126e3b4a5b42a17d61c8","modified":1471414939922},{"_id":"themes/my_theme/source/resource/2016030901.png","hash":"551e10cc31539e338eff4c487b8495b0f78aea9f","modified":1471414939923},{"_id":"themes/my_theme/source/resource/2016030902.png","hash":"5b5b4aab079ab439da671fa651168fdcd4d1c564","modified":1471414939924},{"_id":"themes/my_theme/source/resource/2016030903.png","hash":"b58ce162fc04b9b80ebad5c5fa4196c4787f2379","modified":1471414939924},{"_id":"themes/my_theme/source/resource/2016030904.png","hash":"76e087c3ebc2dfdf73f974266c59f610e366beac","modified":1471414939924},{"_id":"themes/my_theme/source/resource/2016030905.png","hash":"6802c9148b6f406ca77dd283fb8184c04d2f65f3","modified":1471414939925},{"_id":"themes/my_theme/source/resource/2016030906.png","hash":"b59e9e36983c8d170f17e8eadced36400d1eae73","modified":1471414939925},{"_id":"themes/my_theme/source/resource/2016031101.png","hash":"2993032498a14962642c621ac15f60031cdb9cc1","modified":1471414939926},{"_id":"themes/my_theme/source/resource/2016031102.png","hash":"d0b7d8e7299bbef339de550be401cc21d0a212bc","modified":1471414939927},{"_id":"themes/my_theme/source/resource/2016031103.png","hash":"2d56fb8d90f89e24cf602c9321f8303827b4e4d5","modified":1471414939928},{"_id":"themes/my_theme/source/resource/2016031105.png","hash":"4be9b4a87010356dbe278bbb4c7871dd80df13fa","modified":1471414939928},{"_id":"themes/my_theme/source/resource/2016031104.png","hash":"d0e2c28549cf8a0811772b8038cd2ec10f7dcc3c","modified":1471414939928},{"_id":"themes/my_theme/source/resource/2016031106.png","hash":"769ac32f519c61e0407e7b8b0ce59cec3358aa3d","modified":1471414939929},{"_id":"themes/my_theme/source/resource/2016031107.png","hash":"4ef3b5c8506bd98cd3db4015f342a069ad845f62","modified":1471414939929},{"_id":"themes/my_theme/source/resource/2016031108.png","hash":"2505ea2444b136483e4bea06b253efe7dfac7b33","modified":1471414939930},{"_id":"themes/my_theme/source/resource/2016031110.png","hash":"d3f69223d324d19094ecfa3be7848253d03c61da","modified":1471414939931},{"_id":"themes/my_theme/source/resource/2016031109.png","hash":"aceaf4e9a55df06d8b6033ed8fa5cc7f6d4e68c4","modified":1471414939930},{"_id":"themes/my_theme/source/resource/2016031111.png","hash":"1d10fd3b41dda0b95dbaab687b6108dedf4128e1","modified":1471414939931},{"_id":"themes/my_theme/source/resource/2016031112.png","hash":"ae202ffab70c3989b821a0177b7b7dd1d4046091","modified":1471414939931},{"_id":"themes/my_theme/source/resource/2016031113.png","hash":"4cbb4fa6d1d0f9580d51b03d5be49ca580cebca5","modified":1471414939932},{"_id":"themes/my_theme/source/resource/2016031114.png","hash":"1f52ca5c9858f88c8ae26a8288666f19b06ee765","modified":1471414939932},{"_id":"themes/my_theme/source/resource/2016031115.png","hash":"4d0d22ba12debd5f1da8fefac72a694651da0ac6","modified":1471414939933},{"_id":"themes/my_theme/source/resource/2016031116.png","hash":"035d048ac9156262cb5bbd2c935e63928aca308f","modified":1471414939934},{"_id":"themes/my_theme/source/resource/2016031117.png","hash":"853a66721a2bcad85220ecfb1a4d811986b665a7","modified":1471414939934},{"_id":"themes/my_theme/source/resource/2016031118.png","hash":"33b49d46c9123c3ac9eb27c9d865a96bb1ff7809","modified":1471414939934},{"_id":"themes/my_theme/source/resource/2016031119.png","hash":"76caaa5b745febd2890bcd2fb78f0818cd08eab5","modified":1471414939935},{"_id":"themes/my_theme/source/resource/2016031120.png","hash":"f040949f96287b5509c2ce26a7b11d8829cfbfc8","modified":1471414939936},{"_id":"themes/my_theme/source/resource/2016031121.png","hash":"e5d2c2e3529640ba79f2b4fad023752c51d9846b","modified":1471414939936},{"_id":"themes/my_theme/source/resource/2016031122.png","hash":"b7c1d0455da564de2350eb0465c50a79c4aa885b","modified":1471414939938},{"_id":"themes/my_theme/source/resource/2016031123.png","hash":"3e2e7bfc97eeb5367e0aa06f67a777673c63927e","modified":1471414939938},{"_id":"themes/my_theme/source/resource/2016031124.png","hash":"59f60a4deba71488e40ab4ad284b33163d97924d","modified":1471414939939},{"_id":"themes/my_theme/source/resource/2016031125.png","hash":"cc7c806d05212251bd0b475fc50c93143f1b469f","modified":1471414939940},{"_id":"themes/my_theme/source/resource/2016031126.png","hash":"5722fc69ed952aa8ad646c898eda3fdf2fe3ff99","modified":1471414939941},{"_id":"themes/my_theme/source/resource/2016031127.png","hash":"1ae9cf0a43e938aa1680557b37ecd3ac06f208ca","modified":1471414939941},{"_id":"themes/my_theme/source/resource/2016031128.png","hash":"588257aaddf16fd41b10e125865e0e89810cc28b","modified":1471414939942},{"_id":"themes/my_theme/source/resource/2016031129.png","hash":"0b2c72149b36651e774a8bfd8885f2dd2e12a320","modified":1471414939942},{"_id":"themes/my_theme/source/resource/2016031130.png","hash":"a513f7dd498078488b01b2111b0fe1119717bdc9","modified":1471414939943},{"_id":"themes/my_theme/source/resource/2016031131.png","hash":"a56435ee40dc82cb4df8e58e9b031db1f1974c30","modified":1471414939944},{"_id":"themes/my_theme/source/resource/2016031132.png","hash":"c28acfb977111c62a7bf68564cff6d481337e5de","modified":1471414939944},{"_id":"themes/my_theme/source/resource/2016031133.png","hash":"7af1dd5572509659e580912d54635d6430c7a293","modified":1471414939945},{"_id":"themes/my_theme/source/resource/2016031135.png","hash":"16f32efeaff14a181061c60b5c1c6db764772d97","modified":1471414939946},{"_id":"themes/my_theme/source/resource/2016031134.png","hash":"845bb655177dfa85313af12057b058d013d93157","modified":1471414939946},{"_id":"themes/my_theme/source/resource/2016031136.png","hash":"1bb4dcade3beadadb9e311f572f64c5cc0097fe9","modified":1471414939947},{"_id":"themes/my_theme/source/resource/2016031137.png","hash":"c78d0a35771ea36af9cd43268ca1dd0b543e2b75","modified":1471414939947},{"_id":"themes/my_theme/source/resource/2016031138.png","hash":"181a74e1d098e75a70f596bd1198ddcb2e3b0e2b","modified":1471414939948},{"_id":"themes/my_theme/source/resource/2016031139.png","hash":"4d6aad68781b319801f2531ad0c9f2d443c7af2e","modified":1471414939949},{"_id":"themes/my_theme/source/resource/README.md","hash":"d25bfc1652c3060bf97b5ecd734ab8af9f2b07c3","modified":1471414939949},{"_id":"themes/my_theme/source/resource/css-ju-zhong-001.png","hash":"781a8a1b35bf8598fc42d485fa2f6e7dd23b8c92","modified":1471414939950},{"_id":"themes/my_theme/source/resource/css-ju-zhong-002.png","hash":"bb77ddf7683aea437f184c47aa9c2732e44233d0","modified":1471414939951},{"_id":"themes/my_theme/source/resource/css-ju-zhong-003.png","hash":"2ce25003d576f328c1f1b24a63d1e9be20bf2c91","modified":1471414939951},{"_id":"themes/my_theme/source/resource/css-ju-zhong-004.png","hash":"6a9f20720f1686ec1a5078f84824fca7a4237960","modified":1471414939952},{"_id":"themes/my_theme/source/resource/css-ju-zhong-005.png","hash":"a5cbc761df64663a7f848a11eb2bc07cc711d349","modified":1471414939953},{"_id":"themes/my_theme/source/resource/css-ju-zhong-006.png","hash":"d81961af5a503e27bb19d5a6bf3610ae86165e96","modified":1471414939954},{"_id":"themes/my_theme/source/resource/css-ju-zhong-007.png","hash":"b7e9a10efe115fd67c43823fea10c5922d3f2f9d","modified":1471414939955},{"_id":"public/2016/08/10/用数组建立一个简单的循环/index.html","hash":"f453e3a3c9c8451d6b115117ab19c2c81090fdaa","modified":1471937115638},{"_id":"public/2016/06/14/在Ubuntu上安装PPTP的VPN服务/index.html","hash":"da389fc4ffac87081a7a65e04f5cf93f32b92240","modified":1471937115639},{"_id":"public/2016/06/14/使用nginx搭建https服务器/index.html","hash":"57bd2968aa5d9757e1f514528d6b6ffde660985e","modified":1471937115639},{"_id":"public/2016/06/07/使用git pull文件时和本地文件冲突怎么办？/index.html","hash":"b2491c74244759184a87dc66e8232123605d9536","modified":1471937115639},{"_id":"public/2016/06/01/别人家的面试题：统计“1”的个数/index.html","hash":"8b4eaf438fea6f10c7ca10f76f37eb89737eed7a","modified":1471937115639},{"_id":"public/2016/06/01/修改ubuntu DNS的步骤/index.html","hash":"58b3f249a86a17075cb1ed22b9f322e30e07d1bf","modified":1471937115639},{"_id":"public/2016/06/01/GET和POST有什么区别？及为什么网上多数答案都是错的/index.html","hash":"36e5db6bf9093fd87125b2d5be1a41a31c1002db","modified":1471937115640},{"_id":"public/2016/05/18/Angularjs轻松实现表格按指定列排序/index.html","hash":"2601686fe0380f0deb5377d517a38bc5bb971f9a","modified":1471937115640},{"_id":"public/2016/05/13/HTML5可互动的可视化图表js插件库/index.html","hash":"a165e0e635a598776a380ff98cecc371b2fe913c","modified":1471937115640},{"_id":"public/2016/04/25/new的返回值/index.html","hash":"ff7ce6b0292dad59a6a858783d4b1d706f3f0607","modified":1471937115640},{"_id":"public/2016/04/11/Angularjs知识点2/index.html","hash":"24f84528111e742edc7191aea1d4017c6e6e43a5","modified":1471937115640},{"_id":"public/2016/04/11/Angularjs知识点1/index.html","hash":"44534d5cc3e120f97c6f7b46bc62ee3e23da88f6","modified":1471937115640},{"_id":"public/2016/04/10/Array.prototype.reduce函数/index.html","hash":"f54641e7274d39693a923953f89f2aa8eb0d5216","modified":1471937115640},{"_id":"public/2016/04/05/jQuery animate scrollTop not working in IE 7/index.html","hash":"6907cddc4ed6d5f782637f199c75f0b9fe2a76ba","modified":1471937115640},{"_id":"public/2016/04/04/jQuery.each()的5个案例/index.html","hash":"a21e69e9a918d299731397009a9e9b05030e81e3","modified":1471937115640},{"_id":"public/2016/04/03/jQueryMobile笔记/index.html","hash":"719677e7b841a903008b6440de77dc87b99ba6c7","modified":1471937115641},{"_id":"public/2016/03/03/CentOS6.6升级gcc4.8教程/index.html","hash":"84f67fc01f264bb104ef0455a26e7a100f90c141","modified":1471937115641},{"_id":"public/2016/03/02/学会享受孤独是通往成功的第一步/index.html","hash":"ceab5d402c22da2576ffc5aea984ce7767516959","modified":1471937115641},{"_id":"public/2016/02/18/How can i use iptables on centos 7/index.html","hash":"6bbb9cae7cc1985c11e5d94c25f7c01fe42e2f05","modified":1471937115641},{"_id":"public/2016/02/17/糟糕程序员的编程风格/index.html","hash":"6e63f14a695c53afe59cb290b13c1a034d312736","modified":1471937115641},{"_id":"public/2016/02/15/30行代码实现JavaScript中的MVC/index.html","hash":"9833760c26f569a5857b0244044abd20215447ee","modified":1471937115641},{"_id":"public/2016/02/07/Nodejs学习笔记3——基础路由的实现/index.html","hash":"e8b627dfbc01a44da79bdd3ad9ef2c2764b0687d","modified":1471937115641},{"_id":"public/2016/02/06/Nodejs学习笔记2——文件上传/index.html","hash":"73bc734d46521308e06baa1fd9a0d1ade23cd5e5","modified":1471937115641},{"_id":"public/2016/02/05/Nodejs学习笔记1——socket.io模块、url模块/index.html","hash":"150ed36291d4d5b0e601198c1172cb7a1ccc1936","modified":1471937115642},{"_id":"public/2016/02/04/Nodejs模板引擎关联扩展名/index.html","hash":"9b5d7b8373ca82bdced793f6f7c5913dcfab5c8f","modified":1471937115642},{"_id":"public/2016/02/02/nodejs+express/index.html","hash":"872ea90c71bebb90ef86f8ed63a356bd76bc4aed","modified":1471937115642},{"_id":"public/2015/12/25/俞敏洪：我和马云就差了8个字/index.html","hash":"03277e079d7feadccbfcd51b5df9e82faa714e54","modified":1471937115642},{"_id":"public/2015/10/26/CSS“隐藏”元素的几种方法的对比/index.html","hash":"8cdb2f7802dda882d2ca15657ab912f6474609f3","modified":1471937115642},{"_id":"public/2015/10/10/程序员累了怎么办？/index.html","hash":"75bf74c7fedd63127ebd888478daca1d0b25a3de","modified":1471937115642},{"_id":"public/2015/09/18/mongoDB设置数据库并启动/index.html","hash":"4913473f4c6146c10f8963ee9b8f03bee21695ea","modified":1471937115642},{"_id":"public/2015/08/25/使用Git时，怎么忽略不想上传的文件/index.html","hash":"22f392c092ee971c786639b83d34d4fc152fcffa","modified":1471937115643},{"_id":"public/2015/08/11/记一次淘宝首页奇葩的渲染问题/index.html","hash":"d81cd4fcc664fa331e9408c8a1f1d80ce2d2753a","modified":1471937115643},{"_id":"public/2015/07/18/mongodb3.03开启认证/index.html","hash":"21a08c65692006f9158ceaf00c13240b3db7edd4","modified":1471937115643},{"_id":"public/2015/05/27/prop和attr的区别/index.html","hash":"ba5361fe45dfeb766d1191ca7a9ca3ad76732306","modified":1471937115643},{"_id":"public/2015/05/21/Unslider较完美支持bootstrap 3.3.0样式方案/index.html","hash":"a8ad102b4a9c9a49ef2d735262d47a997c0f9bc0","modified":1471937115643},{"_id":"public/2015/05/21/JavaScript总结几个提高性能知识点/index.html","hash":"a579075b1bb3878522c448fb612bc3e7440db2bf","modified":1471937115643},{"_id":"public/2015/05/11/javascript深入理解js闭包/index.html","hash":"6a0c4afabcbd25a9e46f6e8db466fc1b368a7d43","modified":1471937115643},{"_id":"public/2015/04/19/12种不宜使用的Javascript语法/index.html","hash":"da7d696aa87bd1112a8c7d41d92808014c9157f3","modified":1471937115643},{"_id":"public/2015/04/11/viewport详解/index.html","hash":"51ddb025e893fd79ea48031a5a25c9a890bfe6ce","modified":1471937115643},{"_id":"public/2015/02/20/expressjs 4.x增加对上传文件获取的支持/index.html","hash":"6fe22fe44919c2f1c24d71d840e96cb45d539b1b","modified":1471937115644},{"_id":"public/2015/02/17/简单监听DOM事件/index.html","hash":"b1a4ff92f1e0e1ebdc75b018a05d49508aeda583","modified":1471937115644},{"_id":"public/2015/02/16/解决IE下a标签点击有虚线边框的问题/index.html","hash":"f8d74e3839e3c92d3765a61e900ecf698752bf2f","modified":1471937115644},{"_id":"public/2015/02/15/界面切换 jQuery 插件：Animate Transition/index.html","hash":"95931a34f83ebd143ed6a8b078c0803781846371","modified":1471937115644},{"_id":"public/2015/02/13/了解Javascript传值机制/index.html","hash":"155848dbc7183fd6f002643c99bb290f69925478","modified":1471937115644},{"_id":"public/2015/02/12/前端开发指南/index.html","hash":"02ce0729e5fad5a48348bb7d9d6d6ca96871cb42","modified":1471937115645},{"_id":"public/2015/02/10/切片式图片切换效果/index.html","hash":"bcbd23540a83319ac31a9a05e244294b2f2a8a28","modified":1471937115645},{"_id":"public/2015/02/09/轻量级Modal模态框插件cta.js/index.html","hash":"8b5238313cbf6ba3efa23605a6480c3cb980a3a0","modified":1471937115645},{"_id":"public/2015/02/08/取得文件扩展名/index.html","hash":"cda72da138d41243ba3801409a1c09a1c73c02ab","modified":1471937115645},{"_id":"public/2015/02/07/人人必知的10个jQuery小技巧/index.html","hash":"9fa8eca0432ca697a2ed9be6f9af40c968c569f7","modified":1471937115645},{"_id":"public/2015/02/04/使用ajax和history.pushState无刷新改变页面URL/index.html","hash":"f6a400ce9c30078a69114151c37d2da3fe5c27b8","modified":1471937115645},{"_id":"public/2015/02/02/Mac中自定义文件夹中文名/index.html","hash":"98c92086bba42fd77055e9f962f29f3ce83599da","modified":1471937115646},{"_id":"public/2015/02/02/使用Flexbox的六个理由/index.html","hash":"aa34838400b34cd3c7bf28129adfa01a6081f864","modified":1471937115646},{"_id":"public/2015/02/01/使用JSON.Stringify/index.html","hash":"9b8a2970f65342b5c3f4392d56ed74747896ceb9","modified":1471937115646},{"_id":"public/2015/01/31/使用QUnit进行JavaScript单元测试/index.html","hash":"aae8b18d2349ae7632790fb125c0f716fd26fe5d","modified":1471937115646},{"_id":"public/2015/01/30/突袭HTML5/index.html","hash":"bb55acba56475e50b5b9b7a3f7fabf9ffe146fe7","modified":1471937115646},{"_id":"public/2015/01/29/网页字体设置你了解吗/index.html","hash":"b6b23c4ce4e576e5e3960f2f524c06a9616ad0ca","modified":1471937115646},{"_id":"public/2015/01/24/重写js中的window.alert函数/index.html","hash":"8a32b16431683049a61a167ed74f7b545a5bc2d3","modified":1471937115646},{"_id":"public/2015/01/24/12个CSS高级技巧汇总/index.html","hash":"959058fa164e38552655218fd8aa8baaedf0750f","modified":1471937115647},{"_id":"public/2015/01/04/7个你可能不认识的CSS单位/index.html","hash":"2a1aca21cdb3d8082ec42fb4ea58c9c1dd6e84e8","modified":1471937115647},{"_id":"public/2014/10/27/5个经典的前端面试问题/index.html","hash":"628757a14b1c6c7a3aaac5ccf8a6af144e15f5b9","modified":1471937115647},{"_id":"public/2014/07/07/linux下查看和添加PATH环境变量/index.html","hash":"459e247a9f300a02c6ddda2487ad26bc9df2e69f","modified":1471937115647},{"_id":"public/2014/06/06/getJSON在PHP环境下实现跨域数据加载/index.html","hash":"9bcf35a3c67c02d02ad98e408401773c74c60898","modified":1471937115647},{"_id":"public/2014/05/05/linux 下如何启动SVN服务/index.html","hash":"d59273df18e17516955fc85d1834725e0b611082","modified":1471937115647},{"_id":"public/2014/04/18/200个纯CSS3写的图标 支持复制代码/index.html","hash":"83efea1058339affbfc45d8c7b73799cb362eb63","modified":1471937115647},{"_id":"public/2014/01/02/让ubuntu 终端显示英文提示，而桌面环境显示中文的方法/index.html","hash":"bf54543d2f718e31401efc984821530b4ef86af0","modified":1471937115647},{"_id":"public/2013/10/11/解决g++command not found/index.html","hash":"2a338e3a093a3518d43e276c6ac54760106a1443","modified":1471937115647},{"_id":"public/2013/09/09/SVN的Hooks功能——强制添加注释/index.html","hash":"ef62bd15dcf5fd44451dd7680eead60e9faf5044","modified":1471937115648},{"_id":"public/2013/08/08/如何正确配置Nginx+PHP/index.html","hash":"da7d28f5a7df5b6650ac5f0f8e7ff16b954ba02f","modified":1471937115648},{"_id":"public/2012/01/05/安装VirtualBox增强功能（命令行）/index.html","hash":"17697adba52bae65c6acc2f20a897d8c07ec5d19","modified":1471937115648},{"_id":"public/tags/javascript/index.html","hash":"6d4186affac01a728829144a18145538c9524c1c","modified":1471937115648},{"_id":"public/tags/javascript/page/2/index.html","hash":"aee7fc19e41dd47119b4be75fea02e293d39e7f0","modified":1471937115648},{"_id":"public/tags/javascript/page/3/index.html","hash":"6dd3ef84f7928e790ef76510002f5815e9a24521","modified":1471937115648},{"_id":"public/tags/javascript/page/4/index.html","hash":"5704e9e0f6ace186f30e55a976ec0ce6032af0cc","modified":1471937115648},{"_id":"public/tags/jquery/index.html","hash":"750545af048313498a5e574f6233f898be7792a8","modified":1471937115648},{"_id":"public/tags/css/index.html","hash":"5596367d2b9bdd3488bb32d75dbbb9b41baa6e7c","modified":1471937115648},{"_id":"public/tags/css/page/2/index.html","hash":"17385f10155cd4d9dea8a3a51b3c03d2ce3fe1c8","modified":1471937115648},{"_id":"public/tags/other/index.html","hash":"2af297232268c1aa5934a54f6b0d40003c097a71","modified":1471937115648},{"_id":"public/tags/angularjs/index.html","hash":"1dfd63da788bcd21743c0d09b1a7c37801f91d82","modified":1471937115649},{"_id":"public/tags/http/index.html","hash":"83cca92c5c597c2aa8fbeedafc4de401fd1bde55","modified":1471937115649},{"_id":"public/tags/linux/index.html","hash":"062f2e490474e2428b2494aa5b87627b676b3dec","modified":1471937115649},{"_id":"public/tags/linux/page/2/index.html","hash":"4b6c6de9a143be5d6abf268dc46e528f27ac1de8","modified":1471937115649},{"_id":"public/tags/centos/index.html","hash":"45bc2893cbb10028754953fdc2c114e6dd141a67","modified":1471937115649},{"_id":"public/tags/git/index.html","hash":"1383cde24f111033d9a2d621e48c5eabc946fe19","modified":1471937115649},{"_id":"public/tags/html5/index.html","hash":"df2bd2970814e6cedf7e1a913ee79f8a8397da4c","modified":1471937115649},{"_id":"public/tags/mac/index.html","hash":"baf255945b44cd137fdd146bfa9ee76c5e281246","modified":1471937115650},{"_id":"public/tags/nodejs/index.html","hash":"c1d25bbffe895ad8057341812fbb244f5b152a14","modified":1471937115650},{"_id":"public/tags/svn/index.html","hash":"48c6d9c3857fdd7f281719cc3e5ad082d0614afe","modified":1471937115650},{"_id":"public/tags/html/index.html","hash":"f30c09fada232ffa68f486bffbfadc9a1ac83e26","modified":1471937115650},{"_id":"public/tags/html/page/2/index.html","hash":"bc781428815b93a830a99fbb922659a4f8f75f82","modified":1471937115650},{"_id":"public/tags/json/index.html","hash":"a322c9938a6c38d2a0c17d2a04da790c00b082d0","modified":1471937115650},{"_id":"public/tags/express/index.html","hash":"d096cff005f1c37c7743e0aa1f10c8eb0480dfe6","modified":1471937115650},{"_id":"public/tags/database/index.html","hash":"8526be91972e0484e8919f426581f306f8ad61d6","modified":1471937115650},{"_id":"public/tags/mongodb/index.html","hash":"8526be91972e0484e8919f426581f306f8ad61d6","modified":1471937115650},{"_id":"public/tags/es6/index.html","hash":"bd4b4afd5dfad3942d6efbb421b1a53bb67050bf","modified":1471937115650},{"_id":"public/tags/qunit/index.html","hash":"7f08b7703fad443c51d7e1dc8ef0343571e801cc","modified":1471937115651},{"_id":"public/tags/ajax/index.html","hash":"bfe569e3ddcca6ce8ccaf5b71ca585be9dcdf3d4","modified":1471937115651},{"_id":"public/tags/ngnix/index.html","hash":"1ebac8ba8517d7c2e71774f698e6d60aa8dbc252","modified":1471937115651},{"_id":"public/tags/ssl/index.html","hash":"1ebac8ba8517d7c2e71774f698e6d60aa8dbc252","modified":1471937115651},{"_id":"public/tags/其它/index.html","hash":"b46f905675d060fc861fe4f8867adacd2b3b0daa","modified":1471937115651},{"_id":"public/tags/ubuntu/index.html","hash":"4c6d96a17b5abf32ecd350ddf48adce876eb44dd","modified":1471937115651},{"_id":"public/tags/php/index.html","hash":"697a399aaa2b405cc3c83071da57cbc75d0198f1","modified":1471937115651},{"_id":"public/tags/nginx/index.html","hash":"4b6c6de9a143be5d6abf268dc46e528f27ac1de8","modified":1471937115651},{"_id":"public/tags/virtualbox/index.html","hash":"d964da804725af6f14743fefc8c76db6967e9226","modified":1471937115651},{"_id":"public/archives/index.html","hash":"fd6440f8e76ac70ad86a1e1177cd4d3ebd9afb15","modified":1471937115651},{"_id":"public/archives/page/2/index.html","hash":"e9de3dde4b3c4aded26e9ac80ccc1c00ec959f1a","modified":1471937115651},{"_id":"public/archives/page/3/index.html","hash":"273b70c056d5622f2fbe51b8d69b12da00ba1aed","modified":1471937115652},{"_id":"public/archives/page/4/index.html","hash":"7e20a7f4df17aaf5e46d8401205a1a797afd5434","modified":1471937115652},{"_id":"public/archives/page/5/index.html","hash":"8006101a27ba3ae45e4e59175931e227be6f91f3","modified":1471937115652},{"_id":"public/archives/page/6/index.html","hash":"567b6c50bccaabe4002e68572e63de0eb8e2838e","modified":1471937115652},{"_id":"public/archives/page/7/index.html","hash":"d831b14bf772f87f6966c5207cd63d1536785e08","modified":1471937115652},{"_id":"public/archives/page/8/index.html","hash":"a9d4c3ac2a0371e5ad2fb9dcc9e8c889d69285ec","modified":1471937115652},{"_id":"public/archives/page/9/index.html","hash":"336e74bd560fa79465f11bf9bc06c85bbebe968b","modified":1471937115652},{"_id":"public/archives/page/10/index.html","hash":"d964da804725af6f14743fefc8c76db6967e9226","modified":1471937115652},{"_id":"public/archives/2012/index.html","hash":"d964da804725af6f14743fefc8c76db6967e9226","modified":1471937115652},{"_id":"public/archives/2012/01/index.html","hash":"d964da804725af6f14743fefc8c76db6967e9226","modified":1471937115653},{"_id":"public/archives/2013/index.html","hash":"4202a369a943a0b6439cf5467736a9ba7079fe15","modified":1471937115653},{"_id":"public/archives/2013/08/index.html","hash":"4b6c6de9a143be5d6abf268dc46e528f27ac1de8","modified":1471937115653},{"_id":"public/archives/2013/09/index.html","hash":"0f7f92d88463c5ac7eb2727dd7d3eda33e11ac0d","modified":1471937115653},{"_id":"public/archives/2013/10/index.html","hash":"2a2045ed2bfe9b6b1074fd45e31f1d7e73cf43bd","modified":1471937115653},{"_id":"public/archives/2014/index.html","hash":"1051678be87feb840a05f9c469074f015a2882d6","modified":1471937115653},{"_id":"public/archives/2014/01/index.html","hash":"1880a97fc5d20cc55584797db6c43213499a022d","modified":1471937115653},{"_id":"public/archives/2014/04/index.html","hash":"2620b2be20c1ee949cfb9b79141a64661989394f","modified":1471937115653},{"_id":"public/archives/2014/05/index.html","hash":"661c4a77816be12763caf54389b5a2deac948ccd","modified":1471937115653},{"_id":"public/archives/2014/06/index.html","hash":"30705160abf809ac3dcc4a0c53ce1ccfc892c4bb","modified":1471937115653},{"_id":"public/archives/2014/07/index.html","hash":"4e4aac7ca35bd0aca32b6269d97e1d9ac7e723a5","modified":1471937115654},{"_id":"public/archives/2014/10/index.html","hash":"855325e81351b4cb8f2e8e2e1df77340cf54baec","modified":1471937115654},{"_id":"public/archives/2015/index.html","hash":"25587234238a25e55c36c740c957501bcb263d85","modified":1471937115654},{"_id":"public/archives/2015/page/2/index.html","hash":"1ce323a3f39bba99e0d9e966df32128457f42789","modified":1471937115654},{"_id":"public/archives/2015/page/3/index.html","hash":"4fb1007a5600d2748eb13edf3a35f98b57d219f9","modified":1471937115654},{"_id":"public/archives/2015/page/4/index.html","hash":"1221040855c241f5b2358b0696af6c5797710ecc","modified":1471937115654},{"_id":"public/archives/2015/page/5/index.html","hash":"127944fa42d65e2d276a69b95d1e4519d0ce1b30","modified":1471937115654},{"_id":"public/archives/2015/01/index.html","hash":"a0b113b2af455d1233ef6af92552767dbb21f1d0","modified":1471937115654},{"_id":"public/archives/2015/02/index.html","hash":"783d58abc8640d850eddb046555eb65b8e332fa1","modified":1471937115654},{"_id":"public/archives/2015/02/page/2/index.html","hash":"ccd20318883739118ee9f10f36e2402d95295277","modified":1471937115656},{"_id":"public/archives/2015/04/index.html","hash":"a8e0cd81ac5e77ddbf23834f52580551fc9bf62a","modified":1471937115656},{"_id":"public/archives/2015/05/index.html","hash":"193c5d29df0ef84131c9bb104f8efc50812a49f1","modified":1471937115657},{"_id":"public/archives/2015/07/index.html","hash":"f57ec131de19bacbfb53904f46488e563c024cbd","modified":1471937115657},{"_id":"public/archives/2015/08/index.html","hash":"654182d6d85a3062efdc01244f7c2c8e953f3a65","modified":1471937115657},{"_id":"public/archives/2015/09/index.html","hash":"b5a7ea7c395a091939d1fd70bdeb9b44e1065408","modified":1471937115657},{"_id":"public/archives/2015/10/index.html","hash":"4a1167c33cafa1448d6da2e70502fd37bb90ca4c","modified":1471937115657},{"_id":"public/archives/2015/12/index.html","hash":"8a8ced9dd6c94b0bd98e6620b488bb4842a238f0","modified":1471937115657},{"_id":"public/archives/2016/index.html","hash":"fd6440f8e76ac70ad86a1e1177cd4d3ebd9afb15","modified":1471937115657},{"_id":"public/archives/2016/page/2/index.html","hash":"e9de3dde4b3c4aded26e9ac80ccc1c00ec959f1a","modified":1471937115657},{"_id":"public/archives/2016/page/3/index.html","hash":"273b70c056d5622f2fbe51b8d69b12da00ba1aed","modified":1471937115658},{"_id":"public/archives/2016/page/4/index.html","hash":"7e856bc3d6b58bbc5ba70a7cd20227cb44b8cebb","modified":1471937115658},{"_id":"public/archives/2016/01/index.html","hash":"270317df9acf71c402dcda43ba4b7649d6224a83","modified":1471937115658},{"_id":"public/archives/2016/02/index.html","hash":"bcbea865be05b8aa86c4eb8f6173548b390a3bac","modified":1471937115658},{"_id":"public/archives/2016/03/index.html","hash":"677bc805e304d03c97512446d882af2e80f9e589","modified":1471937115658},{"_id":"public/archives/2016/04/index.html","hash":"f96b8499024ab5bbeff39f170e639aa09924c7a1","modified":1471937115658},{"_id":"public/archives/2016/05/index.html","hash":"3d0807ab454e5e22784d16ea0c698b679b8aa790","modified":1471937115658},{"_id":"public/archives/2016/06/index.html","hash":"e589e908b9582a9166291e13975cd4294f3eb0d7","modified":1471937115658},{"_id":"public/archives/2016/07/index.html","hash":"8f7d4066e05a4e2d8cedfce044a7c0be01aab716","modified":1471937115659},{"_id":"public/archives/2016/08/index.html","hash":"3fe086f9f275d9666059860159e7c53f10073086","modified":1471937115659},{"_id":"public/2016/08/09/有趣的JavaScript原生数组函数/index.html","hash":"817582e57730bf365de1311b148c8027b015209a","modified":1471937115659},{"_id":"public/2016/08/03/AngularJS指令实践/index.html","hash":"1a3009b366787c07360d2dfaf43287e8e0ac64e6","modified":1471937115659},{"_id":"public/2016/07/12/59条令人捧腹但真实的程序员编程语录/index.html","hash":"bbdbf58f590f111dbade1d351946a926ef15b282","modified":1471937115659},{"_id":"public/2016/07/12/44个JavaScript变态题解析/index.html","hash":"276cc46b4ad388b75545da95d2b91192ca86a16f","modified":1471937115659},{"_id":"public/2016/05/30/使用ES6写更好的JavaScript/index.html","hash":"33cc1fa0f3ff1abe3fc99fbca742cd3fce26b902","modified":1471937115659},{"_id":"public/2016/05/14/CSS vs JS动画：谁更快？/index.html","hash":"06db6a8242e64cd370c826d24cce7d97da8680d4","modified":1471937115659},{"_id":"public/2016/05/12/12个非常有用的JavaScript技巧/index.html","hash":"e40fab0eb430b20fdcbe80311b9d069de0354d23","modified":1471937115660},{"_id":"public/2016/04/17/AngularJS开发人员最常犯的10个错误/index.html","hash":"e4242ee998446d257e82e072fc236b1e12accd8a","modified":1471937115660},{"_id":"public/2016/03/31/从本质认识JavaScript的原型继承和类继承/index.html","hash":"067ba27e59d85803c92035f87c644a3bd7dadd84","modified":1471937115660},{"_id":"public/2016/03/06/CSS实现垂直居中的常用方法/index.html","hash":"c8e5523e4d278c23ad53d0428af4489bc8e3ab9a","modified":1471937115660},{"_id":"public/2016/03/02/Git详解之Git分支/index.html","hash":"6371555dafe29a1f26751ae0c62affb1c9d63800","modified":1471937115660},{"_id":"public/2016/01/02/毁灭程序员的15个障碍/index.html","hash":"5dad8f2496a8c432920b30de65b054cb437c6910","modified":1471937115660},{"_id":"public/2015/07/13/减少HTTP请求（大型网站优化技术）/index.html","hash":"db2a2a5fdaf8551fe9f96a7f6e3d935a0a4e5f39","modified":1471937115660},{"_id":"public/2015/04/20/【Angularjs文档翻译及实例】DOM事件/index.html","hash":"e7ad77643b7ad37f4b6170a90165b9af7686f4ac","modified":1471937115660},{"_id":"public/2015/04/05/webpack入门指南/index.html","hash":"613be076fe374f4b9218680f3027987a6ecaf6d6","modified":1471937115660},{"_id":"public/2015/02/14/开发者必须知道的HTML5十五大新特性/index.html","hash":"ebf2f60f39157b463cb8890fc0dec023d6fec73a","modified":1471937115661},{"_id":"public/2015/02/11/Web前端面试题目及答案汇总/index.html","hash":"3f002abbfe471a85102fd6b25362a3454b8e2d60","modified":1471937115661},{"_id":"public/2015/02/06/善用meta/index.html","hash":"0aec0b010f90aedcb6667b35cffe4c37702ff3cc","modified":1471937115661},{"_id":"public/2015/02/05/深入理解HTML5标签/index.html","hash":"ca0a281e777fcecbd8d695120fb764c85934d717","modified":1471937115661},{"_id":"public/2015/01/28/详解Javascript的继承实现/index.html","hash":"49d124e238b65878c596cd61a6e49758e8b65e72","modified":1471937115661},{"_id":"public/2015/01/27/学习并运用JavaScript的原生函数/index.html","hash":"cb8025ef0cf35811f00f37632f344ed8fa816b42","modified":1471937115661},{"_id":"public/2015/01/25/移动网页开发总结/index.html","hash":"6efde62213d1d36fd4fa9ecaa8f84e3465a779cb","modified":1471937115661},{"_id":"public/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115661},{"_id":"public/page/2/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115661},{"_id":"public/page/3/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/4/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/5/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/6/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/7/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/8/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/9/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115662},{"_id":"public/page/10/index.html","hash":"908cbbb49846227801d98696199e423a98c14203","modified":1471937115663},{"_id":"public/resource/2016030901.png","hash":"551e10cc31539e338eff4c487b8495b0f78aea9f","modified":1471937115730},{"_id":"public/resource/2016030902.png","hash":"5b5b4aab079ab439da671fa651168fdcd4d1c564","modified":1471937115730},{"_id":"public/resource/2016030903.png","hash":"b58ce162fc04b9b80ebad5c5fa4196c4787f2379","modified":1471937115730},{"_id":"public/resource/2016030904.png","hash":"76e087c3ebc2dfdf73f974266c59f610e366beac","modified":1471937115730},{"_id":"public/resource/2016030905.png","hash":"6802c9148b6f406ca77dd283fb8184c04d2f65f3","modified":1471937115730},{"_id":"public/resource/2016030906.png","hash":"b59e9e36983c8d170f17e8eadced36400d1eae73","modified":1471937115731},{"_id":"public/resource/2016031101.png","hash":"2993032498a14962642c621ac15f60031cdb9cc1","modified":1471937115731},{"_id":"public/resource/2016031102.png","hash":"d0b7d8e7299bbef339de550be401cc21d0a212bc","modified":1471937115731},{"_id":"public/resource/2016031103.png","hash":"2d56fb8d90f89e24cf602c9321f8303827b4e4d5","modified":1471937115731},{"_id":"public/resource/2016031105.png","hash":"4be9b4a87010356dbe278bbb4c7871dd80df13fa","modified":1471937115731},{"_id":"public/resource/2016031104.png","hash":"d0e2c28549cf8a0811772b8038cd2ec10f7dcc3c","modified":1471937115731},{"_id":"public/resource/2016031106.png","hash":"769ac32f519c61e0407e7b8b0ce59cec3358aa3d","modified":1471937115731},{"_id":"public/resource/2016031107.png","hash":"4ef3b5c8506bd98cd3db4015f342a069ad845f62","modified":1471937115731},{"_id":"public/resource/2016031108.png","hash":"2505ea2444b136483e4bea06b253efe7dfac7b33","modified":1471937115731},{"_id":"public/resource/2016031110.png","hash":"d3f69223d324d19094ecfa3be7848253d03c61da","modified":1471937115731},{"_id":"public/resource/2016031109.png","hash":"aceaf4e9a55df06d8b6033ed8fa5cc7f6d4e68c4","modified":1471937115732},{"_id":"public/resource/2016031111.png","hash":"1d10fd3b41dda0b95dbaab687b6108dedf4128e1","modified":1471937115732},{"_id":"public/resource/2016031112.png","hash":"ae202ffab70c3989b821a0177b7b7dd1d4046091","modified":1471937115732},{"_id":"public/resource/2016031113.png","hash":"4cbb4fa6d1d0f9580d51b03d5be49ca580cebca5","modified":1471937115732},{"_id":"public/resource/2016031114.png","hash":"1f52ca5c9858f88c8ae26a8288666f19b06ee765","modified":1471937115732},{"_id":"public/resource/2016031115.png","hash":"4d0d22ba12debd5f1da8fefac72a694651da0ac6","modified":1471937115732},{"_id":"public/resource/2016031116.png","hash":"035d048ac9156262cb5bbd2c935e63928aca308f","modified":1471937115732},{"_id":"public/resource/2016031117.png","hash":"853a66721a2bcad85220ecfb1a4d811986b665a7","modified":1471937115732},{"_id":"public/resource/2016031120.png","hash":"f040949f96287b5509c2ce26a7b11d8829cfbfc8","modified":1471937115732},{"_id":"public/resource/2016031118.png","hash":"33b49d46c9123c3ac9eb27c9d865a96bb1ff7809","modified":1471937115732},{"_id":"public/resource/2016031119.png","hash":"76caaa5b745febd2890bcd2fb78f0818cd08eab5","modified":1471937115733},{"_id":"public/resource/2016031121.png","hash":"e5d2c2e3529640ba79f2b4fad023752c51d9846b","modified":1471937115733},{"_id":"public/resource/2016031122.png","hash":"b7c1d0455da564de2350eb0465c50a79c4aa885b","modified":1471937115733},{"_id":"public/resource/2016031123.png","hash":"3e2e7bfc97eeb5367e0aa06f67a777673c63927e","modified":1471937115733},{"_id":"public/resource/2016031124.png","hash":"59f60a4deba71488e40ab4ad284b33163d97924d","modified":1471937115733},{"_id":"public/resource/2016031125.png","hash":"cc7c806d05212251bd0b475fc50c93143f1b469f","modified":1471937115733},{"_id":"public/resource/2016031126.png","hash":"5722fc69ed952aa8ad646c898eda3fdf2fe3ff99","modified":1471937115733},{"_id":"public/resource/2016031127.png","hash":"1ae9cf0a43e938aa1680557b37ecd3ac06f208ca","modified":1471937115733},{"_id":"public/resource/2016031128.png","hash":"588257aaddf16fd41b10e125865e0e89810cc28b","modified":1471937115733},{"_id":"public/resource/2016031129.png","hash":"0b2c72149b36651e774a8bfd8885f2dd2e12a320","modified":1471937115733},{"_id":"public/resource/2016031130.png","hash":"a513f7dd498078488b01b2111b0fe1119717bdc9","modified":1471937115734},{"_id":"public/resource/2016031131.png","hash":"a56435ee40dc82cb4df8e58e9b031db1f1974c30","modified":1471937115734},{"_id":"public/resource/2016031132.png","hash":"c28acfb977111c62a7bf68564cff6d481337e5de","modified":1471937115734},{"_id":"public/resource/2016031133.png","hash":"7af1dd5572509659e580912d54635d6430c7a293","modified":1471937115734},{"_id":"public/resource/2016031135.png","hash":"16f32efeaff14a181061c60b5c1c6db764772d97","modified":1471937115734},{"_id":"public/resource/2016031134.png","hash":"845bb655177dfa85313af12057b058d013d93157","modified":1471937115734},{"_id":"public/resource/2016031136.png","hash":"1bb4dcade3beadadb9e311f572f64c5cc0097fe9","modified":1471937115734},{"_id":"public/resource/2016031137.png","hash":"c78d0a35771ea36af9cd43268ca1dd0b543e2b75","modified":1471937115734},{"_id":"public/resource/2016031138.png","hash":"181a74e1d098e75a70f596bd1198ddcb2e3b0e2b","modified":1471937115734},{"_id":"public/resource/2016031139.png","hash":"4d6aad68781b319801f2531ad0c9f2d443c7af2e","modified":1471937115734},{"_id":"public/resource/css-ju-zhong-001.png","hash":"781a8a1b35bf8598fc42d485fa2f6e7dd23b8c92","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-003.png","hash":"2ce25003d576f328c1f1b24a63d1e9be20bf2c91","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-004.png","hash":"6a9f20720f1686ec1a5078f84824fca7a4237960","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-002.png","hash":"bb77ddf7683aea437f184c47aa9c2732e44233d0","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-005.png","hash":"a5cbc761df64663a7f848a11eb2bc07cc711d349","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-006.png","hash":"d81961af5a503e27bb19d5a6bf3610ae86165e96","modified":1471937115735},{"_id":"public/resource/css-ju-zhong-007.png","hash":"b7e9a10efe115fd67c43823fea10c5922d3f2f9d","modified":1471937115735},{"_id":"public/css/index.css","hash":"e91425f7b114e7f92ac68133c03e2fb13537c95d","modified":1471937115789},{"_id":"public/resource/README.html","hash":"34efb8171f4ecdc4109a3a8f80c0786277574dde","modified":1471937115789}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"12个非常有用的JavaScript技巧","date":"2016-05-11T16:00:00.000Z","_content":"\n在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。\n\n### 使用!!操作符转换布尔值\n\n有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回`true`值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用`!!variable`做检测，只要变量的值为:`0`、`null`、`\" \"`、`undefined`或者`NaN`都将返回的是`false`，反之返回的是`true`。比如下面的示例：\n\n```javascript\nfunction Account(cash) {\n    this.cash = cash;\n    this.hasMoney = !!cash;\n}\nvar account = new Account(100.50);\nconsole.log(account.cash); // 100.50\nconsole.log(account.hasMoney); // true\n\nvar emptyAccount = new Account(0);\nconsole.log(emptyAccount.cash); // 0\nconsole.log(emptyAccount.hasMoney); // false\n```\n\n在这个示例中，只要`account.cash`的值大于0，那么`account.hasMoney`返回的值就是`true`。\n\n### 使用+将字符串转换成数字\n\n这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：\n\n```javascript\nfunction toNumber(strNumber) {\n    return +strNumber;\n}\nconsole.log(toNumber(\"1234\")); // 1234\nconsole.log(toNumber(\"ACB\")); // NaN\n```\n\n这个也适用于`Date`，在本例中，它将返回的是时间戳数字：\n\n```javascript\nconsole.log(+new Date) // 1461288164385\n```\n\n### 并条件符\n\n如果你有一段这样的代码：\n\n```javascript\nif (conected) {\n    login;\n}\n```\n\n你也可以将变量简写，并且使用`&&`和函数连接在一起，比如上面的示例，可以简写成这样：\n\n```javascript\nconected && login;\n```\n\n如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：\n\n```javascript\nuser && user.login;\n```\n\n### 使用||运算符\n\n在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用`||`操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为`false`，那么第二个值将会认为是一个默认值。如下面这个示例：\n\n```javascript\nfunction User(name, age) {\n    this.name = name || \"Oliver Queen\";\n    this.age = age || 27;\n}\nvar user1 = new User;\nconsole.log(user1.name); // Oliver Queen\nconsole.log(user1.age); // 27\n\nvar user2 = new User(\"Barry Allen\", 25);\nconsole.log(user2.name); // Barry Allen\nconsole.log(user2.age); // 25\n```\n\n### 在循环中缓存array.length\n\n这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：\n\n```javascript\nfor(var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n}\n```\n\n如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：\n\n```javascript\nvar length = array.length;\nfor(var i = 0; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n你也可以写在这样：\n\n```javascript\nfor(var i = 0, length = array.length; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n### 检测对象中属性\n\n当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用`document.querySelector`来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：\n\n```javascript\nif ('querySelector' in document) {\n    document.querySelector(\"#id\");\n} else {\n    document.getElementById(\"id\");\n}\n```\n\n在这个示例中，如果document不存在querySelector函数，那么就会调用`docuemnt.getElementById(\"id\")`。\n\n### 获取数组中最后一个元素\n\n`Array.prototype.slice(begin,end)`用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.slice(-1)); // [6]\nconsole.log(array.slice(-2)); // [5,6]\nconsole.log(array.slice(-3)); // [4,5,6]\n```\n\n### 数组截断\n\n这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.length); // 6\narray.length = 3;\nconsole.log(array.length); // 3\nconsole.log(array); // [1,2,3]\n```\n\n### 替换所有\n\n`String.replace`函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：\n\n```javascript\nvar string = \"john john\";\nconsole.log(string.replace(/hn/, \"ana\")); // \"joana john\"\nconsole.log(string.replace(/hn/g, \"ana\")); // \"joana joana\"\n```\n\n### 合并数组\n\n如果你要合并两个数组，一般情况之下你都会使用`Array.concat`函数：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.concat(array2)); // [1,2,3,4,5,6];\n```\n\n然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用`Array.pus.apply(arr1,arr2)`来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];\n```\n\n### 将NodeList转换成数组\n\n如果你运行`document.querySelectorAll(“p”)`函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用`.slice.call(elements)`来实现：\n\n```javascript\nvar elements = document.querySelectorAll(\"p\"); // NodeList\nvar arrayElements = .slice.call(elements); // Now the NodeList is an array\nvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array\n```\n\n### 数组元素的洗牌\n\n对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：\n\n```javascript\nvar list = [1,2,3];\nconsole.log(list.sort(function { Math.random - 0.5 })); // [2,1,3]\n```\n\n### 总结\n\n现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。\n\n","source":"_posts/12个非常有用的JavaScript技巧.md","raw":"---\ntitle: 12个非常有用的JavaScript技巧\ntags: [javascript,jquery]\ndate: 2016/05/12\n---\n\n在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。\n\n### 使用!!操作符转换布尔值\n\n有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回`true`值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用`!!variable`做检测，只要变量的值为:`0`、`null`、`\" \"`、`undefined`或者`NaN`都将返回的是`false`，反之返回的是`true`。比如下面的示例：\n\n```javascript\nfunction Account(cash) {\n    this.cash = cash;\n    this.hasMoney = !!cash;\n}\nvar account = new Account(100.50);\nconsole.log(account.cash); // 100.50\nconsole.log(account.hasMoney); // true\n\nvar emptyAccount = new Account(0);\nconsole.log(emptyAccount.cash); // 0\nconsole.log(emptyAccount.hasMoney); // false\n```\n\n在这个示例中，只要`account.cash`的值大于0，那么`account.hasMoney`返回的值就是`true`。\n\n### 使用+将字符串转换成数字\n\n这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：\n\n```javascript\nfunction toNumber(strNumber) {\n    return +strNumber;\n}\nconsole.log(toNumber(\"1234\")); // 1234\nconsole.log(toNumber(\"ACB\")); // NaN\n```\n\n这个也适用于`Date`，在本例中，它将返回的是时间戳数字：\n\n```javascript\nconsole.log(+new Date) // 1461288164385\n```\n\n### 并条件符\n\n如果你有一段这样的代码：\n\n```javascript\nif (conected) {\n    login;\n}\n```\n\n你也可以将变量简写，并且使用`&&`和函数连接在一起，比如上面的示例，可以简写成这样：\n\n```javascript\nconected && login;\n```\n\n如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：\n\n```javascript\nuser && user.login;\n```\n\n### 使用||运算符\n\n在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用`||`操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为`false`，那么第二个值将会认为是一个默认值。如下面这个示例：\n\n```javascript\nfunction User(name, age) {\n    this.name = name || \"Oliver Queen\";\n    this.age = age || 27;\n}\nvar user1 = new User;\nconsole.log(user1.name); // Oliver Queen\nconsole.log(user1.age); // 27\n\nvar user2 = new User(\"Barry Allen\", 25);\nconsole.log(user2.name); // Barry Allen\nconsole.log(user2.age); // 25\n```\n\n### 在循环中缓存array.length\n\n这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：\n\n```javascript\nfor(var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n}\n```\n\n如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：\n\n```javascript\nvar length = array.length;\nfor(var i = 0; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n你也可以写在这样：\n\n```javascript\nfor(var i = 0, length = array.length; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n### 检测对象中属性\n\n当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用`document.querySelector`来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：\n\n```javascript\nif ('querySelector' in document) {\n    document.querySelector(\"#id\");\n} else {\n    document.getElementById(\"id\");\n}\n```\n\n在这个示例中，如果document不存在querySelector函数，那么就会调用`docuemnt.getElementById(\"id\")`。\n\n### 获取数组中最后一个元素\n\n`Array.prototype.slice(begin,end)`用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.slice(-1)); // [6]\nconsole.log(array.slice(-2)); // [5,6]\nconsole.log(array.slice(-3)); // [4,5,6]\n```\n\n### 数组截断\n\n这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.length); // 6\narray.length = 3;\nconsole.log(array.length); // 3\nconsole.log(array); // [1,2,3]\n```\n\n### 替换所有\n\n`String.replace`函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：\n\n```javascript\nvar string = \"john john\";\nconsole.log(string.replace(/hn/, \"ana\")); // \"joana john\"\nconsole.log(string.replace(/hn/g, \"ana\")); // \"joana joana\"\n```\n\n### 合并数组\n\n如果你要合并两个数组，一般情况之下你都会使用`Array.concat`函数：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.concat(array2)); // [1,2,3,4,5,6];\n```\n\n然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用`Array.pus.apply(arr1,arr2)`来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];\n```\n\n### 将NodeList转换成数组\n\n如果你运行`document.querySelectorAll(“p”)`函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用`.slice.call(elements)`来实现：\n\n```javascript\nvar elements = document.querySelectorAll(\"p\"); // NodeList\nvar arrayElements = .slice.call(elements); // Now the NodeList is an array\nvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array\n```\n\n### 数组元素的洗牌\n\n对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：\n\n```javascript\nvar list = [1,2,3];\nconsole.log(list.sort(function { Math.random - 0.5 })); // [2,1,3]\n```\n\n### 总结\n\n现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。\n\n","slug":"12个非常有用的JavaScript技巧","published":1,"updated":"2016-08-17T06:22:19.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpgw000068ddmpr2lptl","content":"<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p>\n<h3 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用!!操作符转换布尔值\"></a>使用!!操作符转换布尔值</h3><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account</span>(<span class=\"params\">cash</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cash = cash;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hasMoney = !!cash;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> account = <span class=\"keyword\">new</span> Account(<span class=\"number\">100.50</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(account.cash); <span class=\"comment\">// 100.50</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(account.hasMoney); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> emptyAccount = <span class=\"keyword\">new</span> Account(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.cash); <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.hasMoney); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>在这个示例中，只要<code>account.cash</code>的值大于0，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p>\n<h3 id=\"使用-将字符串转换成数字\"><a href=\"#使用-将字符串转换成数字\" class=\"headerlink\" title=\"使用+将字符串转换成数字\"></a>使用+将字符串转换成数字</h3><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +strNumber;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>) <span class=\"comment\">// 1461288164385</span></div></pre></td></tr></table></figure>\n<h3 id=\"并条件符\"><a href=\"#并条件符\" class=\"headerlink\" title=\"并条件符\"></a>并条件符</h3><p>如果你有一段这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (conected) &#123;</div><div class=\"line\">    login;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以将变量简写，并且使用<code>&amp;&amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">conected &amp;&amp; login;</div></pre></td></tr></table></figure>\n<p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">user &amp;&amp; user.login;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-运算符\"><a href=\"#使用-运算符\" class=\"headerlink\" title=\"使用||运算符\"></a>使用||运算符</h3><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">name, age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"Oliver Queen\"</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age || <span class=\"number\">27</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> user1 = <span class=\"keyword\">new</span> User;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(user1.name); <span class=\"comment\">// Oliver Queen</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(user1.age); <span class=\"comment\">// 27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Barry Allen\"</span>, <span class=\"number\">25</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(user2.name); <span class=\"comment\">// Barry Allen</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(user2.age); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure>\n<h3 id=\"在循环中缓存array-length\"><a href=\"#在循环中缓存array-length\" class=\"headerlink\" title=\"在循环中缓存array.length\"></a>在循环中缓存array.length</h3><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> length = array.length;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以写在这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, length = array.length; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h3><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector</code>来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个示例中，如果document不存在querySelector函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p>\n<h3 id=\"获取数组中最后一个元素\"><a href=\"#获取数组中最后一个元素\" class=\"headerlink\" title=\"获取数组中最后一个元素\"></a>获取数组中最后一个元素</h3><p><code>Array.prototype.slice(begin,end)</code>用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-1</span>)); <span class=\"comment\">// [6]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-2</span>)); <span class=\"comment\">// [5,6]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-3</span>)); <span class=\"comment\">// [4,5,6]</span></div></pre></td></tr></table></figure>\n<h3 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h3><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></div><div class=\"line\">array.length = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"替换所有\"><a href=\"#替换所有\" class=\"headerlink\" title=\"替换所有\"></a>替换所有</h3><p><code>String.replace</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"john john\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana john\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/g</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana joana\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h3><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></div></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus.apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></div></pre></td></tr></table></figure>\n<h3 id=\"将NodeList转换成数组\"><a href=\"#将NodeList转换成数组\" class=\"headerlink\" title=\"将NodeList转换成数组\"></a>将NodeList转换成数组</h3><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>.slice.call(elements)</code>来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeList</span></div><div class=\"line\"><span class=\"keyword\">var</span> arrayElements = .slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></div><div class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></div></pre></td></tr></table></figure>\n<h3 id=\"数组元素的洗牌\"><a href=\"#数组元素的洗牌\" class=\"headerlink\" title=\"数组元素的洗牌\"></a>数组元素的洗牌</h3><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span> </span>&#123; <span class=\"built_in\">Math</span>.random - <span class=\"number\">0.5</span> &#125;)); <span class=\"comment\">// [2,1,3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。</p>\n","excerpt":"","more":"<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p>\n<h3 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用!!操作符转换布尔值\"></a>使用!!操作符转换布尔值</h3><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account</span>(<span class=\"params\">cash</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.cash = cash;</div><div class=\"line\">    <span class=\"keyword\">this</span>.hasMoney = !!cash;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> account = <span class=\"keyword\">new</span> Account(<span class=\"number\">100.50</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(account.cash); <span class=\"comment\">// 100.50</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(account.hasMoney); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> emptyAccount = <span class=\"keyword\">new</span> Account(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.cash); <span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.hasMoney); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>在这个示例中，只要<code>account.cash</code>的值大于0，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p>\n<h3 id=\"使用-将字符串转换成数字\"><a href=\"#使用-将字符串转换成数字\" class=\"headerlink\" title=\"使用+将字符串转换成数字\"></a>使用+将字符串转换成数字</h3><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> +strNumber;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></div></pre></td></tr></table></figure>\n<p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>) <span class=\"comment\">// 1461288164385</span></div></pre></td></tr></table></figure>\n<h3 id=\"并条件符\"><a href=\"#并条件符\" class=\"headerlink\" title=\"并条件符\"></a>并条件符</h3><p>如果你有一段这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (conected) &#123;</div><div class=\"line\">    login;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以将变量简写，并且使用<code>&amp;&amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">conected &amp;&amp; login;</div></pre></td></tr></table></figure>\n<p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">user &amp;&amp; user.login;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-运算符\"><a href=\"#使用-运算符\" class=\"headerlink\" title=\"使用||运算符\"></a>使用||运算符</h3><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">name, age</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"Oliver Queen\"</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.age = age || <span class=\"number\">27</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> user1 = <span class=\"keyword\">new</span> User;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(user1.name); <span class=\"comment\">// Oliver Queen</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(user1.age); <span class=\"comment\">// 27</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Barry Allen\"</span>, <span class=\"number\">25</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(user2.name); <span class=\"comment\">// Barry Allen</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(user2.age); <span class=\"comment\">// 25</span></div></pre></td></tr></table></figure>\n<h3 id=\"在循环中缓存array-length\"><a href=\"#在循环中缓存array-length\" class=\"headerlink\" title=\"在循环中缓存array.length\"></a>在循环中缓存array.length</h3><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> length = array.length;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以写在这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, length = array.length; i &lt; length; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h3><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector</code>来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在这个示例中，如果document不存在querySelector函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p>\n<h3 id=\"获取数组中最后一个元素\"><a href=\"#获取数组中最后一个元素\" class=\"headerlink\" title=\"获取数组中最后一个元素\"></a>获取数组中最后一个元素</h3><p><code>Array.prototype.slice(begin,end)</code>用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-1</span>)); <span class=\"comment\">// [6]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-2</span>)); <span class=\"comment\">// [5,6]</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-3</span>)); <span class=\"comment\">// [4,5,6]</span></div></pre></td></tr></table></figure>\n<h3 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h3><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></div><div class=\"line\">array.length = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"替换所有\"><a href=\"#替换所有\" class=\"headerlink\" title=\"替换所有\"></a>替换所有</h3><p><code>String.replace</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"john john\"</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana john\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/g</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana joana\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h3><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></div></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus.apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></div></pre></td></tr></table></figure>\n<h3 id=\"将NodeList转换成数组\"><a href=\"#将NodeList转换成数组\" class=\"headerlink\" title=\"将NodeList转换成数组\"></a>将NodeList转换成数组</h3><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>.slice.call(elements)</code>来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeList</span></div><div class=\"line\"><span class=\"keyword\">var</span> arrayElements = .slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></div><div class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></div></pre></td></tr></table></figure>\n<h3 id=\"数组元素的洗牌\"><a href=\"#数组元素的洗牌\" class=\"headerlink\" title=\"数组元素的洗牌\"></a>数组元素的洗牌</h3><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span> </span>&#123; <span class=\"built_in\">Math</span>.random - <span class=\"number\">0.5</span> &#125;)); <span class=\"comment\">// [2,1,3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。</p>\n"},{"title":"12个CSS高级技巧汇总","date":"2015-01-23T16:00:00.000Z","_content":"\n**1、使用:not()在菜单上应用/取消应用边框**\n\n先给每一个菜单项添加边框\n\n```css\n/* add border */\n.nav li {\n\tborder-right: 1px solid #666;\n}\n```\n\n……然后再除去最后一个元素……\n\n```css\n//* remove border */\n.nav li:last-child {\n\tborder-right: none;\n}\n```\n\n……可以直接使用:not()伪类来应用元素：\n\n```css\n.nav li:not(:last-child) {\n\tborder-right: 1px solid #666;\n}\n```\n\n这样代码就干净，易读，易于理解了。\n\n当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：\n\n```css\n.nav li:first-child ~ li {\n\tborder-left: 1px solid #666;\n}\n```\n\n**2、给body添加行高**\n\n你不需要分别添加 line-height 到每个```<p>```，```<h*>```等。只要添加到body即可：\n\n```css\nbody {\n\tline-height: 1;\n}\n```\n\n这样文本元素就可以很容易地从body继承。\n\n**3、所有一切都垂直居中**\n\n要将所有元素垂直居中，太简单了：\n\n```css\nhtml, body {\n\theight: 100%;\n\tmargin: 0;\n}\n\nbody {\n\t-webkit-align-items: center;\n\t-ms-flex-align: center;\n\talign-items: center;\n\tdisplay: -webkit-flex;\n\tdisplay: flex;\n}\n```\n\n看，是不是很简单。\n\n> 注：在IE11中要小心flexbox。\n\n**4、逗号分隔的列表**\n\n让HTML列表项看上去像一个真正的，用逗号分隔的列表：\n\n```css\nul > li:not(:last-child)::after {\n\tcontent: \",\";\n}\n```\n\n对最后一个列表项使用:not()伪类。\n\n**5、使用负的nth-child选择项目**\n\n在CSS中使用负的 nth-child 选择项目1到项目n。\n\n```css\nli {\n\tdisplay: none;\n}\n\n/* select items 1 through 3 and display them */\nli:nth-child(-n+3) {\n\tdisplay: block;\n}\n```\n\n就是这么容易。\n\n**6、对图标使用SVG**\n\n我们没有理由不对图标使用SVG：\n\n```css\n.logo {\n\tbackground: url(\"logo.svg\");\n}\n```\n\nSVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。\n\n**7、优化显示文本**\n\n有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：\n\n```css\nhtml {\n\t-moz-osx-font-smoothing: grayscale;\n\t-webkit-font-smoothing: antialiased;\n\ttext-rendering: optimizeLegibility;\n}\n```\n\n注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。\n\n**8、对纯CSS滑块使用max-height**\n\n使用max-height和溢出隐藏来实现只有CSS的滑块：\n\n```css\n.slider ul {\n\tmax-height: 0;\n\toverlow: hidden;\n}\n\n.slider:hover ul {\n\tmax-height: 1000px;\n\ttransition: .3s ease;\n}\n```\n\n**9、继承box-sizing**\n\n让box-sizing继承html：\n\n```css\nhtml {\n\tbox-sizing: border-box;\n}\n\n*, *:before, *:after {\n\tbox-sizing: inherit;\n}\n```\n\n这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。\n\n**10、表格单元格等宽**\n\n表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：\n\n```css\n.calendar {\n\ttable-layout: fixed;\n}\n```\n\n**11、用Flexbox摆脱外边距的各种hack**\n\n当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：\n\n```css\n.list {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.list .person {\n\tflex-basis: 23%;\n}\n```\n\n现在，列表分隔符就会在均匀间隔的位置出现。\n\n**12、使用属性选择器用于空链接**\n\n当`<a>`元素没有文本值，但href属性有链接的时候显示链接：\n\n```css\na[href^=\"http\"]:empty::before {\n\tcontent: attr(href);\n}\n```\n\n相当方便。\n\n> 些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。","source":"_posts/12个CSS高级技巧汇总.md","raw":"---\ntitle: 12个CSS高级技巧汇总\ntags: [css]\ndate: 2015/01/24\n---\n\n**1、使用:not()在菜单上应用/取消应用边框**\n\n先给每一个菜单项添加边框\n\n```css\n/* add border */\n.nav li {\n\tborder-right: 1px solid #666;\n}\n```\n\n……然后再除去最后一个元素……\n\n```css\n//* remove border */\n.nav li:last-child {\n\tborder-right: none;\n}\n```\n\n……可以直接使用:not()伪类来应用元素：\n\n```css\n.nav li:not(:last-child) {\n\tborder-right: 1px solid #666;\n}\n```\n\n这样代码就干净，易读，易于理解了。\n\n当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：\n\n```css\n.nav li:first-child ~ li {\n\tborder-left: 1px solid #666;\n}\n```\n\n**2、给body添加行高**\n\n你不需要分别添加 line-height 到每个```<p>```，```<h*>```等。只要添加到body即可：\n\n```css\nbody {\n\tline-height: 1;\n}\n```\n\n这样文本元素就可以很容易地从body继承。\n\n**3、所有一切都垂直居中**\n\n要将所有元素垂直居中，太简单了：\n\n```css\nhtml, body {\n\theight: 100%;\n\tmargin: 0;\n}\n\nbody {\n\t-webkit-align-items: center;\n\t-ms-flex-align: center;\n\talign-items: center;\n\tdisplay: -webkit-flex;\n\tdisplay: flex;\n}\n```\n\n看，是不是很简单。\n\n> 注：在IE11中要小心flexbox。\n\n**4、逗号分隔的列表**\n\n让HTML列表项看上去像一个真正的，用逗号分隔的列表：\n\n```css\nul > li:not(:last-child)::after {\n\tcontent: \",\";\n}\n```\n\n对最后一个列表项使用:not()伪类。\n\n**5、使用负的nth-child选择项目**\n\n在CSS中使用负的 nth-child 选择项目1到项目n。\n\n```css\nli {\n\tdisplay: none;\n}\n\n/* select items 1 through 3 and display them */\nli:nth-child(-n+3) {\n\tdisplay: block;\n}\n```\n\n就是这么容易。\n\n**6、对图标使用SVG**\n\n我们没有理由不对图标使用SVG：\n\n```css\n.logo {\n\tbackground: url(\"logo.svg\");\n}\n```\n\nSVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。\n\n**7、优化显示文本**\n\n有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：\n\n```css\nhtml {\n\t-moz-osx-font-smoothing: grayscale;\n\t-webkit-font-smoothing: antialiased;\n\ttext-rendering: optimizeLegibility;\n}\n```\n\n注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。\n\n**8、对纯CSS滑块使用max-height**\n\n使用max-height和溢出隐藏来实现只有CSS的滑块：\n\n```css\n.slider ul {\n\tmax-height: 0;\n\toverlow: hidden;\n}\n\n.slider:hover ul {\n\tmax-height: 1000px;\n\ttransition: .3s ease;\n}\n```\n\n**9、继承box-sizing**\n\n让box-sizing继承html：\n\n```css\nhtml {\n\tbox-sizing: border-box;\n}\n\n*, *:before, *:after {\n\tbox-sizing: inherit;\n}\n```\n\n这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。\n\n**10、表格单元格等宽**\n\n表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：\n\n```css\n.calendar {\n\ttable-layout: fixed;\n}\n```\n\n**11、用Flexbox摆脱外边距的各种hack**\n\n当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：\n\n```css\n.list {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.list .person {\n\tflex-basis: 23%;\n}\n```\n\n现在，列表分隔符就会在均匀间隔的位置出现。\n\n**12、使用属性选择器用于空链接**\n\n当`<a>`元素没有文本值，但href属性有链接的时候显示链接：\n\n```css\na[href^=\"http\"]:empty::before {\n\tcontent: attr(href);\n}\n```\n\n相当方便。\n\n> 些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。","slug":"12个CSS高级技巧汇总","published":1,"updated":"2016-08-17T06:22:19.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cph2000168ddvst7mnjt","content":"<p><strong>1、使用:not()在菜单上应用/取消应用边框</strong></p>\n<p>先给每一个菜单项添加边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* add border */</span></div><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>……然后再除去最后一个元素……</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//* remove border */</div><div class=\"line\">.nav li:last-child &#123;</div><div class=\"line\">\tborder-right: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>……可以直接使用:not()伪类来应用元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样代码就干净，易读，易于理解了。</p>\n<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> ~ <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-left</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>2、给body添加行高</strong></p>\n<p>你不需要分别添加 line-height 到每个<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">```css</div><div class=\"line\">body &#123;</div><div class=\"line\">\tline-height: 1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样文本元素就可以很容易地从body继承。</p>\n<p><strong>3、所有一切都垂直居中</strong></p>\n<p>要将所有元素垂直居中，太简单了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-align-items</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">-ms-flex-align</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">align-items</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看，是不是很简单。</p>\n<blockquote>\n<p>注：在IE11中要小心flexbox。</p>\n</blockquote>\n<p><strong>4、逗号分隔的列表</strong></p>\n<p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ul</span> &gt; <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span><span class=\"selector-pseudo\">::after</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\",\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对最后一个列表项使用:not()伪类。</p>\n<p><strong>5、使用负的nth-child选择项目</strong></p>\n<p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* select items 1 through 3 and display them */</span></div><div class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child(-n+3)</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就是这么容易。</p>\n<p><strong>6、对图标使用SVG</strong></p>\n<p>我们没有理由不对图标使用SVG：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"logo.svg\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>\n<p><strong>7、优化显示文本</strong></p>\n<p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">\t<span class=\"attribute\">text-rendering</span>: optimizeLegibility;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。</p>\n<p><strong>8、对纯CSS滑块使用max-height</strong></p>\n<p>使用max-height和溢出隐藏来实现只有CSS的滑块：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.slider</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">overlow</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.slider</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">1000px</span>;</div><div class=\"line\">\t<span class=\"attribute\">transition</span>: .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>9、继承box-sizing</strong></p>\n<p>让box-sizing继承html：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">box-sizing</span>: inherit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。</p>\n<p><strong>10、表格单元格等宽</strong></p>\n<p>表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.calendar</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">table-layout</span>: fixed;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>11、用Flexbox摆脱外边距的各种hack</strong></p>\n<p>当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: flex;</div><div class=\"line\">\t<span class=\"attribute\">justify-content</span>: space-between;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.list</span> <span class=\"selector-class\">.person</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">flex-basis</span>: <span class=\"number\">23%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，列表分隔符就会在均匀间隔的位置出现。</p>\n<p><strong>12、使用属性选择器用于空链接</strong></p>\n<p>当<code>&lt;a&gt;</code>元素没有文本值，但href属性有链接的时候显示链接：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href^=\"http\"]</span><span class=\"selector-pseudo\">:empty</span><span class=\"selector-pseudo\">::before</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(href);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>相当方便。</p>\n<blockquote>\n<p>些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。</p>\n</blockquote>\n","excerpt":"","more":"<p><strong>1、使用:not()在菜单上应用/取消应用边框</strong></p>\n<p>先给每一个菜单项添加边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* add border */</span></div><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>……然后再除去最后一个元素……</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">//* remove border */</div><div class=\"line\">.nav li:last-child &#123;</div><div class=\"line\">\tborder-right: none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>……可以直接使用:not()伪类来应用元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样代码就干净，易读，易于理解了。</p>\n<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> ~ <span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">border-left</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>2、给body添加行高</strong></p>\n<p>你不需要分别添加 line-height 到每个<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">```css</div><div class=\"line\">body &#123;</div><div class=\"line\">\tline-height: 1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样文本元素就可以很容易地从body继承。</p>\n<p><strong>3、所有一切都垂直居中</strong></p>\n<p>要将所有元素垂直居中，太简单了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-tag\">body</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-align-items</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">-ms-flex-align</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">align-items</span>: center;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: -webkit-flex;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看，是不是很简单。</p>\n<blockquote>\n<p>注：在IE11中要小心flexbox。</p>\n</blockquote>\n<p><strong>4、逗号分隔的列表</strong></p>\n<p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">ul</span> &gt; <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span><span class=\"selector-pseudo\">::after</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\",\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对最后一个列表项使用:not()伪类。</p>\n<p><strong>5、使用负的nth-child选择项目</strong></p>\n<p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">li</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: none;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* select items 1 through 3 and display them */</span></div><div class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child(-n+3)</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: block;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>就是这么容易。</p>\n<p><strong>6、对图标使用SVG</strong></p>\n<p>我们没有理由不对图标使用SVG：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"logo.svg\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>\n<p><strong>7、优化显示文本</strong></p>\n<p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale;</div><div class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</div><div class=\"line\">\t<span class=\"attribute\">text-rendering</span>: optimizeLegibility;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。</p>\n<p><strong>8、对纯CSS滑块使用max-height</strong></p>\n<p>使用max-height和溢出隐藏来实现只有CSS的滑块：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.slider</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">overlow</span>: hidden;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.slider</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-tag\">ul</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">1000px</span>;</div><div class=\"line\">\t<span class=\"attribute\">transition</span>: .<span class=\"number\">3s</span> ease;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>9、继承box-sizing</strong></p>\n<p>让box-sizing继承html：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">box-sizing</span>: inherit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。</p>\n<p><strong>10、表格单元格等宽</strong></p>\n<p>表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.calendar</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">table-layout</span>: fixed;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>11、用Flexbox摆脱外边距的各种hack</strong></p>\n<p>当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.list</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">display</span>: flex;</div><div class=\"line\">\t<span class=\"attribute\">justify-content</span>: space-between;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"selector-class\">.list</span> <span class=\"selector-class\">.person</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">flex-basis</span>: <span class=\"number\">23%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，列表分隔符就会在均匀间隔的位置出现。</p>\n<p><strong>12、使用属性选择器用于空链接</strong></p>\n<p>当<code>&lt;a&gt;</code>元素没有文本值，但href属性有链接的时候显示链接：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href^=\"http\"]</span><span class=\"selector-pseudo\">:empty</span><span class=\"selector-pseudo\">::before</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(href);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>相当方便。</p>\n<blockquote>\n<p>些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。</p>\n</blockquote>\n"},{"title":"59条令人捧腹但真实的程序员编程语录","date":"2016-07-12T02:18:37.000Z","_content":"\n### 第1题\n\n```\n[\"1\", \"2\", \"3\"].map(parseInt)\n```\n\n知识点:\n\n- [Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n- [Number/parseInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt)\n- [JavaScript parseInt](http://www.w3school.com.cn/jsref/jsref_parseInt.asp)\n\n首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值\n\n其中回调函数接受三个参数 currentValue, index, arrary;\n\n而题目中, map只传入了回调函数–parseInt.\n\n其次, parseInt 只接受两个两个参数 string, radix(基数).\n\n> 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。\n>\n> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。\n>\n> 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n\n所以本题即问\n\n```\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n\n首先后两者参数不合法.\n\n所以答案是 `[1, NaN, NaN]`\n\n### 第2题\n\n```\n[typeof null, null instanceof Object]\n```\n\n两个知识点:\n\n- [Operators/typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)\n- [Operators/instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)\n- [Operators/instanceof(中)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)\n\ntypeof 返回一个表示类型的字符串.\n\ninstanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.\n\n这个题可以直接看链接… 因为 `typeof null === 'object'` 自语言之初就是这样….\n\ntypeof 的结果请看下表:\n\n```\ntype         result\nUndefined   \"undefined\"\nNull        \"object\"\nBoolean     \"boolean\"\nNumber      \"number\"\nString      \"string\"\nSymbol      \"symbol\"\nHost object Implementation-dependent\nFunction    \"function\"\nObject      \"object\"\n```\n\n所以答案 `[object, false]`\n\n### 第3题\n\n```\n[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]\n```\n\n知识点:\n\n- [Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n`arr.reduce(callback[, initialValue])`\n\nreduce接受两个参数, 一个回调, 一个初始值.\n\n回调函数接受四个参数 `previousValue, currentValue, currentIndex, array`\n\n需要注意的是 `If the array is empty and no initialValue was provided, TypeError would be thrown.`\n\n所以第二个表达式会报异常. 第一个表达式等价于 `Math.pow(3, 2) => 9; Math.pow(9, 1) =>9`\n\n答案 `an error`\n\n### 第4题\n\n```\nvar val = 'smtg';\nconsole.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n```\n\n两个知识点:\n\n- [Operators/Operator_Precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n- [Operators/Conditional_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)\n\n简而言之 `+` 的优先级 大于 `?`\n\n所以原题等价于 `'Value is true' ? 'Somthing' : 'Nonthing'` 而不是 `'Value is' + (true ? 'Something' : 'Nonthing')`\n\n答案 `'Something'`\n\n### 第5题\n\n```\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n\n这个相对简单, 一个知识点:\n\n- [Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n\n在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。\n\n这个题目相当于\n\n```\nvar name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n\n所以答案是 `'Goodbye Jack'`\n\n### 第6题\n\n```\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count);\n```\n\n一个知识点:\n\n- [Infinity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity)\n\n~~在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.~~\n\n补充: [@jelly7723](https://github.com/jelly7723)\n\n> js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。\n> 2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。\n> 9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。\n\n### 第7题\n\n```\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;});\n```\n\n答案是 `[]`\n\n看一篇文章理解稀疏数组\n\n- [译 JavaScript中的稀疏数组与密集数组](http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687165.html)\n- [Array/filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n\n我们来看一下 Array.prototype.filter 的 polyfill:\n\n```\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function(fun/*, thisArg*/) {\n    'use strict';\n\n    if (this === void 0 || this === null) {\n      throw new TypeError();\n    }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== 'function') {\n      throw new TypeError();\n    }\n\n    var res = [];\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    for (var i = 0; i < len; i++) {\n      if (i in t) { // 注意这里!!!\n        var val = t[i];\n        if (fun.call(thisArg, val, i, t)) {\n          res.push(val);\n        }\n      }\n    }\n\n    return res;\n  };\n}\n```\n\n我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.\n\n```\n0 in ary; => true\n3 in ary; => false\n10 in ary; => true\n```\n\n也就是说 从 3 – 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.\n\n### 第8题\n\n```\nvar two   = 0.2\nvar one   = 0.1\nvar eight = 0.8\nvar six   = 0.6\n[two - one == one, eight - six == two]\n```\n\n- [JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3](http://ourjs.com/detail/54695381bc3f9b154e000046)\n\nIEEE 754标准中的[浮点数](http://www.codeceo.com/article/float-number.html)并不能精确地表达小数\n\n那什么时候精准, 什么时候不经准呢? 笔者也不知道…\n\n答案 `[true, false]`\n\n### 第9题\n\n```\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A'));\n```\n\n两个知识点:\n\n- [Statements/switch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)\n- [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\nswitch 是严格比较, String 实例和 字符串不一样.\n\n```\nvar s_prim = 'foo';\nvar s_obj = new String(s_prim);\n\nconsole.log(typeof s_prim); // \"string\"\nconsole.log(typeof s_obj);  // \"object\"\nconsole.log(s_prim === s_obj); // false\n```\n\n答案是 `'Do not know!'`\n\n### 第10题\n\n```\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A'));\n```\n\n解释:\n\n`String(x) does not create an object but does return a string, i.e. typeof String(1) === \"string\"`\n\n还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.\n\n答案 `'Case A'`\n\n### 第11题\n\n```\nfunction isOdd(num) {\n    return num % 2 == 1;\n}\nfunction isEven(num) {\n    return num % 2 == 0;\n}\nfunction isSane(num) {\n    return isEven(num) || isOdd(num);\n}\nvar values = [7, 4, '13', -9, Infinity];\nvalues.map(isSane);\n```\n\n一个知识点\n\n- [Arithmetic_Operators#Remainder](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder)\n\n此题等价于\n\n```\n7 % 2 => 1\n4 % 2 => 0\n'13' % 2 => 1\n-9 % % 2 => -1\nInfinity % 2 => NaN\n```\n\n需要注意的是 余数的正负号随第一个操作数.\n\n答案 `[true, true, true, false, false]`\n\n### 第12题\n\n```\nparseInt(3, 8)\nparseInt(3, 2)\nparseInt(3, 0)\n```\n\n第一个题讲过了, 答案 `3, NaN, 3`\n\n### 第13题\n\n```\nArray.isArray( Array.prototype )\n```\n\n一个知识点:\n\n- [Array/prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)\n\n一个鲜为人知的实事: `Array.prototype => []`;\n\n答案: `true`\n\n### 第14题\n\n```\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n```\n\n- [JavaScript-Equality-Table](https://dorey.github.io/JavaScript-Equality-Table/)\n\n答案: `false`\n\n### 第15题\n\n```\n[]==[]\n```\n\n`==` 是万恶之源, 看上图\n\n答案是 `false`\n\n### 第16题\n\n```\n'5' + 3\n'5' - 3\n```\n\n两个知识点:\n\n- [Arithmetic_Operators#Addition](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition)\n- [Arithmetic_Operators#Subtraction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction)\n\n`+` 用来表示两个数的和或者字符串拼接, `-`表示两数之差.\n\n请看例子, 体会区别:\n\n```\n> '5' + 3\n'53'\n> 5 + '3'\n'53'\n> 5 - '3'\n2\n> '5' - 3\n2\n> '5' - '3'\n2\n```\n\n也就是说 `-` 会尽可能的将两个操作数变成数字, 而 `+` 如果两边不都是数字, 那么就是字符串拼接.\n\n答案是 `'53', 2`\n\n### 第17题\n\n```\n1 + - + + + - + 1\n```\n\n这里应该是(倒着看)\n\n```\n1 + (a)  => 2\na = - (b) => 1\nb = + (c) => -1\nc = + (d) => -1\nd = + (e) => -1\ne = + (f) => -1\nf = - (g) => -1\ng = + 1   => 1\n```\n\n所以答案 `2`\n\n### 第18题\n\n```\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n```\n\n稀疏数组. 同第7题.\n\n题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.\n\n所以答案是 `[\"1\", undefined × 2]`\n\n这里贴上 Array.prototype.map 的 polyfill.\n\n```\nArray.prototype.map = function(callback, thisArg) {\n\n        var T, A, k;\n\n        if (this == null) {\n            throw new TypeError(' this is null or not defined');\n        }\n\n        var O = Object(this);\n        var len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        A = new Array(len);\n        k = 0;\n        while (k < len) {\n            var kValue, mappedValue;\n            if (k in O) {\n                kValue = O[k];\n                mappedValue = callback.call(T, kValue, k, O);\n                A[k] = mappedValue;\n            }\n            k++;\n        }\n        return A;\n    };\n```\n\n### 第19题\n\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n\n这是一个大坑, 尤其是涉及到 ES6语法的时候\n\n知识点:\n\n- [Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\n\n首先 `The arguments object is an Array-like object corresponding to the arguments passed to a function.`\n\n也就是说 `arguments` 是一个 `object`, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.\n\n所以答案是 `21`.\n\n然而!!!!!!\n\n当函数参数涉及到 `any rest parameters, any default parameters or any destructured parameters` 的时候, 这个 arguments 就不在是一个 `mapped arguments object` 了…..\n\n请看:\n\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c=3) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n\n答案是 `12` !!!!\n\n请读者细细体会!!\n\n### 第20题\n\n```\nvar a = 111111111111111110000,\n    b = 1111;\na + b;\n```\n\n答案还是 `111111111111111110000`. 解释是 `Lack of precision for numbers in JavaScript affects both small and big numbers.` 但是笔者不是很明白……………. 请读者赐教!\n\n### 第21题\n\n```\nvar x = [].reverse;\nx();\n```\n\n这个题有意思!\n\n知识点:\n\n- [Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n`The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.`\n\n也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 `window`.\n\n答案是 `window`\n\n### 第22题\n\n```\nNumber.MIN_VALUE > 0\n```\n\n`true`\n\n### 第23题\n\n```\n[1 < 2 < 3, 3 < 2 < 1]\n```\n\n这个题也还可以.\n\n这个题会让人误以为是 `2 > 1 && 2 < 3` 其实不是的.\n\n这个题等价于\n\n```\n 1 < 2 => true;\n true < 3 =>  1 < 3 => true;\n 3 < 2 => false;\n false < 1 => 0 < 1 => true;\n```\n\n答案是 `[true, true]`\n\n### 第24题\n\n```\n// the most classic wtf\n2 == [[[2]]]\n```\n\n这个题我是猜的. 我猜的 `true`, 至于为什么…..\n\n`both objects get converted to strings and in both cases the resulting string is \"2\"` 我不能信服…\n\n### 第25题\n\n```\n3.toString()\n3..toString()\n3...toString()\n```\n\n这个题也挺逗, 我做对了![:)](http://www.codeceo.com/wp-content/themes/d-simple/img/smilies/icon_smile.gif)答案是 `error, '3', error`\n\n你如果换一个写法就更费解了\n\n```\nvar a = 3;\na.toString()\n```\n\n这个答案就是 `'3'`;\n\n为啥呢?\n\n因为在 js 中 `1.1`, `1.`, `.1` 都是合法的数字. 那么在解析 `3.toString` 的时候这个 `.` 到底是属于这个数字还是函数调用呢? 只能是数字, 因为`3.`合法啊!\n\n### 第26题\n\n```\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y);\nconsole.log(x);\n```\n\n答案是 `1, error`\n\ny 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 `ReferenceError`\n\n### 第27题\n\n```\nvar a = /123/,\n    b = /123/;\na == b\na === b\n```\n\n即使正则的字面量一致, 他们也不相等.\n\n答案 `false, false`\n\n### 第28题\n\n```\nvar a = [1, 2, 3],\n    b = [1, 2, 3],\n    c = [1, 2, 4]\na ==  b\na === b\na >   c\na <   c\n```\n\n字面量相等的数组也不相等.\n\n数组在比较大小的时候按照字典序比较\n\n答案 `false, false, false, true`\n\n### 第29题\n\n```\nvar a = {}, b = Object.prototype;\n[a.prototype === b, Object.getPrototypeOf(a) === b]\n```\n\n知识点:\n\n- [Object/getPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)\n\n只有 Function 拥有一个 prototype 的属性. 所以 `a.prototype` 为 `undefined`.\n\n而 `Object.getPrototypeOf(obj)` 返回一个具体对象的原型(该对象的内部`[[prototype]]`值)\n\n答案 `false, true`\n\n### 第30题\n\n```\nfunction f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b\n```\n\nf.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.\n\nf.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.\n\n请看:\n\n```\na === Object.getPrototypeOf(new f()) // true\nb === Function.prototype // true\n```\n\n答案 `false`\n\n### 第31题\n\n```\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n```\n\n答案 `['foo', 'foo']`\n\n知识点:\n\n- [Function/name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name)\n\n因为函数的名字不可变.\n\n### 第32题\n\n```\n\"1 2 3\".replace(/\\d/g, parseInt)\n```\n\n知识点:\n\n- [String/replace#Specifying_a_function_as_a_parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter)\n\n`str.replace(regexp|substr, newSubStr|function)`\n\n如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数\n\n- match 首先是匹配的字符串\n- p1, p2 …. 然后是正则的分组\n- offset match 匹配的index\n- string 整个字符串\n\n由于题目中的正则没有分组, 所以等价于问\n\n```\nparseInt('1', 0)\nparseInt('2', 2)\nparseInt('3', 4)\n```\n\n答案: `1, NaN, 3`\n\n### 第33题\n\n```\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // ?\nparent.name // ?\ntypeof eval(f.name) // ?\ntypeof eval(parent.name) //  ?\n```\n\n先说以下答案 `'f', 'Empty', 'function', error` 这个答案并不重要…..\n\n这里第一小问和第三小问很简单不解释了.\n\n第二小问笔者在自己的浏览器测试的时候是 `''`, 第四问是 `'undefined'`\n\n所以应该是平台相关的. 这里明白 `parent === Function.prototype` 就好了.\n\n### 第34题\n\n```\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n```\n\n知识点:\n\n- [RegExp/test](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n\n这里 test 函数会将参数转为字符串. `'nul'`, `'undefined'` 自然都是全小写了\n\n答案: `true, true`\n\n### 第35题\n\n```\n[,,,].join(\", \")\n```\n\n`[,,,] => [undefined × 3]`\n\n因为javascript 在定义数组的时候允许最后一个元素后跟一个`,`, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)\n\n答案: `\", , \"`\n\n### 第36题\n\n```\nvar a = {class: \"Animal\", name: 'Fido'};\na.class\n```\n\n这个题比较流氓.. 因为是浏览器相关, `class`是个保留字(现在是个关键字了)\n\n所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 `a['class']`\n\n### 第37题\n\n```\nvar a = new Date(\"epoch\")\n```\n\n知识点:\n\n- [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)\n- [Date/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)\n\n简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.\n\n另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 `Invalid Date`.\n\n答案 `Invalid Date`\n\n### 第38题\n\n```\nvar a = Function.length,\n    b = new Function().length\na === b\n```\n\n我们知道一个function(Function 的实例)的 `length` 属性就是函数签名的参数个数, 所以 b.length == 0.\n\n另外 Function.length 定义为1……\n\n所以不相等…….答案 `false`\n\n### 第39题\n\n```\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n```\n\n还是关于Date 的题, 需要注意的是\n\n- 如果不传参数等价于当前时间.\n- 如果是函数调用 返回一个字符串.\n\n答案 `false, false, false`\n\n### 第40题\n\n```\nvar min = Math.min(), max = Math.max()\nmin < max\n```\n\n知识点:\n\n- [Math/min](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min)\n- [Math/max](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max)\n\n有趣的是, Math.min 不传参数返回 `Infinity`, Math.max 不传参数返回 `-Infinity`\n\n答案: `false`\n\n### 第41题\n\n```\nfunction captureOne(re, str) {\n  var match = re.exec(str);\n  return match && match[1];\n}\nvar numRe  = /num=(\\d+)/ig,\n    wordRe = /word=(\\w+)/i,\n    a1 = captureOne(numRe,  \"num=1\"),\n    a2 = captureOne(wordRe, \"word=1\"),\n    a3 = captureOne(numRe,  \"NUM=2\"),\n    a4 = captureOne(wordRe,  \"WORD=2\");\n[a1 === a2, a3 === a4]\n```\n\n知识点:\n\n- [RegExp/exec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\n\n通俗的讲\n\n因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会\n\n举个例子\n\n```\nvar myRe = /ab*/g;\nvar str = 'abbcdefabh';\nvar myArray;\nwhile ((myArray = myRe.exec(str)) !== null) {\n  var msg = 'Found ' + myArray[0] + '. ';\n  msg += 'Next match starts at ' + myRe.lastIndex;\n  console.log(msg);\n}\n// Found abb. Next match starts at 3\n// Found ab. Next match starts at 9\n```\n\n所以 a1 = ’1′; a2 = ’1′; a3 = null; a4 = ’2′\n\n答案 `[true, false]`\n\n### 第42题\n\n```\nvar a = new Date(\"2014-03-19\"),\n    b = new Date(2014, 03, 19);\n[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]\n```\n\n这个….\n\n> JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.\n\n```\na.getDay()\n3\nb.getDay()\n6\na.getMonth()\n2\nb.getMonth()\n3\n```\n\n都是套路!\n\n答案 `[false, false]`\n\n### 第43题\n\n```\nif ('http://giftwrapped.com/picture.jpg'.match('.gif')) {\n  'a gif file'\n} else {\n  'not a gif file'\n}\n```\n\n知识点:\n\n- [String/match](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n\nString.prototype.match 接受一个正则, 如果不是, 按照 `new RegExp(obj)` 转化. 所以 `.` 并不会转义\n那么 `/gif` 就匹配了 /.gif/\n\n答案: `'a gif file'`\n\n### 第44题\n\n```\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n```\n\n在两个函数里, a作为参数其实已经声明了, 所以 `var a; var a = 'bye'` 其实就是 `a; a ='bye'`\n\n所以答案 `'hello', 'bye'`\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/44-javascript-crazy-question.html)\n英文原文：[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)","source":"_posts/44个JavaScript变态题解析.md","raw":"---\ntitle: 59条令人捧腹但真实的程序员编程语录\ndate: 2016-07-12 10:18:37\ntags: [javascript]\n---\n\n### 第1题\n\n```\n[\"1\", \"2\", \"3\"].map(parseInt)\n```\n\n知识点:\n\n- [Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n- [Number/parseInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt)\n- [JavaScript parseInt](http://www.w3school.com.cn/jsref/jsref_parseInt.asp)\n\n首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值\n\n其中回调函数接受三个参数 currentValue, index, arrary;\n\n而题目中, map只传入了回调函数–parseInt.\n\n其次, parseInt 只接受两个两个参数 string, radix(基数).\n\n> 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。\n>\n> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。\n>\n> 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n\n所以本题即问\n\n```\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n\n首先后两者参数不合法.\n\n所以答案是 `[1, NaN, NaN]`\n\n### 第2题\n\n```\n[typeof null, null instanceof Object]\n```\n\n两个知识点:\n\n- [Operators/typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof)\n- [Operators/instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof)\n- [Operators/instanceof(中)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)\n\ntypeof 返回一个表示类型的字符串.\n\ninstanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.\n\n这个题可以直接看链接… 因为 `typeof null === 'object'` 自语言之初就是这样….\n\ntypeof 的结果请看下表:\n\n```\ntype         result\nUndefined   \"undefined\"\nNull        \"object\"\nBoolean     \"boolean\"\nNumber      \"number\"\nString      \"string\"\nSymbol      \"symbol\"\nHost object Implementation-dependent\nFunction    \"function\"\nObject      \"object\"\n```\n\n所以答案 `[object, false]`\n\n### 第3题\n\n```\n[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]\n```\n\n知识点:\n\n- [Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)\n\n`arr.reduce(callback[, initialValue])`\n\nreduce接受两个参数, 一个回调, 一个初始值.\n\n回调函数接受四个参数 `previousValue, currentValue, currentIndex, array`\n\n需要注意的是 `If the array is empty and no initialValue was provided, TypeError would be thrown.`\n\n所以第二个表达式会报异常. 第一个表达式等价于 `Math.pow(3, 2) => 9; Math.pow(9, 1) =>9`\n\n答案 `an error`\n\n### 第4题\n\n```\nvar val = 'smtg';\nconsole.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');\n```\n\n两个知识点:\n\n- [Operators/Operator_Precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n- [Operators/Conditional_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)\n\n简而言之 `+` 的优先级 大于 `?`\n\n所以原题等价于 `'Value is true' ? 'Somthing' : 'Nonthing'` 而不是 `'Value is' + (true ? 'Something' : 'Nonthing')`\n\n答案 `'Something'`\n\n### 第5题\n\n```\nvar name = 'World!';\n(function () {\n    if (typeof name === 'undefined') {\n        var name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n\n这个相对简单, 一个知识点:\n\n- [Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n\n在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。\n\n这个题目相当于\n\n```\nvar name = 'World!';\n(function () {\n    var name;\n    if (typeof name === 'undefined') {\n        name = 'Jack';\n        console.log('Goodbye ' + name);\n    } else {\n        console.log('Hello ' + name);\n    }\n})();\n```\n\n所以答案是 `'Goodbye Jack'`\n\n### 第6题\n\n```\nvar END = Math.pow(2, 53);\nvar START = END - 100;\nvar count = 0;\nfor (var i = START; i <= END; i++) {\n    count++;\n}\nconsole.log(count);\n```\n\n一个知识点:\n\n- [Infinity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity)\n\n~~在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.~~\n\n补充: [@jelly7723](https://github.com/jelly7723)\n\n> js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。\n> 2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。\n> 9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。\n\n### 第7题\n\n```\nvar ary = [0,1,2];\nary[10] = 10;\nary.filter(function(x) { return x === undefined;});\n```\n\n答案是 `[]`\n\n看一篇文章理解稀疏数组\n\n- [译 JavaScript中的稀疏数组与密集数组](http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687165.html)\n- [Array/filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n\n我们来看一下 Array.prototype.filter 的 polyfill:\n\n```\nif (!Array.prototype.filter) {\n  Array.prototype.filter = function(fun/*, thisArg*/) {\n    'use strict';\n\n    if (this === void 0 || this === null) {\n      throw new TypeError();\n    }\n\n    var t = Object(this);\n    var len = t.length >>> 0;\n    if (typeof fun !== 'function') {\n      throw new TypeError();\n    }\n\n    var res = [];\n    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n    for (var i = 0; i < len; i++) {\n      if (i in t) { // 注意这里!!!\n        var val = t[i];\n        if (fun.call(thisArg, val, i, t)) {\n          res.push(val);\n        }\n      }\n    }\n\n    return res;\n  };\n}\n```\n\n我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.\n\n```\n0 in ary; => true\n3 in ary; => false\n10 in ary; => true\n```\n\n也就是说 从 3 – 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.\n\n### 第8题\n\n```\nvar two   = 0.2\nvar one   = 0.1\nvar eight = 0.8\nvar six   = 0.6\n[two - one == one, eight - six == two]\n```\n\n- [JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3](http://ourjs.com/detail/54695381bc3f9b154e000046)\n\nIEEE 754标准中的[浮点数](http://www.codeceo.com/article/float-number.html)并不能精确地表达小数\n\n那什么时候精准, 什么时候不经准呢? 笔者也不知道…\n\n答案 `[true, false]`\n\n### 第9题\n\n```\nfunction showCase(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase(new String('A'));\n```\n\n两个知识点:\n\n- [Statements/switch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)\n- [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\nswitch 是严格比较, String 实例和 字符串不一样.\n\n```\nvar s_prim = 'foo';\nvar s_obj = new String(s_prim);\n\nconsole.log(typeof s_prim); // \"string\"\nconsole.log(typeof s_obj);  // \"object\"\nconsole.log(s_prim === s_obj); // false\n```\n\n答案是 `'Do not know!'`\n\n### 第10题\n\n```\nfunction showCase2(value) {\n    switch(value) {\n    case 'A':\n        console.log('Case A');\n        break;\n    case 'B':\n        console.log('Case B');\n        break;\n    case undefined:\n        console.log('undefined');\n        break;\n    default:\n        console.log('Do not know!');\n    }\n}\nshowCase2(String('A'));\n```\n\n解释:\n\n`String(x) does not create an object but does return a string, i.e. typeof String(1) === \"string\"`\n\n还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.\n\n答案 `'Case A'`\n\n### 第11题\n\n```\nfunction isOdd(num) {\n    return num % 2 == 1;\n}\nfunction isEven(num) {\n    return num % 2 == 0;\n}\nfunction isSane(num) {\n    return isEven(num) || isOdd(num);\n}\nvar values = [7, 4, '13', -9, Infinity];\nvalues.map(isSane);\n```\n\n一个知识点\n\n- [Arithmetic_Operators#Remainder](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder)\n\n此题等价于\n\n```\n7 % 2 => 1\n4 % 2 => 0\n'13' % 2 => 1\n-9 % % 2 => -1\nInfinity % 2 => NaN\n```\n\n需要注意的是 余数的正负号随第一个操作数.\n\n答案 `[true, true, true, false, false]`\n\n### 第12题\n\n```\nparseInt(3, 8)\nparseInt(3, 2)\nparseInt(3, 0)\n```\n\n第一个题讲过了, 答案 `3, NaN, 3`\n\n### 第13题\n\n```\nArray.isArray( Array.prototype )\n```\n\n一个知识点:\n\n- [Array/prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype)\n\n一个鲜为人知的实事: `Array.prototype => []`;\n\n答案: `true`\n\n### 第14题\n\n```\nvar a = [0];\nif ([0]) {\n  console.log(a == true);\n} else {\n  console.log(\"wut\");\n}\n```\n\n- [JavaScript-Equality-Table](https://dorey.github.io/JavaScript-Equality-Table/)\n\n答案: `false`\n\n### 第15题\n\n```\n[]==[]\n```\n\n`==` 是万恶之源, 看上图\n\n答案是 `false`\n\n### 第16题\n\n```\n'5' + 3\n'5' - 3\n```\n\n两个知识点:\n\n- [Arithmetic_Operators#Addition](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition)\n- [Arithmetic_Operators#Subtraction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction)\n\n`+` 用来表示两个数的和或者字符串拼接, `-`表示两数之差.\n\n请看例子, 体会区别:\n\n```\n> '5' + 3\n'53'\n> 5 + '3'\n'53'\n> 5 - '3'\n2\n> '5' - 3\n2\n> '5' - '3'\n2\n```\n\n也就是说 `-` 会尽可能的将两个操作数变成数字, 而 `+` 如果两边不都是数字, 那么就是字符串拼接.\n\n答案是 `'53', 2`\n\n### 第17题\n\n```\n1 + - + + + - + 1\n```\n\n这里应该是(倒着看)\n\n```\n1 + (a)  => 2\na = - (b) => 1\nb = + (c) => -1\nc = + (d) => -1\nd = + (e) => -1\ne = + (f) => -1\nf = - (g) => -1\ng = + 1   => 1\n```\n\n所以答案 `2`\n\n### 第18题\n\n```\nvar ary = Array(3);\nary[0]=2\nary.map(function(elem) { return '1'; });\n```\n\n稀疏数组. 同第7题.\n\n题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.\n\n所以答案是 `[\"1\", undefined × 2]`\n\n这里贴上 Array.prototype.map 的 polyfill.\n\n```\nArray.prototype.map = function(callback, thisArg) {\n\n        var T, A, k;\n\n        if (this == null) {\n            throw new TypeError(' this is null or not defined');\n        }\n\n        var O = Object(this);\n        var len = O.length >>> 0;\n        if (typeof callback !== 'function') {\n            throw new TypeError(callback + ' is not a function');\n        }\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        A = new Array(len);\n        k = 0;\n        while (k < len) {\n            var kValue, mappedValue;\n            if (k in O) {\n                kValue = O[k];\n                mappedValue = callback.call(T, kValue, k, O);\n                A[k] = mappedValue;\n            }\n            k++;\n        }\n        return A;\n    };\n```\n\n### 第19题\n\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n\n这是一个大坑, 尤其是涉及到 ES6语法的时候\n\n知识点:\n\n- [Functions/arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\n\n首先 `The arguments object is an Array-like object corresponding to the arguments passed to a function.`\n\n也就是说 `arguments` 是一个 `object`, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.\n\n所以答案是 `21`.\n\n然而!!!!!!\n\n当函数参数涉及到 `any rest parameters, any default parameters or any destructured parameters` 的时候, 这个 arguments 就不在是一个 `mapped arguments object` 了…..\n\n请看:\n\n```\nfunction sidEffecting(ary) {\n  ary[0] = ary[2];\n}\nfunction bar(a,b,c=3) {\n  c = 10\n  sidEffecting(arguments);\n  return a + b + c;\n}\nbar(1,1,1)\n```\n\n答案是 `12` !!!!\n\n请读者细细体会!!\n\n### 第20题\n\n```\nvar a = 111111111111111110000,\n    b = 1111;\na + b;\n```\n\n答案还是 `111111111111111110000`. 解释是 `Lack of precision for numbers in JavaScript affects both small and big numbers.` 但是笔者不是很明白……………. 请读者赐教!\n\n### 第21题\n\n```\nvar x = [].reverse;\nx();\n```\n\n这个题有意思!\n\n知识点:\n\n- [Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)\n\n`The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.`\n\n也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 `window`.\n\n答案是 `window`\n\n### 第22题\n\n```\nNumber.MIN_VALUE > 0\n```\n\n`true`\n\n### 第23题\n\n```\n[1 < 2 < 3, 3 < 2 < 1]\n```\n\n这个题也还可以.\n\n这个题会让人误以为是 `2 > 1 && 2 < 3` 其实不是的.\n\n这个题等价于\n\n```\n 1 < 2 => true;\n true < 3 =>  1 < 3 => true;\n 3 < 2 => false;\n false < 1 => 0 < 1 => true;\n```\n\n答案是 `[true, true]`\n\n### 第24题\n\n```\n// the most classic wtf\n2 == [[[2]]]\n```\n\n这个题我是猜的. 我猜的 `true`, 至于为什么…..\n\n`both objects get converted to strings and in both cases the resulting string is \"2\"` 我不能信服…\n\n### 第25题\n\n```\n3.toString()\n3..toString()\n3...toString()\n```\n\n这个题也挺逗, 我做对了![:)](http://www.codeceo.com/wp-content/themes/d-simple/img/smilies/icon_smile.gif)答案是 `error, '3', error`\n\n你如果换一个写法就更费解了\n\n```\nvar a = 3;\na.toString()\n```\n\n这个答案就是 `'3'`;\n\n为啥呢?\n\n因为在 js 中 `1.1`, `1.`, `.1` 都是合法的数字. 那么在解析 `3.toString` 的时候这个 `.` 到底是属于这个数字还是函数调用呢? 只能是数字, 因为`3.`合法啊!\n\n### 第26题\n\n```\n(function(){\n  var x = y = 1;\n})();\nconsole.log(y);\nconsole.log(x);\n```\n\n答案是 `1, error`\n\ny 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 `ReferenceError`\n\n### 第27题\n\n```\nvar a = /123/,\n    b = /123/;\na == b\na === b\n```\n\n即使正则的字面量一致, 他们也不相等.\n\n答案 `false, false`\n\n### 第28题\n\n```\nvar a = [1, 2, 3],\n    b = [1, 2, 3],\n    c = [1, 2, 4]\na ==  b\na === b\na >   c\na <   c\n```\n\n字面量相等的数组也不相等.\n\n数组在比较大小的时候按照字典序比较\n\n答案 `false, false, false, true`\n\n### 第29题\n\n```\nvar a = {}, b = Object.prototype;\n[a.prototype === b, Object.getPrototypeOf(a) === b]\n```\n\n知识点:\n\n- [Object/getPrototypeOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)\n\n只有 Function 拥有一个 prototype 的属性. 所以 `a.prototype` 为 `undefined`.\n\n而 `Object.getPrototypeOf(obj)` 返回一个具体对象的原型(该对象的内部`[[prototype]]`值)\n\n答案 `false, true`\n\n### 第30题\n\n```\nfunction f() {}\nvar a = f.prototype, b = Object.getPrototypeOf(f);\na === b\n```\n\nf.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.\n\nf.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.\n\n请看:\n\n```\na === Object.getPrototypeOf(new f()) // true\nb === Function.prototype // true\n```\n\n答案 `false`\n\n### 第31题\n\n```\nfunction foo() { }\nvar oldName = foo.name;\nfoo.name = \"bar\";\n[oldName, foo.name]\n```\n\n答案 `['foo', 'foo']`\n\n知识点:\n\n- [Function/name](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name)\n\n因为函数的名字不可变.\n\n### 第32题\n\n```\n\"1 2 3\".replace(/\\d/g, parseInt)\n```\n\n知识点:\n\n- [String/replace#Specifying_a_function_as_a_parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter)\n\n`str.replace(regexp|substr, newSubStr|function)`\n\n如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数\n\n- match 首先是匹配的字符串\n- p1, p2 …. 然后是正则的分组\n- offset match 匹配的index\n- string 整个字符串\n\n由于题目中的正则没有分组, 所以等价于问\n\n```\nparseInt('1', 0)\nparseInt('2', 2)\nparseInt('3', 4)\n```\n\n答案: `1, NaN, 3`\n\n### 第33题\n\n```\nfunction f() {}\nvar parent = Object.getPrototypeOf(f);\nf.name // ?\nparent.name // ?\ntypeof eval(f.name) // ?\ntypeof eval(parent.name) //  ?\n```\n\n先说以下答案 `'f', 'Empty', 'function', error` 这个答案并不重要…..\n\n这里第一小问和第三小问很简单不解释了.\n\n第二小问笔者在自己的浏览器测试的时候是 `''`, 第四问是 `'undefined'`\n\n所以应该是平台相关的. 这里明白 `parent === Function.prototype` 就好了.\n\n### 第34题\n\n```\nvar lowerCaseOnly =  /^[a-z]+$/;\n[lowerCaseOnly.test(null), lowerCaseOnly.test()]\n```\n\n知识点:\n\n- [RegExp/test](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test)\n\n这里 test 函数会将参数转为字符串. `'nul'`, `'undefined'` 自然都是全小写了\n\n答案: `true, true`\n\n### 第35题\n\n```\n[,,,].join(\", \")\n```\n\n`[,,,] => [undefined × 3]`\n\n因为javascript 在定义数组的时候允许最后一个元素后跟一个`,`, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)\n\n答案: `\", , \"`\n\n### 第36题\n\n```\nvar a = {class: \"Animal\", name: 'Fido'};\na.class\n```\n\n这个题比较流氓.. 因为是浏览器相关, `class`是个保留字(现在是个关键字了)\n\n所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 `a['class']`\n\n### 第37题\n\n```\nvar a = new Date(\"epoch\")\n```\n\n知识点:\n\n- [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)\n- [Date/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)\n\n简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.\n\n另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 `Invalid Date`.\n\n答案 `Invalid Date`\n\n### 第38题\n\n```\nvar a = Function.length,\n    b = new Function().length\na === b\n```\n\n我们知道一个function(Function 的实例)的 `length` 属性就是函数签名的参数个数, 所以 b.length == 0.\n\n另外 Function.length 定义为1……\n\n所以不相等…….答案 `false`\n\n### 第39题\n\n```\nvar a = Date(0);\nvar b = new Date(0);\nvar c = new Date();\n[a === b, b === c, a === c]\n```\n\n还是关于Date 的题, 需要注意的是\n\n- 如果不传参数等价于当前时间.\n- 如果是函数调用 返回一个字符串.\n\n答案 `false, false, false`\n\n### 第40题\n\n```\nvar min = Math.min(), max = Math.max()\nmin < max\n```\n\n知识点:\n\n- [Math/min](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min)\n- [Math/max](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max)\n\n有趣的是, Math.min 不传参数返回 `Infinity`, Math.max 不传参数返回 `-Infinity`\n\n答案: `false`\n\n### 第41题\n\n```\nfunction captureOne(re, str) {\n  var match = re.exec(str);\n  return match && match[1];\n}\nvar numRe  = /num=(\\d+)/ig,\n    wordRe = /word=(\\w+)/i,\n    a1 = captureOne(numRe,  \"num=1\"),\n    a2 = captureOne(wordRe, \"word=1\"),\n    a3 = captureOne(numRe,  \"NUM=2\"),\n    a4 = captureOne(wordRe,  \"WORD=2\");\n[a1 === a2, a3 === a4]\n```\n\n知识点:\n\n- [RegExp/exec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec)\n\n通俗的讲\n\n因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会\n\n举个例子\n\n```\nvar myRe = /ab*/g;\nvar str = 'abbcdefabh';\nvar myArray;\nwhile ((myArray = myRe.exec(str)) !== null) {\n  var msg = 'Found ' + myArray[0] + '. ';\n  msg += 'Next match starts at ' + myRe.lastIndex;\n  console.log(msg);\n}\n// Found abb. Next match starts at 3\n// Found ab. Next match starts at 9\n```\n\n所以 a1 = ’1′; a2 = ’1′; a3 = null; a4 = ’2′\n\n答案 `[true, false]`\n\n### 第42题\n\n```\nvar a = new Date(\"2014-03-19\"),\n    b = new Date(2014, 03, 19);\n[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]\n```\n\n这个….\n\n> JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.\n\n```\na.getDay()\n3\nb.getDay()\n6\na.getMonth()\n2\nb.getMonth()\n3\n```\n\n都是套路!\n\n答案 `[false, false]`\n\n### 第43题\n\n```\nif ('http://giftwrapped.com/picture.jpg'.match('.gif')) {\n  'a gif file'\n} else {\n  'not a gif file'\n}\n```\n\n知识点:\n\n- [String/match](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)\n\nString.prototype.match 接受一个正则, 如果不是, 按照 `new RegExp(obj)` 转化. 所以 `.` 并不会转义\n那么 `/gif` 就匹配了 /.gif/\n\n答案: `'a gif file'`\n\n### 第44题\n\n```\nfunction foo(a) {\n    var a;\n    return a;\n}\nfunction bar(a) {\n    var a = 'bye';\n    return a;\n}\n[foo('hello'), bar('hello')]\n```\n\n在两个函数里, a作为参数其实已经声明了, 所以 `var a; var a = 'bye'` 其实就是 `a; a ='bye'`\n\n所以答案 `'hello', 'bye'`\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/44-javascript-crazy-question.html)\n英文原文：[javascript-puzzlers](http://javascript-puzzlers.herokuapp.com/)","slug":"44个JavaScript变态题解析","published":1,"updated":"2016-08-17T06:22:19.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cph8000368ddqt0sjxnf","content":"<h3 id=\"第1题\"><a href=\"#第1题\" class=\"headerlink\" title=\"第1题\"></a>第1题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\" target=\"_blank\" rel=\"external\">Array/map</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt\" target=\"_blank\" rel=\"external\">Number/parseInt</a></li>\n<li><a href=\"http://www.w3school.com.cn/jsref/jsref_parseInt.asp\" target=\"_blank\" rel=\"external\">JavaScript parseInt</a></li>\n</ul>\n<p>首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值</p>\n<p>其中回调函数接受三个参数 currentValue, index, arrary;</p>\n<p>而题目中, map只传入了回调函数–parseInt.</p>\n<p>其次, parseInt 只接受两个两个参数 string, radix(基数).</p>\n<blockquote>\n<p>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</p>\n<p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。</p>\n<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>\n</blockquote>\n<p>所以本题即问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;1&apos;, 0);</div><div class=\"line\">parseInt(&apos;2&apos;, 1);</div><div class=\"line\">parseInt(&apos;3&apos;, 2);</div></pre></td></tr></table></figure>\n<p>首先后两者参数不合法.</p>\n<p>所以答案是 <code>[1, NaN, NaN]</code></p>\n<h3 id=\"第2题\"><a href=\"#第2题\" class=\"headerlink\" title=\"第2题\"></a>第2题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[typeof null, null instanceof Object]</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\" target=\"_blank\" rel=\"external\">Operators/typeof</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"external\">Operators/instanceof</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\" target=\"_blank\" rel=\"external\">Operators/instanceof(中)</a></li>\n</ul>\n<p>typeof 返回一个表示类型的字符串.</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p>\n<p>这个题可以直接看链接… 因为 <code>typeof null === &#39;object&#39;</code> 自语言之初就是这样….</p>\n<p>typeof 的结果请看下表:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">type         result</div><div class=\"line\">Undefined   &quot;undefined&quot;</div><div class=\"line\">Null        &quot;object&quot;</div><div class=\"line\">Boolean     &quot;boolean&quot;</div><div class=\"line\">Number      &quot;number&quot;</div><div class=\"line\">String      &quot;string&quot;</div><div class=\"line\">Symbol      &quot;symbol&quot;</div><div class=\"line\">Host object Implementation-dependent</div><div class=\"line\">Function    &quot;function&quot;</div><div class=\"line\">Object      &quot;object&quot;</div></pre></td></tr></table></figure>\n<p>所以答案 <code>[object, false]</code></p>\n<h3 id=\"第3题\"><a href=\"#第3题\" class=\"headerlink\" title=\"第3题\"></a>第3题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"external\">Array/Reduce</a></li>\n</ul>\n<p><code>arr.reduce(callback[, initialValue])</code></p>\n<p>reduce接受两个参数, 一个回调, 一个初始值.</p>\n<p>回调函数接受四个参数 <code>previousValue, currentValue, currentIndex, array</code></p>\n<p>需要注意的是 <code>If the array is empty and no initialValue was provided, TypeError would be thrown.</code></p>\n<p>所以第二个表达式会报异常. 第一个表达式等价于 <code>Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</code></p>\n<p>答案 <code>an error</code></p>\n<h3 id=\"第4题\"><a href=\"#第4题\" class=\"headerlink\" title=\"第4题\"></a>第4题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var val = &apos;smtg&apos;;</div><div class=\"line\">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" target=\"_blank\" rel=\"external\">Operators/Operator_Precedence</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" target=\"_blank\" rel=\"external\">Operators/Conditional_Operator</a></li>\n</ul>\n<p>简而言之 <code>+</code> 的优先级 大于 <code>?</code></p>\n<p>所以原题等价于 <code>&#39;Value is true&#39; ? &#39;Somthing&#39; : &#39;Nonthing&#39;</code> 而不是 <code>&#39;Value is&#39; + (true ? &#39;Something&#39; : &#39;Nonthing&#39;)</code></p>\n<p>答案 <code>&#39;Something&#39;</code></p>\n<h3 id=\"第5题\"><a href=\"#第5题\" class=\"headerlink\" title=\"第5题\"></a>第5题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &apos;World!&apos;;</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</div><div class=\"line\">        var name = &apos;Jack&apos;;</div><div class=\"line\">        console.log(&apos;Goodbye &apos; + name);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        console.log(&apos;Hello &apos; + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这个相对简单, 一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\" target=\"_blank\" rel=\"external\">Hoisting</a></li>\n</ul>\n<p>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</p>\n<p>这个题目相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &apos;World!&apos;;</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var name;</div><div class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</div><div class=\"line\">        name = &apos;Jack&apos;;</div><div class=\"line\">        console.log(&apos;Goodbye &apos; + name);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        console.log(&apos;Hello &apos; + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>所以答案是 <code>&#39;Goodbye Jack&#39;</code></p>\n<h3 id=\"第6题\"><a href=\"#第6题\" class=\"headerlink\" title=\"第6题\"></a>第6题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var END = Math.pow(2, 53);</div><div class=\"line\">var START = END - 100;</div><div class=\"line\">var count = 0;</div><div class=\"line\">for (var i = START; i &lt;= END; i++) &#123;</div><div class=\"line\">    count++;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(count);</div></pre></td></tr></table></figure>\n<p>一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity\" target=\"_blank\" rel=\"external\">Infinity</a></li>\n</ul>\n<p><del>在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.</del></p>\n<p>补充: <a href=\"https://github.com/jelly7723\" target=\"_blank\" rel=\"external\">@jelly7723</a></p>\n<blockquote>\n<p>js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。<br>2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。<br>9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。</p>\n</blockquote>\n<h3 id=\"第7题\"><a href=\"#第7题\" class=\"headerlink\" title=\"第7题\"></a>第7题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ary = [0,1,2];</div><div class=\"line\">ary[10] = 10;</div><div class=\"line\">ary.filter(function(x) &#123; return x === undefined;&#125;);</div></pre></td></tr></table></figure>\n<p>答案是 <code>[]</code></p>\n<p>看一篇文章理解稀疏数组</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687165.html\" target=\"_blank\" rel=\"external\">译 JavaScript中的稀疏数组与密集数组</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\" target=\"_blank\" rel=\"external\">Array/filter</a></li>\n</ul>\n<p>我们来看一下 Array.prototype.filter 的 polyfill:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!Array.prototype.filter) &#123;</div><div class=\"line\">  Array.prototype.filter = function(fun/*, thisArg*/) &#123;</div><div class=\"line\">    &apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">    if (this === void 0 || this === null) &#123;</div><div class=\"line\">      throw new TypeError();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var t = Object(this);</div><div class=\"line\">    var len = t.length &gt;&gt;&gt; 0;</div><div class=\"line\">    if (typeof fun !== &apos;function&apos;) &#123;</div><div class=\"line\">      throw new TypeError();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var res = [];</div><div class=\"line\">    var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0;</div><div class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">      if (i in t) &#123; // 注意这里!!!</div><div class=\"line\">        var val = t[i];</div><div class=\"line\">        if (fun.call(thisArg, val, i, t)) &#123;</div><div class=\"line\">          res.push(val);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return res;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">0 in ary; =&gt; true</div><div class=\"line\">3 in ary; =&gt; false</div><div class=\"line\">10 in ary; =&gt; true</div></pre></td></tr></table></figure>\n<p>也就是说 从 3 – 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.</p>\n<h3 id=\"第8题\"><a href=\"#第8题\" class=\"headerlink\" title=\"第8题\"></a>第8题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var two   = 0.2</div><div class=\"line\">var one   = 0.1</div><div class=\"line\">var eight = 0.8</div><div class=\"line\">var six   = 0.6</div><div class=\"line\">[two - one == one, eight - six == two]</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://ourjs.com/detail/54695381bc3f9b154e000046\" target=\"_blank\" rel=\"external\">JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3</a></li>\n</ul>\n<p>IEEE 754标准中的<a href=\"http://www.codeceo.com/article/float-number.html\" target=\"_blank\" rel=\"external\">浮点数</a>并不能精确地表达小数</p>\n<p>那什么时候精准, 什么时候不经准呢? 笔者也不知道…</p>\n<p>答案 <code>[true, false]</code></p>\n<h3 id=\"第9题\"><a href=\"#第9题\" class=\"headerlink\" title=\"第9题\"></a>第9题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function showCase(value) &#123;</div><div class=\"line\">    switch(value) &#123;</div><div class=\"line\">    case &apos;A&apos;:</div><div class=\"line\">        console.log(&apos;Case A&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case &apos;B&apos;:</div><div class=\"line\">        console.log(&apos;Case B&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case undefined:</div><div class=\"line\">        console.log(&apos;undefined&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    default:</div><div class=\"line\">        console.log(&apos;Do not know!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">showCase(new String(&apos;A&apos;));</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch\" target=\"_blank\" rel=\"external\">Statements/switch</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\" target=\"_blank\" rel=\"external\">String</a></li>\n</ul>\n<p>switch 是严格比较, String 实例和 字符串不一样.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var s_prim = &apos;foo&apos;;</div><div class=\"line\">var s_obj = new String(s_prim);</div><div class=\"line\"></div><div class=\"line\">console.log(typeof s_prim); // &quot;string&quot;</div><div class=\"line\">console.log(typeof s_obj);  // &quot;object&quot;</div><div class=\"line\">console.log(s_prim === s_obj); // false</div></pre></td></tr></table></figure>\n<p>答案是 <code>&#39;Do not know!&#39;</code></p>\n<h3 id=\"第10题\"><a href=\"#第10题\" class=\"headerlink\" title=\"第10题\"></a>第10题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function showCase2(value) &#123;</div><div class=\"line\">    switch(value) &#123;</div><div class=\"line\">    case &apos;A&apos;:</div><div class=\"line\">        console.log(&apos;Case A&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case &apos;B&apos;:</div><div class=\"line\">        console.log(&apos;Case B&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case undefined:</div><div class=\"line\">        console.log(&apos;undefined&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    default:</div><div class=\"line\">        console.log(&apos;Do not know!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">showCase2(String(&apos;A&apos;));</div></pre></td></tr></table></figure>\n<p>解释:</p>\n<p><code>String(x) does not create an object but does return a string, i.e. typeof String(1) === &quot;string&quot;</code></p>\n<p>还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.</p>\n<p>答案 <code>&#39;Case A&#39;</code></p>\n<h3 id=\"第11题\"><a href=\"#第11题\" class=\"headerlink\" title=\"第11题\"></a>第11题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function isOdd(num) &#123;</div><div class=\"line\">    return num % 2 == 1;</div><div class=\"line\">&#125;</div><div class=\"line\">function isEven(num) &#123;</div><div class=\"line\">    return num % 2 == 0;</div><div class=\"line\">&#125;</div><div class=\"line\">function isSane(num) &#123;</div><div class=\"line\">    return isEven(num) || isOdd(num);</div><div class=\"line\">&#125;</div><div class=\"line\">var values = [7, 4, &apos;13&apos;, -9, Infinity];</div><div class=\"line\">values.map(isSane);</div></pre></td></tr></table></figure>\n<p>一个知识点</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder\" target=\"_blank\" rel=\"external\">Arithmetic_Operators#Remainder</a></li>\n</ul>\n<p>此题等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">7 % 2 =&gt; 1</div><div class=\"line\">4 % 2 =&gt; 0</div><div class=\"line\">&apos;13&apos; % 2 =&gt; 1</div><div class=\"line\">-9 % % 2 =&gt; -1</div><div class=\"line\">Infinity % 2 =&gt; NaN</div></pre></td></tr></table></figure>\n<p>需要注意的是 余数的正负号随第一个操作数.</p>\n<p>答案 <code>[true, true, true, false, false]</code></p>\n<h3 id=\"第12题\"><a href=\"#第12题\" class=\"headerlink\" title=\"第12题\"></a>第12题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(3, 8)</div><div class=\"line\">parseInt(3, 2)</div><div class=\"line\">parseInt(3, 0)</div></pre></td></tr></table></figure>\n<p>第一个题讲过了, 答案 <code>3, NaN, 3</code></p>\n<h3 id=\"第13题\"><a href=\"#第13题\" class=\"headerlink\" title=\"第13题\"></a>第13题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.isArray( Array.prototype )</div></pre></td></tr></table></figure>\n<p>一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\" target=\"_blank\" rel=\"external\">Array/prototype</a></li>\n</ul>\n<p>一个鲜为人知的实事: <code>Array.prototype =&gt; []</code>;</p>\n<p>答案: <code>true</code></p>\n<h3 id=\"第14题\"><a href=\"#第14题\" class=\"headerlink\" title=\"第14题\"></a>第14题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [0];</div><div class=\"line\">if ([0]) &#123;</div><div class=\"line\">  console.log(a == true);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&quot;wut&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\" target=\"_blank\" rel=\"external\">JavaScript-Equality-Table</a></li>\n</ul>\n<p>答案: <code>false</code></p>\n<h3 id=\"第15题\"><a href=\"#第15题\" class=\"headerlink\" title=\"第15题\"></a>第15题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[]==[]</div></pre></td></tr></table></figure>\n<p><code>==</code> 是万恶之源, 看上图</p>\n<p>答案是 <code>false</code></p>\n<h3 id=\"第16题\"><a href=\"#第16题\" class=\"headerlink\" title=\"第16题\"></a>第16题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&apos;5&apos; + 3</div><div class=\"line\">&apos;5&apos; - 3</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition\" target=\"_blank\" rel=\"external\">Arithmetic_Operators#Addition</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction\" target=\"_blank\" rel=\"external\">Arithmetic_Operators#Subtraction</a></li>\n</ul>\n<p><code>+</code> 用来表示两个数的和或者字符串拼接, <code>-</code>表示两数之差.</p>\n<p>请看例子, 体会区别:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; &apos;5&apos; + 3</div><div class=\"line\">&apos;53&apos;</div><div class=\"line\">&gt; 5 + &apos;3&apos;</div><div class=\"line\">&apos;53&apos;</div><div class=\"line\">&gt; 5 - &apos;3&apos;</div><div class=\"line\">2</div><div class=\"line\">&gt; &apos;5&apos; - 3</div><div class=\"line\">2</div><div class=\"line\">&gt; &apos;5&apos; - &apos;3&apos;</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n<p>也就是说 <code>-</code> 会尽可能的将两个操作数变成数字, 而 <code>+</code> 如果两边不都是数字, 那么就是字符串拼接.</p>\n<p>答案是 <code>&#39;53&#39;, 2</code></p>\n<h3 id=\"第17题\"><a href=\"#第17题\" class=\"headerlink\" title=\"第17题\"></a>第17题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 + - + + + - + 1</div></pre></td></tr></table></figure>\n<p>这里应该是(倒着看)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 + (a)  =&gt; 2</div><div class=\"line\">a = - (b) =&gt; 1</div><div class=\"line\">b = + (c) =&gt; -1</div><div class=\"line\">c = + (d) =&gt; -1</div><div class=\"line\">d = + (e) =&gt; -1</div><div class=\"line\">e = + (f) =&gt; -1</div><div class=\"line\">f = - (g) =&gt; -1</div><div class=\"line\">g = + 1   =&gt; 1</div></pre></td></tr></table></figure>\n<p>所以答案 <code>2</code></p>\n<h3 id=\"第18题\"><a href=\"#第18题\" class=\"headerlink\" title=\"第18题\"></a>第18题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ary = Array(3);</div><div class=\"line\">ary[0]=2</div><div class=\"line\">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</div></pre></td></tr></table></figure>\n<p>稀疏数组. 同第7题.</p>\n<p>题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.</p>\n<p>所以答案是 <code>[&quot;1&quot;, undefined × 2]</code></p>\n<p>这里贴上 Array.prototype.map 的 polyfill.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.map = function(callback, thisArg) &#123;</div><div class=\"line\"></div><div class=\"line\">        var T, A, k;</div><div class=\"line\"></div><div class=\"line\">        if (this == null) &#123;</div><div class=\"line\">            throw new TypeError(&apos; this is null or not defined&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var O = Object(this);</div><div class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</div><div class=\"line\">        if (typeof callback !== &apos;function&apos;) &#123;</div><div class=\"line\">            throw new TypeError(callback + &apos; is not a function&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (arguments.length &gt; 1) &#123;</div><div class=\"line\">            T = thisArg;</div><div class=\"line\">        &#125;</div><div class=\"line\">        A = new Array(len);</div><div class=\"line\">        k = 0;</div><div class=\"line\">        while (k &lt; len) &#123;</div><div class=\"line\">            var kValue, mappedValue;</div><div class=\"line\">            if (k in O) &#123;</div><div class=\"line\">                kValue = O[k];</div><div class=\"line\">                mappedValue = callback.call(T, kValue, k, O);</div><div class=\"line\">                A[k] = mappedValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            k++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return A;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"第19题\"><a href=\"#第19题\" class=\"headerlink\" title=\"第19题\"></a>第19题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function sidEffecting(ary) &#123;</div><div class=\"line\">  ary[0] = ary[2];</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a,b,c) &#123;</div><div class=\"line\">  c = 10</div><div class=\"line\">  sidEffecting(arguments);</div><div class=\"line\">  return a + b + c;</div><div class=\"line\">&#125;</div><div class=\"line\">bar(1,1,1)</div></pre></td></tr></table></figure>\n<p>这是一个大坑, 尤其是涉及到 ES6语法的时候</p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\" target=\"_blank\" rel=\"external\">Functions/arguments</a></li>\n</ul>\n<p>首先 <code>The arguments object is an Array-like object corresponding to the arguments passed to a function.</code></p>\n<p>也就是说 <code>arguments</code> 是一个 <code>object</code>, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.</p>\n<p>所以答案是 <code>21</code>.</p>\n<p>然而!!!!!!</p>\n<p>当函数参数涉及到 <code>any rest parameters, any default parameters or any destructured parameters</code> 的时候, 这个 arguments 就不在是一个 <code>mapped arguments object</code> 了…..</p>\n<p>请看:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function sidEffecting(ary) &#123;</div><div class=\"line\">  ary[0] = ary[2];</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a,b,c=3) &#123;</div><div class=\"line\">  c = 10</div><div class=\"line\">  sidEffecting(arguments);</div><div class=\"line\">  return a + b + c;</div><div class=\"line\">&#125;</div><div class=\"line\">bar(1,1,1)</div></pre></td></tr></table></figure>\n<p>答案是 <code>12</code> !!!!</p>\n<p>请读者细细体会!!</p>\n<h3 id=\"第20题\"><a href=\"#第20题\" class=\"headerlink\" title=\"第20题\"></a>第20题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = 111111111111111110000,</div><div class=\"line\">    b = 1111;</div><div class=\"line\">a + b;</div></pre></td></tr></table></figure>\n<p>答案还是 <code>111111111111111110000</code>. 解释是 <code>Lack of precision for numbers in JavaScript affects both small and big numbers.</code> 但是笔者不是很明白……………. 请读者赐教!</p>\n<h3 id=\"第21题\"><a href=\"#第21题\" class=\"headerlink\" title=\"第21题\"></a>第21题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var x = [].reverse;</div><div class=\"line\">x();</div></pre></td></tr></table></figure>\n<p>这个题有意思!</p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\" target=\"_blank\" rel=\"external\">Array/reverse</a></li>\n</ul>\n<p><code>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</code></p>\n<p>也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 <code>window</code>.</p>\n<p>答案是 <code>window</code></p>\n<h3 id=\"第22题\"><a href=\"#第22题\" class=\"headerlink\" title=\"第22题\"></a>第22题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Number.MIN_VALUE &gt; 0</div></pre></td></tr></table></figure>\n<p><code>true</code></p>\n<h3 id=\"第23题\"><a href=\"#第23题\" class=\"headerlink\" title=\"第23题\"></a>第23题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</div></pre></td></tr></table></figure>\n<p>这个题也还可以.</p>\n<p>这个题会让人误以为是 <code>2 &gt; 1 &amp;&amp; 2 &lt; 3</code> 其实不是的.</p>\n<p>这个题等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 &lt; 2 =&gt; true;</div><div class=\"line\">true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;</div><div class=\"line\">3 &lt; 2 =&gt; false;</div><div class=\"line\">false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;</div></pre></td></tr></table></figure>\n<p>答案是 <code>[true, true]</code></p>\n<h3 id=\"第24题\"><a href=\"#第24题\" class=\"headerlink\" title=\"第24题\"></a>第24题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// the most classic wtf</div><div class=\"line\">2 == [[[2]]]</div></pre></td></tr></table></figure>\n<p>这个题我是猜的. 我猜的 <code>true</code>, 至于为什么…..</p>\n<p><code>both objects get converted to strings and in both cases the resulting string is &quot;2&quot;</code> 我不能信服…</p>\n<h3 id=\"第25题\"><a href=\"#第25题\" class=\"headerlink\" title=\"第25题\"></a>第25题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">3.toString()</div><div class=\"line\">3..toString()</div><div class=\"line\">3...toString()</div></pre></td></tr></table></figure>\n<p>这个题也挺逗, 我做对了<img src=\"http://www.codeceo.com/wp-content/themes/d-simple/img/smilies/icon_smile.gif\" alt=\":)\">答案是 <code>error, &#39;3&#39;, error</code></p>\n<p>你如果换一个写法就更费解了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = 3;</div><div class=\"line\">a.toString()</div></pre></td></tr></table></figure>\n<p>这个答案就是 <code>&#39;3&#39;</code>;</p>\n<p>为啥呢?</p>\n<p>因为在 js 中 <code>1.1</code>, <code>1.</code>, <code>.1</code> 都是合法的数字. 那么在解析 <code>3.toString</code> 的时候这个 <code>.</code> 到底是属于这个数字还是函数调用呢? 只能是数字, 因为<code>3.</code>合法啊!</p>\n<h3 id=\"第26题\"><a href=\"#第26题\" class=\"headerlink\" title=\"第26题\"></a>第26题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  var x = y = 1;</div><div class=\"line\">&#125;)();</div><div class=\"line\">console.log(y);</div><div class=\"line\">console.log(x);</div></pre></td></tr></table></figure>\n<p>答案是 <code>1, error</code></p>\n<p>y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 <code>ReferenceError</code></p>\n<h3 id=\"第27题\"><a href=\"#第27题\" class=\"headerlink\" title=\"第27题\"></a>第27题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = /123/,</div><div class=\"line\">    b = /123/;</div><div class=\"line\">a == b</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>即使正则的字面量一致, 他们也不相等.</p>\n<p>答案 <code>false, false</code></p>\n<h3 id=\"第28题\"><a href=\"#第28题\" class=\"headerlink\" title=\"第28题\"></a>第28题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 2, 3],</div><div class=\"line\">    b = [1, 2, 3],</div><div class=\"line\">    c = [1, 2, 4]</div><div class=\"line\">a ==  b</div><div class=\"line\">a === b</div><div class=\"line\">a &gt;   c</div><div class=\"line\">a &lt;   c</div></pre></td></tr></table></figure>\n<p>字面量相等的数组也不相等.</p>\n<p>数组在比较大小的时候按照字典序比较</p>\n<p>答案 <code>false, false, false, true</code></p>\n<h3 id=\"第29题\"><a href=\"#第29题\" class=\"headerlink\" title=\"第29题\"></a>第29题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123;&#125;, b = Object.prototype;</div><div class=\"line\">[a.prototype === b, Object.getPrototypeOf(a) === b]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\" target=\"_blank\" rel=\"external\">Object/getPrototypeOf</a></li>\n</ul>\n<p>只有 Function 拥有一个 prototype 的属性. 所以 <code>a.prototype</code> 为 <code>undefined</code>.</p>\n<p>而 <code>Object.getPrototypeOf(obj)</code> 返回一个具体对象的原型(该对象的内部<code>[[prototype]]</code>值)</p>\n<p>答案 <code>false, true</code></p>\n<h3 id=\"第30题\"><a href=\"#第30题\" class=\"headerlink\" title=\"第30题\"></a>第30题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f() &#123;&#125;</div><div class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.</p>\n<p>f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.</p>\n<p>请看:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a === Object.getPrototypeOf(new f()) // true</div><div class=\"line\">b === Function.prototype // true</div></pre></td></tr></table></figure>\n<p>答案 <code>false</code></p>\n<h3 id=\"第31题\"><a href=\"#第31题\" class=\"headerlink\" title=\"第31题\"></a>第31题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo() &#123; &#125;</div><div class=\"line\">var oldName = foo.name;</div><div class=\"line\">foo.name = &quot;bar&quot;;</div><div class=\"line\">[oldName, foo.name]</div></pre></td></tr></table></figure>\n<p>答案 <code>[&#39;foo&#39;, &#39;foo&#39;]</code></p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\" target=\"_blank\" rel=\"external\">Function/name</a></li>\n</ul>\n<p>因为函数的名字不可变.</p>\n<h3 id=\"第32题\"><a href=\"#第32题\" class=\"headerlink\" title=\"第32题\"></a>第32题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;1 2 3&quot;.replace(/\\d/g, parseInt)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter\" target=\"_blank\" rel=\"external\">String/replace#Specifying_a_function_as_a_parameter</a></li>\n</ul>\n<p><code>str.replace(regexp|substr, newSubStr|function)</code></p>\n<p>如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数</p>\n<ul>\n<li>match 首先是匹配的字符串</li>\n<li>p1, p2 …. 然后是正则的分组</li>\n<li>offset match 匹配的index</li>\n<li>string 整个字符串</li>\n</ul>\n<p>由于题目中的正则没有分组, 所以等价于问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;1&apos;, 0)</div><div class=\"line\">parseInt(&apos;2&apos;, 2)</div><div class=\"line\">parseInt(&apos;3&apos;, 4)</div></pre></td></tr></table></figure>\n<p>答案: <code>1, NaN, 3</code></p>\n<h3 id=\"第33题\"><a href=\"#第33题\" class=\"headerlink\" title=\"第33题\"></a>第33题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f() &#123;&#125;</div><div class=\"line\">var parent = Object.getPrototypeOf(f);</div><div class=\"line\">f.name // ?</div><div class=\"line\">parent.name // ?</div><div class=\"line\">typeof eval(f.name) // ?</div><div class=\"line\">typeof eval(parent.name) //  ?</div></pre></td></tr></table></figure>\n<p>先说以下答案 <code>&#39;f&#39;, &#39;Empty&#39;, &#39;function&#39;, error</code> 这个答案并不重要…..</p>\n<p>这里第一小问和第三小问很简单不解释了.</p>\n<p>第二小问笔者在自己的浏览器测试的时候是 <code>&#39;&#39;</code>, 第四问是 <code>&#39;undefined&#39;</code></p>\n<p>所以应该是平台相关的. 这里明白 <code>parent === Function.prototype</code> 就好了.</p>\n<h3 id=\"第34题\"><a href=\"#第34题\" class=\"headerlink\" title=\"第34题\"></a>第34题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var lowerCaseOnly =  /^[a-z]+$/;</div><div class=\"line\">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" target=\"_blank\" rel=\"external\">RegExp/test</a></li>\n</ul>\n<p>这里 test 函数会将参数转为字符串. <code>&#39;nul&#39;</code>, <code>&#39;undefined&#39;</code> 自然都是全小写了</p>\n<p>答案: <code>true, true</code></p>\n<h3 id=\"第35题\"><a href=\"#第35题\" class=\"headerlink\" title=\"第35题\"></a>第35题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[,,,].join(&quot;, &quot;)</div></pre></td></tr></table></figure>\n<p><code>[,,,] =&gt; [undefined × 3]</code></p>\n<p>因为javascript 在定义数组的时候允许最后一个元素后跟一个<code>,</code>, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)</p>\n<p>答案: <code>&quot;, , &quot;</code></p>\n<h3 id=\"第36题\"><a href=\"#第36题\" class=\"headerlink\" title=\"第36题\"></a>第36题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</div><div class=\"line\">a.class</div></pre></td></tr></table></figure>\n<p>这个题比较流氓.. 因为是浏览器相关, <code>class</code>是个保留字(现在是个关键字了)</p>\n<p>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 <code>a[&#39;class&#39;]</code></p>\n<h3 id=\"第37题\"><a href=\"#第37题\" class=\"headerlink\" title=\"第37题\"></a>第37题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = new Date(&quot;epoch&quot;)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\" target=\"_blank\" rel=\"external\">Date</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\" target=\"_blank\" rel=\"external\">Date/parse</a></li>\n</ul>\n<p>简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.</p>\n<p>另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 <code>Invalid Date</code>.</p>\n<p>答案 <code>Invalid Date</code></p>\n<h3 id=\"第38题\"><a href=\"#第38题\" class=\"headerlink\" title=\"第38题\"></a>第38题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = Function.length,</div><div class=\"line\">    b = new Function().length</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>我们知道一个function(Function 的实例)的 <code>length</code> 属性就是函数签名的参数个数, 所以 b.length == 0.</p>\n<p>另外 Function.length 定义为1……</p>\n<p>所以不相等…….答案 <code>false</code></p>\n<h3 id=\"第39题\"><a href=\"#第39题\" class=\"headerlink\" title=\"第39题\"></a>第39题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = Date(0);</div><div class=\"line\">var b = new Date(0);</div><div class=\"line\">var c = new Date();</div><div class=\"line\">[a === b, b === c, a === c]</div></pre></td></tr></table></figure>\n<p>还是关于Date 的题, 需要注意的是</p>\n<ul>\n<li>如果不传参数等价于当前时间.</li>\n<li>如果是函数调用 返回一个字符串.</li>\n</ul>\n<p>答案 <code>false, false, false</code></p>\n<h3 id=\"第40题\"><a href=\"#第40题\" class=\"headerlink\" title=\"第40题\"></a>第40题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var min = Math.min(), max = Math.max()</div><div class=\"line\">min &lt; max</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min\" target=\"_blank\" rel=\"external\">Math/min</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max\" target=\"_blank\" rel=\"external\">Math/max</a></li>\n</ul>\n<p>有趣的是, Math.min 不传参数返回 <code>Infinity</code>, Math.max 不传参数返回 <code>-Infinity</code></p>\n<p>答案: <code>false</code></p>\n<h3 id=\"第41题\"><a href=\"#第41题\" class=\"headerlink\" title=\"第41题\"></a>第41题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function captureOne(re, str) &#123;</div><div class=\"line\">  var match = re.exec(str);</div><div class=\"line\">  return match &amp;&amp; match[1];</div><div class=\"line\">&#125;</div><div class=\"line\">var numRe  = /num=(\\d+)/ig,</div><div class=\"line\">    wordRe = /word=(\\w+)/i,</div><div class=\"line\">    a1 = captureOne(numRe,  &quot;num=1&quot;),</div><div class=\"line\">    a2 = captureOne(wordRe, &quot;word=1&quot;),</div><div class=\"line\">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</div><div class=\"line\">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</div><div class=\"line\">[a1 === a2, a3 === a4]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\" target=\"_blank\" rel=\"external\">RegExp/exec</a></li>\n</ul>\n<p>通俗的讲</p>\n<p>因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会</p>\n<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var myRe = /ab*/g;</div><div class=\"line\">var str = &apos;abbcdefabh&apos;;</div><div class=\"line\">var myArray;</div><div class=\"line\">while ((myArray = myRe.exec(str)) !== null) &#123;</div><div class=\"line\">  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</div><div class=\"line\">  msg += &apos;Next match starts at &apos; + myRe.lastIndex;</div><div class=\"line\">  console.log(msg);</div><div class=\"line\">&#125;</div><div class=\"line\">// Found abb. Next match starts at 3</div><div class=\"line\">// Found ab. Next match starts at 9</div></pre></td></tr></table></figure>\n<p>所以 a1 = ’1′; a2 = ’1′; a3 = null; a4 = ’2′</p>\n<p>答案 <code>[true, false]</code></p>\n<h3 id=\"第42题\"><a href=\"#第42题\" class=\"headerlink\" title=\"第42题\"></a>第42题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = new Date(&quot;2014-03-19&quot;),</div><div class=\"line\">    b = new Date(2014, 03, 19);</div><div class=\"line\">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</div></pre></td></tr></table></figure>\n<p>这个….</p>\n<blockquote>\n<p>JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a.getDay()</div><div class=\"line\">3</div><div class=\"line\">b.getDay()</div><div class=\"line\">6</div><div class=\"line\">a.getMonth()</div><div class=\"line\">2</div><div class=\"line\">b.getMonth()</div><div class=\"line\">3</div></pre></td></tr></table></figure>\n<p>都是套路!</p>\n<p>答案 <code>[false, false]</code></p>\n<h3 id=\"第43题\"><a href=\"#第43题\" class=\"headerlink\" title=\"第43题\"></a>第43题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</div><div class=\"line\">  &apos;a gif file&apos;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  &apos;not a gif file&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\" target=\"_blank\" rel=\"external\">String/match</a></li>\n</ul>\n<p>String.prototype.match 接受一个正则, 如果不是, 按照 <code>new RegExp(obj)</code> 转化. 所以 <code>.</code> 并不会转义<br>那么 <code>/gif</code> 就匹配了 /.gif/</p>\n<p>答案: <code>&#39;a gif file&#39;</code></p>\n<h3 id=\"第44题\"><a href=\"#第44题\" class=\"headerlink\" title=\"第44题\"></a>第44题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo(a) &#123;</div><div class=\"line\">    var a;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a) &#123;</div><div class=\"line\">    var a = &apos;bye&apos;;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div><div class=\"line\">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</div></pre></td></tr></table></figure>\n<p>在两个函数里, a作为参数其实已经声明了, 所以 <code>var a; var a = &#39;bye&#39;</code> 其实就是 <code>a; a =&#39;bye&#39;</code></p>\n<p>所以答案 <code>&#39;hello&#39;, &#39;bye&#39;</code></p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/44-javascript-crazy-question.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a><br>英文原文：<a href=\"http://javascript-puzzlers.herokuapp.com/\" target=\"_blank\" rel=\"external\">javascript-puzzlers</a></p>\n","excerpt":"","more":"<h3 id=\"第1题\"><a href=\"#第1题\" class=\"headerlink\" title=\"第1题\"></a>第1题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">Array/map</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt\">Number/parseInt</a></li>\n<li><a href=\"http://www.w3school.com.cn/jsref/jsref_parseInt.asp\">JavaScript parseInt</a></li>\n</ul>\n<p>首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值</p>\n<p>其中回调函数接受三个参数 currentValue, index, arrary;</p>\n<p>而题目中, map只传入了回调函数–parseInt.</p>\n<p>其次, parseInt 只接受两个两个参数 string, radix(基数).</p>\n<blockquote>\n<p>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</p>\n<p>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。</p>\n<p>如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p>\n</blockquote>\n<p>所以本题即问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;1&apos;, 0);</div><div class=\"line\">parseInt(&apos;2&apos;, 1);</div><div class=\"line\">parseInt(&apos;3&apos;, 2);</div></pre></td></tr></table></figure>\n<p>首先后两者参数不合法.</p>\n<p>所以答案是 <code>[1, NaN, NaN]</code></p>\n<h3 id=\"第2题\"><a href=\"#第2题\" class=\"headerlink\" title=\"第2题\"></a>第2题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[typeof null, null instanceof Object]</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\">Operators/typeof</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\">Operators/instanceof</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\">Operators/instanceof(中)</a></li>\n</ul>\n<p>typeof 返回一个表示类型的字符串.</p>\n<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p>\n<p>这个题可以直接看链接… 因为 <code>typeof null === &#39;object&#39;</code> 自语言之初就是这样….</p>\n<p>typeof 的结果请看下表:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">type         result</div><div class=\"line\">Undefined   &quot;undefined&quot;</div><div class=\"line\">Null        &quot;object&quot;</div><div class=\"line\">Boolean     &quot;boolean&quot;</div><div class=\"line\">Number      &quot;number&quot;</div><div class=\"line\">String      &quot;string&quot;</div><div class=\"line\">Symbol      &quot;symbol&quot;</div><div class=\"line\">Host object Implementation-dependent</div><div class=\"line\">Function    &quot;function&quot;</div><div class=\"line\">Object      &quot;object&quot;</div></pre></td></tr></table></figure>\n<p>所以答案 <code>[object, false]</code></p>\n<h3 id=\"第3题\"><a href=\"#第3题\" class=\"headerlink\" title=\"第3题\"></a>第3题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\">Array/Reduce</a></li>\n</ul>\n<p><code>arr.reduce(callback[, initialValue])</code></p>\n<p>reduce接受两个参数, 一个回调, 一个初始值.</p>\n<p>回调函数接受四个参数 <code>previousValue, currentValue, currentIndex, array</code></p>\n<p>需要注意的是 <code>If the array is empty and no initialValue was provided, TypeError would be thrown.</code></p>\n<p>所以第二个表达式会报异常. 第一个表达式等价于 <code>Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</code></p>\n<p>答案 <code>an error</code></p>\n<h3 id=\"第4题\"><a href=\"#第4题\" class=\"headerlink\" title=\"第4题\"></a>第4题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var val = &apos;smtg&apos;;</div><div class=\"line\">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">Operators/Operator_Precedence</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\">Operators/Conditional_Operator</a></li>\n</ul>\n<p>简而言之 <code>+</code> 的优先级 大于 <code>?</code></p>\n<p>所以原题等价于 <code>&#39;Value is true&#39; ? &#39;Somthing&#39; : &#39;Nonthing&#39;</code> 而不是 <code>&#39;Value is&#39; + (true ? &#39;Something&#39; : &#39;Nonthing&#39;)</code></p>\n<p>答案 <code>&#39;Something&#39;</code></p>\n<h3 id=\"第5题\"><a href=\"#第5题\" class=\"headerlink\" title=\"第5题\"></a>第5题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &apos;World!&apos;;</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</div><div class=\"line\">        var name = &apos;Jack&apos;;</div><div class=\"line\">        console.log(&apos;Goodbye &apos; + name);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        console.log(&apos;Hello &apos; + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这个相对简单, 一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\">Hoisting</a></li>\n</ul>\n<p>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</p>\n<p>这个题目相当于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &apos;World!&apos;;</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var name;</div><div class=\"line\">    if (typeof name === &apos;undefined&apos;) &#123;</div><div class=\"line\">        name = &apos;Jack&apos;;</div><div class=\"line\">        console.log(&apos;Goodbye &apos; + name);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        console.log(&apos;Hello &apos; + name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>所以答案是 <code>&#39;Goodbye Jack&#39;</code></p>\n<h3 id=\"第6题\"><a href=\"#第6题\" class=\"headerlink\" title=\"第6题\"></a>第6题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var END = Math.pow(2, 53);</div><div class=\"line\">var START = END - 100;</div><div class=\"line\">var count = 0;</div><div class=\"line\">for (var i = START; i &lt;= END; i++) &#123;</div><div class=\"line\">    count++;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(count);</div></pre></td></tr></table></figure>\n<p>一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity\">Infinity</a></li>\n</ul>\n<p><del>在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.</del></p>\n<p>补充: <a href=\"https://github.com/jelly7723\">@jelly7723</a></p>\n<blockquote>\n<p>js中可以表示的最大整数不是2的53次方，而是1.7976931348623157e+308。<br>2的53次方不是js能表示的最大整数而应该是能正确计算且不失精度的最大整数，可以参见js权威指南。<br>9007199254740992 +1还是 9007199254740992 ，这就是因为精度问题，如果 9007199254740992 +11或者 9007199254740992 +111的话，值是会发生改变的，只是这时候计算的结果不是正确的值，就是因为精度丢失的问题。</p>\n</blockquote>\n<h3 id=\"第7题\"><a href=\"#第7题\" class=\"headerlink\" title=\"第7题\"></a>第7题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ary = [0,1,2];</div><div class=\"line\">ary[10] = 10;</div><div class=\"line\">ary.filter(function(x) &#123; return x === undefined;&#125;);</div></pre></td></tr></table></figure>\n<p>答案是 <code>[]</code></p>\n<p>看一篇文章理解稀疏数组</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/ziyunfei/archive/2012/09/16/2687165.html\">译 JavaScript中的稀疏数组与密集数组</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\">Array/filter</a></li>\n</ul>\n<p>我们来看一下 Array.prototype.filter 的 polyfill:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!Array.prototype.filter) &#123;</div><div class=\"line\">  Array.prototype.filter = function(fun/*, thisArg*/) &#123;</div><div class=\"line\">    &apos;use strict&apos;;</div><div class=\"line\"></div><div class=\"line\">    if (this === void 0 || this === null) &#123;</div><div class=\"line\">      throw new TypeError();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var t = Object(this);</div><div class=\"line\">    var len = t.length &gt;&gt;&gt; 0;</div><div class=\"line\">    if (typeof fun !== &apos;function&apos;) &#123;</div><div class=\"line\">      throw new TypeError();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var res = [];</div><div class=\"line\">    var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0;</div><div class=\"line\">    for (var i = 0; i &lt; len; i++) &#123;</div><div class=\"line\">      if (i in t) &#123; // 注意这里!!!</div><div class=\"line\">        var val = t[i];</div><div class=\"line\">        if (fun.call(thisArg, val, i, t)) &#123;</div><div class=\"line\">          res.push(val);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return res;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">0 in ary; =&gt; true</div><div class=\"line\">3 in ary; =&gt; false</div><div class=\"line\">10 in ary; =&gt; true</div></pre></td></tr></table></figure>\n<p>也就是说 从 3 – 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.</p>\n<h3 id=\"第8题\"><a href=\"#第8题\" class=\"headerlink\" title=\"第8题\"></a>第8题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var two   = 0.2</div><div class=\"line\">var one   = 0.1</div><div class=\"line\">var eight = 0.8</div><div class=\"line\">var six   = 0.6</div><div class=\"line\">[two - one == one, eight - six == two]</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"http://ourjs.com/detail/54695381bc3f9b154e000046\">JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3</a></li>\n</ul>\n<p>IEEE 754标准中的<a href=\"http://www.codeceo.com/article/float-number.html\">浮点数</a>并不能精确地表达小数</p>\n<p>那什么时候精准, 什么时候不经准呢? 笔者也不知道…</p>\n<p>答案 <code>[true, false]</code></p>\n<h3 id=\"第9题\"><a href=\"#第9题\" class=\"headerlink\" title=\"第9题\"></a>第9题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function showCase(value) &#123;</div><div class=\"line\">    switch(value) &#123;</div><div class=\"line\">    case &apos;A&apos;:</div><div class=\"line\">        console.log(&apos;Case A&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case &apos;B&apos;:</div><div class=\"line\">        console.log(&apos;Case B&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case undefined:</div><div class=\"line\">        console.log(&apos;undefined&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    default:</div><div class=\"line\">        console.log(&apos;Do not know!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">showCase(new String(&apos;A&apos;));</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch\">Statements/switch</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\">String</a></li>\n</ul>\n<p>switch 是严格比较, String 实例和 字符串不一样.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var s_prim = &apos;foo&apos;;</div><div class=\"line\">var s_obj = new String(s_prim);</div><div class=\"line\"></div><div class=\"line\">console.log(typeof s_prim); // &quot;string&quot;</div><div class=\"line\">console.log(typeof s_obj);  // &quot;object&quot;</div><div class=\"line\">console.log(s_prim === s_obj); // false</div></pre></td></tr></table></figure>\n<p>答案是 <code>&#39;Do not know!&#39;</code></p>\n<h3 id=\"第10题\"><a href=\"#第10题\" class=\"headerlink\" title=\"第10题\"></a>第10题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function showCase2(value) &#123;</div><div class=\"line\">    switch(value) &#123;</div><div class=\"line\">    case &apos;A&apos;:</div><div class=\"line\">        console.log(&apos;Case A&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case &apos;B&apos;:</div><div class=\"line\">        console.log(&apos;Case B&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    case undefined:</div><div class=\"line\">        console.log(&apos;undefined&apos;);</div><div class=\"line\">        break;</div><div class=\"line\">    default:</div><div class=\"line\">        console.log(&apos;Do not know!&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">showCase2(String(&apos;A&apos;));</div></pre></td></tr></table></figure>\n<p>解释:</p>\n<p><code>String(x) does not create an object but does return a string, i.e. typeof String(1) === &quot;string&quot;</code></p>\n<p>还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.</p>\n<p>答案 <code>&#39;Case A&#39;</code></p>\n<h3 id=\"第11题\"><a href=\"#第11题\" class=\"headerlink\" title=\"第11题\"></a>第11题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function isOdd(num) &#123;</div><div class=\"line\">    return num % 2 == 1;</div><div class=\"line\">&#125;</div><div class=\"line\">function isEven(num) &#123;</div><div class=\"line\">    return num % 2 == 0;</div><div class=\"line\">&#125;</div><div class=\"line\">function isSane(num) &#123;</div><div class=\"line\">    return isEven(num) || isOdd(num);</div><div class=\"line\">&#125;</div><div class=\"line\">var values = [7, 4, &apos;13&apos;, -9, Infinity];</div><div class=\"line\">values.map(isSane);</div></pre></td></tr></table></figure>\n<p>一个知识点</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder\">Arithmetic_Operators#Remainder</a></li>\n</ul>\n<p>此题等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">7 % 2 =&gt; 1</div><div class=\"line\">4 % 2 =&gt; 0</div><div class=\"line\">&apos;13&apos; % 2 =&gt; 1</div><div class=\"line\">-9 % % 2 =&gt; -1</div><div class=\"line\">Infinity % 2 =&gt; NaN</div></pre></td></tr></table></figure>\n<p>需要注意的是 余数的正负号随第一个操作数.</p>\n<p>答案 <code>[true, true, true, false, false]</code></p>\n<h3 id=\"第12题\"><a href=\"#第12题\" class=\"headerlink\" title=\"第12题\"></a>第12题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(3, 8)</div><div class=\"line\">parseInt(3, 2)</div><div class=\"line\">parseInt(3, 0)</div></pre></td></tr></table></figure>\n<p>第一个题讲过了, 答案 <code>3, NaN, 3</code></p>\n<h3 id=\"第13题\"><a href=\"#第13题\" class=\"headerlink\" title=\"第13题\"></a>第13题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.isArray( Array.prototype )</div></pre></td></tr></table></figure>\n<p>一个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype\">Array/prototype</a></li>\n</ul>\n<p>一个鲜为人知的实事: <code>Array.prototype =&gt; []</code>;</p>\n<p>答案: <code>true</code></p>\n<h3 id=\"第14题\"><a href=\"#第14题\" class=\"headerlink\" title=\"第14题\"></a>第14题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [0];</div><div class=\"line\">if ([0]) &#123;</div><div class=\"line\">  console.log(a == true);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&quot;wut&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://dorey.github.io/JavaScript-Equality-Table/\">JavaScript-Equality-Table</a></li>\n</ul>\n<p>答案: <code>false</code></p>\n<h3 id=\"第15题\"><a href=\"#第15题\" class=\"headerlink\" title=\"第15题\"></a>第15题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[]==[]</div></pre></td></tr></table></figure>\n<p><code>==</code> 是万恶之源, 看上图</p>\n<p>答案是 <code>false</code></p>\n<h3 id=\"第16题\"><a href=\"#第16题\" class=\"headerlink\" title=\"第16题\"></a>第16题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&apos;5&apos; + 3</div><div class=\"line\">&apos;5&apos; - 3</div></pre></td></tr></table></figure>\n<p>两个知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Addition\">Arithmetic_Operators#Addition</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Subtraction\">Arithmetic_Operators#Subtraction</a></li>\n</ul>\n<p><code>+</code> 用来表示两个数的和或者字符串拼接, <code>-</code>表示两数之差.</p>\n<p>请看例子, 体会区别:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; &apos;5&apos; + 3</div><div class=\"line\">&apos;53&apos;</div><div class=\"line\">&gt; 5 + &apos;3&apos;</div><div class=\"line\">&apos;53&apos;</div><div class=\"line\">&gt; 5 - &apos;3&apos;</div><div class=\"line\">2</div><div class=\"line\">&gt; &apos;5&apos; - 3</div><div class=\"line\">2</div><div class=\"line\">&gt; &apos;5&apos; - &apos;3&apos;</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n<p>也就是说 <code>-</code> 会尽可能的将两个操作数变成数字, 而 <code>+</code> 如果两边不都是数字, 那么就是字符串拼接.</p>\n<p>答案是 <code>&#39;53&#39;, 2</code></p>\n<h3 id=\"第17题\"><a href=\"#第17题\" class=\"headerlink\" title=\"第17题\"></a>第17题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 + - + + + - + 1</div></pre></td></tr></table></figure>\n<p>这里应该是(倒着看)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 + (a)  =&gt; 2</div><div class=\"line\">a = - (b) =&gt; 1</div><div class=\"line\">b = + (c) =&gt; -1</div><div class=\"line\">c = + (d) =&gt; -1</div><div class=\"line\">d = + (e) =&gt; -1</div><div class=\"line\">e = + (f) =&gt; -1</div><div class=\"line\">f = - (g) =&gt; -1</div><div class=\"line\">g = + 1   =&gt; 1</div></pre></td></tr></table></figure>\n<p>所以答案 <code>2</code></p>\n<h3 id=\"第18题\"><a href=\"#第18题\" class=\"headerlink\" title=\"第18题\"></a>第18题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var ary = Array(3);</div><div class=\"line\">ary[0]=2</div><div class=\"line\">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</div></pre></td></tr></table></figure>\n<p>稀疏数组. 同第7题.</p>\n<p>题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.</p>\n<p>所以答案是 <code>[&quot;1&quot;, undefined × 2]</code></p>\n<p>这里贴上 Array.prototype.map 的 polyfill.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.map = function(callback, thisArg) &#123;</div><div class=\"line\"></div><div class=\"line\">        var T, A, k;</div><div class=\"line\"></div><div class=\"line\">        if (this == null) &#123;</div><div class=\"line\">            throw new TypeError(&apos; this is null or not defined&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var O = Object(this);</div><div class=\"line\">        var len = O.length &gt;&gt;&gt; 0;</div><div class=\"line\">        if (typeof callback !== &apos;function&apos;) &#123;</div><div class=\"line\">            throw new TypeError(callback + &apos; is not a function&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (arguments.length &gt; 1) &#123;</div><div class=\"line\">            T = thisArg;</div><div class=\"line\">        &#125;</div><div class=\"line\">        A = new Array(len);</div><div class=\"line\">        k = 0;</div><div class=\"line\">        while (k &lt; len) &#123;</div><div class=\"line\">            var kValue, mappedValue;</div><div class=\"line\">            if (k in O) &#123;</div><div class=\"line\">                kValue = O[k];</div><div class=\"line\">                mappedValue = callback.call(T, kValue, k, O);</div><div class=\"line\">                A[k] = mappedValue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            k++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return A;</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"第19题\"><a href=\"#第19题\" class=\"headerlink\" title=\"第19题\"></a>第19题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function sidEffecting(ary) &#123;</div><div class=\"line\">  ary[0] = ary[2];</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a,b,c) &#123;</div><div class=\"line\">  c = 10</div><div class=\"line\">  sidEffecting(arguments);</div><div class=\"line\">  return a + b + c;</div><div class=\"line\">&#125;</div><div class=\"line\">bar(1,1,1)</div></pre></td></tr></table></figure>\n<p>这是一个大坑, 尤其是涉及到 ES6语法的时候</p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\">Functions/arguments</a></li>\n</ul>\n<p>首先 <code>The arguments object is an Array-like object corresponding to the arguments passed to a function.</code></p>\n<p>也就是说 <code>arguments</code> 是一个 <code>object</code>, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.</p>\n<p>所以答案是 <code>21</code>.</p>\n<p>然而!!!!!!</p>\n<p>当函数参数涉及到 <code>any rest parameters, any default parameters or any destructured parameters</code> 的时候, 这个 arguments 就不在是一个 <code>mapped arguments object</code> 了…..</p>\n<p>请看:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function sidEffecting(ary) &#123;</div><div class=\"line\">  ary[0] = ary[2];</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a,b,c=3) &#123;</div><div class=\"line\">  c = 10</div><div class=\"line\">  sidEffecting(arguments);</div><div class=\"line\">  return a + b + c;</div><div class=\"line\">&#125;</div><div class=\"line\">bar(1,1,1)</div></pre></td></tr></table></figure>\n<p>答案是 <code>12</code> !!!!</p>\n<p>请读者细细体会!!</p>\n<h3 id=\"第20题\"><a href=\"#第20题\" class=\"headerlink\" title=\"第20题\"></a>第20题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = 111111111111111110000,</div><div class=\"line\">    b = 1111;</div><div class=\"line\">a + b;</div></pre></td></tr></table></figure>\n<p>答案还是 <code>111111111111111110000</code>. 解释是 <code>Lack of precision for numbers in JavaScript affects both small and big numbers.</code> 但是笔者不是很明白……………. 请读者赐教!</p>\n<h3 id=\"第21题\"><a href=\"#第21题\" class=\"headerlink\" title=\"第21题\"></a>第21题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var x = [].reverse;</div><div class=\"line\">x();</div></pre></td></tr></table></figure>\n<p>这个题有意思!</p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse\">Array/reverse</a></li>\n</ul>\n<p><code>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</code></p>\n<p>也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 <code>window</code>.</p>\n<p>答案是 <code>window</code></p>\n<h3 id=\"第22题\"><a href=\"#第22题\" class=\"headerlink\" title=\"第22题\"></a>第22题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Number.MIN_VALUE &gt; 0</div></pre></td></tr></table></figure>\n<p><code>true</code></p>\n<h3 id=\"第23题\"><a href=\"#第23题\" class=\"headerlink\" title=\"第23题\"></a>第23题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</div></pre></td></tr></table></figure>\n<p>这个题也还可以.</p>\n<p>这个题会让人误以为是 <code>2 &gt; 1 &amp;&amp; 2 &lt; 3</code> 其实不是的.</p>\n<p>这个题等价于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">1 &lt; 2 =&gt; true;</div><div class=\"line\">true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;</div><div class=\"line\">3 &lt; 2 =&gt; false;</div><div class=\"line\">false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;</div></pre></td></tr></table></figure>\n<p>答案是 <code>[true, true]</code></p>\n<h3 id=\"第24题\"><a href=\"#第24题\" class=\"headerlink\" title=\"第24题\"></a>第24题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// the most classic wtf</div><div class=\"line\">2 == [[[2]]]</div></pre></td></tr></table></figure>\n<p>这个题我是猜的. 我猜的 <code>true</code>, 至于为什么…..</p>\n<p><code>both objects get converted to strings and in both cases the resulting string is &quot;2&quot;</code> 我不能信服…</p>\n<h3 id=\"第25题\"><a href=\"#第25题\" class=\"headerlink\" title=\"第25题\"></a>第25题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">3.toString()</div><div class=\"line\">3..toString()</div><div class=\"line\">3...toString()</div></pre></td></tr></table></figure>\n<p>这个题也挺逗, 我做对了<img src=\"http://www.codeceo.com/wp-content/themes/d-simple/img/smilies/icon_smile.gif\" alt=\":)\">答案是 <code>error, &#39;3&#39;, error</code></p>\n<p>你如果换一个写法就更费解了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = 3;</div><div class=\"line\">a.toString()</div></pre></td></tr></table></figure>\n<p>这个答案就是 <code>&#39;3&#39;</code>;</p>\n<p>为啥呢?</p>\n<p>因为在 js 中 <code>1.1</code>, <code>1.</code>, <code>.1</code> 都是合法的数字. 那么在解析 <code>3.toString</code> 的时候这个 <code>.</code> 到底是属于这个数字还是函数调用呢? 只能是数字, 因为<code>3.</code>合法啊!</p>\n<h3 id=\"第26题\"><a href=\"#第26题\" class=\"headerlink\" title=\"第26题\"></a>第26题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function()&#123;</div><div class=\"line\">  var x = y = 1;</div><div class=\"line\">&#125;)();</div><div class=\"line\">console.log(y);</div><div class=\"line\">console.log(x);</div></pre></td></tr></table></figure>\n<p>答案是 <code>1, error</code></p>\n<p>y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 <code>ReferenceError</code></p>\n<h3 id=\"第27题\"><a href=\"#第27题\" class=\"headerlink\" title=\"第27题\"></a>第27题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = /123/,</div><div class=\"line\">    b = /123/;</div><div class=\"line\">a == b</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>即使正则的字面量一致, 他们也不相等.</p>\n<p>答案 <code>false, false</code></p>\n<h3 id=\"第28题\"><a href=\"#第28题\" class=\"headerlink\" title=\"第28题\"></a>第28题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 2, 3],</div><div class=\"line\">    b = [1, 2, 3],</div><div class=\"line\">    c = [1, 2, 4]</div><div class=\"line\">a ==  b</div><div class=\"line\">a === b</div><div class=\"line\">a &gt;   c</div><div class=\"line\">a &lt;   c</div></pre></td></tr></table></figure>\n<p>字面量相等的数组也不相等.</p>\n<p>数组在比较大小的时候按照字典序比较</p>\n<p>答案 <code>false, false, false, true</code></p>\n<h3 id=\"第29题\"><a href=\"#第29题\" class=\"headerlink\" title=\"第29题\"></a>第29题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123;&#125;, b = Object.prototype;</div><div class=\"line\">[a.prototype === b, Object.getPrototypeOf(a) === b]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\">Object/getPrototypeOf</a></li>\n</ul>\n<p>只有 Function 拥有一个 prototype 的属性. 所以 <code>a.prototype</code> 为 <code>undefined</code>.</p>\n<p>而 <code>Object.getPrototypeOf(obj)</code> 返回一个具体对象的原型(该对象的内部<code>[[prototype]]</code>值)</p>\n<p>答案 <code>false, true</code></p>\n<h3 id=\"第30题\"><a href=\"#第30题\" class=\"headerlink\" title=\"第30题\"></a>第30题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f() &#123;&#125;</div><div class=\"line\">var a = f.prototype, b = Object.getPrototypeOf(f);</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.</p>\n<p>f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.</p>\n<p>请看:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a === Object.getPrototypeOf(new f()) // true</div><div class=\"line\">b === Function.prototype // true</div></pre></td></tr></table></figure>\n<p>答案 <code>false</code></p>\n<h3 id=\"第31题\"><a href=\"#第31题\" class=\"headerlink\" title=\"第31题\"></a>第31题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo() &#123; &#125;</div><div class=\"line\">var oldName = foo.name;</div><div class=\"line\">foo.name = &quot;bar&quot;;</div><div class=\"line\">[oldName, foo.name]</div></pre></td></tr></table></figure>\n<p>答案 <code>[&#39;foo&#39;, &#39;foo&#39;]</code></p>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\">Function/name</a></li>\n</ul>\n<p>因为函数的名字不可变.</p>\n<h3 id=\"第32题\"><a href=\"#第32题\" class=\"headerlink\" title=\"第32题\"></a>第32题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&quot;1 2 3&quot;.replace(/\\d/g, parseInt)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_function_as_a_parameter\">String/replace#Specifying_a_function_as_a_parameter</a></li>\n</ul>\n<p><code>str.replace(regexp|substr, newSubStr|function)</code></p>\n<p>如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数</p>\n<ul>\n<li>match 首先是匹配的字符串</li>\n<li>p1, p2 …. 然后是正则的分组</li>\n<li>offset match 匹配的index</li>\n<li>string 整个字符串</li>\n</ul>\n<p>由于题目中的正则没有分组, 所以等价于问</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;1&apos;, 0)</div><div class=\"line\">parseInt(&apos;2&apos;, 2)</div><div class=\"line\">parseInt(&apos;3&apos;, 4)</div></pre></td></tr></table></figure>\n<p>答案: <code>1, NaN, 3</code></p>\n<h3 id=\"第33题\"><a href=\"#第33题\" class=\"headerlink\" title=\"第33题\"></a>第33题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f() &#123;&#125;</div><div class=\"line\">var parent = Object.getPrototypeOf(f);</div><div class=\"line\">f.name // ?</div><div class=\"line\">parent.name // ?</div><div class=\"line\">typeof eval(f.name) // ?</div><div class=\"line\">typeof eval(parent.name) //  ?</div></pre></td></tr></table></figure>\n<p>先说以下答案 <code>&#39;f&#39;, &#39;Empty&#39;, &#39;function&#39;, error</code> 这个答案并不重要…..</p>\n<p>这里第一小问和第三小问很简单不解释了.</p>\n<p>第二小问笔者在自己的浏览器测试的时候是 <code>&#39;&#39;</code>, 第四问是 <code>&#39;undefined&#39;</code></p>\n<p>所以应该是平台相关的. 这里明白 <code>parent === Function.prototype</code> 就好了.</p>\n<h3 id=\"第34题\"><a href=\"#第34题\" class=\"headerlink\" title=\"第34题\"></a>第34题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var lowerCaseOnly =  /^[a-z]+$/;</div><div class=\"line\">[lowerCaseOnly.test(null), lowerCaseOnly.test()]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\">RegExp/test</a></li>\n</ul>\n<p>这里 test 函数会将参数转为字符串. <code>&#39;nul&#39;</code>, <code>&#39;undefined&#39;</code> 自然都是全小写了</p>\n<p>答案: <code>true, true</code></p>\n<h3 id=\"第35题\"><a href=\"#第35题\" class=\"headerlink\" title=\"第35题\"></a>第35题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[,,,].join(&quot;, &quot;)</div></pre></td></tr></table></figure>\n<p><code>[,,,] =&gt; [undefined × 3]</code></p>\n<p>因为javascript 在定义数组的时候允许最后一个元素后跟一个<code>,</code>, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)</p>\n<p>答案: <code>&quot;, , &quot;</code></p>\n<h3 id=\"第36题\"><a href=\"#第36题\" class=\"headerlink\" title=\"第36题\"></a>第36题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123;class: &quot;Animal&quot;, name: &apos;Fido&apos;&#125;;</div><div class=\"line\">a.class</div></pre></td></tr></table></figure>\n<p>这个题比较流氓.. 因为是浏览器相关, <code>class</code>是个保留字(现在是个关键字了)</p>\n<p>所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 <code>a[&#39;class&#39;]</code></p>\n<h3 id=\"第37题\"><a href=\"#第37题\" class=\"headerlink\" title=\"第37题\"></a>第37题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = new Date(&quot;epoch&quot;)</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\">Date</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse\">Date/parse</a></li>\n</ul>\n<p>简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.</p>\n<p>另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 <code>Invalid Date</code>.</p>\n<p>答案 <code>Invalid Date</code></p>\n<h3 id=\"第38题\"><a href=\"#第38题\" class=\"headerlink\" title=\"第38题\"></a>第38题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = Function.length,</div><div class=\"line\">    b = new Function().length</div><div class=\"line\">a === b</div></pre></td></tr></table></figure>\n<p>我们知道一个function(Function 的实例)的 <code>length</code> 属性就是函数签名的参数个数, 所以 b.length == 0.</p>\n<p>另外 Function.length 定义为1……</p>\n<p>所以不相等…….答案 <code>false</code></p>\n<h3 id=\"第39题\"><a href=\"#第39题\" class=\"headerlink\" title=\"第39题\"></a>第39题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = Date(0);</div><div class=\"line\">var b = new Date(0);</div><div class=\"line\">var c = new Date();</div><div class=\"line\">[a === b, b === c, a === c]</div></pre></td></tr></table></figure>\n<p>还是关于Date 的题, 需要注意的是</p>\n<ul>\n<li>如果不传参数等价于当前时间.</li>\n<li>如果是函数调用 返回一个字符串.</li>\n</ul>\n<p>答案 <code>false, false, false</code></p>\n<h3 id=\"第40题\"><a href=\"#第40题\" class=\"headerlink\" title=\"第40题\"></a>第40题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var min = Math.min(), max = Math.max()</div><div class=\"line\">min &lt; max</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min\">Math/min</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max\">Math/max</a></li>\n</ul>\n<p>有趣的是, Math.min 不传参数返回 <code>Infinity</code>, Math.max 不传参数返回 <code>-Infinity</code></p>\n<p>答案: <code>false</code></p>\n<h3 id=\"第41题\"><a href=\"#第41题\" class=\"headerlink\" title=\"第41题\"></a>第41题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function captureOne(re, str) &#123;</div><div class=\"line\">  var match = re.exec(str);</div><div class=\"line\">  return match &amp;&amp; match[1];</div><div class=\"line\">&#125;</div><div class=\"line\">var numRe  = /num=(\\d+)/ig,</div><div class=\"line\">    wordRe = /word=(\\w+)/i,</div><div class=\"line\">    a1 = captureOne(numRe,  &quot;num=1&quot;),</div><div class=\"line\">    a2 = captureOne(wordRe, &quot;word=1&quot;),</div><div class=\"line\">    a3 = captureOne(numRe,  &quot;NUM=2&quot;),</div><div class=\"line\">    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);</div><div class=\"line\">[a1 === a2, a3 === a4]</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec\">RegExp/exec</a></li>\n</ul>\n<p>通俗的讲</p>\n<p>因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会</p>\n<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var myRe = /ab*/g;</div><div class=\"line\">var str = &apos;abbcdefabh&apos;;</div><div class=\"line\">var myArray;</div><div class=\"line\">while ((myArray = myRe.exec(str)) !== null) &#123;</div><div class=\"line\">  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;</div><div class=\"line\">  msg += &apos;Next match starts at &apos; + myRe.lastIndex;</div><div class=\"line\">  console.log(msg);</div><div class=\"line\">&#125;</div><div class=\"line\">// Found abb. Next match starts at 3</div><div class=\"line\">// Found ab. Next match starts at 9</div></pre></td></tr></table></figure>\n<p>所以 a1 = ’1′; a2 = ’1′; a3 = null; a4 = ’2′</p>\n<p>答案 <code>[true, false]</code></p>\n<h3 id=\"第42题\"><a href=\"#第42题\" class=\"headerlink\" title=\"第42题\"></a>第42题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = new Date(&quot;2014-03-19&quot;),</div><div class=\"line\">    b = new Date(2014, 03, 19);</div><div class=\"line\">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</div></pre></td></tr></table></figure>\n<p>这个….</p>\n<blockquote>\n<p>JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate, which doesn’t return a Date object.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a.getDay()</div><div class=\"line\">3</div><div class=\"line\">b.getDay()</div><div class=\"line\">6</div><div class=\"line\">a.getMonth()</div><div class=\"line\">2</div><div class=\"line\">b.getMonth()</div><div class=\"line\">3</div></pre></td></tr></table></figure>\n<p>都是套路!</p>\n<p>答案 <code>[false, false]</code></p>\n<h3 id=\"第43题\"><a href=\"#第43题\" class=\"headerlink\" title=\"第43题\"></a>第43题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) &#123;</div><div class=\"line\">  &apos;a gif file&apos;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  &apos;not a gif file&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>知识点:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\">String/match</a></li>\n</ul>\n<p>String.prototype.match 接受一个正则, 如果不是, 按照 <code>new RegExp(obj)</code> 转化. 所以 <code>.</code> 并不会转义<br>那么 <code>/gif</code> 就匹配了 /.gif/</p>\n<p>答案: <code>&#39;a gif file&#39;</code></p>\n<h3 id=\"第44题\"><a href=\"#第44题\" class=\"headerlink\" title=\"第44题\"></a>第44题</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo(a) &#123;</div><div class=\"line\">    var a;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div><div class=\"line\">function bar(a) &#123;</div><div class=\"line\">    var a = &apos;bye&apos;;</div><div class=\"line\">    return a;</div><div class=\"line\">&#125;</div><div class=\"line\">[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</div></pre></td></tr></table></figure>\n<p>在两个函数里, a作为参数其实已经声明了, 所以 <code>var a; var a = &#39;bye&#39;</code> 其实就是 <code>a; a =&#39;bye&#39;</code></p>\n<p>所以答案 <code>&#39;hello&#39;, &#39;bye&#39;</code></p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/44-javascript-crazy-question.html\">http://www.codeceo.com</a><br>英文原文：<a href=\"http://javascript-puzzlers.herokuapp.com/\">javascript-puzzlers</a></p>\n"},{"title":"12种不宜使用的Javascript语法","date":"2015-04-18T16:00:00.000Z","_content":"\n### 1、==\n\nJavascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。\n请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：\n\n```\nfalse == 'false'\nfalse == undefined\nfalse == null\nnull == undefined\n0 == ''\n```\n\n前三个是false，后两个是true。\n\n### 2、with\n\nwith的本意是减少键盘输入。比如\n\n```\nobj.a = obj.b;\nobj.c = obj.d;\n```\n\n可以简写成\n\n```\nwith(obj) {\n　　a = b;\n　　c = d;\n}\n```\n\n但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。\n\n### 3、eval\n\neval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。\n\neval能够做到的事情，不用它也能做到。比如\n\n```\neval(\"myValue = myObject.\" + myKey + \";\");\n```\n\n可以直接写成\n\n```\nmyValue = myObject[myKey];\n```\n\n至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行\n\n### 4、continue\n\n这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。\n\n### 5、switch 贯穿\n\nswitch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如\n\n```\nswitch(n) {\n　　case 1:\n　　case 2:\n　　　　break;\n}\n```\n\n这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。\n\n```\nswitch(n) {\n　　case 1:\n　　　　break;\n　　case 2:\n　　　　break;\n}\n```\n\n### 6、单行的块结构\n\nif、while、do和for，都是块结构语句，但是也可以接受单行命令。比如\n\n```\nif (ok) t = true;\n```\n\n甚至写成\n\n```\nif (ok)\n　　t = true;\n```\n\n这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。\n\n```\nif (ok){\n　　t = true;\n}\n```\n\n### 7、++和--\n\n递增运算符++和递减运算符--，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。\n\n### 8、位运算符\n\nJavascript完全套用了Java的位运算符，包括按位与&、按位或|、按位异或^、按位非~、左移<<、带符号的右移>>和用0补足的右移>>>。\n\n这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且\"按位与运算符\"&同\"逻辑与运算符\"&&，很容易混淆。\n\n### 9、function语句\n\n在Javascript中定义一个函数，有两种写法：\n\n```\nfunction foo() { }\n```\n\n和\n\n```\nvar foo = function () { }\n```\n\n两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。\n\n### 10、基本数据类型的包装对象\n\nJavascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：\n\n```\nnew String(\"Hello World\");\nnew Number(2000);\nnew Boolean(false);\n```\n\n这样写完全没有必要，而且非常费解，因此建议不要使用。\n\n另外，new Object和new Array也不建议使用，可以用{}和[]代替。\n\n### 11、new语句\n\nJavascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。\n\n类是这样定义的：\n\n```\nvar Cat = function (name) {\n　　this.name = name;\n　　this.saying = 'meow' ;\n}\n```\n\n然后，再生成一个对象\n\n```\nvar myCat = new Cat('mimi');\n```\n\n这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。\n\nDouglas Crockford给出了一个函数：\n\n```\nObject.beget = function (o) {\n　　var F = function (o) {};\n　　F.prototype = o ;\n　　return new F;\n};\n```\n\n创建对象时就利用这个函数，对原型对象进行操作：\n\n```\nvar Cat = {\n　　name:'',\n　　saying:'meow'\n};\nvar myCat = Object.beget(Cat);\n```\n\n对象生成后，可以自行对相关属性进行赋值：\n\n```\nmyCat.name = 'mimi';\n```\n\n### 12、void\n\n在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。\n\n```\nvoid 0; // undefined\n```\n\n这个命令没什么用，而且很令人困惑，建议避免使用。\n","source":"_posts/12种不宜使用的Javascript语法.md","raw":"---\ntitle: 12种不宜使用的Javascript语法\ntags: [javascript]\ndate: 2015/04/19\n---\n\n### 1、==\n\nJavascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。\n请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：\n\n```\nfalse == 'false'\nfalse == undefined\nfalse == null\nnull == undefined\n0 == ''\n```\n\n前三个是false，后两个是true。\n\n### 2、with\n\nwith的本意是减少键盘输入。比如\n\n```\nobj.a = obj.b;\nobj.c = obj.d;\n```\n\n可以简写成\n\n```\nwith(obj) {\n　　a = b;\n　　c = d;\n}\n```\n\n但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。\n\n### 3、eval\n\neval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。\n\neval能够做到的事情，不用它也能做到。比如\n\n```\neval(\"myValue = myObject.\" + myKey + \";\");\n```\n\n可以直接写成\n\n```\nmyValue = myObject[myKey];\n```\n\n至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行\n\n### 4、continue\n\n这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。\n\n### 5、switch 贯穿\n\nswitch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如\n\n```\nswitch(n) {\n　　case 1:\n　　case 2:\n　　　　break;\n}\n```\n\n这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。\n\n```\nswitch(n) {\n　　case 1:\n　　　　break;\n　　case 2:\n　　　　break;\n}\n```\n\n### 6、单行的块结构\n\nif、while、do和for，都是块结构语句，但是也可以接受单行命令。比如\n\n```\nif (ok) t = true;\n```\n\n甚至写成\n\n```\nif (ok)\n　　t = true;\n```\n\n这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。\n\n```\nif (ok){\n　　t = true;\n}\n```\n\n### 7、++和--\n\n递增运算符++和递减运算符--，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。\n\n### 8、位运算符\n\nJavascript完全套用了Java的位运算符，包括按位与&、按位或|、按位异或^、按位非~、左移<<、带符号的右移>>和用0补足的右移>>>。\n\n这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且\"按位与运算符\"&同\"逻辑与运算符\"&&，很容易混淆。\n\n### 9、function语句\n\n在Javascript中定义一个函数，有两种写法：\n\n```\nfunction foo() { }\n```\n\n和\n\n```\nvar foo = function () { }\n```\n\n两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。\n\n### 10、基本数据类型的包装对象\n\nJavascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：\n\n```\nnew String(\"Hello World\");\nnew Number(2000);\nnew Boolean(false);\n```\n\n这样写完全没有必要，而且非常费解，因此建议不要使用。\n\n另外，new Object和new Array也不建议使用，可以用{}和[]代替。\n\n### 11、new语句\n\nJavascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。\n\n类是这样定义的：\n\n```\nvar Cat = function (name) {\n　　this.name = name;\n　　this.saying = 'meow' ;\n}\n```\n\n然后，再生成一个对象\n\n```\nvar myCat = new Cat('mimi');\n```\n\n这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。\n\nDouglas Crockford给出了一个函数：\n\n```\nObject.beget = function (o) {\n　　var F = function (o) {};\n　　F.prototype = o ;\n　　return new F;\n};\n```\n\n创建对象时就利用这个函数，对原型对象进行操作：\n\n```\nvar Cat = {\n　　name:'',\n　　saying:'meow'\n};\nvar myCat = Object.beget(Cat);\n```\n\n对象生成后，可以自行对相关属性进行赋值：\n\n```\nmyCat.name = 'mimi';\n```\n\n### 12、void\n\n在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。\n\n```\nvoid 0; // undefined\n```\n\n这个命令没什么用，而且很令人困惑，建议避免使用。\n","slug":"12种不宜使用的Javascript语法","published":1,"updated":"2016-08-17T06:22:19.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphb000468dd5vmu624j","content":"<h3 id=\"1、\"><a href=\"#1、\" class=\"headerlink\" title=\"1、==\"></a>1、==</h3><p>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">false == &apos;false&apos;</div><div class=\"line\">false == undefined</div><div class=\"line\">false == null</div><div class=\"line\">null == undefined</div><div class=\"line\">0 == &apos;&apos;</div></pre></td></tr></table></figure>\n<p>前三个是false，后两个是true。</p>\n<h3 id=\"2、with\"><a href=\"#2、with\" class=\"headerlink\" title=\"2、with\"></a>2、with</h3><p>with的本意是减少键盘输入。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">obj.a = obj.b;</div><div class=\"line\">obj.c = obj.d;</div></pre></td></tr></table></figure>\n<p>可以简写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">with(obj) &#123;</div><div class=\"line\">　　a = b;</div><div class=\"line\">　　c = d;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p>\n<h3 id=\"3、eval\"><a href=\"#3、eval\" class=\"headerlink\" title=\"3、eval\"></a>3、eval</h3><p>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>\n<p>eval能够做到的事情，不用它也能做到。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">eval(&quot;myValue = myObject.&quot; + myKey + &quot;;&quot;);</div></pre></td></tr></table></figure>\n<p>可以直接写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myValue = myObject[myKey];</div></pre></td></tr></table></figure>\n<p>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行</p>\n<h3 id=\"4、continue\"><a href=\"#4、continue\" class=\"headerlink\" title=\"4、continue\"></a>4、continue</h3><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>\n<h3 id=\"5、switch-贯穿\"><a href=\"#5、switch-贯穿\" class=\"headerlink\" title=\"5、switch 贯穿\"></a>5、switch 贯穿</h3><p>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">switch(n) &#123;</div><div class=\"line\">　　case 1:</div><div class=\"line\">　　case 2:</div><div class=\"line\">　　　　break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">switch(n) &#123;</div><div class=\"line\">　　case 1:</div><div class=\"line\">　　　　break;</div><div class=\"line\">　　case 2:</div><div class=\"line\">　　　　break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6、单行的块结构\"><a href=\"#6、单行的块结构\" class=\"headerlink\" title=\"6、单行的块结构\"></a>6、单行的块结构</h3><p>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok) t = true;</div></pre></td></tr></table></figure>\n<p>甚至写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok)</div><div class=\"line\">　　t = true;</div></pre></td></tr></table></figure>\n<p>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok)&#123;</div><div class=\"line\">　　t = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"7、-和–\"><a href=\"#7、-和–\" class=\"headerlink\" title=\"7、++和–\"></a>7、++和–</h3><p>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>\n<h3 id=\"8、位运算符\"><a href=\"#8、位运算符\" class=\"headerlink\" title=\"8、位运算符\"></a>8、位运算符</h3><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。</p>\n<p>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p>\n<h3 id=\"9、function语句\"><a href=\"#9、function语句\" class=\"headerlink\" title=\"9、function语句\"></a>9、function语句</h3><p>在Javascript中定义一个函数，有两种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo() &#123; &#125;</div></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var foo = function () &#123; &#125;</div></pre></td></tr></table></figure>\n<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>\n<h3 id=\"10、基本数据类型的包装对象\"><a href=\"#10、基本数据类型的包装对象\" class=\"headerlink\" title=\"10、基本数据类型的包装对象\"></a>10、基本数据类型的包装对象</h3><p>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">new String(&quot;Hello World&quot;);</div><div class=\"line\">new Number(2000);</div><div class=\"line\">new Boolean(false);</div></pre></td></tr></table></figure>\n<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>\n<p>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</p>\n<h3 id=\"11、new语句\"><a href=\"#11、new语句\" class=\"headerlink\" title=\"11、new语句\"></a>11、new语句</h3><p>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。</p>\n<p>类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Cat = function (name) &#123;</div><div class=\"line\">　　this.name = name;</div><div class=\"line\">　　this.saying = &apos;meow&apos; ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，再生成一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var myCat = new Cat(&apos;mimi&apos;);</div></pre></td></tr></table></figure>\n<p>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>\n<p>Douglas Crockford给出了一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Object.beget = function (o) &#123;</div><div class=\"line\">　　var F = function (o) &#123;&#125;;</div><div class=\"line\">　　F.prototype = o ;</div><div class=\"line\">　　return new F;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>创建对象时就利用这个函数，对原型对象进行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Cat = &#123;</div><div class=\"line\">　　name:&apos;&apos;,</div><div class=\"line\">　　saying:&apos;meow&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\">var myCat = Object.beget(Cat);</div></pre></td></tr></table></figure>\n<p>对象生成后，可以自行对相关属性进行赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myCat.name = &apos;mimi&apos;;</div></pre></td></tr></table></figure>\n<h3 id=\"12、void\"><a href=\"#12、void\" class=\"headerlink\" title=\"12、void\"></a>12、void</h3><p>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">void 0; // undefined</div></pre></td></tr></table></figure>\n<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>\n","excerpt":"","more":"<h3 id=\"1、\"><a href=\"#1、\" class=\"headerlink\" title=\"1、==\"></a>1、==</h3><p>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">false == &apos;false&apos;</div><div class=\"line\">false == undefined</div><div class=\"line\">false == null</div><div class=\"line\">null == undefined</div><div class=\"line\">0 == &apos;&apos;</div></pre></td></tr></table></figure>\n<p>前三个是false，后两个是true。</p>\n<h3 id=\"2、with\"><a href=\"#2、with\" class=\"headerlink\" title=\"2、with\"></a>2、with</h3><p>with的本意是减少键盘输入。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">obj.a = obj.b;</div><div class=\"line\">obj.c = obj.d;</div></pre></td></tr></table></figure>\n<p>可以简写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">with(obj) &#123;</div><div class=\"line\">　　a = b;</div><div class=\"line\">　　c = d;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p>\n<h3 id=\"3、eval\"><a href=\"#3、eval\" class=\"headerlink\" title=\"3、eval\"></a>3、eval</h3><p>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>\n<p>eval能够做到的事情，不用它也能做到。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">eval(&quot;myValue = myObject.&quot; + myKey + &quot;;&quot;);</div></pre></td></tr></table></figure>\n<p>可以直接写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myValue = myObject[myKey];</div></pre></td></tr></table></figure>\n<p>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行</p>\n<h3 id=\"4、continue\"><a href=\"#4、continue\" class=\"headerlink\" title=\"4、continue\"></a>4、continue</h3><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>\n<h3 id=\"5、switch-贯穿\"><a href=\"#5、switch-贯穿\" class=\"headerlink\" title=\"5、switch 贯穿\"></a>5、switch 贯穿</h3><p>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">switch(n) &#123;</div><div class=\"line\">　　case 1:</div><div class=\"line\">　　case 2:</div><div class=\"line\">　　　　break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">switch(n) &#123;</div><div class=\"line\">　　case 1:</div><div class=\"line\">　　　　break;</div><div class=\"line\">　　case 2:</div><div class=\"line\">　　　　break;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"6、单行的块结构\"><a href=\"#6、单行的块结构\" class=\"headerlink\" title=\"6、单行的块结构\"></a>6、单行的块结构</h3><p>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok) t = true;</div></pre></td></tr></table></figure>\n<p>甚至写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok)</div><div class=\"line\">　　t = true;</div></pre></td></tr></table></figure>\n<p>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (ok)&#123;</div><div class=\"line\">　　t = true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"7、-和–\"><a href=\"#7、-和–\" class=\"headerlink\" title=\"7、++和–\"></a>7、++和–</h3><p>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>\n<h3 id=\"8、位运算符\"><a href=\"#8、位运算符\" class=\"headerlink\" title=\"8、位运算符\"></a>8、位运算符</h3><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。</p>\n<p>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p>\n<h3 id=\"9、function语句\"><a href=\"#9、function语句\" class=\"headerlink\" title=\"9、function语句\"></a>9、function语句</h3><p>在Javascript中定义一个函数，有两种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function foo() &#123; &#125;</div></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var foo = function () &#123; &#125;</div></pre></td></tr></table></figure>\n<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>\n<h3 id=\"10、基本数据类型的包装对象\"><a href=\"#10、基本数据类型的包装对象\" class=\"headerlink\" title=\"10、基本数据类型的包装对象\"></a>10、基本数据类型的包装对象</h3><p>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">new String(&quot;Hello World&quot;);</div><div class=\"line\">new Number(2000);</div><div class=\"line\">new Boolean(false);</div></pre></td></tr></table></figure>\n<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>\n<p>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</p>\n<h3 id=\"11、new语句\"><a href=\"#11、new语句\" class=\"headerlink\" title=\"11、new语句\"></a>11、new语句</h3><p>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。</p>\n<p>类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Cat = function (name) &#123;</div><div class=\"line\">　　this.name = name;</div><div class=\"line\">　　this.saying = &apos;meow&apos; ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后，再生成一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var myCat = new Cat(&apos;mimi&apos;);</div></pre></td></tr></table></figure>\n<p>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>\n<p>Douglas Crockford给出了一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Object.beget = function (o) &#123;</div><div class=\"line\">　　var F = function (o) &#123;&#125;;</div><div class=\"line\">　　F.prototype = o ;</div><div class=\"line\">　　return new F;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>创建对象时就利用这个函数，对原型对象进行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Cat = &#123;</div><div class=\"line\">　　name:&apos;&apos;,</div><div class=\"line\">　　saying:&apos;meow&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\">var myCat = Object.beget(Cat);</div></pre></td></tr></table></figure>\n<p>对象生成后，可以自行对相关属性进行赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myCat.name = &apos;mimi&apos;;</div></pre></td></tr></table></figure>\n<h3 id=\"12、void\"><a href=\"#12、void\" class=\"headerlink\" title=\"12、void\"></a>12、void</h3><p>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">void 0; // undefined</div></pre></td></tr></table></figure>\n<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>\n"},{"title":"200个纯CSS3写的图标","date":"2014-04-17T16:00:00.000Z","_content":"\n这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png)\n\n网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png)\n\n这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！\n\n传送门：[CSS3 Icons](http://www.uiplayground.in/css3-icons/)\n","source":"_posts/200个纯CSS3写的图标 支持复制代码.md","raw":"---\ntitle: 200个纯CSS3写的图标\ntags: [css]\ndate: 2014/04/18\n---\n\n这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png)\n\n网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png)\n\n这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！\n\n传送门：[CSS3 Icons](http://www.uiplayground.in/css3-icons/)\n","slug":"200个纯CSS3写的图标 支持复制代码","published":1,"updated":"2016-08-17T06:22:19.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphe000668ddtdmdq6ax","content":"<p>这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png\" target=\"_blank\" rel=\"external\">大图</a></p>\n<p>网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png\" target=\"_blank\" rel=\"external\">大图</a></p>\n<p>这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！</p>\n<p>传送门：<a href=\"http://www.uiplayground.in/css3-icons/\" target=\"_blank\" rel=\"external\">CSS3 Icons</a></p>\n","excerpt":"","more":"<p>这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png\">大图</a></p>\n<p>网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png\">大图</a></p>\n<p>这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！</p>\n<p>传送门：<a href=\"http://www.uiplayground.in/css3-icons/\">CSS3 Icons</a></p>\n"},{"title":"30行代码实现JavaScript中的MVC","date":"2016-02-14T16:00:00.000Z","_content":"\n从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。\n\n很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。\n\n这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。\n\n### 1. MVC的基础是观察者模式，这是实现model和view同步的关键\n\n为了简单起见，每个model实例中只包含一个primitive value值。\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    // model中的值改变时，应通知注册过的回调函数\n    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\n    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    // 注册监听的回调函数\n    this._listeners.push(listener);\n};\n// html代码：\n<div id=\"div1\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    var div1 = document.getElementById('div1');\n    model.watch(function (value) {\n        div1.innerHTML = value;\n    });\n    model.set('hello, this is a div');\n})();\n```\n\n借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？\n\n### 2. 实现bind方法，绑定model和view\n\n```\nModel.prototype.bind = function (node) {\n    // 将watch的逻辑和通用的回调函数放到这里\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\n// html代码：\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    model.bind(document.getElementById('div1'));\n    model.bind(document.getElementById('div2'));\n    model.set('this is a div');\n})();\n```\n\n通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？\n\n### 3. 实现controller，将绑定从逻辑代码中解耦\n\n细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。\n\n如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。\n\n```\nfunction Controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.querySelectorAll('[bind]');\n    // 将views处理为普通数组\n    views = Array.prototype.slice.call(views, 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelName] = models[modelName] || new Model();\n        // 完成该元素和指定model的绑定\n        models[modelName].bind(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n}\n// html:\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n// 逻辑代码：\nnew Controller(function (models) {\n    var model1 = models.model1;\n    model1.set('this is a div');\n});\n```\n\n就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。\n\n整理后去掉注释的”框架”代码：\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nModel.prototype.bind = function (node) {\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\nfunction Controller(callback) {\n    var models = {};\n    var views = Array.prototype.slice.call(document.querySelectorAll('[bind]'), 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        models[modelName] = models[modelName] || new Model();\n        models[modelName].bind(view);\n    });\n    callback.call(this, models);\n}\n```\n\n### 后记：\n\n笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。\n\n如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：\n\n1. 实现对input类标签的双向绑定\n2. 实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树\n3. 实现view层有关dom node隐藏/显示、创建/销毁的逻辑\n4. 集成virtual dom，增加dom diff的功能，提高渲染效率\n5. 提供依赖注入功能，实现控制反转\n6. 对innerHTML的赋值内容进行安全检查，防止恶意注入\n7. 实现model collection的逻辑，这里每个model只有一个值\n8. 利用es5中的setter改变set方法的实现，使得对model的修改更加简单\n9. 在view层中增加对属性和css的控制\n   10.支持类似AngularJS中双大括号的语法，只绑定部分html\n   ……\n\n一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈\n\n[转载地址](http://www.codeceo.com/article/30-line-javascript-mvc.html)\n","source":"_posts/30行代码实现JavaScript中的MVC.md","raw":"---\ntitle: 30行代码实现JavaScript中的MVC\ntags: [javascript]\ndate: 2016/02/15\n---\n\n从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。\n\n很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。\n\n这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。\n\n### 1. MVC的基础是观察者模式，这是实现model和view同步的关键\n\n为了简单起见，每个model实例中只包含一个primitive value值。\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    // model中的值改变时，应通知注册过的回调函数\n    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\n    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    // 注册监听的回调函数\n    this._listeners.push(listener);\n};\n// html代码：\n<div id=\"div1\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    var div1 = document.getElementById('div1');\n    model.watch(function (value) {\n        div1.innerHTML = value;\n    });\n    model.set('hello, this is a div');\n})();\n```\n\n借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？\n\n### 2. 实现bind方法，绑定model和view\n\n```\nModel.prototype.bind = function (node) {\n    // 将watch的逻辑和通用的回调函数放到这里\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\n// html代码：\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    model.bind(document.getElementById('div1'));\n    model.bind(document.getElementById('div2'));\n    model.set('this is a div');\n})();\n```\n\n通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？\n\n### 3. 实现controller，将绑定从逻辑代码中解耦\n\n细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。\n\n如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。\n\n```\nfunction Controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.querySelectorAll('[bind]');\n    // 将views处理为普通数组\n    views = Array.prototype.slice.call(views, 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelName] = models[modelName] || new Model();\n        // 完成该元素和指定model的绑定\n        models[modelName].bind(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n}\n// html:\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n// 逻辑代码：\nnew Controller(function (models) {\n    var model1 = models.model1;\n    model1.set('this is a div');\n});\n```\n\n就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。\n\n整理后去掉注释的”框架”代码：\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nModel.prototype.bind = function (node) {\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\nfunction Controller(callback) {\n    var models = {};\n    var views = Array.prototype.slice.call(document.querySelectorAll('[bind]'), 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        models[modelName] = models[modelName] || new Model();\n        models[modelName].bind(view);\n    });\n    callback.call(this, models);\n}\n```\n\n### 后记：\n\n笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。\n\n如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：\n\n1. 实现对input类标签的双向绑定\n2. 实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树\n3. 实现view层有关dom node隐藏/显示、创建/销毁的逻辑\n4. 集成virtual dom，增加dom diff的功能，提高渲染效率\n5. 提供依赖注入功能，实现控制反转\n6. 对innerHTML的赋值内容进行安全检查，防止恶意注入\n7. 实现model collection的逻辑，这里每个model只有一个值\n8. 利用es5中的setter改变set方法的实现，使得对model的修改更加简单\n9. 在view层中增加对属性和css的控制\n   10.支持类似AngularJS中双大括号的语法，只绑定部分html\n   ……\n\n一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈\n\n[转载地址](http://www.codeceo.com/article/30-line-javascript-mvc.html)\n","slug":"30行代码实现JavaScript中的MVC","published":1,"updated":"2016-08-17T06:22:19.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphi000868ddshlqbzst","content":"<p>从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。</p>\n<p>很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。</p>\n<p>这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。</p>\n<h3 id=\"1-MVC的基础是观察者模式，这是实现model和view同步的关键\"><a href=\"#1-MVC的基础是观察者模式，这是实现model和view同步的关键\" class=\"headerlink\" title=\"1. MVC的基础是观察者模式，这是实现model和view同步的关键\"></a>1. MVC的基础是观察者模式，这是实现model和view同步的关键</h3><p>为了简单起见，每个model实例中只包含一个primitive value值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Model(value) &#123;</div><div class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class=\"line\">    this._listeners = [];</div><div class=\"line\">&#125;</div><div class=\"line\">Model.prototype.set = function (value) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    self._value = value;</div><div class=\"line\">    // model中的值改变时，应通知注册过的回调函数</div><div class=\"line\">    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数</div><div class=\"line\">    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame</div><div class=\"line\">    setTimeout(function () &#123;</div><div class=\"line\">        self._listeners.forEach(function (listener) &#123;</div><div class=\"line\">            listener.call(self, value);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.watch = function (listener) &#123;</div><div class=\"line\">    // 注册监听的回调函数</div><div class=\"line\">    this._listeners.push(listener);</div><div class=\"line\">&#125;;</div><div class=\"line\">// html代码：</div><div class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var model = new Model();</div><div class=\"line\">    var div1 = document.getElementById(&apos;div1&apos;);</div><div class=\"line\">    model.watch(function (value) &#123;</div><div class=\"line\">        div1.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    model.set(&apos;hello, this is a div&apos;);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？</p>\n<h3 id=\"2-实现bind方法，绑定model和view\"><a href=\"#2-实现bind方法，绑定model和view\" class=\"headerlink\" title=\"2. 实现bind方法，绑定model和view\"></a>2. 实现bind方法，绑定model和view</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Model.prototype.bind = function (node) &#123;</div><div class=\"line\">    // 将watch的逻辑和通用的回调函数放到这里</div><div class=\"line\">    this.watch(function (value) &#123;</div><div class=\"line\">        node.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">// html代码：</div><div class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var model = new Model();</div><div class=\"line\">    model.bind(document.getElementById(&apos;div1&apos;));</div><div class=\"line\">    model.bind(document.getElementById(&apos;div2&apos;));</div><div class=\"line\">    model.set(&apos;this is a div&apos;);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？</p>\n<h3 id=\"3-实现controller，将绑定从逻辑代码中解耦\"><a href=\"#3-实现controller，将绑定从逻辑代码中解耦\" class=\"headerlink\" title=\"3. 实现controller，将绑定从逻辑代码中解耦\"></a>3. 实现controller，将绑定从逻辑代码中解耦</h3><p>细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。</p>\n<p>如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Controller(callback) &#123;</div><div class=\"line\">    var models = &#123;&#125;;</div><div class=\"line\">    // 找到所有有bind属性的元素</div><div class=\"line\">    var views = document.querySelectorAll(&apos;[bind]&apos;);</div><div class=\"line\">    // 将views处理为普通数组</div><div class=\"line\">    views = Array.prototype.slice.call(views, 0);</div><div class=\"line\">    views.forEach(function (view) &#123;</div><div class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</div><div class=\"line\">        // 取出或新建该元素所绑定的model</div><div class=\"line\">        models[modelName] = models[modelName] || new Model();</div><div class=\"line\">        // 完成该元素和指定model的绑定</div><div class=\"line\">        models[modelName].bind(view);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    // 调用controller的具体逻辑，将models传入，方便业务处理</div><div class=\"line\">    callback.call(this, models);</div><div class=\"line\">&#125;</div><div class=\"line\">// html:</div><div class=\"line\">&lt;div id=&quot;div1&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;div2&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">new Controller(function (models) &#123;</div><div class=\"line\">    var model1 = models.model1;</div><div class=\"line\">    model1.set(&apos;this is a div&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。</p>\n<p>整理后去掉注释的”框架”代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Model(value) &#123;</div><div class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class=\"line\">    this._listeners = [];</div><div class=\"line\">&#125;</div><div class=\"line\">Model.prototype.set = function (value) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    self._value = value;</div><div class=\"line\">    setTimeout(function () &#123;</div><div class=\"line\">        self._listeners.forEach(function (listener) &#123;</div><div class=\"line\">            listener.call(self, value);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.watch = function (listener) &#123;</div><div class=\"line\">    this._listeners.push(listener);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.bind = function (node) &#123;</div><div class=\"line\">    this.watch(function (value) &#123;</div><div class=\"line\">        node.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Controller(callback) &#123;</div><div class=\"line\">    var models = &#123;&#125;;</div><div class=\"line\">    var views = Array.prototype.slice.call(document.querySelectorAll(&apos;[bind]&apos;), 0);</div><div class=\"line\">    views.forEach(function (view) &#123;</div><div class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</div><div class=\"line\">        models[modelName] = models[modelName] || new Model();</div><div class=\"line\">        models[modelName].bind(view);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    callback.call(this, models);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h3><p>笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。</p>\n<p>如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：</p>\n<ol>\n<li>实现对input类标签的双向绑定</li>\n<li>实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树</li>\n<li>实现view层有关dom node隐藏/显示、创建/销毁的逻辑</li>\n<li>集成virtual dom，增加dom diff的功能，提高渲染效率</li>\n<li>提供依赖注入功能，实现控制反转</li>\n<li>对innerHTML的赋值内容进行安全检查，防止恶意注入</li>\n<li>实现model collection的逻辑，这里每个model只有一个值</li>\n<li>利用es5中的setter改变set方法的实现，使得对model的修改更加简单</li>\n<li>在view层中增加对属性和css的控制<br>10.支持类似AngularJS中双大括号的语法，只绑定部分html<br>……</li>\n</ol>\n<p>一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈</p>\n<p><a href=\"http://www.codeceo.com/article/30-line-javascript-mvc.html\" target=\"_blank\" rel=\"external\">转载地址</a></p>\n","excerpt":"","more":"<p>从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。</p>\n<p>很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。</p>\n<p>这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。</p>\n<h3 id=\"1-MVC的基础是观察者模式，这是实现model和view同步的关键\"><a href=\"#1-MVC的基础是观察者模式，这是实现model和view同步的关键\" class=\"headerlink\" title=\"1. MVC的基础是观察者模式，这是实现model和view同步的关键\"></a>1. MVC的基础是观察者模式，这是实现model和view同步的关键</h3><p>为了简单起见，每个model实例中只包含一个primitive value值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Model(value) &#123;</div><div class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class=\"line\">    this._listeners = [];</div><div class=\"line\">&#125;</div><div class=\"line\">Model.prototype.set = function (value) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    self._value = value;</div><div class=\"line\">    // model中的值改变时，应通知注册过的回调函数</div><div class=\"line\">    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数</div><div class=\"line\">    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame</div><div class=\"line\">    setTimeout(function () &#123;</div><div class=\"line\">        self._listeners.forEach(function (listener) &#123;</div><div class=\"line\">            listener.call(self, value);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.watch = function (listener) &#123;</div><div class=\"line\">    // 注册监听的回调函数</div><div class=\"line\">    this._listeners.push(listener);</div><div class=\"line\">&#125;;</div><div class=\"line\">// html代码：</div><div class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var model = new Model();</div><div class=\"line\">    var div1 = document.getElementById(&apos;div1&apos;);</div><div class=\"line\">    model.watch(function (value) &#123;</div><div class=\"line\">        div1.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    model.set(&apos;hello, this is a div&apos;);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？</p>\n<h3 id=\"2-实现bind方法，绑定model和view\"><a href=\"#2-实现bind方法，绑定model和view\" class=\"headerlink\" title=\"2. 实现bind方法，绑定model和view\"></a>2. 实现bind方法，绑定model和view</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Model.prototype.bind = function (node) &#123;</div><div class=\"line\">    // 将watch的逻辑和通用的回调函数放到这里</div><div class=\"line\">    this.watch(function (value) &#123;</div><div class=\"line\">        node.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">// html代码：</div><div class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">(function () &#123;</div><div class=\"line\">    var model = new Model();</div><div class=\"line\">    model.bind(document.getElementById(&apos;div1&apos;));</div><div class=\"line\">    model.bind(document.getElementById(&apos;div2&apos;));</div><div class=\"line\">    model.set(&apos;this is a div&apos;);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？</p>\n<h3 id=\"3-实现controller，将绑定从逻辑代码中解耦\"><a href=\"#3-实现controller，将绑定从逻辑代码中解耦\" class=\"headerlink\" title=\"3. 实现controller，将绑定从逻辑代码中解耦\"></a>3. 实现controller，将绑定从逻辑代码中解耦</h3><p>细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。</p>\n<p>如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Controller(callback) &#123;</div><div class=\"line\">    var models = &#123;&#125;;</div><div class=\"line\">    // 找到所有有bind属性的元素</div><div class=\"line\">    var views = document.querySelectorAll(&apos;[bind]&apos;);</div><div class=\"line\">    // 将views处理为普通数组</div><div class=\"line\">    views = Array.prototype.slice.call(views, 0);</div><div class=\"line\">    views.forEach(function (view) &#123;</div><div class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</div><div class=\"line\">        // 取出或新建该元素所绑定的model</div><div class=\"line\">        models[modelName] = models[modelName] || new Model();</div><div class=\"line\">        // 完成该元素和指定model的绑定</div><div class=\"line\">        models[modelName].bind(view);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    // 调用controller的具体逻辑，将models传入，方便业务处理</div><div class=\"line\">    callback.call(this, models);</div><div class=\"line\">&#125;</div><div class=\"line\">// html:</div><div class=\"line\">&lt;div id=&quot;div1&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;div2&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</div><div class=\"line\">// 逻辑代码：</div><div class=\"line\">new Controller(function (models) &#123;</div><div class=\"line\">    var model1 = models.model1;</div><div class=\"line\">    model1.set(&apos;this is a div&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。</p>\n<p>整理后去掉注释的”框架”代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Model(value) &#123;</div><div class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</div><div class=\"line\">    this._listeners = [];</div><div class=\"line\">&#125;</div><div class=\"line\">Model.prototype.set = function (value) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    self._value = value;</div><div class=\"line\">    setTimeout(function () &#123;</div><div class=\"line\">        self._listeners.forEach(function (listener) &#123;</div><div class=\"line\">            listener.call(self, value);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.watch = function (listener) &#123;</div><div class=\"line\">    this._listeners.push(listener);</div><div class=\"line\">&#125;;</div><div class=\"line\">Model.prototype.bind = function (node) &#123;</div><div class=\"line\">    this.watch(function (value) &#123;</div><div class=\"line\">        node.innerHTML = value;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div><div class=\"line\">function Controller(callback) &#123;</div><div class=\"line\">    var models = &#123;&#125;;</div><div class=\"line\">    var views = Array.prototype.slice.call(document.querySelectorAll(&apos;[bind]&apos;), 0);</div><div class=\"line\">    views.forEach(function (view) &#123;</div><div class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</div><div class=\"line\">        models[modelName] = models[modelName] || new Model();</div><div class=\"line\">        models[modelName].bind(view);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    callback.call(this, models);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h3><p>笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。</p>\n<p>如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：</p>\n<ol>\n<li>实现对input类标签的双向绑定</li>\n<li>实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树</li>\n<li>实现view层有关dom node隐藏/显示、创建/销毁的逻辑</li>\n<li>集成virtual dom，增加dom diff的功能，提高渲染效率</li>\n<li>提供依赖注入功能，实现控制反转</li>\n<li>对innerHTML的赋值内容进行安全检查，防止恶意注入</li>\n<li>实现model collection的逻辑，这里每个model只有一个值</li>\n<li>利用es5中的setter改变set方法的实现，使得对model的修改更加简单</li>\n<li>在view层中增加对属性和css的控制<br>10.支持类似AngularJS中双大括号的语法，只绑定部分html<br>……</li>\n</ol>\n<p>一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈</p>\n<p><a href=\"http://www.codeceo.com/article/30-line-javascript-mvc.html\">转载地址</a></p>\n"},{"title":"59条令人捧腹但真实的程序员编程语录","date":"2016-07-12T02:18:37.000Z","_content":"\n### 软件开发人员和程序员语录\n\n1.A good programmer is someone who always looks both ways before crossing a one-way street. (Doug Linder)\n\n好的程序员即使在过单行道时也总是会环顾两边。\n\n2.Don’t worry if it doesn’t work right. If everything did, you’d be out of a job. (Mosher’s Law of Software Engineering)\n\n不要担心它能否正常工作。如果一切正常，那么你就会失去工作。\n\n3.The trouble with programmers is that you can never tell what a programmer is doing until it’s too late. (Seymour Cray)\n\n程序员的烦恼是，你永远无法知道一个程序员在做什么，直到为时已晚。\n\n4.Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. (Larry Wall)\n\n程序员的美德：懒惰，没有耐心以及老子天下第一。\n\n5.Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)\n\n写代码的时候总是想象维护你代码的家伙是一个知道你住在哪里的暴力精神病患者。\n\n6.One man’s crappy software is another man’s full time job. (Jessica Gaston)\n\n一个人写的烂软件将会给另一个人带来一份全职工作。\n\n7.If builders built buildings the way programmers wrote programs, then the first woodpecker that came along wound destroy civilization. (Gerald Weinberg)\n\n如果建筑工人用程序员写程序的方式建造建筑物，那么来的第一只啄木鸟（找bug）就将摧毁文明。\n\n8.The most likely way for the world to be destroyed, most experts agree, is by accident.  That’s where we come in; we’re computer professionals. We cause accidents. (Nathaniel Borenstein)\n\n大多数专家认为，世界被破坏的最有可能的方式是，是因为偶然。那就是我们所要进入的领域：我们是计算机专家。我们制造偶然。\n\n9.It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes. (Keith  Braithwaite)\n\n这是我们这个行业的一件咄咄怪事：我们不仅不从错误中学习，我们也不从成功中学习。\n\n10.Once a new technology starts rolling, if you’re not part of the steamroller, you’re part of the road. (Stewart Brand)\n\n一旦一种新技术开始滚动碾压道路，如果你不能成为压路机的一部分，那么你就只能成为道路的一部分。\n\n11.If at first you don’t succeed, call it version 1.0 (unknown)\n\n如果第一次你没有成功，那么称之为1.0版，继续加油。\n\n12.All programmers are playwrights and all computers are lousy actors. (Anonymous Hack Actor)\n\n所有的程序员都剧作家，而所有计算机都是糟糕的演员。\n\n13.The sooner you get behind in your work, the more time you have to catch up. (Anonymous Scheduler)\n\n工作拉下得越早，赶上去所需要的时间越多。\n\n14.When a programming language is created that allows programmers to program in simple English, it will be discovered that programmers cannot speak English. (Anonymous Linguist)\n\n当创建一种编程语言允许程序员使用简单英语编程的时候，那么新问题又来了，你会发现程序员不说英语。\n\n15.Why do we never have time to do it right, but always have time to do it over? (Anonymous)\n\n为什么我们总是没有时间把事情做对，却有时间做完它？\n\n16.Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\n\n傻瓜写计算机能理解的代码。优秀的程序员写人类能读懂的代码。\n\n17.Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else. (Eagleson’s law)\n\n自己的代码六个月或更久不见，还不如别人写的代码。\n\n### 编程/软件开发语录\n\n1.Measuring programming progress by lines of code is like measuring aircraft building progress by weight. (Bill Gates)\n\n通过代码行数衡量开发进程就好比用重量来衡量飞机制造进度。\n\n2.Programming is like sex. One mistake and you have to support it for the rest of your life. (Michael Sinz)\n\n编程就像性爱一样。一个错误就能绑住你的余生。\n\n3.Walking on water and developing software from a specification are easy if both are frozen. (Edward V Berard)\n\n在目的明确的基础上开发软件就像在结冰的水上行走一样简单。\n\n4.The first 90 percent of the code accounts for the first 90 percent of the development time…The remaining 10 percent of the code accounts for the other 90 percent of the development time.(Tom Cargill)\n\n开始90％的代码占开始90％的开发时间……剩下10％的代码还是占90％的开发时间。\n\n5.Commenting your code is like cleaning your bathroom — you never want to do it, but it really does create a more pleasant experience for you and your guests. (Ryan Campbell)\n\n注释代码就像是清洁浴室——尽管你满心不情愿，但它确实可以为你和你的客人创造一种更舒适的体验。\n\n6.Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. (Rick Cook)\n\n当今的编程是软件工程师——努力建设更大多更好的傻瓜式程序，和上帝——试图产出更大多更好的傻瓜之间的竞争。到目前为止，世上帝是获胜者。\n\n7.The hardest part of design … is keeping features out. (Donald Norman)\n\n设计中最难的部分……是阻止功能。\n\n8.In order to understand recursion, one must first understand recursion. (Anonymous)\n\n要想了解递归，首先必须理解递归。\n\n9.There are only two kinds of programming languages: those people always bitch about and those nobody uses. (Bjarne Stroustrup)\n\n只有两种编程语言：一种是天天挨骂的，另一种是没人用的。\n\n10.The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)\n\n关于布尔值最妙的一点是，就算你错了，你也只是错了这一处而已。\n\n11.If Java had true garbage collection, most programs would delete themselves upon execution. (Robert Swell)\n\n如果Java真的有垃圾收集，那么大多数程序会执行自我删除。\n\n12.In theory, there is no difference between theory and practice. But, in practice, there is. (Jan L. A. van de Snepscheut)\n\n理论上看，理论和实践之间是没有差别的。但是，在实践中，有。\n\n13.Ready, fire, aim: the fast approach to software development. Ready, aim, aim, aim, aim: the slow approach to software development. (Anonymous)\n\n准备，开火，瞄准：快速的软件开发方法。准备，瞄准，瞄准，瞄准，瞄准：缓慢的软件开发方法。\n\n14.Programming is 10% science, 20% ingenuity, and 70% getting the ingenuity to work with the science. (Anonymous)\n\n编程就是10％的科学，20％得的独创性，再加70％和这门科学的灵巧合作。\n\n15.It is easier to measure something than to understand what you have measured. (Anonymous)\n\n衡量比理解你衡量了什么容易。\n\n16.Benchmarks don’t lie, but liars do benchmarks. (Anonymous)\n\n基准不会撒谎，但制定基准的人会撒谎。\n\n17.Better train people and risk they leave – than do nothing and risk they stay. (Anonymous)\n\n就算是培训好的员工离开——也好过他们什么也不做却留下来。\n\n18.The goal of Computer Science is to build something that will last at least until we’ve finished building it. (Anonymous)\n\n计算机科学的目标是构建一个至少能持续到我们构建完成的东西。\n\n19.Java is to JavaScript what Car is to Carpet.  (Chris Heilmann)\n\nJava之于JavaScript就像car之于carpet（地毯）。后者看上去像是前者的衍生物，实则是完全不同的两个东西。\n\n20.It’s not at all important to get it right the first time. It’s vitally important to get it right the last time. (Andrew Hunt and David Thomas)\n\n第一次是否正确完成一点也不重要。最后一次正确完成才至关重要。\n\n21.Should array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration. (Stan Kelly-Bootle)\n\n数组的下标一定要从0或1开始吗？我认为，我采取的中间值0.5没有经过适当考虑就被驳回了。\n\n22.Programs must be written for people to read, and only incidentally for machines to execute. (Abelson / Sussman)\n\n程序必须写得能供人阅读，机器执行只是附带。\n\n23.Programming can be fun, so can cryptography; however they should not be combined. (Kreitzberg and Shneiderman)\n\n编程可以很有趣，密码学也是如此；但是两者不应该搅和在一起。\n\n24.Copy and paste is a design error.  (David Parnas)\n\n复制粘贴是一个设计错误。\n\n25.Computers are good at following instructions, but not at reading your mind. (Donald Knuth)\n\n计算机善于遵循指令，不善于读取你的想法。\n\n### 软件调试语录\n\n1.Deleted code is debugged code. (Jeff Sickel)\n\n删除的代码是经过调试的代码。\n\n2.If debugging is the process of removing software bugs, then programming must be the process of putting them in. (Edsger Dijkstra)\n\n如果调试是消除软件bug的过程，那么编程就是产出bug的过程。\n\n3.Debugging is twice as hard as writing the code in the first place.  Therefore, if you write the code as cleverly as possible, you are–by definition–not smart enough to debug it.\n\n调试一段程序的难度是写出这段程序的难度的两倍，因此，如果你的代码尽可能清楚的话，那么你就不用费力地调试它。\n\n4.It’s hard enough to find an error in your code when you’re looking for it; it’s even harder when you’ve assumed your code is error-free. (Steve McConnel)\n\n你的目的是找bug的时候，bug已经很难找了；更不要说当你认为自己的代码中没有错误的时候。\n\n### 软件bug语录\n\n1.It’s not a bug – it’s an undocumented feature. (Anonymous)\n\n这不是bug——这是没有被证明的功能。\n\n2.Without requirements or design, programming is the art of adding bugs to an empty text file. (Louis Srygley)\n\n如果没有需求和设计，那么编程就是添加bug到空的文本文件的艺术。\n\n3.Bad code isn’t bad, its just misunderstood. (Anonymous Code Behaviorist)\n\n所谓坏的代码并不坏，它只是被误解了。\n\n4.There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)\n\n写没有错误的程序有两种方式；但第三种才有效。\n\n5.Beware of bugs in the above code; I have only proved it correct, not tried it. (Donald Knuth)\n\n小心上面代码中的bug；我只证明了它是正确的，还没有尝试过。\n\n### 软件/终端产品语录\n\n1.Before software can be reusable it first has to be usable. (Ralph Johnson)\n\n在软件可以被可重复使用前，它首先必须是可用的。\n\n2.Software undergoes beta testing shortly before it’s released. Beta is Latin for “still doesn’t work”. (Anonymous)\n\n软件在发布前要经过beta测试。beta即拉丁语“仍然无法正常工作”的意思。\n\n3.The best performance improvement is the transition from the nonworking state to the working state. (J. Osterhout)\n\n最佳性能改进是指从不可工作状态向工作状态的转变。\n\n4.The cheapest, fastest, and most reliable components are those that aren’t there. (Gordon Bell)\n\n最便宜，最快和最可靠的组件是不存在的。\n\n5.I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)\n\n我认为微软命名.Net，它就不会在Unix目录列表显示出来。\n\n6.Software and cathedrals are much the same – first we build them, then we pray. (Sam Redwine)\n\n软件和教堂非常相似——首先，我们建造它们，然后我们祈祷。\n\n7.The software isn’t finished until the last user is dead. (Anonymous)\n\n直到最后一个用户死去，软件才算完成。\n\n8.Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves. (Alan Kay)\n\n现在的大多数软件非常像埃及金字塔，在彼此之间堆建了成千上万的砖块，缺乏结构完整性，只是靠蛮力和成千上万的奴隶完成。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html)\n译文链接：[http://www.codeceo.com](http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html)\n英文原文：59 Hilarious but True Programming Quotes for Software Developers","source":"_posts/59条令人捧腹但真实的程序员编程语录.md","raw":"---\ntitle: 59条令人捧腹但真实的程序员编程语录\ndate: 2016-07-12 10:18:37\ntags: [other]\n---\n\n### 软件开发人员和程序员语录\n\n1.A good programmer is someone who always looks both ways before crossing a one-way street. (Doug Linder)\n\n好的程序员即使在过单行道时也总是会环顾两边。\n\n2.Don’t worry if it doesn’t work right. If everything did, you’d be out of a job. (Mosher’s Law of Software Engineering)\n\n不要担心它能否正常工作。如果一切正常，那么你就会失去工作。\n\n3.The trouble with programmers is that you can never tell what a programmer is doing until it’s too late. (Seymour Cray)\n\n程序员的烦恼是，你永远无法知道一个程序员在做什么，直到为时已晚。\n\n4.Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. (Larry Wall)\n\n程序员的美德：懒惰，没有耐心以及老子天下第一。\n\n5.Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)\n\n写代码的时候总是想象维护你代码的家伙是一个知道你住在哪里的暴力精神病患者。\n\n6.One man’s crappy software is another man’s full time job. (Jessica Gaston)\n\n一个人写的烂软件将会给另一个人带来一份全职工作。\n\n7.If builders built buildings the way programmers wrote programs, then the first woodpecker that came along wound destroy civilization. (Gerald Weinberg)\n\n如果建筑工人用程序员写程序的方式建造建筑物，那么来的第一只啄木鸟（找bug）就将摧毁文明。\n\n8.The most likely way for the world to be destroyed, most experts agree, is by accident.  That’s where we come in; we’re computer professionals. We cause accidents. (Nathaniel Borenstein)\n\n大多数专家认为，世界被破坏的最有可能的方式是，是因为偶然。那就是我们所要进入的领域：我们是计算机专家。我们制造偶然。\n\n9.It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes. (Keith  Braithwaite)\n\n这是我们这个行业的一件咄咄怪事：我们不仅不从错误中学习，我们也不从成功中学习。\n\n10.Once a new technology starts rolling, if you’re not part of the steamroller, you’re part of the road. (Stewart Brand)\n\n一旦一种新技术开始滚动碾压道路，如果你不能成为压路机的一部分，那么你就只能成为道路的一部分。\n\n11.If at first you don’t succeed, call it version 1.0 (unknown)\n\n如果第一次你没有成功，那么称之为1.0版，继续加油。\n\n12.All programmers are playwrights and all computers are lousy actors. (Anonymous Hack Actor)\n\n所有的程序员都剧作家，而所有计算机都是糟糕的演员。\n\n13.The sooner you get behind in your work, the more time you have to catch up. (Anonymous Scheduler)\n\n工作拉下得越早，赶上去所需要的时间越多。\n\n14.When a programming language is created that allows programmers to program in simple English, it will be discovered that programmers cannot speak English. (Anonymous Linguist)\n\n当创建一种编程语言允许程序员使用简单英语编程的时候，那么新问题又来了，你会发现程序员不说英语。\n\n15.Why do we never have time to do it right, but always have time to do it over? (Anonymous)\n\n为什么我们总是没有时间把事情做对，却有时间做完它？\n\n16.Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\n\n傻瓜写计算机能理解的代码。优秀的程序员写人类能读懂的代码。\n\n17.Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else. (Eagleson’s law)\n\n自己的代码六个月或更久不见，还不如别人写的代码。\n\n### 编程/软件开发语录\n\n1.Measuring programming progress by lines of code is like measuring aircraft building progress by weight. (Bill Gates)\n\n通过代码行数衡量开发进程就好比用重量来衡量飞机制造进度。\n\n2.Programming is like sex. One mistake and you have to support it for the rest of your life. (Michael Sinz)\n\n编程就像性爱一样。一个错误就能绑住你的余生。\n\n3.Walking on water and developing software from a specification are easy if both are frozen. (Edward V Berard)\n\n在目的明确的基础上开发软件就像在结冰的水上行走一样简单。\n\n4.The first 90 percent of the code accounts for the first 90 percent of the development time…The remaining 10 percent of the code accounts for the other 90 percent of the development time.(Tom Cargill)\n\n开始90％的代码占开始90％的开发时间……剩下10％的代码还是占90％的开发时间。\n\n5.Commenting your code is like cleaning your bathroom — you never want to do it, but it really does create a more pleasant experience for you and your guests. (Ryan Campbell)\n\n注释代码就像是清洁浴室——尽管你满心不情愿，但它确实可以为你和你的客人创造一种更舒适的体验。\n\n6.Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. (Rick Cook)\n\n当今的编程是软件工程师——努力建设更大多更好的傻瓜式程序，和上帝——试图产出更大多更好的傻瓜之间的竞争。到目前为止，世上帝是获胜者。\n\n7.The hardest part of design … is keeping features out. (Donald Norman)\n\n设计中最难的部分……是阻止功能。\n\n8.In order to understand recursion, one must first understand recursion. (Anonymous)\n\n要想了解递归，首先必须理解递归。\n\n9.There are only two kinds of programming languages: those people always bitch about and those nobody uses. (Bjarne Stroustrup)\n\n只有两种编程语言：一种是天天挨骂的，另一种是没人用的。\n\n10.The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)\n\n关于布尔值最妙的一点是，就算你错了，你也只是错了这一处而已。\n\n11.If Java had true garbage collection, most programs would delete themselves upon execution. (Robert Swell)\n\n如果Java真的有垃圾收集，那么大多数程序会执行自我删除。\n\n12.In theory, there is no difference between theory and practice. But, in practice, there is. (Jan L. A. van de Snepscheut)\n\n理论上看，理论和实践之间是没有差别的。但是，在实践中，有。\n\n13.Ready, fire, aim: the fast approach to software development. Ready, aim, aim, aim, aim: the slow approach to software development. (Anonymous)\n\n准备，开火，瞄准：快速的软件开发方法。准备，瞄准，瞄准，瞄准，瞄准：缓慢的软件开发方法。\n\n14.Programming is 10% science, 20% ingenuity, and 70% getting the ingenuity to work with the science. (Anonymous)\n\n编程就是10％的科学，20％得的独创性，再加70％和这门科学的灵巧合作。\n\n15.It is easier to measure something than to understand what you have measured. (Anonymous)\n\n衡量比理解你衡量了什么容易。\n\n16.Benchmarks don’t lie, but liars do benchmarks. (Anonymous)\n\n基准不会撒谎，但制定基准的人会撒谎。\n\n17.Better train people and risk they leave – than do nothing and risk they stay. (Anonymous)\n\n就算是培训好的员工离开——也好过他们什么也不做却留下来。\n\n18.The goal of Computer Science is to build something that will last at least until we’ve finished building it. (Anonymous)\n\n计算机科学的目标是构建一个至少能持续到我们构建完成的东西。\n\n19.Java is to JavaScript what Car is to Carpet.  (Chris Heilmann)\n\nJava之于JavaScript就像car之于carpet（地毯）。后者看上去像是前者的衍生物，实则是完全不同的两个东西。\n\n20.It’s not at all important to get it right the first time. It’s vitally important to get it right the last time. (Andrew Hunt and David Thomas)\n\n第一次是否正确完成一点也不重要。最后一次正确完成才至关重要。\n\n21.Should array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration. (Stan Kelly-Bootle)\n\n数组的下标一定要从0或1开始吗？我认为，我采取的中间值0.5没有经过适当考虑就被驳回了。\n\n22.Programs must be written for people to read, and only incidentally for machines to execute. (Abelson / Sussman)\n\n程序必须写得能供人阅读，机器执行只是附带。\n\n23.Programming can be fun, so can cryptography; however they should not be combined. (Kreitzberg and Shneiderman)\n\n编程可以很有趣，密码学也是如此；但是两者不应该搅和在一起。\n\n24.Copy and paste is a design error.  (David Parnas)\n\n复制粘贴是一个设计错误。\n\n25.Computers are good at following instructions, but not at reading your mind. (Donald Knuth)\n\n计算机善于遵循指令，不善于读取你的想法。\n\n### 软件调试语录\n\n1.Deleted code is debugged code. (Jeff Sickel)\n\n删除的代码是经过调试的代码。\n\n2.If debugging is the process of removing software bugs, then programming must be the process of putting them in. (Edsger Dijkstra)\n\n如果调试是消除软件bug的过程，那么编程就是产出bug的过程。\n\n3.Debugging is twice as hard as writing the code in the first place.  Therefore, if you write the code as cleverly as possible, you are–by definition–not smart enough to debug it.\n\n调试一段程序的难度是写出这段程序的难度的两倍，因此，如果你的代码尽可能清楚的话，那么你就不用费力地调试它。\n\n4.It’s hard enough to find an error in your code when you’re looking for it; it’s even harder when you’ve assumed your code is error-free. (Steve McConnel)\n\n你的目的是找bug的时候，bug已经很难找了；更不要说当你认为自己的代码中没有错误的时候。\n\n### 软件bug语录\n\n1.It’s not a bug – it’s an undocumented feature. (Anonymous)\n\n这不是bug——这是没有被证明的功能。\n\n2.Without requirements or design, programming is the art of adding bugs to an empty text file. (Louis Srygley)\n\n如果没有需求和设计，那么编程就是添加bug到空的文本文件的艺术。\n\n3.Bad code isn’t bad, its just misunderstood. (Anonymous Code Behaviorist)\n\n所谓坏的代码并不坏，它只是被误解了。\n\n4.There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)\n\n写没有错误的程序有两种方式；但第三种才有效。\n\n5.Beware of bugs in the above code; I have only proved it correct, not tried it. (Donald Knuth)\n\n小心上面代码中的bug；我只证明了它是正确的，还没有尝试过。\n\n### 软件/终端产品语录\n\n1.Before software can be reusable it first has to be usable. (Ralph Johnson)\n\n在软件可以被可重复使用前，它首先必须是可用的。\n\n2.Software undergoes beta testing shortly before it’s released. Beta is Latin for “still doesn’t work”. (Anonymous)\n\n软件在发布前要经过beta测试。beta即拉丁语“仍然无法正常工作”的意思。\n\n3.The best performance improvement is the transition from the nonworking state to the working state. (J. Osterhout)\n\n最佳性能改进是指从不可工作状态向工作状态的转变。\n\n4.The cheapest, fastest, and most reliable components are those that aren’t there. (Gordon Bell)\n\n最便宜，最快和最可靠的组件是不存在的。\n\n5.I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)\n\n我认为微软命名.Net，它就不会在Unix目录列表显示出来。\n\n6.Software and cathedrals are much the same – first we build them, then we pray. (Sam Redwine)\n\n软件和教堂非常相似——首先，我们建造它们，然后我们祈祷。\n\n7.The software isn’t finished until the last user is dead. (Anonymous)\n\n直到最后一个用户死去，软件才算完成。\n\n8.Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves. (Alan Kay)\n\n现在的大多数软件非常像埃及金字塔，在彼此之间堆建了成千上万的砖块，缺乏结构完整性，只是靠蛮力和成千上万的奴隶完成。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html)\n译文链接：[http://www.codeceo.com](http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html)\n英文原文：59 Hilarious but True Programming Quotes for Software Developers","slug":"59条令人捧腹但真实的程序员编程语录","published":1,"updated":"2016-08-17T06:22:19.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphk000968dddht4l9b1","content":"<h3 id=\"软件开发人员和程序员语录\"><a href=\"#软件开发人员和程序员语录\" class=\"headerlink\" title=\"软件开发人员和程序员语录\"></a>软件开发人员和程序员语录</h3><p>1.A good programmer is someone who always looks both ways before crossing a one-way street. (Doug Linder)</p>\n<p>好的程序员即使在过单行道时也总是会环顾两边。</p>\n<p>2.Don’t worry if it doesn’t work right. If everything did, you’d be out of a job. (Mosher’s Law of Software Engineering)</p>\n<p>不要担心它能否正常工作。如果一切正常，那么你就会失去工作。</p>\n<p>3.The trouble with programmers is that you can never tell what a programmer is doing until it’s too late. (Seymour Cray)</p>\n<p>程序员的烦恼是，你永远无法知道一个程序员在做什么，直到为时已晚。</p>\n<p>4.Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. (Larry Wall)</p>\n<p>程序员的美德：懒惰，没有耐心以及老子天下第一。</p>\n<p>5.Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)</p>\n<p>写代码的时候总是想象维护你代码的家伙是一个知道你住在哪里的暴力精神病患者。</p>\n<p>6.One man’s crappy software is another man’s full time job. (Jessica Gaston)</p>\n<p>一个人写的烂软件将会给另一个人带来一份全职工作。</p>\n<p>7.If builders built buildings the way programmers wrote programs, then the first woodpecker that came along wound destroy civilization. (Gerald Weinberg)</p>\n<p>如果建筑工人用程序员写程序的方式建造建筑物，那么来的第一只啄木鸟（找bug）就将摧毁文明。</p>\n<p>8.The most likely way for the world to be destroyed, most experts agree, is by accident.  That’s where we come in; we’re computer professionals. We cause accidents. (Nathaniel Borenstein)</p>\n<p>大多数专家认为，世界被破坏的最有可能的方式是，是因为偶然。那就是我们所要进入的领域：我们是计算机专家。我们制造偶然。</p>\n<p>9.It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes. (Keith  Braithwaite)</p>\n<p>这是我们这个行业的一件咄咄怪事：我们不仅不从错误中学习，我们也不从成功中学习。</p>\n<p>10.Once a new technology starts rolling, if you’re not part of the steamroller, you’re part of the road. (Stewart Brand)</p>\n<p>一旦一种新技术开始滚动碾压道路，如果你不能成为压路机的一部分，那么你就只能成为道路的一部分。</p>\n<p>11.If at first you don’t succeed, call it version 1.0 (unknown)</p>\n<p>如果第一次你没有成功，那么称之为1.0版，继续加油。</p>\n<p>12.All programmers are playwrights and all computers are lousy actors. (Anonymous Hack Actor)</p>\n<p>所有的程序员都剧作家，而所有计算机都是糟糕的演员。</p>\n<p>13.The sooner you get behind in your work, the more time you have to catch up. (Anonymous Scheduler)</p>\n<p>工作拉下得越早，赶上去所需要的时间越多。</p>\n<p>14.When a programming language is created that allows programmers to program in simple English, it will be discovered that programmers cannot speak English. (Anonymous Linguist)</p>\n<p>当创建一种编程语言允许程序员使用简单英语编程的时候，那么新问题又来了，你会发现程序员不说英语。</p>\n<p>15.Why do we never have time to do it right, but always have time to do it over? (Anonymous)</p>\n<p>为什么我们总是没有时间把事情做对，却有时间做完它？</p>\n<p>16.Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</p>\n<p>傻瓜写计算机能理解的代码。优秀的程序员写人类能读懂的代码。</p>\n<p>17.Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else. (Eagleson’s law)</p>\n<p>自己的代码六个月或更久不见，还不如别人写的代码。</p>\n<h3 id=\"编程-软件开发语录\"><a href=\"#编程-软件开发语录\" class=\"headerlink\" title=\"编程/软件开发语录\"></a>编程/软件开发语录</h3><p>1.Measuring programming progress by lines of code is like measuring aircraft building progress by weight. (Bill Gates)</p>\n<p>通过代码行数衡量开发进程就好比用重量来衡量飞机制造进度。</p>\n<p>2.Programming is like sex. One mistake and you have to support it for the rest of your life. (Michael Sinz)</p>\n<p>编程就像性爱一样。一个错误就能绑住你的余生。</p>\n<p>3.Walking on water and developing software from a specification are easy if both are frozen. (Edward V Berard)</p>\n<p>在目的明确的基础上开发软件就像在结冰的水上行走一样简单。</p>\n<p>4.The first 90 percent of the code accounts for the first 90 percent of the development time…The remaining 10 percent of the code accounts for the other 90 percent of the development time.(Tom Cargill)</p>\n<p>开始90％的代码占开始90％的开发时间……剩下10％的代码还是占90％的开发时间。</p>\n<p>5.Commenting your code is like cleaning your bathroom — you never want to do it, but it really does create a more pleasant experience for you and your guests. (Ryan Campbell)</p>\n<p>注释代码就像是清洁浴室——尽管你满心不情愿，但它确实可以为你和你的客人创造一种更舒适的体验。</p>\n<p>6.Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. (Rick Cook)</p>\n<p>当今的编程是软件工程师——努力建设更大多更好的傻瓜式程序，和上帝——试图产出更大多更好的傻瓜之间的竞争。到目前为止，世上帝是获胜者。</p>\n<p>7.The hardest part of design … is keeping features out. (Donald Norman)</p>\n<p>设计中最难的部分……是阻止功能。</p>\n<p>8.In order to understand recursion, one must first understand recursion. (Anonymous)</p>\n<p>要想了解递归，首先必须理解递归。</p>\n<p>9.There are only two kinds of programming languages: those people always bitch about and those nobody uses. (Bjarne Stroustrup)</p>\n<p>只有两种编程语言：一种是天天挨骂的，另一种是没人用的。</p>\n<p>10.The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)</p>\n<p>关于布尔值最妙的一点是，就算你错了，你也只是错了这一处而已。</p>\n<p>11.If Java had true garbage collection, most programs would delete themselves upon execution. (Robert Swell)</p>\n<p>如果Java真的有垃圾收集，那么大多数程序会执行自我删除。</p>\n<p>12.In theory, there is no difference between theory and practice. But, in practice, there is. (Jan L. A. van de Snepscheut)</p>\n<p>理论上看，理论和实践之间是没有差别的。但是，在实践中，有。</p>\n<p>13.Ready, fire, aim: the fast approach to software development. Ready, aim, aim, aim, aim: the slow approach to software development. (Anonymous)</p>\n<p>准备，开火，瞄准：快速的软件开发方法。准备，瞄准，瞄准，瞄准，瞄准：缓慢的软件开发方法。</p>\n<p>14.Programming is 10% science, 20% ingenuity, and 70% getting the ingenuity to work with the science. (Anonymous)</p>\n<p>编程就是10％的科学，20％得的独创性，再加70％和这门科学的灵巧合作。</p>\n<p>15.It is easier to measure something than to understand what you have measured. (Anonymous)</p>\n<p>衡量比理解你衡量了什么容易。</p>\n<p>16.Benchmarks don’t lie, but liars do benchmarks. (Anonymous)</p>\n<p>基准不会撒谎，但制定基准的人会撒谎。</p>\n<p>17.Better train people and risk they leave – than do nothing and risk they stay. (Anonymous)</p>\n<p>就算是培训好的员工离开——也好过他们什么也不做却留下来。</p>\n<p>18.The goal of Computer Science is to build something that will last at least until we’ve finished building it. (Anonymous)</p>\n<p>计算机科学的目标是构建一个至少能持续到我们构建完成的东西。</p>\n<p>19.Java is to JavaScript what Car is to Carpet.  (Chris Heilmann)</p>\n<p>Java之于JavaScript就像car之于carpet（地毯）。后者看上去像是前者的衍生物，实则是完全不同的两个东西。</p>\n<p>20.It’s not at all important to get it right the first time. It’s vitally important to get it right the last time. (Andrew Hunt and David Thomas)</p>\n<p>第一次是否正确完成一点也不重要。最后一次正确完成才至关重要。</p>\n<p>21.Should array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration. (Stan Kelly-Bootle)</p>\n<p>数组的下标一定要从0或1开始吗？我认为，我采取的中间值0.5没有经过适当考虑就被驳回了。</p>\n<p>22.Programs must be written for people to read, and only incidentally for machines to execute. (Abelson / Sussman)</p>\n<p>程序必须写得能供人阅读，机器执行只是附带。</p>\n<p>23.Programming can be fun, so can cryptography; however they should not be combined. (Kreitzberg and Shneiderman)</p>\n<p>编程可以很有趣，密码学也是如此；但是两者不应该搅和在一起。</p>\n<p>24.Copy and paste is a design error.  (David Parnas)</p>\n<p>复制粘贴是一个设计错误。</p>\n<p>25.Computers are good at following instructions, but not at reading your mind. (Donald Knuth)</p>\n<p>计算机善于遵循指令，不善于读取你的想法。</p>\n<h3 id=\"软件调试语录\"><a href=\"#软件调试语录\" class=\"headerlink\" title=\"软件调试语录\"></a>软件调试语录</h3><p>1.Deleted code is debugged code. (Jeff Sickel)</p>\n<p>删除的代码是经过调试的代码。</p>\n<p>2.If debugging is the process of removing software bugs, then programming must be the process of putting them in. (Edsger Dijkstra)</p>\n<p>如果调试是消除软件bug的过程，那么编程就是产出bug的过程。</p>\n<p>3.Debugging is twice as hard as writing the code in the first place.  Therefore, if you write the code as cleverly as possible, you are–by definition–not smart enough to debug it.</p>\n<p>调试一段程序的难度是写出这段程序的难度的两倍，因此，如果你的代码尽可能清楚的话，那么你就不用费力地调试它。</p>\n<p>4.It’s hard enough to find an error in your code when you’re looking for it; it’s even harder when you’ve assumed your code is error-free. (Steve McConnel)</p>\n<p>你的目的是找bug的时候，bug已经很难找了；更不要说当你认为自己的代码中没有错误的时候。</p>\n<h3 id=\"软件bug语录\"><a href=\"#软件bug语录\" class=\"headerlink\" title=\"软件bug语录\"></a>软件bug语录</h3><p>1.It’s not a bug – it’s an undocumented feature. (Anonymous)</p>\n<p>这不是bug——这是没有被证明的功能。</p>\n<p>2.Without requirements or design, programming is the art of adding bugs to an empty text file. (Louis Srygley)</p>\n<p>如果没有需求和设计，那么编程就是添加bug到空的文本文件的艺术。</p>\n<p>3.Bad code isn’t bad, its just misunderstood. (Anonymous Code Behaviorist)</p>\n<p>所谓坏的代码并不坏，它只是被误解了。</p>\n<p>4.There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)</p>\n<p>写没有错误的程序有两种方式；但第三种才有效。</p>\n<p>5.Beware of bugs in the above code; I have only proved it correct, not tried it. (Donald Knuth)</p>\n<p>小心上面代码中的bug；我只证明了它是正确的，还没有尝试过。</p>\n<h3 id=\"软件-终端产品语录\"><a href=\"#软件-终端产品语录\" class=\"headerlink\" title=\"软件/终端产品语录\"></a>软件/终端产品语录</h3><p>1.Before software can be reusable it first has to be usable. (Ralph Johnson)</p>\n<p>在软件可以被可重复使用前，它首先必须是可用的。</p>\n<p>2.Software undergoes beta testing shortly before it’s released. Beta is Latin for “still doesn’t work”. (Anonymous)</p>\n<p>软件在发布前要经过beta测试。beta即拉丁语“仍然无法正常工作”的意思。</p>\n<p>3.The best performance improvement is the transition from the nonworking state to the working state. (J. Osterhout)</p>\n<p>最佳性能改进是指从不可工作状态向工作状态的转变。</p>\n<p>4.The cheapest, fastest, and most reliable components are those that aren’t there. (Gordon Bell)</p>\n<p>最便宜，最快和最可靠的组件是不存在的。</p>\n<p>5.I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)</p>\n<p>我认为微软命名.Net，它就不会在Unix目录列表显示出来。</p>\n<p>6.Software and cathedrals are much the same – first we build them, then we pray. (Sam Redwine)</p>\n<p>软件和教堂非常相似——首先，我们建造它们，然后我们祈祷。</p>\n<p>7.The software isn’t finished until the last user is dead. (Anonymous)</p>\n<p>直到最后一个用户死去，软件才算完成。</p>\n<p>8.Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves. (Alan Kay)</p>\n<p>现在的大多数软件非常像埃及金字塔，在彼此之间堆建了成千上万的砖块，缺乏结构完整性，只是靠蛮力和成千上万的奴隶完成。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a><br>译文链接：<a href=\"http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a><br>英文原文：59 Hilarious but True Programming Quotes for Software Developers</p>\n","excerpt":"","more":"<h3 id=\"软件开发人员和程序员语录\"><a href=\"#软件开发人员和程序员语录\" class=\"headerlink\" title=\"软件开发人员和程序员语录\"></a>软件开发人员和程序员语录</h3><p>1.A good programmer is someone who always looks both ways before crossing a one-way street. (Doug Linder)</p>\n<p>好的程序员即使在过单行道时也总是会环顾两边。</p>\n<p>2.Don’t worry if it doesn’t work right. If everything did, you’d be out of a job. (Mosher’s Law of Software Engineering)</p>\n<p>不要担心它能否正常工作。如果一切正常，那么你就会失去工作。</p>\n<p>3.The trouble with programmers is that you can never tell what a programmer is doing until it’s too late. (Seymour Cray)</p>\n<p>程序员的烦恼是，你永远无法知道一个程序员在做什么，直到为时已晚。</p>\n<p>4.Most of you are familiar with the virtues of a programmer. There are three, of course: laziness, impatience, and hubris. (Larry Wall)</p>\n<p>程序员的美德：懒惰，没有耐心以及老子天下第一。</p>\n<p>5.Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. (Martin Golding)</p>\n<p>写代码的时候总是想象维护你代码的家伙是一个知道你住在哪里的暴力精神病患者。</p>\n<p>6.One man’s crappy software is another man’s full time job. (Jessica Gaston)</p>\n<p>一个人写的烂软件将会给另一个人带来一份全职工作。</p>\n<p>7.If builders built buildings the way programmers wrote programs, then the first woodpecker that came along wound destroy civilization. (Gerald Weinberg)</p>\n<p>如果建筑工人用程序员写程序的方式建造建筑物，那么来的第一只啄木鸟（找bug）就将摧毁文明。</p>\n<p>8.The most likely way for the world to be destroyed, most experts agree, is by accident.  That’s where we come in; we’re computer professionals. We cause accidents. (Nathaniel Borenstein)</p>\n<p>大多数专家认为，世界被破坏的最有可能的方式是，是因为偶然。那就是我们所要进入的领域：我们是计算机专家。我们制造偶然。</p>\n<p>9.It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes. (Keith  Braithwaite)</p>\n<p>这是我们这个行业的一件咄咄怪事：我们不仅不从错误中学习，我们也不从成功中学习。</p>\n<p>10.Once a new technology starts rolling, if you’re not part of the steamroller, you’re part of the road. (Stewart Brand)</p>\n<p>一旦一种新技术开始滚动碾压道路，如果你不能成为压路机的一部分，那么你就只能成为道路的一部分。</p>\n<p>11.If at first you don’t succeed, call it version 1.0 (unknown)</p>\n<p>如果第一次你没有成功，那么称之为1.0版，继续加油。</p>\n<p>12.All programmers are playwrights and all computers are lousy actors. (Anonymous Hack Actor)</p>\n<p>所有的程序员都剧作家，而所有计算机都是糟糕的演员。</p>\n<p>13.The sooner you get behind in your work, the more time you have to catch up. (Anonymous Scheduler)</p>\n<p>工作拉下得越早，赶上去所需要的时间越多。</p>\n<p>14.When a programming language is created that allows programmers to program in simple English, it will be discovered that programmers cannot speak English. (Anonymous Linguist)</p>\n<p>当创建一种编程语言允许程序员使用简单英语编程的时候，那么新问题又来了，你会发现程序员不说英语。</p>\n<p>15.Why do we never have time to do it right, but always have time to do it over? (Anonymous)</p>\n<p>为什么我们总是没有时间把事情做对，却有时间做完它？</p>\n<p>16.Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</p>\n<p>傻瓜写计算机能理解的代码。优秀的程序员写人类能读懂的代码。</p>\n<p>17.Any code of your own that you haven’t looked at for six or more months might as well have been written by someone else. (Eagleson’s law)</p>\n<p>自己的代码六个月或更久不见，还不如别人写的代码。</p>\n<h3 id=\"编程-软件开发语录\"><a href=\"#编程-软件开发语录\" class=\"headerlink\" title=\"编程/软件开发语录\"></a>编程/软件开发语录</h3><p>1.Measuring programming progress by lines of code is like measuring aircraft building progress by weight. (Bill Gates)</p>\n<p>通过代码行数衡量开发进程就好比用重量来衡量飞机制造进度。</p>\n<p>2.Programming is like sex. One mistake and you have to support it for the rest of your life. (Michael Sinz)</p>\n<p>编程就像性爱一样。一个错误就能绑住你的余生。</p>\n<p>3.Walking on water and developing software from a specification are easy if both are frozen. (Edward V Berard)</p>\n<p>在目的明确的基础上开发软件就像在结冰的水上行走一样简单。</p>\n<p>4.The first 90 percent of the code accounts for the first 90 percent of the development time…The remaining 10 percent of the code accounts for the other 90 percent of the development time.(Tom Cargill)</p>\n<p>开始90％的代码占开始90％的开发时间……剩下10％的代码还是占90％的开发时间。</p>\n<p>5.Commenting your code is like cleaning your bathroom — you never want to do it, but it really does create a more pleasant experience for you and your guests. (Ryan Campbell)</p>\n<p>注释代码就像是清洁浴室——尽管你满心不情愿，但它确实可以为你和你的客人创造一种更舒适的体验。</p>\n<p>6.Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. (Rick Cook)</p>\n<p>当今的编程是软件工程师——努力建设更大多更好的傻瓜式程序，和上帝——试图产出更大多更好的傻瓜之间的竞争。到目前为止，世上帝是获胜者。</p>\n<p>7.The hardest part of design … is keeping features out. (Donald Norman)</p>\n<p>设计中最难的部分……是阻止功能。</p>\n<p>8.In order to understand recursion, one must first understand recursion. (Anonymous)</p>\n<p>要想了解递归，首先必须理解递归。</p>\n<p>9.There are only two kinds of programming languages: those people always bitch about and those nobody uses. (Bjarne Stroustrup)</p>\n<p>只有两种编程语言：一种是天天挨骂的，另一种是没人用的。</p>\n<p>10.The best thing about a boolean is even if you are wrong, you are only off by a bit. (Anonymous)</p>\n<p>关于布尔值最妙的一点是，就算你错了，你也只是错了这一处而已。</p>\n<p>11.If Java had true garbage collection, most programs would delete themselves upon execution. (Robert Swell)</p>\n<p>如果Java真的有垃圾收集，那么大多数程序会执行自我删除。</p>\n<p>12.In theory, there is no difference between theory and practice. But, in practice, there is. (Jan L. A. van de Snepscheut)</p>\n<p>理论上看，理论和实践之间是没有差别的。但是，在实践中，有。</p>\n<p>13.Ready, fire, aim: the fast approach to software development. Ready, aim, aim, aim, aim: the slow approach to software development. (Anonymous)</p>\n<p>准备，开火，瞄准：快速的软件开发方法。准备，瞄准，瞄准，瞄准，瞄准：缓慢的软件开发方法。</p>\n<p>14.Programming is 10% science, 20% ingenuity, and 70% getting the ingenuity to work with the science. (Anonymous)</p>\n<p>编程就是10％的科学，20％得的独创性，再加70％和这门科学的灵巧合作。</p>\n<p>15.It is easier to measure something than to understand what you have measured. (Anonymous)</p>\n<p>衡量比理解你衡量了什么容易。</p>\n<p>16.Benchmarks don’t lie, but liars do benchmarks. (Anonymous)</p>\n<p>基准不会撒谎，但制定基准的人会撒谎。</p>\n<p>17.Better train people and risk they leave – than do nothing and risk they stay. (Anonymous)</p>\n<p>就算是培训好的员工离开——也好过他们什么也不做却留下来。</p>\n<p>18.The goal of Computer Science is to build something that will last at least until we’ve finished building it. (Anonymous)</p>\n<p>计算机科学的目标是构建一个至少能持续到我们构建完成的东西。</p>\n<p>19.Java is to JavaScript what Car is to Carpet.  (Chris Heilmann)</p>\n<p>Java之于JavaScript就像car之于carpet（地毯）。后者看上去像是前者的衍生物，实则是完全不同的两个东西。</p>\n<p>20.It’s not at all important to get it right the first time. It’s vitally important to get it right the last time. (Andrew Hunt and David Thomas)</p>\n<p>第一次是否正确完成一点也不重要。最后一次正确完成才至关重要。</p>\n<p>21.Should array indices start at 0 or 1? My compromise of 0.5 was rejected without, I thought, proper consideration. (Stan Kelly-Bootle)</p>\n<p>数组的下标一定要从0或1开始吗？我认为，我采取的中间值0.5没有经过适当考虑就被驳回了。</p>\n<p>22.Programs must be written for people to read, and only incidentally for machines to execute. (Abelson / Sussman)</p>\n<p>程序必须写得能供人阅读，机器执行只是附带。</p>\n<p>23.Programming can be fun, so can cryptography; however they should not be combined. (Kreitzberg and Shneiderman)</p>\n<p>编程可以很有趣，密码学也是如此；但是两者不应该搅和在一起。</p>\n<p>24.Copy and paste is a design error.  (David Parnas)</p>\n<p>复制粘贴是一个设计错误。</p>\n<p>25.Computers are good at following instructions, but not at reading your mind. (Donald Knuth)</p>\n<p>计算机善于遵循指令，不善于读取你的想法。</p>\n<h3 id=\"软件调试语录\"><a href=\"#软件调试语录\" class=\"headerlink\" title=\"软件调试语录\"></a>软件调试语录</h3><p>1.Deleted code is debugged code. (Jeff Sickel)</p>\n<p>删除的代码是经过调试的代码。</p>\n<p>2.If debugging is the process of removing software bugs, then programming must be the process of putting them in. (Edsger Dijkstra)</p>\n<p>如果调试是消除软件bug的过程，那么编程就是产出bug的过程。</p>\n<p>3.Debugging is twice as hard as writing the code in the first place.  Therefore, if you write the code as cleverly as possible, you are–by definition–not smart enough to debug it.</p>\n<p>调试一段程序的难度是写出这段程序的难度的两倍，因此，如果你的代码尽可能清楚的话，那么你就不用费力地调试它。</p>\n<p>4.It’s hard enough to find an error in your code when you’re looking for it; it’s even harder when you’ve assumed your code is error-free. (Steve McConnel)</p>\n<p>你的目的是找bug的时候，bug已经很难找了；更不要说当你认为自己的代码中没有错误的时候。</p>\n<h3 id=\"软件bug语录\"><a href=\"#软件bug语录\" class=\"headerlink\" title=\"软件bug语录\"></a>软件bug语录</h3><p>1.It’s not a bug – it’s an undocumented feature. (Anonymous)</p>\n<p>这不是bug——这是没有被证明的功能。</p>\n<p>2.Without requirements or design, programming is the art of adding bugs to an empty text file. (Louis Srygley)</p>\n<p>如果没有需求和设计，那么编程就是添加bug到空的文本文件的艺术。</p>\n<p>3.Bad code isn’t bad, its just misunderstood. (Anonymous Code Behaviorist)</p>\n<p>所谓坏的代码并不坏，它只是被误解了。</p>\n<p>4.There are two ways to write error-free programs; only the third one works. (Alan J. Perlis)</p>\n<p>写没有错误的程序有两种方式；但第三种才有效。</p>\n<p>5.Beware of bugs in the above code; I have only proved it correct, not tried it. (Donald Knuth)</p>\n<p>小心上面代码中的bug；我只证明了它是正确的，还没有尝试过。</p>\n<h3 id=\"软件-终端产品语录\"><a href=\"#软件-终端产品语录\" class=\"headerlink\" title=\"软件/终端产品语录\"></a>软件/终端产品语录</h3><p>1.Before software can be reusable it first has to be usable. (Ralph Johnson)</p>\n<p>在软件可以被可重复使用前，它首先必须是可用的。</p>\n<p>2.Software undergoes beta testing shortly before it’s released. Beta is Latin for “still doesn’t work”. (Anonymous)</p>\n<p>软件在发布前要经过beta测试。beta即拉丁语“仍然无法正常工作”的意思。</p>\n<p>3.The best performance improvement is the transition from the nonworking state to the working state. (J. Osterhout)</p>\n<p>最佳性能改进是指从不可工作状态向工作状态的转变。</p>\n<p>4.The cheapest, fastest, and most reliable components are those that aren’t there. (Gordon Bell)</p>\n<p>最便宜，最快和最可靠的组件是不存在的。</p>\n<p>5.I think Microsoft named .Net so it wouldn’t show up in a Unix directory listing. (Oktal)</p>\n<p>我认为微软命名.Net，它就不会在Unix目录列表显示出来。</p>\n<p>6.Software and cathedrals are much the same – first we build them, then we pray. (Sam Redwine)</p>\n<p>软件和教堂非常相似——首先，我们建造它们，然后我们祈祷。</p>\n<p>7.The software isn’t finished until the last user is dead. (Anonymous)</p>\n<p>直到最后一个用户死去，软件才算完成。</p>\n<p>8.Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves. (Alan Kay)</p>\n<p>现在的大多数软件非常像埃及金字塔，在彼此之间堆建了成千上万的砖块，缺乏结构完整性，只是靠蛮力和成千上万的奴隶完成。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html\">http://www.codeceo.com</a><br>译文链接：<a href=\"http://www.codeceo.com/article/59-hilarious-true-programming-quotes.html\">http://www.codeceo.com</a><br>英文原文：59 Hilarious but True Programming Quotes for Software Developers</p>\n"},{"title":"5个经典的前端面试问题","date":"2014-10-26T16:00:00.000Z","_content":"\n###问题1：Scope作用范围\n\n考虑下面的代码：\n\n```\n(function() {\n   var a = b = 5;\n})();\n\nconsole.log(b);\n```\n\n什么会被打印在控制台上？\n\n回答\n\n上面的代码会打印 5。\n\n这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。\n\n这个问题的另一个诀窍是，它没有使用严格模式 ('use strict';) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：\n\n```\n(function() {\n   'use strict';\n   var a = window.b = 5;\n})();\n \nconsole.log(b);\n```\n\n###问题2：创建“原生”（native）方法\n\n给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：\n\n```\nconsole.log('hello'.repeatify(3));\n```\n\n应打印 hellohellohello。\n\n回答\n\n一个可能的实现如下所示：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {\n   var str = '';\n   for (var i = 0; i < times; i++) {\n      str += this;\n   }\n   return str;\n};\n```\n\n现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。\n\n这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {/* code here */};\n```\n\n当你被要求做好JavaScript函数兼容时这种技术特别有用。\n\n###问题3：声明提升（Hoisting）\n\n执行这段代码，输出什么结果。\n\n```\nfunction test() {\n   console.log(a);\n   console.log(foo());\n   var a = 1;\n   function foo() {\n      return 2;\n   }\n}\n \ntest();\n```\n\n回答\n\n这段代码的结果是 undefined 和 2。\n\n原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：\n\n```\nfunction test() {\n   var a;\n   function foo() {\n      return 2;\n   }\n  \n   console.log(a);\n   console.log(foo());\n     \n   a = 1;\n}\n  \ntest();\n```\n\n###问题4：this在JavaScript中如何工作的\n\n面的代码会输出什么结果？给出你的答案。\n\n```\nvar fullname = 'John Doe';\nvar obj = {\n   fullname: 'Colin Ihrig',\n   prop: {\n      fullname: 'Aurelio De Rosa',\n      getFullname: function() {\n         return this.fullname;\n      }\n   }\n};\n \nconsole.log(obj.prop.getFullname());\n  \nvar test = obj.prop.getFullname;\n  \nconsole.log(test());\n```\n\n回答\n\n答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。\n\n在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。\n\n###问题5：call() 和 apply()\n\n现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。\n\n回答\n\n该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：\n\n```\nconsole.log(test.call(obj.prop));\n```\n\n###结论\n\n在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。\n\n如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。\n\n来源：[http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html](http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html)\n","source":"_posts/5个经典的前端面试问题.md","raw":"---\ntitle: 5个经典的前端面试问题\ntags: [javascript]\ndate: 2014/10/27\n---\n\n###问题1：Scope作用范围\n\n考虑下面的代码：\n\n```\n(function() {\n   var a = b = 5;\n})();\n\nconsole.log(b);\n```\n\n什么会被打印在控制台上？\n\n回答\n\n上面的代码会打印 5。\n\n这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。\n\n这个问题的另一个诀窍是，它没有使用严格模式 ('use strict';) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：\n\n```\n(function() {\n   'use strict';\n   var a = window.b = 5;\n})();\n \nconsole.log(b);\n```\n\n###问题2：创建“原生”（native）方法\n\n给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：\n\n```\nconsole.log('hello'.repeatify(3));\n```\n\n应打印 hellohellohello。\n\n回答\n\n一个可能的实现如下所示：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {\n   var str = '';\n   for (var i = 0; i < times; i++) {\n      str += this;\n   }\n   return str;\n};\n```\n\n现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。\n\n这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {/* code here */};\n```\n\n当你被要求做好JavaScript函数兼容时这种技术特别有用。\n\n###问题3：声明提升（Hoisting）\n\n执行这段代码，输出什么结果。\n\n```\nfunction test() {\n   console.log(a);\n   console.log(foo());\n   var a = 1;\n   function foo() {\n      return 2;\n   }\n}\n \ntest();\n```\n\n回答\n\n这段代码的结果是 undefined 和 2。\n\n原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：\n\n```\nfunction test() {\n   var a;\n   function foo() {\n      return 2;\n   }\n  \n   console.log(a);\n   console.log(foo());\n     \n   a = 1;\n}\n  \ntest();\n```\n\n###问题4：this在JavaScript中如何工作的\n\n面的代码会输出什么结果？给出你的答案。\n\n```\nvar fullname = 'John Doe';\nvar obj = {\n   fullname: 'Colin Ihrig',\n   prop: {\n      fullname: 'Aurelio De Rosa',\n      getFullname: function() {\n         return this.fullname;\n      }\n   }\n};\n \nconsole.log(obj.prop.getFullname());\n  \nvar test = obj.prop.getFullname;\n  \nconsole.log(test());\n```\n\n回答\n\n答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。\n\n在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。\n\n###问题5：call() 和 apply()\n\n现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。\n\n回答\n\n该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：\n\n```\nconsole.log(test.call(obj.prop));\n```\n\n###结论\n\n在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。\n\n如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。\n\n来源：[http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html](http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html)\n","slug":"5个经典的前端面试问题","published":1,"updated":"2016-08-17T06:22:19.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpho000c68ddrt2ry9zi","content":"<p>###问题1：Scope作用范围</p>\n<p>考虑下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">   var a = b = 5;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">console.log(b);</div></pre></td></tr></table></figure>\n<p>什么会被打印在控制台上？</p>\n<p>回答</p>\n<p>上面的代码会打印 5。</p>\n<p>这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>\n<p>这个问题的另一个诀窍是，它没有使用严格模式 (‘use strict’;) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">   &apos;use strict&apos;;</div><div class=\"line\">   var a = window.b = 5;</div><div class=\"line\">&#125;)();</div><div class=\"line\"> </div><div class=\"line\">console.log(b);</div></pre></td></tr></table></figure>\n<p>###问题2：创建“原生”（native）方法</p>\n<p>给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(&apos;hello&apos;.repeatify(3));</div></pre></td></tr></table></figure>\n<p>应打印 hellohellohello。</p>\n<p>回答</p>\n<p>一个可能的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;</div><div class=\"line\">   var str = &apos;&apos;;</div><div class=\"line\">   for (var i = 0; i &lt; times; i++) &#123;</div><div class=\"line\">      str += this;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return str;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。</p>\n<p>这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;/* code here */&#125;;</div></pre></td></tr></table></figure>\n<p>当你被要求做好JavaScript函数兼容时这种技术特别有用。</p>\n<p>###问题3：声明提升（Hoisting）</p>\n<p>执行这段代码，输出什么结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function test() &#123;</div><div class=\"line\">   console.log(a);</div><div class=\"line\">   console.log(foo());</div><div class=\"line\">   var a = 1;</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">      return 2;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">test();</div></pre></td></tr></table></figure>\n<p>回答</p>\n<p>这段代码的结果是 undefined 和 2。</p>\n<p>原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function test() &#123;</div><div class=\"line\">   var a;</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">      return 2;</div><div class=\"line\">   &#125;</div><div class=\"line\">  </div><div class=\"line\">   console.log(a);</div><div class=\"line\">   console.log(foo());</div><div class=\"line\">     </div><div class=\"line\">   a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">test();</div></pre></td></tr></table></figure>\n<p>###问题4：this在JavaScript中如何工作的</p>\n<p>面的代码会输出什么结果？给出你的答案。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var fullname = &apos;John Doe&apos;;</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   fullname: &apos;Colin Ihrig&apos;,</div><div class=\"line\">   prop: &#123;</div><div class=\"line\">      fullname: &apos;Aurelio De Rosa&apos;,</div><div class=\"line\">      getFullname: function() &#123;</div><div class=\"line\">         return this.fullname;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">console.log(obj.prop.getFullname());</div><div class=\"line\">  </div><div class=\"line\">var test = obj.prop.getFullname;</div><div class=\"line\">  </div><div class=\"line\">console.log(test());</div></pre></td></tr></table></figure>\n<p>回答</p>\n<p>答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。</p>\n<p>在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。</p>\n<p>###问题5：call() 和 apply()</p>\n<p>现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。</p>\n<p>回答</p>\n<p>该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(test.call(obj.prop));</div></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。</p>\n<p>如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。</p>\n<p>来源：<a href=\"http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html</a></p>\n","excerpt":"","more":"<p>###问题1：Scope作用范围</p>\n<p>考虑下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">   var a = b = 5;</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">console.log(b);</div></pre></td></tr></table></figure>\n<p>什么会被打印在控制台上？</p>\n<p>回答</p>\n<p>上面的代码会打印 5。</p>\n<p>这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>\n<p>这个问题的另一个诀窍是，它没有使用严格模式 (‘use strict’;) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">   &apos;use strict&apos;;</div><div class=\"line\">   var a = window.b = 5;</div><div class=\"line\">&#125;)();</div><div class=\"line\"> </div><div class=\"line\">console.log(b);</div></pre></td></tr></table></figure>\n<p>###问题2：创建“原生”（native）方法</p>\n<p>给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(&apos;hello&apos;.repeatify(3));</div></pre></td></tr></table></figure>\n<p>应打印 hellohellohello。</p>\n<p>回答</p>\n<p>一个可能的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;</div><div class=\"line\">   var str = &apos;&apos;;</div><div class=\"line\">   for (var i = 0; i &lt; times; i++) &#123;</div><div class=\"line\">      str += this;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return str;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。</p>\n<p>这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;/* code here */&#125;;</div></pre></td></tr></table></figure>\n<p>当你被要求做好JavaScript函数兼容时这种技术特别有用。</p>\n<p>###问题3：声明提升（Hoisting）</p>\n<p>执行这段代码，输出什么结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function test() &#123;</div><div class=\"line\">   console.log(a);</div><div class=\"line\">   console.log(foo());</div><div class=\"line\">   var a = 1;</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">      return 2;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">test();</div></pre></td></tr></table></figure>\n<p>回答</p>\n<p>这段代码的结果是 undefined 和 2。</p>\n<p>原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function test() &#123;</div><div class=\"line\">   var a;</div><div class=\"line\">   function foo() &#123;</div><div class=\"line\">      return 2;</div><div class=\"line\">   &#125;</div><div class=\"line\">  </div><div class=\"line\">   console.log(a);</div><div class=\"line\">   console.log(foo());</div><div class=\"line\">     </div><div class=\"line\">   a = 1;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">test();</div></pre></td></tr></table></figure>\n<p>###问题4：this在JavaScript中如何工作的</p>\n<p>面的代码会输出什么结果？给出你的答案。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var fullname = &apos;John Doe&apos;;</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   fullname: &apos;Colin Ihrig&apos;,</div><div class=\"line\">   prop: &#123;</div><div class=\"line\">      fullname: &apos;Aurelio De Rosa&apos;,</div><div class=\"line\">      getFullname: function() &#123;</div><div class=\"line\">         return this.fullname;</div><div class=\"line\">      &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">console.log(obj.prop.getFullname());</div><div class=\"line\">  </div><div class=\"line\">var test = obj.prop.getFullname;</div><div class=\"line\">  </div><div class=\"line\">console.log(test());</div></pre></td></tr></table></figure>\n<p>回答</p>\n<p>答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。</p>\n<p>在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。</p>\n<p>###问题5：call() 和 apply()</p>\n<p>现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。</p>\n<p>回答</p>\n<p>该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(test.call(obj.prop));</div></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。</p>\n<p>如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。</p>\n<p>来源：<a href=\"http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html\">http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html</a></p>\n"},{"title":"AngularJS开发人员最常犯的10个错误","date":"2016-04-16T16:00:00.000Z","_content":"\n### 简介\n\nAngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。\n\n### 1. MVC目录结构\n\nAngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：\n\n```\ntemplates/\n    _login.html\n    _feed.html\napp/\n    app.js\n    controllers/\n        LoginController.js\n        FeedController.js\n    directives/\n        FeedEntryDirective.js\n    services/\n        LoginService.js\n        FeedService.js\n    filters/\n        CapatalizeFilter.js\n```\n\n看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。\n\n与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：\n\n```\napp/\n    app.js\n    Feed/\n        _feed.html\n        FeedController.js\n        FeedEntryDirective.js\n        FeedService.js\n    Login/\n        _login.html\n        LoginController.js\n        LoginService.js\n    Shared/\n        CapatalizeFilter.js\n```\n\n这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。\n\n### 2. 模块\n\n将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。\n\n```\nvar app = angular.module('app',[]);\napp.service('MyService', function(){\n    \n//service code\n});\napp.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n```\n\n在此之后，一个常见的策略是对相同类型的对象归类。\n\n```\nvar services = angular.module('services',[]);\nservices.service('MyService', function(){\n    \n//service code\n});\n \nvar controllers = angular.module('controllers',['services']);\ncontrollers.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n \nvar app = angular.module('app',['controllers', 'services']);\n```\n\n这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。\n\n```\nvar sharedServicesModule = angular.module('sharedServices',[]);\nsharedServices.service('NetworkService', function($http){});\n \nvar loginModule = angular.module('login',['sharedServices']);\nloginModule.service('loginService', function(NetworkService){});\nloginModule.controller('loginCtrl', function($scope, loginService){});\n \nvar app = angular.module('app', ['sharedServices', 'login']);\n```\n\n当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。\n\n### 3. 依赖注入\n\n依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：\n\n```\nvar app = angular.module('app',[]);\n \napp.controller('MainCtrl', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n});\n```\n\n这里，很明显，MainCtrl依赖$scope和$timeout。\n\n直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：\n\n```\nvar app=angular.module(\"app\",[]);\napp.controller(\"MainCtrl\",function(e,t){t(function(){console.log(e)},1e3)})\n```\n\n现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。\n\n```\napp.controller('MainCtrl', ['$scope', '$timeout', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n}]);\n```\n\n这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：\n\n```\napp.controller(\"MainCtrl\",[\"$scope\",\"$timeout\",function(e,t){t(function(){console.log(e)},1e3)}])\n```\n\n**3.1 全局依赖**\n\n在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。\n\n使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。\n\nUnderscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：\n\n```\nvar underscore = angular.module('underscore', []);\nunderscore.factory('_', function() {\n  return window._; \n//Underscore must already be loaded on the page\n});\nvar app = angular.module('app', ['underscore']);\n \napp.controller('MainCtrl', ['$scope', '_', function($scope, _) {\n    init = function() {\n          _.keys($scope);\n      }\n \n      init();\n}]);\n```\n\n这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。\n\n这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。\n\n### 4. 控制器膨胀\n\n控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。\n\n数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。\n\nAngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。\n\n### 5. Service vs Factory\n\n几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！\n\n以下是它们在AngularJS源代码中的定义：\n\n```\nfunction factory(name, factoryFn) { \n    return provider(name, { $get: factoryFn }); \n}\n \nfunction service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n}\n```\n\n从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。\n\n由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。\n\n以下是一个例子，展示了一个service和一个factory如何完成相同的事情：\n\n```\nvar app = angular.module('app',[]);\n \napp.service('helloWorldService', function(){\n    this.hello = function() {\n        return \"Hello World\";\n    };\n});\n \napp.factory('helloWorldFactory', function(){\n    return {\n        hello: function() {\n            return \"Hello World\";\n        }\n    }\n});\n```\n\n当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。\n\n既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。\n\n```\napp.factory('helloFactory', function() {\n    return function(name) {\n        this.name = name;\n \n        this.hello = function() {\n            return \"Hello \" + this.name;\n        };\n    };\n});\n```\n\n这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。\n\n```\napp.controller('helloCtrl', function($scope, helloWorldService, helloWorldFactory, helloFactory) {\n    init = function() {\n      helloWorldService.hello(); \n//'Hello World'\n      helloWorldFactory.hello(); \n//'Hello World'\n      new helloFactory('Readers').hello() \n//'Hello Readers'\n    }\n \n    init();\n});\n```\n\n在初学时，最好只使用service。\n\nFactory在设计一个包含很多私有方法的类时也很有用：\n\n```\napp.factory('privateFactory', function(){\n    var privateFunc = function(name) {\n        return name.split(\"\").reverse().join(\"\"); \n//reverses the name\n    };\n \n    return {\n        hello: function(name){\n          return \"Hello \" + privateFunc(name);\n        }\n    };\n});\n```\n\n通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。\n\n### 6. 没有使用Batarang\n\nBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。\n\nBatarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。\n\nBatarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。\n\n最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。\n\n### 7. 过多的watcher\n\n在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）\n\n以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：\n\n```\n(function () { \n    var root = $(document.getElementsByTagName('body'));\n    var watchers = [];\n \n    var f = function (element) {\n        if (element.data().hasOwnProperty('$scope')) {\n            angular.forEach(element.data().$scope.$$watchers, function (watcher) {\n                watchers.push(watcher);\n            });\n        }\n \n        angular.forEach(element.children(), function (childElement) {\n            f($(childElement));\n        });\n    };\n \n    f(root);\n \n    console.log(watchers.length);\n})();\n```\n\n通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。\n\n当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。\n\n### 8. 限定$scope的范围\n\nJavascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）\n\n由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。\n\n比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user}}</span>\n        <input ng-model=\"user\"></input>\n   </div>\n</div>\n```\n\n那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？\n\n如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。\n\n当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）\n\n所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user.name}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user.name}}</span>\n        <input ng-model=\"user.name\"></input>\n   </div>\n</div>\n```\n\n现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。\n\n这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。\n\n### 9. 手工测试\n\n由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。\n\n不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。\n\n**9.1 Protractor**\n\n单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。\n\n我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。\n\nProtractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。\n\n我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。\n\n**9.2 Karma**\n\n一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。\n\nKarma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。\n\n### 10. 使用jQuery\n\njQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。\n\nAngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。\n\n为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。\n\nDOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。\n\n但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。\n\n### 结论\n\nAngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。\n","source":"_posts/AngularJS开发人员最常犯的10个错误.md","raw":"---\ntitle: AngularJS开发人员最常犯的10个错误\ntags: [javascript,angularjs]\ndate: 2016/04/17\n---\n\n### 简介\n\nAngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。\n\n### 1. MVC目录结构\n\nAngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：\n\n```\ntemplates/\n    _login.html\n    _feed.html\napp/\n    app.js\n    controllers/\n        LoginController.js\n        FeedController.js\n    directives/\n        FeedEntryDirective.js\n    services/\n        LoginService.js\n        FeedService.js\n    filters/\n        CapatalizeFilter.js\n```\n\n看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。\n\n与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：\n\n```\napp/\n    app.js\n    Feed/\n        _feed.html\n        FeedController.js\n        FeedEntryDirective.js\n        FeedService.js\n    Login/\n        _login.html\n        LoginController.js\n        LoginService.js\n    Shared/\n        CapatalizeFilter.js\n```\n\n这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。\n\n### 2. 模块\n\n将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。\n\n```\nvar app = angular.module('app',[]);\napp.service('MyService', function(){\n    \n//service code\n});\napp.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n```\n\n在此之后，一个常见的策略是对相同类型的对象归类。\n\n```\nvar services = angular.module('services',[]);\nservices.service('MyService', function(){\n    \n//service code\n});\n \nvar controllers = angular.module('controllers',['services']);\ncontrollers.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n \nvar app = angular.module('app',['controllers', 'services']);\n```\n\n这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。\n\n```\nvar sharedServicesModule = angular.module('sharedServices',[]);\nsharedServices.service('NetworkService', function($http){});\n \nvar loginModule = angular.module('login',['sharedServices']);\nloginModule.service('loginService', function(NetworkService){});\nloginModule.controller('loginCtrl', function($scope, loginService){});\n \nvar app = angular.module('app', ['sharedServices', 'login']);\n```\n\n当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。\n\n### 3. 依赖注入\n\n依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：\n\n```\nvar app = angular.module('app',[]);\n \napp.controller('MainCtrl', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n});\n```\n\n这里，很明显，MainCtrl依赖$scope和$timeout。\n\n直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：\n\n```\nvar app=angular.module(\"app\",[]);\napp.controller(\"MainCtrl\",function(e,t){t(function(){console.log(e)},1e3)})\n```\n\n现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。\n\n```\napp.controller('MainCtrl', ['$scope', '$timeout', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n}]);\n```\n\n这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：\n\n```\napp.controller(\"MainCtrl\",[\"$scope\",\"$timeout\",function(e,t){t(function(){console.log(e)},1e3)}])\n```\n\n**3.1 全局依赖**\n\n在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。\n\n使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。\n\nUnderscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：\n\n```\nvar underscore = angular.module('underscore', []);\nunderscore.factory('_', function() {\n  return window._; \n//Underscore must already be loaded on the page\n});\nvar app = angular.module('app', ['underscore']);\n \napp.controller('MainCtrl', ['$scope', '_', function($scope, _) {\n    init = function() {\n          _.keys($scope);\n      }\n \n      init();\n}]);\n```\n\n这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。\n\n这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。\n\n### 4. 控制器膨胀\n\n控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。\n\n数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。\n\nAngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。\n\n### 5. Service vs Factory\n\n几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！\n\n以下是它们在AngularJS源代码中的定义：\n\n```\nfunction factory(name, factoryFn) { \n    return provider(name, { $get: factoryFn }); \n}\n \nfunction service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n}\n```\n\n从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。\n\n由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。\n\n以下是一个例子，展示了一个service和一个factory如何完成相同的事情：\n\n```\nvar app = angular.module('app',[]);\n \napp.service('helloWorldService', function(){\n    this.hello = function() {\n        return \"Hello World\";\n    };\n});\n \napp.factory('helloWorldFactory', function(){\n    return {\n        hello: function() {\n            return \"Hello World\";\n        }\n    }\n});\n```\n\n当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。\n\n既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。\n\n```\napp.factory('helloFactory', function() {\n    return function(name) {\n        this.name = name;\n \n        this.hello = function() {\n            return \"Hello \" + this.name;\n        };\n    };\n});\n```\n\n这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。\n\n```\napp.controller('helloCtrl', function($scope, helloWorldService, helloWorldFactory, helloFactory) {\n    init = function() {\n      helloWorldService.hello(); \n//'Hello World'\n      helloWorldFactory.hello(); \n//'Hello World'\n      new helloFactory('Readers').hello() \n//'Hello Readers'\n    }\n \n    init();\n});\n```\n\n在初学时，最好只使用service。\n\nFactory在设计一个包含很多私有方法的类时也很有用：\n\n```\napp.factory('privateFactory', function(){\n    var privateFunc = function(name) {\n        return name.split(\"\").reverse().join(\"\"); \n//reverses the name\n    };\n \n    return {\n        hello: function(name){\n          return \"Hello \" + privateFunc(name);\n        }\n    };\n});\n```\n\n通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。\n\n### 6. 没有使用Batarang\n\nBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。\n\nBatarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。\n\nBatarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。\n\n最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。\n\n### 7. 过多的watcher\n\n在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）\n\n以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：\n\n```\n(function () { \n    var root = $(document.getElementsByTagName('body'));\n    var watchers = [];\n \n    var f = function (element) {\n        if (element.data().hasOwnProperty('$scope')) {\n            angular.forEach(element.data().$scope.$$watchers, function (watcher) {\n                watchers.push(watcher);\n            });\n        }\n \n        angular.forEach(element.children(), function (childElement) {\n            f($(childElement));\n        });\n    };\n \n    f(root);\n \n    console.log(watchers.length);\n})();\n```\n\n通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。\n\n当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。\n\n### 8. 限定$scope的范围\n\nJavascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）\n\n由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。\n\n比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user}}</span>\n        <input ng-model=\"user\"></input>\n   </div>\n</div>\n```\n\n那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？\n\n如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。\n\n当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）\n\n所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user.name}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user.name}}</span>\n        <input ng-model=\"user.name\"></input>\n   </div>\n</div>\n```\n\n现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。\n\n这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。\n\n### 9. 手工测试\n\n由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。\n\n不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。\n\n**9.1 Protractor**\n\n单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。\n\n我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。\n\nProtractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。\n\n我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。\n\n**9.2 Karma**\n\n一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。\n\nKarma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。\n\n### 10. 使用jQuery\n\njQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。\n\nAngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。\n\n为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。\n\nDOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。\n\n但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。\n\n### 结论\n\nAngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。\n","slug":"AngularJS开发人员最常犯的10个错误","published":1,"updated":"2016-08-17T06:22:19.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphr000e68ddq1bc3991","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>AngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。</p>\n<h3 id=\"1-MVC目录结构\"><a href=\"#1-MVC目录结构\" class=\"headerlink\" title=\"1. MVC目录结构\"></a>1. MVC目录结构</h3><p>AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">templates/</div><div class=\"line\">    _login.html</div><div class=\"line\">    _feed.html</div><div class=\"line\">app/</div><div class=\"line\">    app.js</div><div class=\"line\">    controllers/</div><div class=\"line\">        LoginController.js</div><div class=\"line\">        FeedController.js</div><div class=\"line\">    directives/</div><div class=\"line\">        FeedEntryDirective.js</div><div class=\"line\">    services/</div><div class=\"line\">        LoginService.js</div><div class=\"line\">        FeedService.js</div><div class=\"line\">    filters/</div><div class=\"line\">        CapatalizeFilter.js</div></pre></td></tr></table></figure>\n<p>看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。</p>\n<p>与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app/</div><div class=\"line\">    app.js</div><div class=\"line\">    Feed/</div><div class=\"line\">        _feed.html</div><div class=\"line\">        FeedController.js</div><div class=\"line\">        FeedEntryDirective.js</div><div class=\"line\">        FeedService.js</div><div class=\"line\">    Login/</div><div class=\"line\">        _login.html</div><div class=\"line\">        LoginController.js</div><div class=\"line\">        LoginService.js</div><div class=\"line\">    Shared/</div><div class=\"line\">        CapatalizeFilter.js</div></pre></td></tr></table></figure>\n<p>这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。</p>\n<h3 id=\"2-模块\"><a href=\"#2-模块\" class=\"headerlink\" title=\"2. 模块\"></a>2. 模块</h3><p>将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\">app.service(&apos;MyService&apos;, function()&#123;</div><div class=\"line\">    </div><div class=\"line\">//service code</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</div><div class=\"line\">    </div><div class=\"line\">//controller code</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在此之后，一个常见的策略是对相同类型的对象归类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var services = angular.module(&apos;services&apos;,[]);</div><div class=\"line\">services.service(&apos;MyService&apos;, function()&#123;</div><div class=\"line\">    </div><div class=\"line\">//service code</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);</div><div class=\"line\">controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</div><div class=\"line\">    </div><div class=\"line\">//controller code</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]);</div></pre></td></tr></table></figure>\n<p>这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);</div><div class=\"line\">sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);</div><div class=\"line\">loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);</div><div class=\"line\">loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]);</div></pre></td></tr></table></figure>\n<p>当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。</p>\n<h3 id=\"3-依赖注入\"><a href=\"#3-依赖注入\" class=\"headerlink\" title=\"3. 依赖注入\"></a>3. 依赖注入</h3><p>依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\"> </div><div class=\"line\">app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123;</div><div class=\"line\">    $timeout(function()&#123;</div><div class=\"line\">        console.log($scope);</div><div class=\"line\">    &#125;, 1000);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里，很明显，MainCtrl依赖$scope和$timeout。</p>\n<p>直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app=angular.module(&quot;app&quot;,[]);</div><div class=\"line\">app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;)</div></pre></td></tr></table></figure>\n<p>现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123;</div><div class=\"line\">    $timeout(function()&#123;</div><div class=\"line\">        console.log($scope);</div><div class=\"line\">    &#125;, 1000);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure>\n<p>这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;])</div></pre></td></tr></table></figure>\n<p><strong>3.1 全局依赖</strong></p>\n<p>在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。</p>\n<p>使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。</p>\n<p>Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var underscore = angular.module(&apos;underscore&apos;, []);</div><div class=\"line\">underscore.factory(&apos;_&apos;, function() &#123;</div><div class=\"line\">  return window._; </div><div class=\"line\">//Underscore must already be loaded on the page</div><div class=\"line\">&#125;);</div><div class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);</div><div class=\"line\"> </div><div class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123;</div><div class=\"line\">    init = function() &#123;</div><div class=\"line\">          _.keys($scope);</div><div class=\"line\">      &#125;</div><div class=\"line\"> </div><div class=\"line\">      init();</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure>\n<p>这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。</p>\n<p>这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。</p>\n<h3 id=\"4-控制器膨胀\"><a href=\"#4-控制器膨胀\" class=\"headerlink\" title=\"4. 控制器膨胀\"></a>4. 控制器膨胀</h3><p>控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。</p>\n<p>数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。</p>\n<p>AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。</p>\n<h3 id=\"5-Service-vs-Factory\"><a href=\"#5-Service-vs-Factory\" class=\"headerlink\" title=\"5. Service vs Factory\"></a>5. Service vs Factory</h3><p>几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！</p>\n<p>以下是它们在AngularJS源代码中的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function factory(name, factoryFn) &#123; </div><div class=\"line\">    return provider(name, &#123; $get: factoryFn &#125;); </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function service(name, constructor) &#123;</div><div class=\"line\">    return factory(name, [&apos;$injector&apos;, function($injector) &#123;</div><div class=\"line\">      return $injector.instantiate(constructor);</div><div class=\"line\">    &#125;]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。</p>\n<p>由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。</p>\n<p>以下是一个例子，展示了一个service和一个factory如何完成相同的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\"> </div><div class=\"line\">app.service(&apos;helloWorldService&apos;, function()&#123;</div><div class=\"line\">    this.hello = function() &#123;</div><div class=\"line\">        return &quot;Hello World&quot;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">app.factory(&apos;helloWorldFactory&apos;, function()&#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        hello: function() &#123;</div><div class=\"line\">            return &quot;Hello World&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。</p>\n<p>既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;helloFactory&apos;, function() &#123;</div><div class=\"line\">    return function(name) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\"> </div><div class=\"line\">        this.hello = function() &#123;</div><div class=\"line\">            return &quot;Hello &quot; + this.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123;</div><div class=\"line\">    init = function() &#123;</div><div class=\"line\">      helloWorldService.hello(); </div><div class=\"line\">//&apos;Hello World&apos;</div><div class=\"line\">      helloWorldFactory.hello(); </div><div class=\"line\">//&apos;Hello World&apos;</div><div class=\"line\">      new helloFactory(&apos;Readers&apos;).hello() </div><div class=\"line\">//&apos;Hello Readers&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    init();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在初学时，最好只使用service。</p>\n<p>Factory在设计一个包含很多私有方法的类时也很有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;privateFactory&apos;, function()&#123;</div><div class=\"line\">    var privateFunc = function(name) &#123;</div><div class=\"line\">        return name.split(&quot;&quot;).reverse().join(&quot;&quot;); </div><div class=\"line\">//reverses the name</div><div class=\"line\">    &#125;;</div><div class=\"line\"> </div><div class=\"line\">    return &#123;</div><div class=\"line\">        hello: function(name)&#123;</div><div class=\"line\">          return &quot;Hello &quot; + privateFunc(name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。</p>\n<h3 id=\"6-没有使用Batarang\"><a href=\"#6-没有使用Batarang\" class=\"headerlink\" title=\"6. 没有使用Batarang\"></a>6. 没有使用Batarang</h3><p>Batarang是一个出色的Chrome插件，用来开发和测试AngularJS app。</p>\n<p>Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。</p>\n<p>Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。</p>\n<p>最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。</p>\n<h3 id=\"7-过多的watcher\"><a href=\"#7-过多的watcher\" class=\"headerlink\" title=\"7. 过多的watcher\"></a>7. 过多的watcher</h3><p>在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）</p>\n<p>以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function () &#123; </div><div class=\"line\">    var root = $(document.getElementsByTagName(&apos;body&apos;));</div><div class=\"line\">    var watchers = [];</div><div class=\"line\"> </div><div class=\"line\">    var f = function (element) &#123;</div><div class=\"line\">        if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123;</div><div class=\"line\">            angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123;</div><div class=\"line\">                watchers.push(watcher);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        angular.forEach(element.children(), function (childElement) &#123;</div><div class=\"line\">            f($(childElement));</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;;</div><div class=\"line\"> </div><div class=\"line\">    f(root);</div><div class=\"line\"> </div><div class=\"line\">    console.log(watchers.length);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。</p>\n<p>当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。</p>\n<h3 id=\"8-限定-scope的范围\"><a href=\"#8-限定-scope的范围\" class=\"headerlink\" title=\"8. 限定$scope的范围\"></a>8. 限定$scope的范围</h3><p>Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）</p>\n<p>由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。</p>\n<p>比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</div><div class=\"line\">   &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</div><div class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</div><div class=\"line\">        &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</div><div class=\"line\">        &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt;</div><div class=\"line\">   &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？</p>\n<p>如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。</p>\n<p>当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）</p>\n<p>所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</div><div class=\"line\">   &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</div><div class=\"line\">        &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">        &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt;</div><div class=\"line\">   &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。</p>\n<p>这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。</p>\n<h3 id=\"9-手工测试\"><a href=\"#9-手工测试\" class=\"headerlink\" title=\"9. 手工测试\"></a>9. 手工测试</h3><p>由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。</p>\n<p>不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。</p>\n<p><strong>9.1 Protractor</strong></p>\n<p>单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。</p>\n<p>我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。</p>\n<p>Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。</p>\n<p>我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。</p>\n<p><strong>9.2 Karma</strong></p>\n<p>一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。</p>\n<p>Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。</p>\n<h3 id=\"10-使用jQuery\"><a href=\"#10-使用jQuery\" class=\"headerlink\" title=\"10. 使用jQuery\"></a>10. 使用jQuery</h3><p>jQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。</p>\n<p>AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。</p>\n<p>为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。</p>\n<p>DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。</p>\n<p>但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>AngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。</p>\n<h3 id=\"1-MVC目录结构\"><a href=\"#1-MVC目录结构\" class=\"headerlink\" title=\"1. MVC目录结构\"></a>1. MVC目录结构</h3><p>AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">templates/</div><div class=\"line\">    _login.html</div><div class=\"line\">    _feed.html</div><div class=\"line\">app/</div><div class=\"line\">    app.js</div><div class=\"line\">    controllers/</div><div class=\"line\">        LoginController.js</div><div class=\"line\">        FeedController.js</div><div class=\"line\">    directives/</div><div class=\"line\">        FeedEntryDirective.js</div><div class=\"line\">    services/</div><div class=\"line\">        LoginService.js</div><div class=\"line\">        FeedService.js</div><div class=\"line\">    filters/</div><div class=\"line\">        CapatalizeFilter.js</div></pre></td></tr></table></figure>\n<p>看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。</p>\n<p>与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app/</div><div class=\"line\">    app.js</div><div class=\"line\">    Feed/</div><div class=\"line\">        _feed.html</div><div class=\"line\">        FeedController.js</div><div class=\"line\">        FeedEntryDirective.js</div><div class=\"line\">        FeedService.js</div><div class=\"line\">    Login/</div><div class=\"line\">        _login.html</div><div class=\"line\">        LoginController.js</div><div class=\"line\">        LoginService.js</div><div class=\"line\">    Shared/</div><div class=\"line\">        CapatalizeFilter.js</div></pre></td></tr></table></figure>\n<p>这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。</p>\n<h3 id=\"2-模块\"><a href=\"#2-模块\" class=\"headerlink\" title=\"2. 模块\"></a>2. 模块</h3><p>将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\">app.service(&apos;MyService&apos;, function()&#123;</div><div class=\"line\">    </div><div class=\"line\">//service code</div><div class=\"line\">&#125;);</div><div class=\"line\">app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</div><div class=\"line\">    </div><div class=\"line\">//controller code</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在此之后，一个常见的策略是对相同类型的对象归类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var services = angular.module(&apos;services&apos;,[]);</div><div class=\"line\">services.service(&apos;MyService&apos;, function()&#123;</div><div class=\"line\">    </div><div class=\"line\">//service code</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);</div><div class=\"line\">controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</div><div class=\"line\">    </div><div class=\"line\">//controller code</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]);</div></pre></td></tr></table></figure>\n<p>这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);</div><div class=\"line\">sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);</div><div class=\"line\">loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);</div><div class=\"line\">loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]);</div></pre></td></tr></table></figure>\n<p>当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。</p>\n<h3 id=\"3-依赖注入\"><a href=\"#3-依赖注入\" class=\"headerlink\" title=\"3. 依赖注入\"></a>3. 依赖注入</h3><p>依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\"> </div><div class=\"line\">app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123;</div><div class=\"line\">    $timeout(function()&#123;</div><div class=\"line\">        console.log($scope);</div><div class=\"line\">    &#125;, 1000);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里，很明显，MainCtrl依赖$scope和$timeout。</p>\n<p>直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app=angular.module(&quot;app&quot;,[]);</div><div class=\"line\">app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;)</div></pre></td></tr></table></figure>\n<p>现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123;</div><div class=\"line\">    $timeout(function()&#123;</div><div class=\"line\">        console.log($scope);</div><div class=\"line\">    &#125;, 1000);</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure>\n<p>这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;])</div></pre></td></tr></table></figure>\n<p><strong>3.1 全局依赖</strong></p>\n<p>在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。</p>\n<p>使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。</p>\n<p>Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var underscore = angular.module(&apos;underscore&apos;, []);</div><div class=\"line\">underscore.factory(&apos;_&apos;, function() &#123;</div><div class=\"line\">  return window._; </div><div class=\"line\">//Underscore must already be loaded on the page</div><div class=\"line\">&#125;);</div><div class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);</div><div class=\"line\"> </div><div class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123;</div><div class=\"line\">    init = function() &#123;</div><div class=\"line\">          _.keys($scope);</div><div class=\"line\">      &#125;</div><div class=\"line\"> </div><div class=\"line\">      init();</div><div class=\"line\">&#125;]);</div></pre></td></tr></table></figure>\n<p>这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。</p>\n<p>这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。</p>\n<h3 id=\"4-控制器膨胀\"><a href=\"#4-控制器膨胀\" class=\"headerlink\" title=\"4. 控制器膨胀\"></a>4. 控制器膨胀</h3><p>控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。</p>\n<p>数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。</p>\n<p>AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。</p>\n<h3 id=\"5-Service-vs-Factory\"><a href=\"#5-Service-vs-Factory\" class=\"headerlink\" title=\"5. Service vs Factory\"></a>5. Service vs Factory</h3><p>几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！</p>\n<p>以下是它们在AngularJS源代码中的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function factory(name, factoryFn) &#123; </div><div class=\"line\">    return provider(name, &#123; $get: factoryFn &#125;); </div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">function service(name, constructor) &#123;</div><div class=\"line\">    return factory(name, [&apos;$injector&apos;, function($injector) &#123;</div><div class=\"line\">      return $injector.instantiate(constructor);</div><div class=\"line\">    &#125;]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。</p>\n<p>由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。</p>\n<p>以下是一个例子，展示了一个service和一个factory如何完成相同的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = angular.module(&apos;app&apos;,[]);</div><div class=\"line\"> </div><div class=\"line\">app.service(&apos;helloWorldService&apos;, function()&#123;</div><div class=\"line\">    this.hello = function() &#123;</div><div class=\"line\">        return &quot;Hello World&quot;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">app.factory(&apos;helloWorldFactory&apos;, function()&#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        hello: function() &#123;</div><div class=\"line\">            return &quot;Hello World&quot;;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。</p>\n<p>既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;helloFactory&apos;, function() &#123;</div><div class=\"line\">    return function(name) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\"> </div><div class=\"line\">        this.hello = function() &#123;</div><div class=\"line\">            return &quot;Hello &quot; + this.name;</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123;</div><div class=\"line\">    init = function() &#123;</div><div class=\"line\">      helloWorldService.hello(); </div><div class=\"line\">//&apos;Hello World&apos;</div><div class=\"line\">      helloWorldFactory.hello(); </div><div class=\"line\">//&apos;Hello World&apos;</div><div class=\"line\">      new helloFactory(&apos;Readers&apos;).hello() </div><div class=\"line\">//&apos;Hello Readers&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    init();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在初学时，最好只使用service。</p>\n<p>Factory在设计一个包含很多私有方法的类时也很有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.factory(&apos;privateFactory&apos;, function()&#123;</div><div class=\"line\">    var privateFunc = function(name) &#123;</div><div class=\"line\">        return name.split(&quot;&quot;).reverse().join(&quot;&quot;); </div><div class=\"line\">//reverses the name</div><div class=\"line\">    &#125;;</div><div class=\"line\"> </div><div class=\"line\">    return &#123;</div><div class=\"line\">        hello: function(name)&#123;</div><div class=\"line\">          return &quot;Hello &quot; + privateFunc(name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。</p>\n<h3 id=\"6-没有使用Batarang\"><a href=\"#6-没有使用Batarang\" class=\"headerlink\" title=\"6. 没有使用Batarang\"></a>6. 没有使用Batarang</h3><p>Batarang是一个出色的Chrome插件，用来开发和测试AngularJS app。</p>\n<p>Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。</p>\n<p>Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。</p>\n<p>最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。</p>\n<h3 id=\"7-过多的watcher\"><a href=\"#7-过多的watcher\" class=\"headerlink\" title=\"7. 过多的watcher\"></a>7. 过多的watcher</h3><p>在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）</p>\n<p>以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function () &#123; </div><div class=\"line\">    var root = $(document.getElementsByTagName(&apos;body&apos;));</div><div class=\"line\">    var watchers = [];</div><div class=\"line\"> </div><div class=\"line\">    var f = function (element) &#123;</div><div class=\"line\">        if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123;</div><div class=\"line\">            angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123;</div><div class=\"line\">                watchers.push(watcher);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        angular.forEach(element.children(), function (childElement) &#123;</div><div class=\"line\">            f($(childElement));</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;;</div><div class=\"line\"> </div><div class=\"line\">    f(root);</div><div class=\"line\"> </div><div class=\"line\">    console.log(watchers.length);</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。</p>\n<p>当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。</p>\n<h3 id=\"8-限定-scope的范围\"><a href=\"#8-限定-scope的范围\" class=\"headerlink\" title=\"8. 限定$scope的范围\"></a>8. 限定$scope的范围</h3><p>Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）</p>\n<p>由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。</p>\n<p>比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</div><div class=\"line\">   &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</div><div class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</div><div class=\"line\">        &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</div><div class=\"line\">        &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt;</div><div class=\"line\">   &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？</p>\n<p>如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。</p>\n<p>当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）</p>\n<p>所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</div><div class=\"line\">   &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</div><div class=\"line\">        &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">        &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt;</div><div class=\"line\">   &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。</p>\n<p>这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。</p>\n<h3 id=\"9-手工测试\"><a href=\"#9-手工测试\" class=\"headerlink\" title=\"9. 手工测试\"></a>9. 手工测试</h3><p>由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。</p>\n<p>不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。</p>\n<p><strong>9.1 Protractor</strong></p>\n<p>单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。</p>\n<p>我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。</p>\n<p>Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。</p>\n<p>我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。</p>\n<p><strong>9.2 Karma</strong></p>\n<p>一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。</p>\n<p>Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。</p>\n<h3 id=\"10-使用jQuery\"><a href=\"#10-使用jQuery\" class=\"headerlink\" title=\"10. 使用jQuery\"></a>10. 使用jQuery</h3><p>jQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。</p>\n<p>AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。</p>\n<p>为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。</p>\n<p>DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。</p>\n<p>但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。</p>\n"},{"title":"Angularjs指令实践","date":"2016-08-02T16:00:00.000Z","_content":"\n指令（Directives）是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。这篇教程会为你讲述如何自定义指令，以及介绍如何在实际项目中使用。在这篇文章的最后，我会指导你如何使用Angular指令来创建一个简单的记事本应用。\n\n### 概述\n\n一个指令用来引入新的HTML语法。指令是DOM元素上的标记，使元素拥有特定的行为。举例来说，静态的HTML不知道如何来创建和展现一个日期选择器控件。让HTML能识别这个语法，我们需要使用指令。指令通过某种方法来创建一个能够支持日期选择的元素。我们会循序渐进地介绍这是如何实现的。 如果你写过AngularJS的应用，那么你一定已经使用过指令，不管你有没有意识到。你肯定已经用过简单的指令，比如 ng-mode, ng-repeat, ng-show等。这些指令都赋予DOM元素特定的行为。例如，ng-repeat 重复特定的元素，ng-show 有条件地显示一个元素。如果你想让一个元素支持拖拽，你也需要创建一个指令来实现它。指令背后基本的想法很简单。它通过对元素绑定事件监听或者改变DOM而使HTML拥有真实的交互性。\n\n### jQuery视角\n\n想象一下使用jQuery如何创建一个日期选择器。首先，我们在HTML中添加一个普通的输入框，然后通过jQuery调用 $(element).dataPicker() 来将它转变成一个日期选择器。但是，仔细想一下。当一个设计人员过来检查HTML标记的时候，他/她能否立刻猜到这个字段实际上表示的内容？这只是一个简单的输入框，或者一个日期选择器？你需要查看jQuery代码来确定这些。而Angular的方法是使用一个指令来扩展HTML。所以，一个日期选择器的指令可以是下面的形式：\n\n```html\n<input type=\"text\" />\n```\n\n创建自定义指令：这种创建UI组建的方式更加直接和清晰。你可以轻易地通过查看元素就明白这到底是什么。\n\n一个Angular指令可以有以下的四种表现形式：\n\n1. 一个新的HTML元素（`<data-picker></data-picker>`）\n\n2. 元素的属性（`<input type=”text” data-picker/>`）\n\n3. CSS class（`<input type=”text” class=”data-picker”/>`）\n\n4. 注释（`<!–directive:data-picker –>`）\n\n当然，我们可以控制我们的指令在HTML中的表现形式。下面我们来看一下AngularJS中的一个典型的指令的写法。指令注册的方式与 controller 一样，但是它返回的是一个拥有指令配置属性的简单对象(指令定义对象) 。下面的代码是一个简单的 [Hello World](http://www.codeceo.com/article/hello-world-30-years.html) 指令。\n\n```javascript\nvar app = angular.module('myapp', []);\napp.directive('helloWorld', function() {\n  return {\n      restrict: 'AE',\n      replace: 'true',\n      template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n在上面的代码中，app.directive()方法在模块中注册了一个新的指令。这个方法的第一个参数是这个指令的名字。第二个参数是一个返回指令定义对象的函数。如果你的指令依赖于其他的对象或者服务，比如 $rootScope, $http, 或者$compile，他们可以在这个时间被注入。这个指令在HTML中以一个元素使用，如下：\n\n```html\n<hello-world/>\n//OR\n<hello:world/>\n```\n\n或者，以一个属性的方式使用：\n\n```html\n<div hello-world></div>\n//OR\n<div hello:world/>\n```\n\n如果你想要符合HTML5的规范，你可以在元素前面添加 x- 或者 data-的前缀。所以下面的标记也会匹配 helloWorld 指令：\n\n```html\n<div data-hello-world></div>\n//OR\n<div x-hello-world></div>\n```\n\nrestrict – 这个属性用来指定指令在HTML中如何使用（还记得之前说的，指令的四种表示方式吗）。在上面的例子中，我们使用了 ‘AE’。所以这个指令可以被当作新的HTML元素或者属性来使用。如果要允许指令被当作class来使用，我们将 restrict 设置成 ‘AEC’。\n\n**注意：** 在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)表现形式，然后再与注册过的指令进行匹配。这是为什么，我们在HTML中以 hello-world 的方式使用 helloWorld 指令。其实，这跟HTML对标签和属性不区分大小写有关。 尽管上面的指令仅仅实现了静态文字的显示，但是这里还是有一些有趣的点值得我们去挖掘。我们在指令定义过程中使用了三个属性来配置指令。我们来一一介绍他们的作用。\n\n- template – 这个属性规定了指令被Angular编译和链接（link）后生成的HTML标记。这个属性值不一定要是简单的字符串。template 可以非常复杂，而且经常包含其他的指令，以及表达式等。更多的情况下你可能会见到 templateUrl， 而不是 template。所以，理想情况下，你应该将模板放到一个特定的HTML文件中，然后将 templateUrl 属性指向它。\n- replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。在我们的例子中，我们用 `<hello-world></hello-world>`的方式使用我们的指令，并且将 replace 设置成 true。所以，在指令被编译之后，生成的模板内容替换掉了 `<hello-world></hello-world>`。最终的输出是 `<h3>Hello World!!</h3>`。如果你将 replace 设置成 false，也就是默认值，那么生成的模板会被插入到定义指令的元素中。\n\n打开这个 [plunker](http://plnkr.co/edit/GKI339z2VDdZTOE2bGFP)，在”Hello World!!”右键检查元素内容，来更形象地明白这些。\n\n### Link函数和Scope\n\n指令生成出的模板其实没有太多意义，除非它在特定的scope下编译。默认情况下，指令并不会创建新的子scope。更多的，它使用父scope。也就是说，如果指令存在于一个controller下，它就会使用这个controller的scope。 如何运用scope，我们要用到一个叫做 link 的函数。它由指令定义对象中的link属性配置。让我们来改变一下我们的 helloWorld 指令，当用户在一个输入框中输入一种颜色的名称时，Hello World 文字的背景色自动发生变化。同时，当用户在 Hello World 文字上点击时，背景色变回白色。 相应的HTML标记如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\" />\n  <hello-world/>\n</body>\n```\n\nJavaScript修改后的 helloWorld 指令如下：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    restrict: 'AE',\n    replace: true,\n    template: '<p style=\"background-color:{ {color} }\">Hello World',\n    link: function(scope, elem, attrs) {\n      elem.bind('click', function() {\n        elem.css('background-color', 'white');\n        scope.$apply(function() {\n          scope.color = \"white\";\n        });\n      });\n      elem.bind('mouseover', function() {\n        elem.css('cursor', 'pointer');\n      });\n    }\n  };\n});\n```\n\nscope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。我们注意到指令定义中的 link 函数。 它有三个参数：\n\n- elem – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行包装。\n- attr – 一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性：，那么可以在 link 函数中通过 attrs.someAttribute 来使用它。\n\nlink函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM。在上面的指令代码片段中，我们添加了两个事件， click，和 mouseover。click 处理函数用来重置 `<p>` 的背景色，而 mouseover 处理函数改变鼠标为 pointer。在模板中有一个表达式 `{ {color} }`，当父scope中的 color 发生变化时，它用来改变 Hello World 文字的背景色。 这个 plunker 演示了这些概念。\n\n### compile函数\n\ncompile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：\n\n- tElement – 指令所在的元素\n- attrs – 元素上赋予的参数的标准化列表\n\n要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。compile函数可以写成如下的形式：\n\n```javascript\napp.directive('test', function() {\n  return {\n    compile: function(tElem,attrs) {\n      //do optional DOM transformation here\n      return function(scope,elem,attrs) {\n        //linking function here\n      };\n    }\n  };\n});\n```\n\n指令是如何被编译的大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的！\n\n当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。\n\n### 改变指令的Scope\n\n默认情况下，指令获取它父节点的controller的scope。但这并不适用于所有情况。如果将父controller的scope暴露给指令，那么他们可以随意地修改 scope 的属性。在某些情况下，你的指令希望能够添加一些仅限内部使用的属性和方法。如果我们在父的scope中添加，会污染父scope。 其实我们还有两种选择：\n\n- 一个子scope – 这个scope原型继承子父scope。\n- 一个隔离的scope – 一个孤立存在不继承自父scope的scope。\n\n这样的scope可以通过指令定义对象中 scope 属性来配置。下面的代码片段是一个例子：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: true,  // use a child scope that inherits from parent\n    restrict: 'AE',\n    replace: 'true',\n    template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n上面的代码，让Angular给指令创建一个继承自父socpe的新的子scope。 另外一个选择，隔离的scope：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {},  // use a new isolated scope\n    restrict: 'AE',\n    replace: 'true',\n    template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n这个指令使用了一个隔离的scope。隔离的scope在我们想要创建可重用的指令的时候是非常有好处的。通过使用隔离的scope，我们能够保证我们的指令是自包含的，可以被很容易的插入到HTML应用中。 它内部不能访问父的scope，所保证了父scope不被污染。 在我们的 helloWorld 指令例子中，如果我们将 scope 设置成 {}，那么上面的代码将不会工作。 它会创建一个新的隔离的scope，那么相应的表达式 `{ {color} }` 会指向到这个新的scope中，它的值将是 undefined. 使用隔离的scope并不意味着我们完全不能访问父scope的属性。\n\n### 隔离scope和父scope之间的数据绑定\n\n通常，隔离指令的scope会带来很多的便利，尤其是在你要操作多个scope模型的时候。但有时为了使代码能够正确工作，你也需要从指令内部访问父scope的属性。好消息是Angular给了你足够的灵活性让你能够有选择性的通过绑定的方式传入父scope的属性。让我们重温一下我们的 [helloWorld](http://plnkr.co/edit/14q6WxHyhWuVxEIqwww1?p=preview) 指令，它的背景色会随着用户在输入框中输入的颜色名称而变化。还记得当我们对这个指令使用隔离scope的之后，它不能工作了吗？现在，我们来让它恢复正常。\n\n假设我们已经初始化完成app这个变量所指向的Angular模块。那么我们的 helloWorld 指令如下面代码所示：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    replace: true,\n    template: '<p style=\"background-color:{ {color} }\">Hello World</p>',\n    link: function(scope, elem, attrs) {\n      elem.bind('click', function() {\n        elem.css('background-color','white');\n        scope.$apply(function() {\n          scope.color = \"white\";\n        });\n      });\n      elem.bind('mouseover', function() {\n        elem.css('cursor', 'pointer');\n      });\n    }\n  };\n});\n```\n\n使用这个指令的HTML标签如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world/>\n</body>\n```\n\n**选择一：**使用 @ 实现单向文本绑定上面的代码现在是不能工作的。因为我们用了一个隔离的scope，指令内部的 `{ {color} }` 表达式被隔离在指令内部的scope中(不是父scope)。但是外面的输入框元素中的 ng-model 指令是指向父scope中的 color 属性的。所以，我们需要一种方式来绑定隔离scope和父scope中的这两个参数。在Angular中，这种数据绑定可以通过为指令所在的HTML元素添加属性和并指令定义对象中配置相应的 scope 属性来实现。让我们来细究一下建立数据绑定的几种方式。`\n\n在下面的指令定义中，我们指定了隔离scope中的属性 color 绑定到指令所在HTML元素上的参数 colorAttr。在HTML标记中，你可以看到 `{ {color} }`表达式被指定给了 color-attr 参数。当表达式的值发生改变时，color-attr 参数也跟着改变。隔离scope中的 color 属性的值也相应地被改变。\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '@colorAttr'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n更新后的HTML标记代码如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world color-attr=\"{ {color} }\"/>\n</body>\n```\n\n注意点：我们称这种方式为单项绑定，是因为在这种方式下，你只能将字符串(使用表达式`{ {} }`)传递给参数。当父scope的属性变化时，你的隔离scope模型中的属性值跟着变化。你甚至可以在指令内部监控这个scope属性的变化，并且触发一些任务。然而，反向的传递并不工作。你不能通过对隔离scope属性的操作来改变父scope的值。\n\n当隔离scope属性和指令元素参数的名字一样是，你可以更简单的方式设置scope绑定：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '@'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应使用指令的HTML代码如下：\n\n```html\n<hello-world color=\"{ {color} }\"/>\n```\n\n**选择二：**使用 = 实现双向绑定\n\n让我们将指令的定义改变成下面的样子：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '='\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应的HTML修改如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world color=\"color\"/>\n</body>\n```\n\n**选择三：**使用 & 在父scope中执行函数与 @ 不同，这种方式让你能够给属性指定一个真实的scope数据模型，而不是简单的字符串。这样你就可以传递简单的字符串、数组、甚至复杂的对象给隔离scope。同时，还支持双向的绑定。每当父scope属性变化时，相对应的隔离scope中的属性也跟着改变，反之亦然。和之前的一样，你也可以监视这个scope属性的变化。\n\n有时候从隔离scope中调用父scope中定义的函数是非常有必要的。为了能够访问外部scope中定义的函数，我们使用 &。比如我们想要从指令内部调用 sayHello() 方法。下面的代码告诉我们该怎么做：\n\n```javascript\napp.directive('sayHello', function() {\n  return {\n    scope: {\n      sayHelloIsolated: '&amp;'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应的HTML代码如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <say-hello sayHelloIsolated=\"sayHello()\"/>\n</body>\n```\n\n父scope、子scope以及隔离scope的区别这个 [Plunker](http://plnkr.co/edit/k4scWKwtGBJw7lfKGqVJ?p=preview) 例子对上面的概念做了很好的诠释。\n\n作为一个Angular的新手，你可能会在选择正确的指令scope的时候感到困惑。默认情况下，指令不会创建一个新的scope，而是沿用父scope。但是在很多情况下，这并不是我们想要的。如果你的指令重度地使用父scope的属性、甚至创建新的属性，会污染父scope。让所有的指令都使用同一个父scope不会是一个好主意，因为任何人都可能修改这个scope中的属性。因此，下面的这个原则也许可以帮助你为你的指令选择正确的scope。\n\n1.父scope(scope: false) – 这是默认情况。如果你的指令不操作父scoe的属性，你就不需要一个新的scope。这种情况下是可以使用父scope的。\n\n2.子scope(scope: true) – 这会为指令创建一个新的scope，并且原型继承自父scope。如果你的指令scope中的属性和方法与其他的指令以及父scope都没有关系的时候，你应该创建一个新scope。在这种方式下，你同样拥有父scope中所定义的属性和方法。\n\n3.隔离scope(scope:{}) – 这就像一个沙箱！当你创建的指令是自包含的并且可重用的，你就需要使用这种scope。你在指令中会创建很多scope属性和方法，它们仅在指令内部使用，永远不会被外部的世界所知晓。如果是这样的话，隔离的scope是更好的选择。隔离的scope不会继承父scope。\n\n### Transclusion（嵌入）\n\nTransclusion是让我们的指令包含任意内容的方法。我们可以延时提取并在正确的scope下编译这些嵌入的内容，最终将它们放入指令模板中指定的位置。 如果你在指令定义中设置 transclude:true，一个新的嵌入的scope会被创建，它原型继承子父scope。 如果你想要你的指令使用隔离的scope，但是它所包含的内容能够在父scope中执行，transclusion也可以帮忙。\n\n假设我们注册一个如下的指令：\n\n```javascript\napp.directive('outputText', function() {\n  return {\n    transclude: true,\n    scope: {},\n    template: '<div ng-transclude></div>'\n  };\n});\n```\n\n它使用如下：\n\n```html\n<div output-text>\n  <p>Hello { {name} }</p>\n</div>\n```\n\ntransclude:’element’ 和 transclude:true的区别ng-transclude 指明在哪里放置被嵌入的内容。在这个例子中DOM内容 <p>Hello { {name} }</p> 被提取和放置到 <div ng-transclude></div> 内部。有一个很重要的点需要注意的是，表达式{ {name} }所对应的属性是在父scope中被定义的，而非子scope。你可以在这个Plunker例子中做一些实验。如果你想要学习更多关于scope的知识，可以阅读[这篇文章](https://github.com/angular/angular.js/wiki/Understanding-Scopes)。\n\n有时候我我们要嵌入指令元素本身，而不仅仅是它的内容。在这种情况下，我们需要使用 transclude:’element’。它和 transclude:true 不同，它将标记了 ng-transclude 指令的元素一起包含到了指令模板中。使用transclusion，你的link函数会获得一个名叫 transclude 的链接函数，这个函数绑定了正确的指令scope，并且传入了另一个拥有被嵌入DOM元素拷贝的函数。你可以在这个 transclude 函数中执行比如修改元素拷贝或者将它添加到DOM上等操作。 类似 ng-repeat 这样的指令使用这种方式来重复DOM元素。仔细研究一下这个Plunker，它使用这种方式复制了DOM元素，并且改变了第二个实例的背景色。\n\n同样需要注意的是，在使用 transclude:’element’的时候，指令所在的元素会被转换成HTML注释。所以，如果你结合使用 transclude:’element’ 和 replace:false，那么指令模板本质上是被添加到了注释的innerHTML中——也就是说其实什么都没有发生！相反，如果你选择使用 replace:true，指令模板会替换HTML注释，那么一切就会如果所愿的工作。使用 replade:false 和 transclue:’element’有时候也是有用的，比如当你需要重复DOM元素但是并不想保留第一个元素实例（它会被转换成注释）的情况下。对这块还有疑惑的同学可以阅读stackoverflow上的[这篇讨论](http://stackoverflow.com/questions/18449743/when-to-use-transclude-true-and-transclude-element)，介绍的比较清晰。\n\n### controller 函数和 require\n\n如果你想要允许其他的指令和你的指令发生交互时，你需要使用 controller 函数。比如有些情况下，你需要通过组合两个指令来实现一个UI组件。那么你可以通过如下的方式来给指令添加一个 controller 函数。\n\n```javascript\napp.directive('outerDirective', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    controller: function($scope, $compile, $http) {\n      // $scope is the appropriate scope for the directive\n      this.addChild = function(nestedDirective) { // this refers to the controller\n        console.log('Got the message from nested directive:' + nestedDirective.message);\n      };\n    }\n  };\n});\n```\n\nJavaScript这个代码为指令添加了一个名叫 outerDirective 的controller。当另一个指令想要交互时，它需要声明它对你的指令 controller 实例的引用(require)。可以通过如下的方式实现：\n\n```javascript\napp.directive('innerDirective', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    require: '^outerDirective',\n    link: function(scope, elem, attrs, controllerInstance) {\n      //the fourth argument is the controller instance you require\n      scope.message = \"Hi, Parent directive\";\n      controllerInstance.addChild(scope);\n    }\n  };\n});\n```\n\n相应的HTML代码如下：\n\n```html\n<outer-directive>   <inner-directive></inner-directive> </outer-directive>\n```\n\nrequire: ‘^outerDirective’ 告诉Angular在元素以及它的父元素中搜索controller。这样被找到的 controller 实例会作为第四个参数被传入到 link 函数中。在我们的例子中，我们将嵌入的指令的scope发送给父亲指令。如果你想尝试这个代码的话，请在开启浏览器控制台的情况下打开这个Plunker。同时，[这篇Angular官方文档](http://docs.angularjs.org/guide/directive)上的最后部分给了一个非常好的关于指令交互的例子，是非常值得一读的。\n\n### 一个记事本应用\n\n这一部分，我们使用Angular指令创建一个简单的记事本应用。我们会使用HTML5的 localStorage 来存储笔记。最终的产品在[这里](http://embed.plnkr.co/QvxI4LbqfUY3C3XQjN3m/preview)，你可以先睹为快。\n\n我们会创建一个展现记事本的指令。用户可以查看他/她创建过的笔记记录。当他点击 add new 按钮的时候，记事本会进入可编辑状态，并且允许创建新的笔记。当点击 back 按钮的时候，新的笔记会被自动保存。笔记的保存使用了一个名叫 noteFactory 的工厂类，它使用了 localStorage。工厂类中的代码是非常直接和可理解的。所以我们就集中讨论指令的代码。\n\n### 第一步\n\n我们从注册 notepad 指令开始。\n\n```javascript\napp.directive('notepad', function(notesFactory) {\n  return {\n    restrict: 'AE',\n    scope: {},\n    link: function(scope, elem, attrs) {\n    },\n    templateUrl: 'templateurl.html'\n  };\n});\n```\n\n因为我们想让指令可重用，所以选择使用隔离的scope。这个指令可以拥有很多与外界没有关联的属性和方法。这里有几点需要注意的：\n\n- 这个指令可以以属性或者元素的方式被使用，这个被定义在 restrict 属性中。\n- 现在的link函数是空的\n- 这个指令从 templateurl.html 中获取指令模板\n\n### 第二步\n\n下面的HTML组成了指令的模板。\n\n```html\n<div class=\"note-area\" ng-show=\"!editMode\">\n  <ul>\n    <li ng-repeat=\"note in notes|orderBy:'id'\">\n      <a href=\"#\" ng-click=\"openEditor(note.id)\">{ {note.title} }</a>\n    </li>\n  </ul>\n</div>\n<div id=\"editor\" ng-show=\"editMode\" class=\"note-area\" contenteditable=\"true\" ng-bind=\"noteText\"></div>\n<span><a href=\"#\" ng-click=\"save()\" ng-show=\"editMode\">Back</a></span>\n<span><a href=\"#\" ng-click=\"openEditor()\" ng-show=\"!editMode\">Add Note</a></span>\n```\n\nnote 对象中封装了 title，id 和 content。几个重要的注意点：\n\n- ng-repeat 用来遍历 notes 中所有的笔记，并且按照自动生成的 id 属性进行升序排序。\n- 我们使用一个叫 editMode 的属性来指明我们现在在哪种模式下。在编辑模式下，这个属性的值为 true 并且可编辑的 div 节点会显示。用户在这里输入自己的笔记。\n- 如果 editMode 为 false，我们就在查看模式，显示所有的 notes。\n- 两个按钮也是基于 editMode 的值而显示和隐藏。\n- ng-click 指令用来响应按钮的点击事件。这些方法将和 editMode 一起添加到scope中。\n- 可编辑的 div 框与 noteText 相绑定，存放了用户输入的文本。如果你想编辑一个已存在的笔记，那么这个模型会用它的文本内容初始化这个 div 框。\n\n### 第三步\n\n我们在scope中创建一个名叫 restore() 的新函数，它用来初始化我们应用中的各种控制器。 它会在 link 函数执行的时候被调用，也会在 save 按钮被点击的时候调用。\n\n```javascript\nscope.restore = function() {\n  scope.editMode = false;\n  scope.index = -1;\n  scope.noteText = '';\n};\n```\n\n### 第四步\n\n我们在 link 函数的内部创建这个函数。 editMode 和 noteText 之前已经解释过了。 index 用来跟踪当前正在编辑的笔记。 当我们在创建一个新的笔记的时候，index 的值会设成 -1. 我们在编辑一个已存在的笔记的时候，它包含了那个 note 对象的 id 值。\n\n现在我们要创建两个scope函数来处理编辑和保存操作。\n\n```javascript\nscope.openEditor = function(index) {\n  scope.editMode = true;\n  if (index !== undefined) {\n    scope.noteText = notesFactory.get(index).content;\n    scope.index = index;\n  } else {\n    scope.noteText = undefined;\n  }\n};\nscope.save = function() {\n  if (scope.noteText !== '') {\n    var note = {};\n    note.title = scope.noteText.length > 10 ? scope.noteText.substring(0, 10) + '. . .' : scope.noteText;\n    note.content = scope.noteText;\n    note.id = scope.index != -1 ? scope.index : localStorage.length;\n    scope.notes = notesFactory.put(note);\n  }\n  scope.restore();\n};\n```\n\nopenEditor 为编辑器做准备工作。如果我们在编辑一个笔记，它会获取当前笔记的内容并且通过使用 ng-bind 将内容更新到可编辑的 div 中。这两个函数有几点需要注意：\n\n- 如果我们在创建一个新的笔记，我们会将 noteText 设置成 undefined，以便当我们在保存笔记的时候，触发相应的监听器。\n- 如果 index 参数是 undefined，它表明用户正在创建一个新的笔记。\n- save 函数通过使用 notesFactory 来存储笔记。在保存完成后，它会刷新 notes 数组，从而监听器能够监测到笔记列表的变化，来及时更新。\n- save 函数调用在重置 controllers 之后调用restore()，从而可以从编辑模式进入查看模式。\n\n### 第五步\n\n在 link 函数执行时，我们初始化 notes 数组，并且为可编辑的 div 框绑定一个 keydown 事件，从而保证我们的 nodeText 模型与 div 中的内容保持同步。我们使用这个 noteText 来保存我们的笔记内容。\n\n```javascript\nvar editor = elem.find('#editor');\nscope.restore();  // initialize our app controls\nscope.notes = notesFactory.getAll(); // load notes\neditor.bind('keyup keydown', function() {\n  scope.noteText = editor.text().trim();\n});\n```\n\n### 第六步\n\n最后，我们在HTML如同使用其他的HTML元素一样使用我们的指令，然后开始做笔记吧。\n\n```html\n<h1 class=\"title\">The Note Making App</h1>\n<notepad/>\n```\n\n源码下载：[https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip](https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip)\n\n### 总结\n\n一个很重要的点需要注意的是，任何使用jQuery能做的事情，我们都能用Angular指令来做到，并且使用更少的代码。所以，在使用jQuery之前，请考虑一下我们能否在不进行DOM操作的情况下以更好的方式来完成任务。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/angularjs-command-learn.html)","source":"_posts/AngularJS指令实践.md","raw":"---\ntitle: Angularjs指令实践\ntags: [javascript,angularjs]\ndate: 2016/08/03\n---\n\n指令（Directives）是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。这篇教程会为你讲述如何自定义指令，以及介绍如何在实际项目中使用。在这篇文章的最后，我会指导你如何使用Angular指令来创建一个简单的记事本应用。\n\n### 概述\n\n一个指令用来引入新的HTML语法。指令是DOM元素上的标记，使元素拥有特定的行为。举例来说，静态的HTML不知道如何来创建和展现一个日期选择器控件。让HTML能识别这个语法，我们需要使用指令。指令通过某种方法来创建一个能够支持日期选择的元素。我们会循序渐进地介绍这是如何实现的。 如果你写过AngularJS的应用，那么你一定已经使用过指令，不管你有没有意识到。你肯定已经用过简单的指令，比如 ng-mode, ng-repeat, ng-show等。这些指令都赋予DOM元素特定的行为。例如，ng-repeat 重复特定的元素，ng-show 有条件地显示一个元素。如果你想让一个元素支持拖拽，你也需要创建一个指令来实现它。指令背后基本的想法很简单。它通过对元素绑定事件监听或者改变DOM而使HTML拥有真实的交互性。\n\n### jQuery视角\n\n想象一下使用jQuery如何创建一个日期选择器。首先，我们在HTML中添加一个普通的输入框，然后通过jQuery调用 $(element).dataPicker() 来将它转变成一个日期选择器。但是，仔细想一下。当一个设计人员过来检查HTML标记的时候，他/她能否立刻猜到这个字段实际上表示的内容？这只是一个简单的输入框，或者一个日期选择器？你需要查看jQuery代码来确定这些。而Angular的方法是使用一个指令来扩展HTML。所以，一个日期选择器的指令可以是下面的形式：\n\n```html\n<input type=\"text\" />\n```\n\n创建自定义指令：这种创建UI组建的方式更加直接和清晰。你可以轻易地通过查看元素就明白这到底是什么。\n\n一个Angular指令可以有以下的四种表现形式：\n\n1. 一个新的HTML元素（`<data-picker></data-picker>`）\n\n2. 元素的属性（`<input type=”text” data-picker/>`）\n\n3. CSS class（`<input type=”text” class=”data-picker”/>`）\n\n4. 注释（`<!–directive:data-picker –>`）\n\n当然，我们可以控制我们的指令在HTML中的表现形式。下面我们来看一下AngularJS中的一个典型的指令的写法。指令注册的方式与 controller 一样，但是它返回的是一个拥有指令配置属性的简单对象(指令定义对象) 。下面的代码是一个简单的 [Hello World](http://www.codeceo.com/article/hello-world-30-years.html) 指令。\n\n```javascript\nvar app = angular.module('myapp', []);\napp.directive('helloWorld', function() {\n  return {\n      restrict: 'AE',\n      replace: 'true',\n      template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n在上面的代码中，app.directive()方法在模块中注册了一个新的指令。这个方法的第一个参数是这个指令的名字。第二个参数是一个返回指令定义对象的函数。如果你的指令依赖于其他的对象或者服务，比如 $rootScope, $http, 或者$compile，他们可以在这个时间被注入。这个指令在HTML中以一个元素使用，如下：\n\n```html\n<hello-world/>\n//OR\n<hello:world/>\n```\n\n或者，以一个属性的方式使用：\n\n```html\n<div hello-world></div>\n//OR\n<div hello:world/>\n```\n\n如果你想要符合HTML5的规范，你可以在元素前面添加 x- 或者 data-的前缀。所以下面的标记也会匹配 helloWorld 指令：\n\n```html\n<div data-hello-world></div>\n//OR\n<div x-hello-world></div>\n```\n\nrestrict – 这个属性用来指定指令在HTML中如何使用（还记得之前说的，指令的四种表示方式吗）。在上面的例子中，我们使用了 ‘AE’。所以这个指令可以被当作新的HTML元素或者属性来使用。如果要允许指令被当作class来使用，我们将 restrict 设置成 ‘AEC’。\n\n**注意：** 在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)表现形式，然后再与注册过的指令进行匹配。这是为什么，我们在HTML中以 hello-world 的方式使用 helloWorld 指令。其实，这跟HTML对标签和属性不区分大小写有关。 尽管上面的指令仅仅实现了静态文字的显示，但是这里还是有一些有趣的点值得我们去挖掘。我们在指令定义过程中使用了三个属性来配置指令。我们来一一介绍他们的作用。\n\n- template – 这个属性规定了指令被Angular编译和链接（link）后生成的HTML标记。这个属性值不一定要是简单的字符串。template 可以非常复杂，而且经常包含其他的指令，以及表达式等。更多的情况下你可能会见到 templateUrl， 而不是 template。所以，理想情况下，你应该将模板放到一个特定的HTML文件中，然后将 templateUrl 属性指向它。\n- replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。在我们的例子中，我们用 `<hello-world></hello-world>`的方式使用我们的指令，并且将 replace 设置成 true。所以，在指令被编译之后，生成的模板内容替换掉了 `<hello-world></hello-world>`。最终的输出是 `<h3>Hello World!!</h3>`。如果你将 replace 设置成 false，也就是默认值，那么生成的模板会被插入到定义指令的元素中。\n\n打开这个 [plunker](http://plnkr.co/edit/GKI339z2VDdZTOE2bGFP)，在”Hello World!!”右键检查元素内容，来更形象地明白这些。\n\n### Link函数和Scope\n\n指令生成出的模板其实没有太多意义，除非它在特定的scope下编译。默认情况下，指令并不会创建新的子scope。更多的，它使用父scope。也就是说，如果指令存在于一个controller下，它就会使用这个controller的scope。 如何运用scope，我们要用到一个叫做 link 的函数。它由指令定义对象中的link属性配置。让我们来改变一下我们的 helloWorld 指令，当用户在一个输入框中输入一种颜色的名称时，Hello World 文字的背景色自动发生变化。同时，当用户在 Hello World 文字上点击时，背景色变回白色。 相应的HTML标记如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\" />\n  <hello-world/>\n</body>\n```\n\nJavaScript修改后的 helloWorld 指令如下：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    restrict: 'AE',\n    replace: true,\n    template: '<p style=\"background-color:{ {color} }\">Hello World',\n    link: function(scope, elem, attrs) {\n      elem.bind('click', function() {\n        elem.css('background-color', 'white');\n        scope.$apply(function() {\n          scope.color = \"white\";\n        });\n      });\n      elem.bind('mouseover', function() {\n        elem.css('cursor', 'pointer');\n      });\n    }\n  };\n});\n```\n\nscope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。我们注意到指令定义中的 link 函数。 它有三个参数：\n\n- elem – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行包装。\n- attr – 一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性：，那么可以在 link 函数中通过 attrs.someAttribute 来使用它。\n\nlink函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM。在上面的指令代码片段中，我们添加了两个事件， click，和 mouseover。click 处理函数用来重置 `<p>` 的背景色，而 mouseover 处理函数改变鼠标为 pointer。在模板中有一个表达式 `{ {color} }`，当父scope中的 color 发生变化时，它用来改变 Hello World 文字的背景色。 这个 plunker 演示了这些概念。\n\n### compile函数\n\ncompile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：\n\n- tElement – 指令所在的元素\n- attrs – 元素上赋予的参数的标准化列表\n\n要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。compile函数可以写成如下的形式：\n\n```javascript\napp.directive('test', function() {\n  return {\n    compile: function(tElem,attrs) {\n      //do optional DOM transformation here\n      return function(scope,elem,attrs) {\n        //linking function here\n      };\n    }\n  };\n});\n```\n\n指令是如何被编译的大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的！\n\n当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。\n\n### 改变指令的Scope\n\n默认情况下，指令获取它父节点的controller的scope。但这并不适用于所有情况。如果将父controller的scope暴露给指令，那么他们可以随意地修改 scope 的属性。在某些情况下，你的指令希望能够添加一些仅限内部使用的属性和方法。如果我们在父的scope中添加，会污染父scope。 其实我们还有两种选择：\n\n- 一个子scope – 这个scope原型继承子父scope。\n- 一个隔离的scope – 一个孤立存在不继承自父scope的scope。\n\n这样的scope可以通过指令定义对象中 scope 属性来配置。下面的代码片段是一个例子：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: true,  // use a child scope that inherits from parent\n    restrict: 'AE',\n    replace: 'true',\n    template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n上面的代码，让Angular给指令创建一个继承自父socpe的新的子scope。 另外一个选择，隔离的scope：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {},  // use a new isolated scope\n    restrict: 'AE',\n    replace: 'true',\n    template: '<h3>Hello World!!</h3>'\n  };\n});\n```\n\n这个指令使用了一个隔离的scope。隔离的scope在我们想要创建可重用的指令的时候是非常有好处的。通过使用隔离的scope，我们能够保证我们的指令是自包含的，可以被很容易的插入到HTML应用中。 它内部不能访问父的scope，所保证了父scope不被污染。 在我们的 helloWorld 指令例子中，如果我们将 scope 设置成 {}，那么上面的代码将不会工作。 它会创建一个新的隔离的scope，那么相应的表达式 `{ {color} }` 会指向到这个新的scope中，它的值将是 undefined. 使用隔离的scope并不意味着我们完全不能访问父scope的属性。\n\n### 隔离scope和父scope之间的数据绑定\n\n通常，隔离指令的scope会带来很多的便利，尤其是在你要操作多个scope模型的时候。但有时为了使代码能够正确工作，你也需要从指令内部访问父scope的属性。好消息是Angular给了你足够的灵活性让你能够有选择性的通过绑定的方式传入父scope的属性。让我们重温一下我们的 [helloWorld](http://plnkr.co/edit/14q6WxHyhWuVxEIqwww1?p=preview) 指令，它的背景色会随着用户在输入框中输入的颜色名称而变化。还记得当我们对这个指令使用隔离scope的之后，它不能工作了吗？现在，我们来让它恢复正常。\n\n假设我们已经初始化完成app这个变量所指向的Angular模块。那么我们的 helloWorld 指令如下面代码所示：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    replace: true,\n    template: '<p style=\"background-color:{ {color} }\">Hello World</p>',\n    link: function(scope, elem, attrs) {\n      elem.bind('click', function() {\n        elem.css('background-color','white');\n        scope.$apply(function() {\n          scope.color = \"white\";\n        });\n      });\n      elem.bind('mouseover', function() {\n        elem.css('cursor', 'pointer');\n      });\n    }\n  };\n});\n```\n\n使用这个指令的HTML标签如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world/>\n</body>\n```\n\n**选择一：**使用 @ 实现单向文本绑定上面的代码现在是不能工作的。因为我们用了一个隔离的scope，指令内部的 `{ {color} }` 表达式被隔离在指令内部的scope中(不是父scope)。但是外面的输入框元素中的 ng-model 指令是指向父scope中的 color 属性的。所以，我们需要一种方式来绑定隔离scope和父scope中的这两个参数。在Angular中，这种数据绑定可以通过为指令所在的HTML元素添加属性和并指令定义对象中配置相应的 scope 属性来实现。让我们来细究一下建立数据绑定的几种方式。`\n\n在下面的指令定义中，我们指定了隔离scope中的属性 color 绑定到指令所在HTML元素上的参数 colorAttr。在HTML标记中，你可以看到 `{ {color} }`表达式被指定给了 color-attr 参数。当表达式的值发生改变时，color-attr 参数也跟着改变。隔离scope中的 color 属性的值也相应地被改变。\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '@colorAttr'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n更新后的HTML标记代码如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world color-attr=\"{ {color} }\"/>\n</body>\n```\n\n注意点：我们称这种方式为单项绑定，是因为在这种方式下，你只能将字符串(使用表达式`{ {} }`)传递给参数。当父scope的属性变化时，你的隔离scope模型中的属性值跟着变化。你甚至可以在指令内部监控这个scope属性的变化，并且触发一些任务。然而，反向的传递并不工作。你不能通过对隔离scope属性的操作来改变父scope的值。\n\n当隔离scope属性和指令元素参数的名字一样是，你可以更简单的方式设置scope绑定：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '@'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应使用指令的HTML代码如下：\n\n```html\n<hello-world color=\"{ {color} }\"/>\n```\n\n**选择二：**使用 = 实现双向绑定\n\n让我们将指令的定义改变成下面的样子：\n\n```javascript\napp.directive('helloWorld', function() {\n  return {\n    scope: {\n      color: '='\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应的HTML修改如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <hello-world color=\"color\"/>\n</body>\n```\n\n**选择三：**使用 & 在父scope中执行函数与 @ 不同，这种方式让你能够给属性指定一个真实的scope数据模型，而不是简单的字符串。这样你就可以传递简单的字符串、数组、甚至复杂的对象给隔离scope。同时，还支持双向的绑定。每当父scope属性变化时，相对应的隔离scope中的属性也跟着改变，反之亦然。和之前的一样，你也可以监视这个scope属性的变化。\n\n有时候从隔离scope中调用父scope中定义的函数是非常有必要的。为了能够访问外部scope中定义的函数，我们使用 &。比如我们想要从指令内部调用 sayHello() 方法。下面的代码告诉我们该怎么做：\n\n```javascript\napp.directive('sayHello', function() {\n  return {\n    scope: {\n      sayHelloIsolated: '&amp;'\n    },\n    ....\n    // the rest of the configurations\n  };\n});\n```\n\n相应的HTML代码如下：\n\n```html\n<body ng-controller=\"MainCtrl\">\n  <input type=\"text\" ng-model=\"color\" placeholder=\"Enter a color\"/>\n  <say-hello sayHelloIsolated=\"sayHello()\"/>\n</body>\n```\n\n父scope、子scope以及隔离scope的区别这个 [Plunker](http://plnkr.co/edit/k4scWKwtGBJw7lfKGqVJ?p=preview) 例子对上面的概念做了很好的诠释。\n\n作为一个Angular的新手，你可能会在选择正确的指令scope的时候感到困惑。默认情况下，指令不会创建一个新的scope，而是沿用父scope。但是在很多情况下，这并不是我们想要的。如果你的指令重度地使用父scope的属性、甚至创建新的属性，会污染父scope。让所有的指令都使用同一个父scope不会是一个好主意，因为任何人都可能修改这个scope中的属性。因此，下面的这个原则也许可以帮助你为你的指令选择正确的scope。\n\n1.父scope(scope: false) – 这是默认情况。如果你的指令不操作父scoe的属性，你就不需要一个新的scope。这种情况下是可以使用父scope的。\n\n2.子scope(scope: true) – 这会为指令创建一个新的scope，并且原型继承自父scope。如果你的指令scope中的属性和方法与其他的指令以及父scope都没有关系的时候，你应该创建一个新scope。在这种方式下，你同样拥有父scope中所定义的属性和方法。\n\n3.隔离scope(scope:{}) – 这就像一个沙箱！当你创建的指令是自包含的并且可重用的，你就需要使用这种scope。你在指令中会创建很多scope属性和方法，它们仅在指令内部使用，永远不会被外部的世界所知晓。如果是这样的话，隔离的scope是更好的选择。隔离的scope不会继承父scope。\n\n### Transclusion（嵌入）\n\nTransclusion是让我们的指令包含任意内容的方法。我们可以延时提取并在正确的scope下编译这些嵌入的内容，最终将它们放入指令模板中指定的位置。 如果你在指令定义中设置 transclude:true，一个新的嵌入的scope会被创建，它原型继承子父scope。 如果你想要你的指令使用隔离的scope，但是它所包含的内容能够在父scope中执行，transclusion也可以帮忙。\n\n假设我们注册一个如下的指令：\n\n```javascript\napp.directive('outputText', function() {\n  return {\n    transclude: true,\n    scope: {},\n    template: '<div ng-transclude></div>'\n  };\n});\n```\n\n它使用如下：\n\n```html\n<div output-text>\n  <p>Hello { {name} }</p>\n</div>\n```\n\ntransclude:’element’ 和 transclude:true的区别ng-transclude 指明在哪里放置被嵌入的内容。在这个例子中DOM内容 <p>Hello { {name} }</p> 被提取和放置到 <div ng-transclude></div> 内部。有一个很重要的点需要注意的是，表达式{ {name} }所对应的属性是在父scope中被定义的，而非子scope。你可以在这个Plunker例子中做一些实验。如果你想要学习更多关于scope的知识，可以阅读[这篇文章](https://github.com/angular/angular.js/wiki/Understanding-Scopes)。\n\n有时候我我们要嵌入指令元素本身，而不仅仅是它的内容。在这种情况下，我们需要使用 transclude:’element’。它和 transclude:true 不同，它将标记了 ng-transclude 指令的元素一起包含到了指令模板中。使用transclusion，你的link函数会获得一个名叫 transclude 的链接函数，这个函数绑定了正确的指令scope，并且传入了另一个拥有被嵌入DOM元素拷贝的函数。你可以在这个 transclude 函数中执行比如修改元素拷贝或者将它添加到DOM上等操作。 类似 ng-repeat 这样的指令使用这种方式来重复DOM元素。仔细研究一下这个Plunker，它使用这种方式复制了DOM元素，并且改变了第二个实例的背景色。\n\n同样需要注意的是，在使用 transclude:’element’的时候，指令所在的元素会被转换成HTML注释。所以，如果你结合使用 transclude:’element’ 和 replace:false，那么指令模板本质上是被添加到了注释的innerHTML中——也就是说其实什么都没有发生！相反，如果你选择使用 replace:true，指令模板会替换HTML注释，那么一切就会如果所愿的工作。使用 replade:false 和 transclue:’element’有时候也是有用的，比如当你需要重复DOM元素但是并不想保留第一个元素实例（它会被转换成注释）的情况下。对这块还有疑惑的同学可以阅读stackoverflow上的[这篇讨论](http://stackoverflow.com/questions/18449743/when-to-use-transclude-true-and-transclude-element)，介绍的比较清晰。\n\n### controller 函数和 require\n\n如果你想要允许其他的指令和你的指令发生交互时，你需要使用 controller 函数。比如有些情况下，你需要通过组合两个指令来实现一个UI组件。那么你可以通过如下的方式来给指令添加一个 controller 函数。\n\n```javascript\napp.directive('outerDirective', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    controller: function($scope, $compile, $http) {\n      // $scope is the appropriate scope for the directive\n      this.addChild = function(nestedDirective) { // this refers to the controller\n        console.log('Got the message from nested directive:' + nestedDirective.message);\n      };\n    }\n  };\n});\n```\n\nJavaScript这个代码为指令添加了一个名叫 outerDirective 的controller。当另一个指令想要交互时，它需要声明它对你的指令 controller 实例的引用(require)。可以通过如下的方式实现：\n\n```javascript\napp.directive('innerDirective', function() {\n  return {\n    scope: {},\n    restrict: 'AE',\n    require: '^outerDirective',\n    link: function(scope, elem, attrs, controllerInstance) {\n      //the fourth argument is the controller instance you require\n      scope.message = \"Hi, Parent directive\";\n      controllerInstance.addChild(scope);\n    }\n  };\n});\n```\n\n相应的HTML代码如下：\n\n```html\n<outer-directive>   <inner-directive></inner-directive> </outer-directive>\n```\n\nrequire: ‘^outerDirective’ 告诉Angular在元素以及它的父元素中搜索controller。这样被找到的 controller 实例会作为第四个参数被传入到 link 函数中。在我们的例子中，我们将嵌入的指令的scope发送给父亲指令。如果你想尝试这个代码的话，请在开启浏览器控制台的情况下打开这个Plunker。同时，[这篇Angular官方文档](http://docs.angularjs.org/guide/directive)上的最后部分给了一个非常好的关于指令交互的例子，是非常值得一读的。\n\n### 一个记事本应用\n\n这一部分，我们使用Angular指令创建一个简单的记事本应用。我们会使用HTML5的 localStorage 来存储笔记。最终的产品在[这里](http://embed.plnkr.co/QvxI4LbqfUY3C3XQjN3m/preview)，你可以先睹为快。\n\n我们会创建一个展现记事本的指令。用户可以查看他/她创建过的笔记记录。当他点击 add new 按钮的时候，记事本会进入可编辑状态，并且允许创建新的笔记。当点击 back 按钮的时候，新的笔记会被自动保存。笔记的保存使用了一个名叫 noteFactory 的工厂类，它使用了 localStorage。工厂类中的代码是非常直接和可理解的。所以我们就集中讨论指令的代码。\n\n### 第一步\n\n我们从注册 notepad 指令开始。\n\n```javascript\napp.directive('notepad', function(notesFactory) {\n  return {\n    restrict: 'AE',\n    scope: {},\n    link: function(scope, elem, attrs) {\n    },\n    templateUrl: 'templateurl.html'\n  };\n});\n```\n\n因为我们想让指令可重用，所以选择使用隔离的scope。这个指令可以拥有很多与外界没有关联的属性和方法。这里有几点需要注意的：\n\n- 这个指令可以以属性或者元素的方式被使用，这个被定义在 restrict 属性中。\n- 现在的link函数是空的\n- 这个指令从 templateurl.html 中获取指令模板\n\n### 第二步\n\n下面的HTML组成了指令的模板。\n\n```html\n<div class=\"note-area\" ng-show=\"!editMode\">\n  <ul>\n    <li ng-repeat=\"note in notes|orderBy:'id'\">\n      <a href=\"#\" ng-click=\"openEditor(note.id)\">{ {note.title} }</a>\n    </li>\n  </ul>\n</div>\n<div id=\"editor\" ng-show=\"editMode\" class=\"note-area\" contenteditable=\"true\" ng-bind=\"noteText\"></div>\n<span><a href=\"#\" ng-click=\"save()\" ng-show=\"editMode\">Back</a></span>\n<span><a href=\"#\" ng-click=\"openEditor()\" ng-show=\"!editMode\">Add Note</a></span>\n```\n\nnote 对象中封装了 title，id 和 content。几个重要的注意点：\n\n- ng-repeat 用来遍历 notes 中所有的笔记，并且按照自动生成的 id 属性进行升序排序。\n- 我们使用一个叫 editMode 的属性来指明我们现在在哪种模式下。在编辑模式下，这个属性的值为 true 并且可编辑的 div 节点会显示。用户在这里输入自己的笔记。\n- 如果 editMode 为 false，我们就在查看模式，显示所有的 notes。\n- 两个按钮也是基于 editMode 的值而显示和隐藏。\n- ng-click 指令用来响应按钮的点击事件。这些方法将和 editMode 一起添加到scope中。\n- 可编辑的 div 框与 noteText 相绑定，存放了用户输入的文本。如果你想编辑一个已存在的笔记，那么这个模型会用它的文本内容初始化这个 div 框。\n\n### 第三步\n\n我们在scope中创建一个名叫 restore() 的新函数，它用来初始化我们应用中的各种控制器。 它会在 link 函数执行的时候被调用，也会在 save 按钮被点击的时候调用。\n\n```javascript\nscope.restore = function() {\n  scope.editMode = false;\n  scope.index = -1;\n  scope.noteText = '';\n};\n```\n\n### 第四步\n\n我们在 link 函数的内部创建这个函数。 editMode 和 noteText 之前已经解释过了。 index 用来跟踪当前正在编辑的笔记。 当我们在创建一个新的笔记的时候，index 的值会设成 -1. 我们在编辑一个已存在的笔记的时候，它包含了那个 note 对象的 id 值。\n\n现在我们要创建两个scope函数来处理编辑和保存操作。\n\n```javascript\nscope.openEditor = function(index) {\n  scope.editMode = true;\n  if (index !== undefined) {\n    scope.noteText = notesFactory.get(index).content;\n    scope.index = index;\n  } else {\n    scope.noteText = undefined;\n  }\n};\nscope.save = function() {\n  if (scope.noteText !== '') {\n    var note = {};\n    note.title = scope.noteText.length > 10 ? scope.noteText.substring(0, 10) + '. . .' : scope.noteText;\n    note.content = scope.noteText;\n    note.id = scope.index != -1 ? scope.index : localStorage.length;\n    scope.notes = notesFactory.put(note);\n  }\n  scope.restore();\n};\n```\n\nopenEditor 为编辑器做准备工作。如果我们在编辑一个笔记，它会获取当前笔记的内容并且通过使用 ng-bind 将内容更新到可编辑的 div 中。这两个函数有几点需要注意：\n\n- 如果我们在创建一个新的笔记，我们会将 noteText 设置成 undefined，以便当我们在保存笔记的时候，触发相应的监听器。\n- 如果 index 参数是 undefined，它表明用户正在创建一个新的笔记。\n- save 函数通过使用 notesFactory 来存储笔记。在保存完成后，它会刷新 notes 数组，从而监听器能够监测到笔记列表的变化，来及时更新。\n- save 函数调用在重置 controllers 之后调用restore()，从而可以从编辑模式进入查看模式。\n\n### 第五步\n\n在 link 函数执行时，我们初始化 notes 数组，并且为可编辑的 div 框绑定一个 keydown 事件，从而保证我们的 nodeText 模型与 div 中的内容保持同步。我们使用这个 noteText 来保存我们的笔记内容。\n\n```javascript\nvar editor = elem.find('#editor');\nscope.restore();  // initialize our app controls\nscope.notes = notesFactory.getAll(); // load notes\neditor.bind('keyup keydown', function() {\n  scope.noteText = editor.text().trim();\n});\n```\n\n### 第六步\n\n最后，我们在HTML如同使用其他的HTML元素一样使用我们的指令，然后开始做笔记吧。\n\n```html\n<h1 class=\"title\">The Note Making App</h1>\n<notepad/>\n```\n\n源码下载：[https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip](https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip)\n\n### 总结\n\n一个很重要的点需要注意的是，任何使用jQuery能做的事情，我们都能用Angular指令来做到，并且使用更少的代码。所以，在使用jQuery之前，请考虑一下我们能否在不进行DOM操作的情况下以更好的方式来完成任务。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/angularjs-command-learn.html)","slug":"AngularJS指令实践","published":1,"updated":"2016-08-17T06:22:19.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpht000h68ddzd0uewh7","content":"<p>指令（Directives）是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。这篇教程会为你讲述如何自定义指令，以及介绍如何在实际项目中使用。在这篇文章的最后，我会指导你如何使用Angular指令来创建一个简单的记事本应用。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>一个指令用来引入新的HTML语法。指令是DOM元素上的标记，使元素拥有特定的行为。举例来说，静态的HTML不知道如何来创建和展现一个日期选择器控件。让HTML能识别这个语法，我们需要使用指令。指令通过某种方法来创建一个能够支持日期选择的元素。我们会循序渐进地介绍这是如何实现的。 如果你写过AngularJS的应用，那么你一定已经使用过指令，不管你有没有意识到。你肯定已经用过简单的指令，比如 ng-mode, ng-repeat, ng-show等。这些指令都赋予DOM元素特定的行为。例如，ng-repeat 重复特定的元素，ng-show 有条件地显示一个元素。如果你想让一个元素支持拖拽，你也需要创建一个指令来实现它。指令背后基本的想法很简单。它通过对元素绑定事件监听或者改变DOM而使HTML拥有真实的交互性。</p>\n<h3 id=\"jQuery视角\"><a href=\"#jQuery视角\" class=\"headerlink\" title=\"jQuery视角\"></a>jQuery视角</h3><p>想象一下使用jQuery如何创建一个日期选择器。首先，我们在HTML中添加一个普通的输入框，然后通过jQuery调用 $(element).dataPicker() 来将它转变成一个日期选择器。但是，仔细想一下。当一个设计人员过来检查HTML标记的时候，他/她能否立刻猜到这个字段实际上表示的内容？这只是一个简单的输入框，或者一个日期选择器？你需要查看jQuery代码来确定这些。而Angular的方法是使用一个指令来扩展HTML。所以，一个日期选择器的指令可以是下面的形式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>创建自定义指令：这种创建UI组建的方式更加直接和清晰。你可以轻易地通过查看元素就明白这到底是什么。</p>\n<p>一个Angular指令可以有以下的四种表现形式：</p>\n<ol>\n<li><p>一个新的HTML元素（<code>&lt;data-picker&gt;&lt;/data-picker&gt;</code>）</p>\n</li>\n<li><p>元素的属性（<code>&lt;input type=”text” data-picker/&gt;</code>）</p>\n</li>\n<li><p>CSS class（<code>&lt;input type=”text” class=”data-picker”/&gt;</code>）</p>\n</li>\n<li><p>注释（<code>&lt;!–directive:data-picker –&gt;</code>）</p>\n</li>\n</ol>\n<p>当然，我们可以控制我们的指令在HTML中的表现形式。下面我们来看一下AngularJS中的一个典型的指令的写法。指令注册的方式与 controller 一样，但是它返回的是一个拥有指令配置属性的简单对象(指令定义对象) 。下面的代码是一个简单的 <a href=\"http://www.codeceo.com/article/hello-world-30-years.html\" target=\"_blank\" rel=\"external\">Hello World</a> 指令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</div><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">      replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">      template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在上面的代码中，app.directive()方法在模块中注册了一个新的指令。这个方法的第一个参数是这个指令的名字。第二个参数是一个返回指令定义对象的函数。如果你的指令依赖于其他的对象或者服务，比如 $rootScope, $http, 或者$compile，他们可以在这个时间被注入。这个指令在HTML中以一个元素使用，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello:world</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>或者，以一个属性的方式使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">hello:world</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你想要符合HTML5的规范，你可以在元素前面添加 x- 或者 data-的前缀。所以下面的标记也会匹配 helloWorld 指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">x-hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>restrict – 这个属性用来指定指令在HTML中如何使用（还记得之前说的，指令的四种表示方式吗）。在上面的例子中，我们使用了 ‘AE’。所以这个指令可以被当作新的HTML元素或者属性来使用。如果要允许指令被当作class来使用，我们将 restrict 设置成 ‘AEC’。</p>\n<p><strong>注意：</strong> 在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)表现形式，然后再与注册过的指令进行匹配。这是为什么，我们在HTML中以 hello-world 的方式使用 helloWorld 指令。其实，这跟HTML对标签和属性不区分大小写有关。 尽管上面的指令仅仅实现了静态文字的显示，但是这里还是有一些有趣的点值得我们去挖掘。我们在指令定义过程中使用了三个属性来配置指令。我们来一一介绍他们的作用。</p>\n<ul>\n<li>template – 这个属性规定了指令被Angular编译和链接（link）后生成的HTML标记。这个属性值不一定要是简单的字符串。template 可以非常复杂，而且经常包含其他的指令，以及表达式等。更多的情况下你可能会见到 templateUrl， 而不是 template。所以，理想情况下，你应该将模板放到一个特定的HTML文件中，然后将 templateUrl 属性指向它。</li>\n<li>replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。在我们的例子中，我们用 <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>的方式使用我们的指令，并且将 replace 设置成 true。所以，在指令被编译之后，生成的模板内容替换掉了 <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>。最终的输出是 <code>&lt;h3&gt;Hello World!!&lt;/h3&gt;</code>。如果你将 replace 设置成 false，也就是默认值，那么生成的模板会被插入到定义指令的元素中。</li>\n</ul>\n<p>打开这个 <a href=\"http://plnkr.co/edit/GKI339z2VDdZTOE2bGFP\" target=\"_blank\" rel=\"external\">plunker</a>，在”Hello World!!”右键检查元素内容，来更形象地明白这些。</p>\n<h3 id=\"Link函数和Scope\"><a href=\"#Link函数和Scope\" class=\"headerlink\" title=\"Link函数和Scope\"></a>Link函数和Scope</h3><p>指令生成出的模板其实没有太多意义，除非它在特定的scope下编译。默认情况下，指令并不会创建新的子scope。更多的，它使用父scope。也就是说，如果指令存在于一个controller下，它就会使用这个controller的scope。 如何运用scope，我们要用到一个叫做 link 的函数。它由指令定义对象中的link属性配置。让我们来改变一下我们的 helloWorld 指令，当用户在一个输入框中输入一种颜色的名称时，Hello World 文字的背景色自动发生变化。同时，当用户在 Hello World 文字上点击时，背景色变回白色。 相应的HTML标记如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>JavaScript修改后的 helloWorld 指令如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"literal\">true</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;p style=\"background-color:&#123; &#123;color&#125; &#125;\"&gt;Hello World'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">      elem.bind(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'background-color'</span>, <span class=\"string\">'white'</span>);</div><div class=\"line\">        scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          scope.color = <span class=\"string\">\"white\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;);</div><div class=\"line\">      elem.bind(<span class=\"string\">'mouseover'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'cursor'</span>, <span class=\"string\">'pointer'</span>);</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。我们注意到指令定义中的 link 函数。 它有三个参数：</p>\n<ul>\n<li>elem – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行包装。</li>\n<li>attr – 一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性：，那么可以在 link 函数中通过 attrs.someAttribute 来使用它。</li>\n</ul>\n<p>link函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM。在上面的指令代码片段中，我们添加了两个事件， click，和 mouseover。click 处理函数用来重置 <code>&lt;p&gt;</code> 的背景色，而 mouseover 处理函数改变鼠标为 pointer。在模板中有一个表达式 <code>{ {color} }</code>，当父scope中的 color 发生变化时，它用来改变 Hello World 文字的背景色。 这个 plunker 演示了这些概念。</p>\n<h3 id=\"compile函数\"><a href=\"#compile函数\" class=\"headerlink\" title=\"compile函数\"></a>compile函数</h3><p>compile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：</p>\n<ul>\n<li>tElement – 指令所在的元素</li>\n<li>attrs – 元素上赋予的参数的标准化列表</li>\n</ul>\n<p>要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。compile函数可以写成如下的形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    compile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tElem,attrs</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//do optional DOM transformation here</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope,elem,attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//linking function here</span></div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>指令是如何被编译的大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的！</p>\n<p>当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。</p>\n<h3 id=\"改变指令的Scope\"><a href=\"#改变指令的Scope\" class=\"headerlink\" title=\"改变指令的Scope\"></a>改变指令的Scope</h3><p>默认情况下，指令获取它父节点的controller的scope。但这并不适用于所有情况。如果将父controller的scope暴露给指令，那么他们可以随意地修改 scope 的属性。在某些情况下，你的指令希望能够添加一些仅限内部使用的属性和方法。如果我们在父的scope中添加，会污染父scope。 其实我们还有两种选择：</p>\n<ul>\n<li>一个子scope – 这个scope原型继承子父scope。</li>\n<li>一个隔离的scope – 一个孤立存在不继承自父scope的scope。</li>\n</ul>\n<p>这样的scope可以通过指令定义对象中 scope 属性来配置。下面的代码片段是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: <span class=\"literal\">true</span>,  <span class=\"comment\">// use a child scope that inherits from parent</span></div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面的代码，让Angular给指令创建一个继承自父socpe的新的子scope。 另外一个选择，隔离的scope：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,  <span class=\"comment\">// use a new isolated scope</span></div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这个指令使用了一个隔离的scope。隔离的scope在我们想要创建可重用的指令的时候是非常有好处的。通过使用隔离的scope，我们能够保证我们的指令是自包含的，可以被很容易的插入到HTML应用中。 它内部不能访问父的scope，所保证了父scope不被污染。 在我们的 helloWorld 指令例子中，如果我们将 scope 设置成 {}，那么上面的代码将不会工作。 它会创建一个新的隔离的scope，那么相应的表达式 <code>{ {color} }</code> 会指向到这个新的scope中，它的值将是 undefined. 使用隔离的scope并不意味着我们完全不能访问父scope的属性。</p>\n<h3 id=\"隔离scope和父scope之间的数据绑定\"><a href=\"#隔离scope和父scope之间的数据绑定\" class=\"headerlink\" title=\"隔离scope和父scope之间的数据绑定\"></a>隔离scope和父scope之间的数据绑定</h3><p>通常，隔离指令的scope会带来很多的便利，尤其是在你要操作多个scope模型的时候。但有时为了使代码能够正确工作，你也需要从指令内部访问父scope的属性。好消息是Angular给了你足够的灵活性让你能够有选择性的通过绑定的方式传入父scope的属性。让我们重温一下我们的 <a href=\"http://plnkr.co/edit/14q6WxHyhWuVxEIqwww1?p=preview\" target=\"_blank\" rel=\"external\">helloWorld</a> 指令，它的背景色会随着用户在输入框中输入的颜色名称而变化。还记得当我们对这个指令使用隔离scope的之后，它不能工作了吗？现在，我们来让它恢复正常。</p>\n<p>假设我们已经初始化完成app这个变量所指向的Angular模块。那么我们的 helloWorld 指令如下面代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"literal\">true</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;p style=\"background-color:&#123; &#123;color&#125; &#125;\"&gt;Hello World&lt;/p&gt;'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">      elem.bind(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'background-color'</span>,<span class=\"string\">'white'</span>);</div><div class=\"line\">        scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          scope.color = <span class=\"string\">\"white\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;);</div><div class=\"line\">      elem.bind(<span class=\"string\">'mouseover'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'cursor'</span>, <span class=\"string\">'pointer'</span>);</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用这个指令的HTML标签如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择一：</strong>使用 @ 实现单向文本绑定上面的代码现在是不能工作的。因为我们用了一个隔离的scope，指令内部的 <code>{ {color} }</code> 表达式被隔离在指令内部的scope中(不是父scope)。但是外面的输入框元素中的 ng-model 指令是指向父scope中的 color 属性的。所以，我们需要一种方式来绑定隔离scope和父scope中的这两个参数。在Angular中，这种数据绑定可以通过为指令所在的HTML元素添加属性和并指令定义对象中配置相应的 scope 属性来实现。让我们来细究一下建立数据绑定的几种方式。`</p>\n<p>在下面的指令定义中，我们指定了隔离scope中的属性 color 绑定到指令所在HTML元素上的参数 colorAttr。在HTML标记中，你可以看到 <code>{ {color} }</code>表达式被指定给了 color-attr 参数。当表达式的值发生改变时，color-attr 参数也跟着改变。隔离scope中的 color 属性的值也相应地被改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'@colorAttr'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>更新后的HTML标记代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color-attr</span>=<span class=\"string\">\"&#123; &#123;color&#125; &#125;\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意点：我们称这种方式为单项绑定，是因为在这种方式下，你只能将字符串(使用表达式<code>{ {} }</code>)传递给参数。当父scope的属性变化时，你的隔离scope模型中的属性值跟着变化。你甚至可以在指令内部监控这个scope属性的变化，并且触发一些任务。然而，反向的传递并不工作。你不能通过对隔离scope属性的操作来改变父scope的值。</p>\n<p>当隔离scope属性和指令元素参数的名字一样是，你可以更简单的方式设置scope绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'@'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应使用指令的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color</span>=<span class=\"string\">\"&#123; &#123;color&#125; &#125;\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择二：</strong>使用 = 实现双向绑定</p>\n<p>让我们将指令的定义改变成下面的样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'='</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML修改如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color</span>=<span class=\"string\">\"color\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择三：</strong>使用 &amp; 在父scope中执行函数与 @ 不同，这种方式让你能够给属性指定一个真实的scope数据模型，而不是简单的字符串。这样你就可以传递简单的字符串、数组、甚至复杂的对象给隔离scope。同时，还支持双向的绑定。每当父scope属性变化时，相对应的隔离scope中的属性也跟着改变，反之亦然。和之前的一样，你也可以监视这个scope属性的变化。</p>\n<p>有时候从隔离scope中调用父scope中定义的函数是非常有必要的。为了能够访问外部scope中定义的函数，我们使用 &amp;。比如我们想要从指令内部调用 sayHello() 方法。下面的代码告诉我们该怎么做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'sayHello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      sayHelloIsolated: <span class=\"string\">'&amp;amp;'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">say-hello</span> <span class=\"attr\">sayHelloIsolated</span>=<span class=\"string\">\"sayHello()\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父scope、子scope以及隔离scope的区别这个 <a href=\"http://plnkr.co/edit/k4scWKwtGBJw7lfKGqVJ?p=preview\" target=\"_blank\" rel=\"external\">Plunker</a> 例子对上面的概念做了很好的诠释。</p>\n<p>作为一个Angular的新手，你可能会在选择正确的指令scope的时候感到困惑。默认情况下，指令不会创建一个新的scope，而是沿用父scope。但是在很多情况下，这并不是我们想要的。如果你的指令重度地使用父scope的属性、甚至创建新的属性，会污染父scope。让所有的指令都使用同一个父scope不会是一个好主意，因为任何人都可能修改这个scope中的属性。因此，下面的这个原则也许可以帮助你为你的指令选择正确的scope。</p>\n<p>1.父scope(scope: false) – 这是默认情况。如果你的指令不操作父scoe的属性，你就不需要一个新的scope。这种情况下是可以使用父scope的。</p>\n<p>2.子scope(scope: true) – 这会为指令创建一个新的scope，并且原型继承自父scope。如果你的指令scope中的属性和方法与其他的指令以及父scope都没有关系的时候，你应该创建一个新scope。在这种方式下，你同样拥有父scope中所定义的属性和方法。</p>\n<p>3.隔离scope(scope:{}) – 这就像一个沙箱！当你创建的指令是自包含的并且可重用的，你就需要使用这种scope。你在指令中会创建很多scope属性和方法，它们仅在指令内部使用，永远不会被外部的世界所知晓。如果是这样的话，隔离的scope是更好的选择。隔离的scope不会继承父scope。</p>\n<h3 id=\"Transclusion（嵌入）\"><a href=\"#Transclusion（嵌入）\" class=\"headerlink\" title=\"Transclusion（嵌入）\"></a>Transclusion（嵌入）</h3><p>Transclusion是让我们的指令包含任意内容的方法。我们可以延时提取并在正确的scope下编译这些嵌入的内容，最终将它们放入指令模板中指定的位置。 如果你在指令定义中设置 transclude:true，一个新的嵌入的scope会被创建，它原型继承子父scope。 如果你想要你的指令使用隔离的scope，但是它所包含的内容能够在父scope中执行，transclusion也可以帮忙。</p>\n<p>假设我们注册一个如下的指令：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'outputText'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    transclude: <span class=\"literal\">true</span>,</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    template: <span class=\"string\">'&lt;div ng-transclude&gt;&lt;/div&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>它使用如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">output-text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello &#123; &#123;name&#125; &#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>transclude:’element’ 和 transclude:true的区别ng-transclude 指明在哪里放置被嵌入的内容。在这个例子中DOM内容 </p><p>Hello { {name} }</p> 被提取和放置到 <div ng-transclude=\"\"></div> 内部。有一个很重要的点需要注意的是，表达式{ {name} }所对应的属性是在父scope中被定义的，而非子scope。你可以在这个Plunker例子中做一些实验。如果你想要学习更多关于scope的知识，可以阅读<a href=\"https://github.com/angular/angular.js/wiki/Understanding-Scopes\" target=\"_blank\" rel=\"external\">这篇文章</a>。<p></p>\n<p>有时候我我们要嵌入指令元素本身，而不仅仅是它的内容。在这种情况下，我们需要使用 transclude:’element’。它和 transclude:true 不同，它将标记了 ng-transclude 指令的元素一起包含到了指令模板中。使用transclusion，你的link函数会获得一个名叫 transclude 的链接函数，这个函数绑定了正确的指令scope，并且传入了另一个拥有被嵌入DOM元素拷贝的函数。你可以在这个 transclude 函数中执行比如修改元素拷贝或者将它添加到DOM上等操作。 类似 ng-repeat 这样的指令使用这种方式来重复DOM元素。仔细研究一下这个Plunker，它使用这种方式复制了DOM元素，并且改变了第二个实例的背景色。</p>\n<p>同样需要注意的是，在使用 transclude:’element’的时候，指令所在的元素会被转换成HTML注释。所以，如果你结合使用 transclude:’element’ 和 replace:false，那么指令模板本质上是被添加到了注释的innerHTML中——也就是说其实什么都没有发生！相反，如果你选择使用 replace:true，指令模板会替换HTML注释，那么一切就会如果所愿的工作。使用 replade:false 和 transclue:’element’有时候也是有用的，比如当你需要重复DOM元素但是并不想保留第一个元素实例（它会被转换成注释）的情况下。对这块还有疑惑的同学可以阅读stackoverflow上的<a href=\"http://stackoverflow.com/questions/18449743/when-to-use-transclude-true-and-transclude-element\" target=\"_blank\" rel=\"external\">这篇讨论</a>，介绍的比较清晰。</p>\n<h3 id=\"controller-函数和-require\"><a href=\"#controller-函数和-require\" class=\"headerlink\" title=\"controller 函数和 require\"></a>controller 函数和 require</h3><p>如果你想要允许其他的指令和你的指令发生交互时，你需要使用 controller 函数。比如有些情况下，你需要通过组合两个指令来实现一个UI组件。那么你可以通过如下的方式来给指令添加一个 controller 函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'outerDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    controller: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $compile, $http</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// $scope is the appropriate scope for the directive</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.addChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nestedDirective</span>) </span>&#123; <span class=\"comment\">// this refers to the controller</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Got the message from nested directive:'</span> + nestedDirective.message);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>JavaScript这个代码为指令添加了一个名叫 outerDirective 的controller。当另一个指令想要交互时，它需要声明它对你的指令 controller 实例的引用(require)。可以通过如下的方式实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'innerDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    <span class=\"built_in\">require</span>: <span class=\"string\">'^outerDirective'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs, controllerInstance</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//the fourth argument is the controller instance you require</span></div><div class=\"line\">      scope.message = <span class=\"string\">\"Hi, Parent directive\"</span>;</div><div class=\"line\">      controllerInstance.addChild(scope);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">outer-directive</span>&gt;</span>   <span class=\"tag\">&lt;<span class=\"name\">inner-directive</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">inner-directive</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">outer-directive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>require: ‘^outerDirective’ 告诉Angular在元素以及它的父元素中搜索controller。这样被找到的 controller 实例会作为第四个参数被传入到 link 函数中。在我们的例子中，我们将嵌入的指令的scope发送给父亲指令。如果你想尝试这个代码的话，请在开启浏览器控制台的情况下打开这个Plunker。同时，<a href=\"http://docs.angularjs.org/guide/directive\" target=\"_blank\" rel=\"external\">这篇Angular官方文档</a>上的最后部分给了一个非常好的关于指令交互的例子，是非常值得一读的。</p>\n<h3 id=\"一个记事本应用\"><a href=\"#一个记事本应用\" class=\"headerlink\" title=\"一个记事本应用\"></a>一个记事本应用</h3><p>这一部分，我们使用Angular指令创建一个简单的记事本应用。我们会使用HTML5的 localStorage 来存储笔记。最终的产品在<a href=\"http://embed.plnkr.co/QvxI4LbqfUY3C3XQjN3m/preview\" target=\"_blank\" rel=\"external\">这里</a>，你可以先睹为快。</p>\n<p>我们会创建一个展现记事本的指令。用户可以查看他/她创建过的笔记记录。当他点击 add new 按钮的时候，记事本会进入可编辑状态，并且允许创建新的笔记。当点击 back 按钮的时候，新的笔记会被自动保存。笔记的保存使用了一个名叫 noteFactory 的工厂类，它使用了 localStorage。工厂类中的代码是非常直接和可理解的。所以我们就集中讨论指令的代码。</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>我们从注册 notepad 指令开始。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'notepad'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">notesFactory</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    templateUrl: <span class=\"string\">'templateurl.html'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>因为我们想让指令可重用，所以选择使用隔离的scope。这个指令可以拥有很多与外界没有关联的属性和方法。这里有几点需要注意的：</p>\n<ul>\n<li>这个指令可以以属性或者元素的方式被使用，这个被定义在 restrict 属性中。</li>\n<li>现在的link函数是空的</li>\n<li>这个指令从 templateurl.html 中获取指令模板</li>\n</ul>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>下面的HTML组成了指令的模板。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-area\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"!editMode\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"note in notes|orderBy:'id'\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"openEditor(note.id)\"</span>&gt;</span>&#123; &#123;note.title&#125; &#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"editor\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"editMode\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-area\"</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"noteText\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"save()\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"editMode\"</span>&gt;</span>Back<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"openEditor()\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"!editMode\"</span>&gt;</span>Add Note<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>note 对象中封装了 title，id 和 content。几个重要的注意点：</p>\n<ul>\n<li>ng-repeat 用来遍历 notes 中所有的笔记，并且按照自动生成的 id 属性进行升序排序。</li>\n<li>我们使用一个叫 editMode 的属性来指明我们现在在哪种模式下。在编辑模式下，这个属性的值为 true 并且可编辑的 div 节点会显示。用户在这里输入自己的笔记。</li>\n<li>如果 editMode 为 false，我们就在查看模式，显示所有的 notes。</li>\n<li>两个按钮也是基于 editMode 的值而显示和隐藏。</li>\n<li>ng-click 指令用来响应按钮的点击事件。这些方法将和 editMode 一起添加到scope中。</li>\n<li>可编辑的 div 框与 noteText 相绑定，存放了用户输入的文本。如果你想编辑一个已存在的笔记，那么这个模型会用它的文本内容初始化这个 div 框。</li>\n</ul>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>我们在scope中创建一个名叫 restore() 的新函数，它用来初始化我们应用中的各种控制器。 它会在 link 函数执行的时候被调用，也会在 save 按钮被点击的时候调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">scope.restore = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  scope.editMode = <span class=\"literal\">false</span>;</div><div class=\"line\">  scope.index = <span class=\"number\">-1</span>;</div><div class=\"line\">  scope.noteText = <span class=\"string\">''</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>我们在 link 函数的内部创建这个函数。 editMode 和 noteText 之前已经解释过了。 index 用来跟踪当前正在编辑的笔记。 当我们在创建一个新的笔记的时候，index 的值会设成 -1. 我们在编辑一个已存在的笔记的时候，它包含了那个 note 对象的 id 值。</p>\n<p>现在我们要创建两个scope函数来处理编辑和保存操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">scope.openEditor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">  scope.editMode = <span class=\"literal\">true</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (index !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">    scope.noteText = notesFactory.get(index).content;</div><div class=\"line\">    scope.index = index;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    scope.noteText = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">scope.save = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (scope.noteText !== <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> note = &#123;&#125;;</div><div class=\"line\">    note.title = scope.noteText.length &gt; <span class=\"number\">10</span> ? scope.noteText.substring(<span class=\"number\">0</span>, <span class=\"number\">10</span>) + <span class=\"string\">'. . .'</span> : scope.noteText;</div><div class=\"line\">    note.content = scope.noteText;</div><div class=\"line\">    note.id = scope.index != <span class=\"number\">-1</span> ? scope.index : localStorage.length;</div><div class=\"line\">    scope.notes = notesFactory.put(note);</div><div class=\"line\">  &#125;</div><div class=\"line\">  scope.restore();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>openEditor 为编辑器做准备工作。如果我们在编辑一个笔记，它会获取当前笔记的内容并且通过使用 ng-bind 将内容更新到可编辑的 div 中。这两个函数有几点需要注意：</p>\n<ul>\n<li>如果我们在创建一个新的笔记，我们会将 noteText 设置成 undefined，以便当我们在保存笔记的时候，触发相应的监听器。</li>\n<li>如果 index 参数是 undefined，它表明用户正在创建一个新的笔记。</li>\n<li>save 函数通过使用 notesFactory 来存储笔记。在保存完成后，它会刷新 notes 数组，从而监听器能够监测到笔记列表的变化，来及时更新。</li>\n<li>save 函数调用在重置 controllers 之后调用restore()，从而可以从编辑模式进入查看模式。</li>\n</ul>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>在 link 函数执行时，我们初始化 notes 数组，并且为可编辑的 div 框绑定一个 keydown 事件，从而保证我们的 nodeText 模型与 div 中的内容保持同步。我们使用这个 noteText 来保存我们的笔记内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> editor = elem.find(<span class=\"string\">'#editor'</span>);</div><div class=\"line\">scope.restore();  <span class=\"comment\">// initialize our app controls</span></div><div class=\"line\">scope.notes = notesFactory.getAll(); <span class=\"comment\">// load notes</span></div><div class=\"line\">editor.bind(<span class=\"string\">'keyup keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  scope.noteText = editor.text().trim();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>最后，我们在HTML如同使用其他的HTML元素一样使用我们的指令，然后开始做笔记吧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>The Note Making App<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">notepad</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>源码下载：<a href=\"https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip\" target=\"_blank\" rel=\"external\">https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一个很重要的点需要注意的是，任何使用jQuery能做的事情，我们都能用Angular指令来做到，并且使用更少的代码。所以，在使用jQuery之前，请考虑一下我们能否在不进行DOM操作的情况下以更好的方式来完成任务。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/angularjs-command-learn.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a></p>\n","excerpt":"","more":"<p>指令（Directives）是所有AngularJS应用最重要的部分。尽管AngularJS已经提供了非常丰富的指令，但还是经常需要创建应用特定的指令。这篇教程会为你讲述如何自定义指令，以及介绍如何在实际项目中使用。在这篇文章的最后，我会指导你如何使用Angular指令来创建一个简单的记事本应用。</p>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>一个指令用来引入新的HTML语法。指令是DOM元素上的标记，使元素拥有特定的行为。举例来说，静态的HTML不知道如何来创建和展现一个日期选择器控件。让HTML能识别这个语法，我们需要使用指令。指令通过某种方法来创建一个能够支持日期选择的元素。我们会循序渐进地介绍这是如何实现的。 如果你写过AngularJS的应用，那么你一定已经使用过指令，不管你有没有意识到。你肯定已经用过简单的指令，比如 ng-mode, ng-repeat, ng-show等。这些指令都赋予DOM元素特定的行为。例如，ng-repeat 重复特定的元素，ng-show 有条件地显示一个元素。如果你想让一个元素支持拖拽，你也需要创建一个指令来实现它。指令背后基本的想法很简单。它通过对元素绑定事件监听或者改变DOM而使HTML拥有真实的交互性。</p>\n<h3 id=\"jQuery视角\"><a href=\"#jQuery视角\" class=\"headerlink\" title=\"jQuery视角\"></a>jQuery视角</h3><p>想象一下使用jQuery如何创建一个日期选择器。首先，我们在HTML中添加一个普通的输入框，然后通过jQuery调用 $(element).dataPicker() 来将它转变成一个日期选择器。但是，仔细想一下。当一个设计人员过来检查HTML标记的时候，他/她能否立刻猜到这个字段实际上表示的内容？这只是一个简单的输入框，或者一个日期选择器？你需要查看jQuery代码来确定这些。而Angular的方法是使用一个指令来扩展HTML。所以，一个日期选择器的指令可以是下面的形式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span></div></pre></td></tr></table></figure>\n<p>创建自定义指令：这种创建UI组建的方式更加直接和清晰。你可以轻易地通过查看元素就明白这到底是什么。</p>\n<p>一个Angular指令可以有以下的四种表现形式：</p>\n<ol>\n<li><p>一个新的HTML元素（<code>&lt;data-picker&gt;&lt;/data-picker&gt;</code>）</p>\n</li>\n<li><p>元素的属性（<code>&lt;input type=”text” data-picker/&gt;</code>）</p>\n</li>\n<li><p>CSS class（<code>&lt;input type=”text” class=”data-picker”/&gt;</code>）</p>\n</li>\n<li><p>注释（<code>&lt;!–directive:data-picker –&gt;</code>）</p>\n</li>\n</ol>\n<p>当然，我们可以控制我们的指令在HTML中的表现形式。下面我们来看一下AngularJS中的一个典型的指令的写法。指令注册的方式与 controller 一样，但是它返回的是一个拥有指令配置属性的简单对象(指令定义对象) 。下面的代码是一个简单的 <a href=\"http://www.codeceo.com/article/hello-world-30-years.html\">Hello World</a> 指令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</div><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">      restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">      replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">      template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在上面的代码中，app.directive()方法在模块中注册了一个新的指令。这个方法的第一个参数是这个指令的名字。第二个参数是一个返回指令定义对象的函数。如果你的指令依赖于其他的对象或者服务，比如 $rootScope, $http, 或者$compile，他们可以在这个时间被注入。这个指令在HTML中以一个元素使用，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello:world</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>或者，以一个属性的方式使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">hello:world</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>如果你想要符合HTML5的规范，你可以在元素前面添加 x- 或者 data-的前缀。所以下面的标记也会匹配 helloWorld 指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">//OR</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">x-hello-world</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>restrict – 这个属性用来指定指令在HTML中如何使用（还记得之前说的，指令的四种表示方式吗）。在上面的例子中，我们使用了 ‘AE’。所以这个指令可以被当作新的HTML元素或者属性来使用。如果要允许指令被当作class来使用，我们将 restrict 设置成 ‘AEC’。</p>\n<p><strong>注意：</strong> 在匹配指令的时候，Angular会在元素或者属性的名字中剔除 x- 或者 data- 前缀。 然后将 – 或者 : 连接的字符串转换成驼峰(camelCase)表现形式，然后再与注册过的指令进行匹配。这是为什么，我们在HTML中以 hello-world 的方式使用 helloWorld 指令。其实，这跟HTML对标签和属性不区分大小写有关。 尽管上面的指令仅仅实现了静态文字的显示，但是这里还是有一些有趣的点值得我们去挖掘。我们在指令定义过程中使用了三个属性来配置指令。我们来一一介绍他们的作用。</p>\n<ul>\n<li>template – 这个属性规定了指令被Angular编译和链接（link）后生成的HTML标记。这个属性值不一定要是简单的字符串。template 可以非常复杂，而且经常包含其他的指令，以及表达式等。更多的情况下你可能会见到 templateUrl， 而不是 template。所以，理想情况下，你应该将模板放到一个特定的HTML文件中，然后将 templateUrl 属性指向它。</li>\n<li>replace – 这个属性指明生成的HTML内容是否会替换掉定义此指令的HTML元素。在我们的例子中，我们用 <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>的方式使用我们的指令，并且将 replace 设置成 true。所以，在指令被编译之后，生成的模板内容替换掉了 <code>&lt;hello-world&gt;&lt;/hello-world&gt;</code>。最终的输出是 <code>&lt;h3&gt;Hello World!!&lt;/h3&gt;</code>。如果你将 replace 设置成 false，也就是默认值，那么生成的模板会被插入到定义指令的元素中。</li>\n</ul>\n<p>打开这个 <a href=\"http://plnkr.co/edit/GKI339z2VDdZTOE2bGFP\">plunker</a>，在”Hello World!!”右键检查元素内容，来更形象地明白这些。</p>\n<h3 id=\"Link函数和Scope\"><a href=\"#Link函数和Scope\" class=\"headerlink\" title=\"Link函数和Scope\"></a>Link函数和Scope</h3><p>指令生成出的模板其实没有太多意义，除非它在特定的scope下编译。默认情况下，指令并不会创建新的子scope。更多的，它使用父scope。也就是说，如果指令存在于一个controller下，它就会使用这个controller的scope。 如何运用scope，我们要用到一个叫做 link 的函数。它由指令定义对象中的link属性配置。让我们来改变一下我们的 helloWorld 指令，当用户在一个输入框中输入一种颜色的名称时，Hello World 文字的背景色自动发生变化。同时，当用户在 Hello World 文字上点击时，背景色变回白色。 相应的HTML标记如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span> /&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>JavaScript修改后的 helloWorld 指令如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"literal\">true</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;p style=\"background-color:&#123; &#123;color&#125; &#125;\"&gt;Hello World'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">      elem.bind(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'background-color'</span>, <span class=\"string\">'white'</span>);</div><div class=\"line\">        scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          scope.color = <span class=\"string\">\"white\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;);</div><div class=\"line\">      elem.bind(<span class=\"string\">'mouseover'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'cursor'</span>, <span class=\"string\">'pointer'</span>);</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>scope – 指令的scope。在我们的例子中，指令的scope就是父controller的scope。我们注意到指令定义中的 link 函数。 它有三个参数：</p>\n<ul>\n<li>elem – 指令的jQLite(jQuery的子集)包装DOM元素。如果你在引入AngularJS之前引入了jQuery，那么这个元素就是jQuery元素，而不是jQLite元素。由于这个元素已经被jQuery/jQLite包装了，所以我们就在进行DOM操作的时候就不需要再使用 $()来进行包装。</li>\n<li>attr – 一个包含了指令所在元素的属性的标准化的参数对象。举个例子，你给一个HTML元素添加了一些属性：，那么可以在 link 函数中通过 attrs.someAttribute 来使用它。</li>\n</ul>\n<p>link函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM。在上面的指令代码片段中，我们添加了两个事件， click，和 mouseover。click 处理函数用来重置 <code>&lt;p&gt;</code> 的背景色，而 mouseover 处理函数改变鼠标为 pointer。在模板中有一个表达式 <code>{ {color} }</code>，当父scope中的 color 发生变化时，它用来改变 Hello World 文字的背景色。 这个 plunker 演示了这些概念。</p>\n<h3 id=\"compile函数\"><a href=\"#compile函数\" class=\"headerlink\" title=\"compile函数\"></a>compile函数</h3><p>compile 函数在 link 函数被执行之前用来做一些DOM改造。它接收下面的参数：</p>\n<ul>\n<li>tElement – 指令所在的元素</li>\n<li>attrs – 元素上赋予的参数的标准化列表</li>\n</ul>\n<p>要注意的是 compile 函数不能访问 scope，并且必须返回一个 link 函数。但是如果没有设置 compile 函数，你可以正常地配置 link 函数，（有了compile，就不能用link，link函数由compile返回）。compile函数可以写成如下的形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'test'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    compile: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tElem,attrs</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//do optional DOM transformation here</span></div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope,elem,attrs</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//linking function here</span></div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>指令是如何被编译的大多数的情况下，你只需要使用 link 函数。这是因为大部分的指令只需要考虑注册事件监听、监视模型、以及更新DOM等，这些都可以在 link 函数中完成。 但是对于像 ng-repeat 之类的指令，需要克隆和重复 DOM 元素多次，在 link 函数执行之前由 compile 函数来完成。这就带来了一个问题，为什么我们需要两个分开的函数来完成生成过程，为什么不能只使用一个？要回答好这个问题，我们需要理解指令在Angular中是如何被编译的！</p>\n<p>当应用引导启动的时候，Angular开始使用 $compile 服务遍历DOM元素。这个服务基于注册过的指令在标记文本中搜索指令。一旦所有的指令都被识别后，Angular执行他们的 compile 方法。如前面所讲的，compile 方法返回一个 link 函数，被添加到稍后执行的 link 函数列表中。这被称为编译阶段。如果一个指令需要被克隆很多次（比如 ng-repeat），compile函数只在编译阶段被执行一次，复制这些模板，但是link 函数会针对每个被复制的实例被执行。所以分开处理，让我们在性能上有一定的提高。这也说明了为什么在 compile 函数中不能访问到scope对象。 在编译阶段之后，就开始了链接（linking）阶段。在这个阶段，所有收集的 link 函数将被一一执行。指令创造出来的模板会在正确的scope下被解析和处理，然后返回具有事件响应的真实的DOM节点。</p>\n<h3 id=\"改变指令的Scope\"><a href=\"#改变指令的Scope\" class=\"headerlink\" title=\"改变指令的Scope\"></a>改变指令的Scope</h3><p>默认情况下，指令获取它父节点的controller的scope。但这并不适用于所有情况。如果将父controller的scope暴露给指令，那么他们可以随意地修改 scope 的属性。在某些情况下，你的指令希望能够添加一些仅限内部使用的属性和方法。如果我们在父的scope中添加，会污染父scope。 其实我们还有两种选择：</p>\n<ul>\n<li>一个子scope – 这个scope原型继承子父scope。</li>\n<li>一个隔离的scope – 一个孤立存在不继承自父scope的scope。</li>\n</ul>\n<p>这样的scope可以通过指令定义对象中 scope 属性来配置。下面的代码片段是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: <span class=\"literal\">true</span>,  <span class=\"comment\">// use a child scope that inherits from parent</span></div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面的代码，让Angular给指令创建一个继承自父socpe的新的子scope。 另外一个选择，隔离的scope：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,  <span class=\"comment\">// use a new isolated scope</span></div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"string\">'true'</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;h3&gt;Hello World!!&lt;/h3&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这个指令使用了一个隔离的scope。隔离的scope在我们想要创建可重用的指令的时候是非常有好处的。通过使用隔离的scope，我们能够保证我们的指令是自包含的，可以被很容易的插入到HTML应用中。 它内部不能访问父的scope，所保证了父scope不被污染。 在我们的 helloWorld 指令例子中，如果我们将 scope 设置成 {}，那么上面的代码将不会工作。 它会创建一个新的隔离的scope，那么相应的表达式 <code>{ {color} }</code> 会指向到这个新的scope中，它的值将是 undefined. 使用隔离的scope并不意味着我们完全不能访问父scope的属性。</p>\n<h3 id=\"隔离scope和父scope之间的数据绑定\"><a href=\"#隔离scope和父scope之间的数据绑定\" class=\"headerlink\" title=\"隔离scope和父scope之间的数据绑定\"></a>隔离scope和父scope之间的数据绑定</h3><p>通常，隔离指令的scope会带来很多的便利，尤其是在你要操作多个scope模型的时候。但有时为了使代码能够正确工作，你也需要从指令内部访问父scope的属性。好消息是Angular给了你足够的灵活性让你能够有选择性的通过绑定的方式传入父scope的属性。让我们重温一下我们的 <a href=\"http://plnkr.co/edit/14q6WxHyhWuVxEIqwww1?p=preview\">helloWorld</a> 指令，它的背景色会随着用户在输入框中输入的颜色名称而变化。还记得当我们对这个指令使用隔离scope的之后，它不能工作了吗？现在，我们来让它恢复正常。</p>\n<p>假设我们已经初始化完成app这个变量所指向的Angular模块。那么我们的 helloWorld 指令如下面代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    replace: <span class=\"literal\">true</span>,</div><div class=\"line\">    template: <span class=\"string\">'&lt;p style=\"background-color:&#123; &#123;color&#125; &#125;\"&gt;Hello World&lt;/p&gt;'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">      elem.bind(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'background-color'</span>,<span class=\"string\">'white'</span>);</div><div class=\"line\">        scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">          scope.color = <span class=\"string\">\"white\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">      &#125;);</div><div class=\"line\">      elem.bind(<span class=\"string\">'mouseover'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        elem.css(<span class=\"string\">'cursor'</span>, <span class=\"string\">'pointer'</span>);</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>使用这个指令的HTML标签如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择一：</strong>使用 @ 实现单向文本绑定上面的代码现在是不能工作的。因为我们用了一个隔离的scope，指令内部的 <code>{ {color} }</code> 表达式被隔离在指令内部的scope中(不是父scope)。但是外面的输入框元素中的 ng-model 指令是指向父scope中的 color 属性的。所以，我们需要一种方式来绑定隔离scope和父scope中的这两个参数。在Angular中，这种数据绑定可以通过为指令所在的HTML元素添加属性和并指令定义对象中配置相应的 scope 属性来实现。让我们来细究一下建立数据绑定的几种方式。`</p>\n<p>在下面的指令定义中，我们指定了隔离scope中的属性 color 绑定到指令所在HTML元素上的参数 colorAttr。在HTML标记中，你可以看到 <code>{ {color} }</code>表达式被指定给了 color-attr 参数。当表达式的值发生改变时，color-attr 参数也跟着改变。隔离scope中的 color 属性的值也相应地被改变。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'@colorAttr'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>更新后的HTML标记代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color-attr</span>=<span class=\"string\">\"&#123; &#123;color&#125; &#125;\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>注意点：我们称这种方式为单项绑定，是因为在这种方式下，你只能将字符串(使用表达式<code>{ {} }</code>)传递给参数。当父scope的属性变化时，你的隔离scope模型中的属性值跟着变化。你甚至可以在指令内部监控这个scope属性的变化，并且触发一些任务。然而，反向的传递并不工作。你不能通过对隔离scope属性的操作来改变父scope的值。</p>\n<p>当隔离scope属性和指令元素参数的名字一样是，你可以更简单的方式设置scope绑定：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'@'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应使用指令的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color</span>=<span class=\"string\">\"&#123; &#123;color&#125; &#125;\"</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择二：</strong>使用 = 实现双向绑定</p>\n<p>让我们将指令的定义改变成下面的样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'helloWorld'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      color: <span class=\"string\">'='</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML修改如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">hello-world</span> <span class=\"attr\">color</span>=<span class=\"string\">\"color\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>选择三：</strong>使用 &amp; 在父scope中执行函数与 @ 不同，这种方式让你能够给属性指定一个真实的scope数据模型，而不是简单的字符串。这样你就可以传递简单的字符串、数组、甚至复杂的对象给隔离scope。同时，还支持双向的绑定。每当父scope属性变化时，相对应的隔离scope中的属性也跟着改变，反之亦然。和之前的一样，你也可以监视这个scope属性的变化。</p>\n<p>有时候从隔离scope中调用父scope中定义的函数是非常有必要的。为了能够访问外部scope中定义的函数，我们使用 &amp;。比如我们想要从指令内部调用 sayHello() 方法。下面的代码告诉我们该怎么做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'sayHello'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;</div><div class=\"line\">      sayHelloIsolated: <span class=\"string\">'&amp;amp;'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    ....</div><div class=\"line\">    <span class=\"comment\">// the rest of the configurations</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"MainCtrl\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">ng-model</span>=<span class=\"string\">\"color\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Enter a color\"</span>/&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">say-hello</span> <span class=\"attr\">sayHelloIsolated</span>=<span class=\"string\">\"sayHello()\"</span>/&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>父scope、子scope以及隔离scope的区别这个 <a href=\"http://plnkr.co/edit/k4scWKwtGBJw7lfKGqVJ?p=preview\">Plunker</a> 例子对上面的概念做了很好的诠释。</p>\n<p>作为一个Angular的新手，你可能会在选择正确的指令scope的时候感到困惑。默认情况下，指令不会创建一个新的scope，而是沿用父scope。但是在很多情况下，这并不是我们想要的。如果你的指令重度地使用父scope的属性、甚至创建新的属性，会污染父scope。让所有的指令都使用同一个父scope不会是一个好主意，因为任何人都可能修改这个scope中的属性。因此，下面的这个原则也许可以帮助你为你的指令选择正确的scope。</p>\n<p>1.父scope(scope: false) – 这是默认情况。如果你的指令不操作父scoe的属性，你就不需要一个新的scope。这种情况下是可以使用父scope的。</p>\n<p>2.子scope(scope: true) – 这会为指令创建一个新的scope，并且原型继承自父scope。如果你的指令scope中的属性和方法与其他的指令以及父scope都没有关系的时候，你应该创建一个新scope。在这种方式下，你同样拥有父scope中所定义的属性和方法。</p>\n<p>3.隔离scope(scope:{}) – 这就像一个沙箱！当你创建的指令是自包含的并且可重用的，你就需要使用这种scope。你在指令中会创建很多scope属性和方法，它们仅在指令内部使用，永远不会被外部的世界所知晓。如果是这样的话，隔离的scope是更好的选择。隔离的scope不会继承父scope。</p>\n<h3 id=\"Transclusion（嵌入）\"><a href=\"#Transclusion（嵌入）\" class=\"headerlink\" title=\"Transclusion（嵌入）\"></a>Transclusion（嵌入）</h3><p>Transclusion是让我们的指令包含任意内容的方法。我们可以延时提取并在正确的scope下编译这些嵌入的内容，最终将它们放入指令模板中指定的位置。 如果你在指令定义中设置 transclude:true，一个新的嵌入的scope会被创建，它原型继承子父scope。 如果你想要你的指令使用隔离的scope，但是它所包含的内容能够在父scope中执行，transclusion也可以帮忙。</p>\n<p>假设我们注册一个如下的指令：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'outputText'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    transclude: <span class=\"literal\">true</span>,</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    template: <span class=\"string\">'&lt;div ng-transclude&gt;&lt;/div&gt;'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>它使用如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">output-text</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello &#123; &#123;name&#125; &#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>transclude:’element’ 和 transclude:true的区别ng-transclude 指明在哪里放置被嵌入的内容。在这个例子中DOM内容 <p>Hello { {name} }</p> 被提取和放置到 <div ng-transclude></div> 内部。有一个很重要的点需要注意的是，表达式{ {name} }所对应的属性是在父scope中被定义的，而非子scope。你可以在这个Plunker例子中做一些实验。如果你想要学习更多关于scope的知识，可以阅读<a href=\"https://github.com/angular/angular.js/wiki/Understanding-Scopes\">这篇文章</a>。</p>\n<p>有时候我我们要嵌入指令元素本身，而不仅仅是它的内容。在这种情况下，我们需要使用 transclude:’element’。它和 transclude:true 不同，它将标记了 ng-transclude 指令的元素一起包含到了指令模板中。使用transclusion，你的link函数会获得一个名叫 transclude 的链接函数，这个函数绑定了正确的指令scope，并且传入了另一个拥有被嵌入DOM元素拷贝的函数。你可以在这个 transclude 函数中执行比如修改元素拷贝或者将它添加到DOM上等操作。 类似 ng-repeat 这样的指令使用这种方式来重复DOM元素。仔细研究一下这个Plunker，它使用这种方式复制了DOM元素，并且改变了第二个实例的背景色。</p>\n<p>同样需要注意的是，在使用 transclude:’element’的时候，指令所在的元素会被转换成HTML注释。所以，如果你结合使用 transclude:’element’ 和 replace:false，那么指令模板本质上是被添加到了注释的innerHTML中——也就是说其实什么都没有发生！相反，如果你选择使用 replace:true，指令模板会替换HTML注释，那么一切就会如果所愿的工作。使用 replade:false 和 transclue:’element’有时候也是有用的，比如当你需要重复DOM元素但是并不想保留第一个元素实例（它会被转换成注释）的情况下。对这块还有疑惑的同学可以阅读stackoverflow上的<a href=\"http://stackoverflow.com/questions/18449743/when-to-use-transclude-true-and-transclude-element\">这篇讨论</a>，介绍的比较清晰。</p>\n<h3 id=\"controller-函数和-require\"><a href=\"#controller-函数和-require\" class=\"headerlink\" title=\"controller 函数和 require\"></a>controller 函数和 require</h3><p>如果你想要允许其他的指令和你的指令发生交互时，你需要使用 controller 函数。比如有些情况下，你需要通过组合两个指令来实现一个UI组件。那么你可以通过如下的方式来给指令添加一个 controller 函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'outerDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    controller: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope, $compile, $http</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// $scope is the appropriate scope for the directive</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.addChild = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nestedDirective</span>) </span>&#123; <span class=\"comment\">// this refers to the controller</span></div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Got the message from nested directive:'</span> + nestedDirective.message);</div><div class=\"line\">      &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>JavaScript这个代码为指令添加了一个名叫 outerDirective 的controller。当另一个指令想要交互时，它需要声明它对你的指令 controller 实例的引用(require)。可以通过如下的方式实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'innerDirective'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    <span class=\"built_in\">require</span>: <span class=\"string\">'^outerDirective'</span>,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs, controllerInstance</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//the fourth argument is the controller instance you require</span></div><div class=\"line\">      scope.message = <span class=\"string\">\"Hi, Parent directive\"</span>;</div><div class=\"line\">      controllerInstance.addChild(scope);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>相应的HTML代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">outer-directive</span>&gt;</span>   <span class=\"tag\">&lt;<span class=\"name\">inner-directive</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">inner-directive</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">outer-directive</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>require: ‘^outerDirective’ 告诉Angular在元素以及它的父元素中搜索controller。这样被找到的 controller 实例会作为第四个参数被传入到 link 函数中。在我们的例子中，我们将嵌入的指令的scope发送给父亲指令。如果你想尝试这个代码的话，请在开启浏览器控制台的情况下打开这个Plunker。同时，<a href=\"http://docs.angularjs.org/guide/directive\">这篇Angular官方文档</a>上的最后部分给了一个非常好的关于指令交互的例子，是非常值得一读的。</p>\n<h3 id=\"一个记事本应用\"><a href=\"#一个记事本应用\" class=\"headerlink\" title=\"一个记事本应用\"></a>一个记事本应用</h3><p>这一部分，我们使用Angular指令创建一个简单的记事本应用。我们会使用HTML5的 localStorage 来存储笔记。最终的产品在<a href=\"http://embed.plnkr.co/QvxI4LbqfUY3C3XQjN3m/preview\">这里</a>，你可以先睹为快。</p>\n<p>我们会创建一个展现记事本的指令。用户可以查看他/她创建过的笔记记录。当他点击 add new 按钮的时候，记事本会进入可编辑状态，并且允许创建新的笔记。当点击 back 按钮的时候，新的笔记会被自动保存。笔记的保存使用了一个名叫 noteFactory 的工厂类，它使用了 localStorage。工厂类中的代码是非常直接和可理解的。所以我们就集中讨论指令的代码。</p>\n<h3 id=\"第一步\"><a href=\"#第一步\" class=\"headerlink\" title=\"第一步\"></a>第一步</h3><p>我们从注册 notepad 指令开始。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.directive(<span class=\"string\">'notepad'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">notesFactory</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    restrict: <span class=\"string\">'AE'</span>,</div><div class=\"line\">    scope: &#123;&#125;,</div><div class=\"line\">    link: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope, elem, attrs</span>) </span>&#123;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    templateUrl: <span class=\"string\">'templateurl.html'</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>因为我们想让指令可重用，所以选择使用隔离的scope。这个指令可以拥有很多与外界没有关联的属性和方法。这里有几点需要注意的：</p>\n<ul>\n<li>这个指令可以以属性或者元素的方式被使用，这个被定义在 restrict 属性中。</li>\n<li>现在的link函数是空的</li>\n<li>这个指令从 templateurl.html 中获取指令模板</li>\n</ul>\n<h3 id=\"第二步\"><a href=\"#第二步\" class=\"headerlink\" title=\"第二步\"></a>第二步</h3><p>下面的HTML组成了指令的模板。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-area\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"!editMode\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"note in notes|orderBy:'id'\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"openEditor(note.id)\"</span>&gt;</span>&#123; &#123;note.title&#125; &#125;<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"editor\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"editMode\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"note-area\"</span> <span class=\"attr\">contenteditable</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"noteText\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"save()\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"editMode\"</span>&gt;</span>Back<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"openEditor()\"</span> <span class=\"attr\">ng-show</span>=<span class=\"string\">\"!editMode\"</span>&gt;</span>Add Note<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>note 对象中封装了 title，id 和 content。几个重要的注意点：</p>\n<ul>\n<li>ng-repeat 用来遍历 notes 中所有的笔记，并且按照自动生成的 id 属性进行升序排序。</li>\n<li>我们使用一个叫 editMode 的属性来指明我们现在在哪种模式下。在编辑模式下，这个属性的值为 true 并且可编辑的 div 节点会显示。用户在这里输入自己的笔记。</li>\n<li>如果 editMode 为 false，我们就在查看模式，显示所有的 notes。</li>\n<li>两个按钮也是基于 editMode 的值而显示和隐藏。</li>\n<li>ng-click 指令用来响应按钮的点击事件。这些方法将和 editMode 一起添加到scope中。</li>\n<li>可编辑的 div 框与 noteText 相绑定，存放了用户输入的文本。如果你想编辑一个已存在的笔记，那么这个模型会用它的文本内容初始化这个 div 框。</li>\n</ul>\n<h3 id=\"第三步\"><a href=\"#第三步\" class=\"headerlink\" title=\"第三步\"></a>第三步</h3><p>我们在scope中创建一个名叫 restore() 的新函数，它用来初始化我们应用中的各种控制器。 它会在 link 函数执行的时候被调用，也会在 save 按钮被点击的时候调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">scope.restore = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  scope.editMode = <span class=\"literal\">false</span>;</div><div class=\"line\">  scope.index = <span class=\"number\">-1</span>;</div><div class=\"line\">  scope.noteText = <span class=\"string\">''</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"第四步\"><a href=\"#第四步\" class=\"headerlink\" title=\"第四步\"></a>第四步</h3><p>我们在 link 函数的内部创建这个函数。 editMode 和 noteText 之前已经解释过了。 index 用来跟踪当前正在编辑的笔记。 当我们在创建一个新的笔记的时候，index 的值会设成 -1. 我们在编辑一个已存在的笔记的时候，它包含了那个 note 对象的 id 值。</p>\n<p>现在我们要创建两个scope函数来处理编辑和保存操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">scope.openEditor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</div><div class=\"line\">  scope.editMode = <span class=\"literal\">true</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (index !== <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">    scope.noteText = notesFactory.get(index).content;</div><div class=\"line\">    scope.index = index;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    scope.noteText = <span class=\"literal\">undefined</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">scope.save = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (scope.noteText !== <span class=\"string\">''</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> note = &#123;&#125;;</div><div class=\"line\">    note.title = scope.noteText.length &gt; <span class=\"number\">10</span> ? scope.noteText.substring(<span class=\"number\">0</span>, <span class=\"number\">10</span>) + <span class=\"string\">'. . .'</span> : scope.noteText;</div><div class=\"line\">    note.content = scope.noteText;</div><div class=\"line\">    note.id = scope.index != <span class=\"number\">-1</span> ? scope.index : localStorage.length;</div><div class=\"line\">    scope.notes = notesFactory.put(note);</div><div class=\"line\">  &#125;</div><div class=\"line\">  scope.restore();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>openEditor 为编辑器做准备工作。如果我们在编辑一个笔记，它会获取当前笔记的内容并且通过使用 ng-bind 将内容更新到可编辑的 div 中。这两个函数有几点需要注意：</p>\n<ul>\n<li>如果我们在创建一个新的笔记，我们会将 noteText 设置成 undefined，以便当我们在保存笔记的时候，触发相应的监听器。</li>\n<li>如果 index 参数是 undefined，它表明用户正在创建一个新的笔记。</li>\n<li>save 函数通过使用 notesFactory 来存储笔记。在保存完成后，它会刷新 notes 数组，从而监听器能够监测到笔记列表的变化，来及时更新。</li>\n<li>save 函数调用在重置 controllers 之后调用restore()，从而可以从编辑模式进入查看模式。</li>\n</ul>\n<h3 id=\"第五步\"><a href=\"#第五步\" class=\"headerlink\" title=\"第五步\"></a>第五步</h3><p>在 link 函数执行时，我们初始化 notes 数组，并且为可编辑的 div 框绑定一个 keydown 事件，从而保证我们的 nodeText 模型与 div 中的内容保持同步。我们使用这个 noteText 来保存我们的笔记内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> editor = elem.find(<span class=\"string\">'#editor'</span>);</div><div class=\"line\">scope.restore();  <span class=\"comment\">// initialize our app controls</span></div><div class=\"line\">scope.notes = notesFactory.getAll(); <span class=\"comment\">// load notes</span></div><div class=\"line\">editor.bind(<span class=\"string\">'keyup keydown'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  scope.noteText = editor.text().trim();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"第六步\"><a href=\"#第六步\" class=\"headerlink\" title=\"第六步\"></a>第六步</h3><p>最后，我们在HTML如同使用其他的HTML元素一样使用我们的指令，然后开始做笔记吧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">class</span>=<span class=\"string\">\"title\"</span>&gt;</span>The Note Making App<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">notepad</span>/&gt;</span></div></pre></td></tr></table></figure>\n<p>源码下载：<a href=\"https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip\">https://github.com/jsprodotcom/source/blob/master/AngularJS_Note_Taker-source_code.zip</a></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一个很重要的点需要注意的是，任何使用jQuery能做的事情，我们都能用Angular指令来做到，并且使用更少的代码。所以，在使用jQuery之前，请考虑一下我们能否在不进行DOM操作的情况下以更好的方式来完成任务。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/angularjs-command-learn.html\">http://www.codeceo.com</a></p>\n"},{"title":"7个你可能不认识的CSS单位","date":"2015-01-03T16:00:00.000Z","_content":"\n众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。\n随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。\n\n这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。\n\n今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~\n\n###rem\n\n我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。\n\n```\n    <body>\n      <div class=\"test\">Test</div>\n    </body>\n    \n    body {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px\n    }\n```\n\n你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。\n\n但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。\n\n```\n    <body>\n      <div>\n        Test <!-- 14 * 1.2 = 16.8px -->\n        <div>\n          Test <!-- 16.8 * 1.2 = 20.16px -->\n          <div>\n            Test <!-- 20.16 * 1.2 = 24.192px -->\n          </div>\n        </div>\n      </div>\n    </body>\n```\n\n###实例\n\n虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。\n\n```\n    html {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2rem;\n    }\n```\n\n这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。\n\n适用于网格布局\nRems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，\n\n```\n    .container {\n      width: 70rem; // 70 * 14px = 980px\n    }\n    \n```\n\n概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。\n\n###vh and vw\n\n响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。\n\n1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。\n\n可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。\n\n```\n    .slide {\n      height: 100vh;\n    }\n```\n\n假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！\n实例\n\n###vmin and vmax\n\nvh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。\n那么问题来了，我们应该在什么场景下使用这两个单位呢？\n假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：\n\n```\n    .box {\n      height: 100vmin;\n      width: 100vmin;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png)\n\n如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）\n\n```\n    .box {\n        height: 100vmax;\n        width: 100vmax;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png)\n\n结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。\n\n###ex and ch\n\nex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。\n\nch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。\n\nex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png)\n\nx-height; the height of the lower case x\n\n这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用\n上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：\n\n```\n    sup {\n        position: relative;\n        bottom: 1ex;\n    }\n    sub {\n        position: relative;\n        bottom: -1ex;\n    }\n```\n\n###结论\n\n持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！\n","source":"_posts/7个你可能不认识的CSS单位.md","raw":"---\ntitle: 7个你可能不认识的CSS单位\ntags: [css]\ndate: 2015/01/04\n---\n\n众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。\n随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。\n\n这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。\n\n今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~\n\n###rem\n\n我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。\n\n```\n    <body>\n      <div class=\"test\">Test</div>\n    </body>\n    \n    body {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px\n    }\n```\n\n你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。\n\n但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。\n\n```\n    <body>\n      <div>\n        Test <!-- 14 * 1.2 = 16.8px -->\n        <div>\n          Test <!-- 16.8 * 1.2 = 20.16px -->\n          <div>\n            Test <!-- 20.16 * 1.2 = 24.192px -->\n          </div>\n        </div>\n      </div>\n    </body>\n```\n\n###实例\n\n虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。\n\n```\n    html {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2rem;\n    }\n```\n\n这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。\n\n适用于网格布局\nRems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，\n\n```\n    .container {\n      width: 70rem; // 70 * 14px = 980px\n    }\n    \n```\n\n概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。\n\n###vh and vw\n\n响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。\n\n1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。\n\n可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。\n\n```\n    .slide {\n      height: 100vh;\n    }\n```\n\n假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！\n实例\n\n###vmin and vmax\n\nvh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。\n那么问题来了，我们应该在什么场景下使用这两个单位呢？\n假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：\n\n```\n    .box {\n      height: 100vmin;\n      width: 100vmin;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png)\n\n如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）\n\n```\n    .box {\n        height: 100vmax;\n        width: 100vmax;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png)\n\n结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。\n\n###ex and ch\n\nex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。\n\nch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。\n\nex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png)\n\nx-height; the height of the lower case x\n\n这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用\n上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：\n\n```\n    sup {\n        position: relative;\n        bottom: 1ex;\n    }\n    sub {\n        position: relative;\n        bottom: -1ex;\n    }\n```\n\n###结论\n\n持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！\n","slug":"7个你可能不认识的CSS单位","published":1,"updated":"2016-08-17T06:22:19.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphv000j68ddtwek2ixq","content":"<p>众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。<br>随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。</p>\n<p>这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。</p>\n<p>今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~</p>\n<p>###rem</p>\n<p>我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;div class=&quot;test&quot;&gt;Test&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\"></div><div class=\"line\">body &#123;</div><div class=\"line\">  font-size: 14px;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。</p>\n<p>但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    Test &lt;!-- 14 * 1.2 = 16.8px --&gt;</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt;</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>###实例</p>\n<p>虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。</html></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">html &#123;</div><div class=\"line\">  font-size: 14px;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  font-size: 1.2rem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。</p>\n<p>适用于网格布局<br>Rems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.container &#123;</div><div class=\"line\">  width: 70rem; // 70 * 14px = 980px</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。</p>\n<p>###vh and vw</p>\n<p>响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。</p>\n<p>1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。</p>\n<p>可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.slide &#123;</div><div class=\"line\">  height: 100vh;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！<br>实例</p>\n<p>###vmin and vmax</p>\n<p>vh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。<br>那么问题来了，我们应该在什么场景下使用这两个单位呢？<br>假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.box &#123;</div><div class=\"line\">  height: 100vmin;</div><div class=\"line\">  width: 100vmin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png\" alt=\"img\"></p>\n<p>如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.box &#123;</div><div class=\"line\">    height: 100vmax;</div><div class=\"line\">    width: 100vmax;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png\" alt=\"img\"></p>\n<p>结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。</p>\n<p>###ex and ch</p>\n<p>ex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。</p>\n<p>ch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。</p>\n<p>ex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。</p>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png\" alt=\"img\"></p>\n<p>x-height; the height of the lower case x</p>\n<p>这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用<br>上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sup &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    bottom: 1ex;</div><div class=\"line\">&#125;</div><div class=\"line\">sub &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    bottom: -1ex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！</p>\n","excerpt":"","more":"<p>众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。<br>随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。</p>\n<p>这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。</p>\n<p>今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~</p>\n<p>###rem</p>\n<p>我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;div class=&quot;test&quot;&gt;Test&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\"></div><div class=\"line\">body &#123;</div><div class=\"line\">  font-size: 14px;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。</p>\n<p>但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;body&gt;</div><div class=\"line\">  &lt;div&gt;</div><div class=\"line\">    Test &lt;!-- 14 * 1.2 = 16.8px --&gt;</div><div class=\"line\">    &lt;div&gt;</div><div class=\"line\">      Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt;</div><div class=\"line\">      &lt;div&gt;</div><div class=\"line\">        Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt;</div><div class=\"line\">      &lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">  &lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div></pre></td></tr></table></figure>\n<p>###实例</p>\n<p>虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">html &#123;</div><div class=\"line\">  font-size: 14px;</div><div class=\"line\">&#125;</div><div class=\"line\">div &#123;</div><div class=\"line\">  font-size: 1.2rem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。</p>\n<p>适用于网格布局<br>Rems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.container &#123;</div><div class=\"line\">  width: 70rem; // 70 * 14px = 980px</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。</p>\n<p>###vh and vw</p>\n<p>响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。</p>\n<p>1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。</p>\n<p>可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.slide &#123;</div><div class=\"line\">  height: 100vh;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！<br>实例</p>\n<p>###vmin and vmax</p>\n<p>vh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。<br>那么问题来了，我们应该在什么场景下使用这两个单位呢？<br>假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.box &#123;</div><div class=\"line\">  height: 100vmin;</div><div class=\"line\">  width: 100vmin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png\" alt=\"img\"></p>\n<p>如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.box &#123;</div><div class=\"line\">    height: 100vmax;</div><div class=\"line\">    width: 100vmax;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png\" alt=\"img\"></p>\n<p>结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。</p>\n<p>###ex and ch</p>\n<p>ex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。</p>\n<p>ch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。</p>\n<p>ex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。</p>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png\" alt=\"img\"></p>\n<p>x-height; the height of the lower case x</p>\n<p>这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用<br>上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sup &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    bottom: 1ex;</div><div class=\"line\">&#125;</div><div class=\"line\">sub &#123;</div><div class=\"line\">    position: relative;</div><div class=\"line\">    bottom: -1ex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！</p>\n"},{"title":"Angularjs知识点1","date":"2016-04-10T16:00:00.000Z","_content":"\n### 知识点：\n\n+ ng-repeat\n+ ng-class-odd\n+ ng-class-even\n\n### 代码及演示：\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/kmqf1hpq/)\n","source":"_posts/Angularjs知识点1.md","raw":"---\ntitle: Angularjs知识点1\ntags: [javascript,angularjs]\ndate: 2016/04/11\n---\n\n### 知识点：\n\n+ ng-repeat\n+ ng-class-odd\n+ ng-class-even\n\n### 代码及演示：\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/kmqf1hpq/)\n","slug":"Angularjs知识点1","published":1,"updated":"2016-08-17T06:22:19.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cphy000m68ddomlji6wg","content":"<h3 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h3><ul>\n<li>ng-repeat</li>\n<li>ng-class-odd</li>\n<li>ng-class-even</li>\n</ul>\n<h3 id=\"代码及演示：\"><a href=\"#代码及演示：\" class=\"headerlink\" title=\"代码及演示：\"></a>代码及演示：</h3><p><a href=\"https://jsfiddle.net/Lionney/kmqf1hpq/\" target=\"_blank\" rel=\"external\">jsfiddle.net</a></p>\n","excerpt":"","more":"<h3 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h3><ul>\n<li>ng-repeat</li>\n<li>ng-class-odd</li>\n<li>ng-class-even</li>\n</ul>\n<h3 id=\"代码及演示：\"><a href=\"#代码及演示：\" class=\"headerlink\" title=\"代码及演示：\"></a>代码及演示：</h3><p><a href=\"https://jsfiddle.net/Lionney/kmqf1hpq/\">jsfiddle.net</a></p>\n"},{"title":"Angularjs轻松实现表格按指定列排序","date":"2016-05-17T16:00:00.000Z","_content":"\n使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：\n\nhtml代码：\n\n```html\n<table class=\"table table-border\" ng-app=\"myapp\" ng-controller=\"orderByCtrl\">\n    <thead>\n        <tr>\n            <th>inx</th>\n            <th ng-click=\"col='name';desc=!desc\">name</th>\n            <!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 -->\n            <th ng-click=\"col='gender';desc=!desc\">gender</th>\n            <th ng-click=\"col='age';desc=!desc\">age</th>\n            <th ng-click=\"col='score';desc=!desc\">score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr ng-repeat=\"d in data|orderBy:col:desc\">\n            <td ng-bind=\"$index+1\"></td>\n            <td ng-bind=\"d.name\"></td>\n            <td ng-bind=\"d.gender\"></td>\n            <td ng-bind=\"d.age\"></td>\n            <td ng-bind=\"d.score\"></td>\n        </tr>\n    </tbody>\n</table>\n```\n\njs代码：\n\n```javascript\nvar app = angular.module('myapp', []);\n\napp.controller('orderByCtrl', function($scope) {\n    $scope.col = 'name';//默认按name列排序\n    $scope.desc = 0;//默认排序条件升序\n    $scope.data = [{\n        name: 'name 1',\n        gender: 'male',\n        age: 26,\n        score: 70\n    }, {\n        name: 'name 2',\n        gender: 'female',\n        age: 24,\n        score: 84\n    }, {\n        name: 'name 3',\n        gender: 'male',\n        age: 20,\n        score: 76\n    }, {\n        name: 'name 4',\n        gender: 'female',\n        age: 22,\n        score: 64\n    }];\n\n\n})\n```\n\n让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式\n\n```css\nth {\n    cursor: pointer;\n}\n```\n\n运行结果[点击这里](https://jsfiddle.net/Lionney/xowyoaxj/)查看\n","source":"_posts/Angularjs轻松实现表格按指定列排序.md","raw":"---\ntitle: Angularjs轻松实现表格按指定列排序\ntags: [javascript,angularjs]\ndate: 2016/05/18\n---\n\n使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：\n\nhtml代码：\n\n```html\n<table class=\"table table-border\" ng-app=\"myapp\" ng-controller=\"orderByCtrl\">\n    <thead>\n        <tr>\n            <th>inx</th>\n            <th ng-click=\"col='name';desc=!desc\">name</th>\n            <!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 -->\n            <th ng-click=\"col='gender';desc=!desc\">gender</th>\n            <th ng-click=\"col='age';desc=!desc\">age</th>\n            <th ng-click=\"col='score';desc=!desc\">score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr ng-repeat=\"d in data|orderBy:col:desc\">\n            <td ng-bind=\"$index+1\"></td>\n            <td ng-bind=\"d.name\"></td>\n            <td ng-bind=\"d.gender\"></td>\n            <td ng-bind=\"d.age\"></td>\n            <td ng-bind=\"d.score\"></td>\n        </tr>\n    </tbody>\n</table>\n```\n\njs代码：\n\n```javascript\nvar app = angular.module('myapp', []);\n\napp.controller('orderByCtrl', function($scope) {\n    $scope.col = 'name';//默认按name列排序\n    $scope.desc = 0;//默认排序条件升序\n    $scope.data = [{\n        name: 'name 1',\n        gender: 'male',\n        age: 26,\n        score: 70\n    }, {\n        name: 'name 2',\n        gender: 'female',\n        age: 24,\n        score: 84\n    }, {\n        name: 'name 3',\n        gender: 'male',\n        age: 20,\n        score: 76\n    }, {\n        name: 'name 4',\n        gender: 'female',\n        age: 22,\n        score: 64\n    }];\n\n\n})\n```\n\n让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式\n\n```css\nth {\n    cursor: pointer;\n}\n```\n\n运行结果[点击这里](https://jsfiddle.net/Lionney/xowyoaxj/)查看\n","slug":"Angularjs轻松实现表格按指定列排序","published":1,"updated":"2016-08-17T06:22:19.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpi0000o68ddpzieqq4g","content":"<p>使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：</p>\n<p>html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table table-border\"</span> <span class=\"attr\">ng-app</span>=<span class=\"string\">\"myapp\"</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"orderByCtrl\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>inx<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='name';desc=!desc\"</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"comment\">&lt;!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 --&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='gender';desc=!desc\"</span>&gt;</span>gender<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='age';desc=!desc\"</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='score';desc=!desc\"</span>&gt;</span>score<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"d in data|orderBy:col:desc\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"$index+1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.gender\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.age\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.score\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(<span class=\"string\">'orderByCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</div><div class=\"line\">    $scope.col = <span class=\"string\">'name'</span>;<span class=\"comment\">//默认按name列排序</span></div><div class=\"line\">    $scope.desc = <span class=\"number\">0</span>;<span class=\"comment\">//默认排序条件升序</span></div><div class=\"line\">    $scope.data = [&#123;</div><div class=\"line\">        name: <span class=\"string\">'name 1'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">        age: <span class=\"number\">26</span>,</div><div class=\"line\">        score: <span class=\"number\">70</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 2'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">        age: <span class=\"number\">24</span>,</div><div class=\"line\">        score: <span class=\"number\">84</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 3'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">        age: <span class=\"number\">20</span>,</div><div class=\"line\">        score: <span class=\"number\">76</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 4'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">        age: <span class=\"number\">22</span>,</div><div class=\"line\">        score: <span class=\"number\">64</span></div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">th</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果<a href=\"https://jsfiddle.net/Lionney/xowyoaxj/\" target=\"_blank\" rel=\"external\">点击这里</a>查看</p>\n","excerpt":"","more":"<p>使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：</p>\n<p>html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table table-border\"</span> <span class=\"attr\">ng-app</span>=<span class=\"string\">\"myapp\"</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"orderByCtrl\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>inx<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='name';desc=!desc\"</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"comment\">&lt;!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 --&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='gender';desc=!desc\"</span>&gt;</span>gender<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='age';desc=!desc\"</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='score';desc=!desc\"</span>&gt;</span>score<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"d in data|orderBy:col:desc\"</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"$index+1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.gender\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.age\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.score\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</div><div class=\"line\"></div><div class=\"line\">app.controller(<span class=\"string\">'orderByCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</div><div class=\"line\">    $scope.col = <span class=\"string\">'name'</span>;<span class=\"comment\">//默认按name列排序</span></div><div class=\"line\">    $scope.desc = <span class=\"number\">0</span>;<span class=\"comment\">//默认排序条件升序</span></div><div class=\"line\">    $scope.data = [&#123;</div><div class=\"line\">        name: <span class=\"string\">'name 1'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">        age: <span class=\"number\">26</span>,</div><div class=\"line\">        score: <span class=\"number\">70</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 2'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">        age: <span class=\"number\">24</span>,</div><div class=\"line\">        score: <span class=\"number\">84</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 3'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'male'</span>,</div><div class=\"line\">        age: <span class=\"number\">20</span>,</div><div class=\"line\">        score: <span class=\"number\">76</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        name: <span class=\"string\">'name 4'</span>,</div><div class=\"line\">        gender: <span class=\"string\">'female'</span>,</div><div class=\"line\">        age: <span class=\"number\">22</span>,</div><div class=\"line\">        score: <span class=\"number\">64</span></div><div class=\"line\">    &#125;];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">th</span> &#123;</div><div class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>运行结果<a href=\"https://jsfiddle.net/Lionney/xowyoaxj/\">点击这里</a>查看</p>\n"},{"title":"Array.prototype.reduce函数","date":"2016-04-09T16:00:00.000Z","_content":"\n### 概述\n\nreduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\n### 语法\n\n`arr.reduce(callback,[initialValue])`\n\n**参数**\n\n*callback 执行数组中每个值的函数，包含四个参数*\n\n> *previousValue*\n> 上一次调用回调返回的值，或者是提供的初始值（initialValue）\n> *currentValue*\n> 数组中当前被处理的元素\n> *index*\n> 当前元素在数组中的索引\n> *array*\n> 调用 reduce 的数组\n> *initialValue*\n> 作为第一次调用 callback 的第一个参数。\n\n### 描述\n\nreduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。\n\n回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。\n\n例如执行下面的代码\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n});\n```\n\n回调被执行四次，每次的参数和返回值如下表：\n\n| previousValue | currentValue | index | array | return | value       |\n| ------------- | ------------ | ----- | ----- | ------ | ----------- |\n| first         | call         | 0     | 1     | 1      | [0,1,2,3,4] |\n| second        | call         | 1     | 2     | 2      | [0,1,2,3,4] |\n| third         | call         | 3     | 3     | 3      | [0,1,2,3,4] |\n| fourth        | call         | 6     | 4     | 4      | [0,1,2,3,4] |\n\nreduce 的返回值是回调函数最后一次被调用的返回值（10）。\n\n如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n}, 10);\n```\n\n| previousValue | currentValue | index | array | return      | value |\n| ------------- | ------------ | ----- | ----- | ----------- | ----- |\n| 第一次调用         | 10           | 0     | 0     | [0,1,2,3,4] | 10    |\n| 第二次调用         | 10           | 1     | 1     | [0,1,2,3,4] | 11    |\n| 第三次调用         | 11           | 2     | 2     | [0,1,2,3,4] | 13    |\n| 第四次调用         | 13           | 3     | 3     | [0,1,2,3,4] | 16    |\n| 第五次调用         | 16           | 4     | 4     | [0,1,2,3,4] | 20    |\n\n### 例子\n\n例子:将数组所有项相加\n\n```\nvar total = [0, 1, 2, 3].reduce(function(a, b) {\n    return a + b;\n});\n// total == 6\n```\n\n例子: 数组扁平化\n\n```\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n    return a.concat(b);\n});\n// flattened is [0, 1, 2, 3, 4, 5]\n```\n\n### 兼容旧环境（Polyfill）\n\nArray.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。\n\n```\nif ('function' !== typeof Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback, opt_initialValue){\n    'use strict';\n    if (null === this || 'undefined' === typeof this) {\n      // At the moment all modern browsers, that support strict mode, have\n      // native implementation of Array.prototype.reduce. For instance, IE8\n      // does not support strict mode, so this check is actually useless.\n      throw new TypeError(\n          'Array.prototype.reduce called on null or undefined');\n    }\n    if ('function' !== typeof callback) {\n      throw new TypeError(callback + ' is not a function');\n    }\n    var index, value,\n        length = this.length >>> 0,\n        isValueSet = false;\n    if (1 < arguments.length) {\n      value = opt_initialValue;\n      isValueSet = true;\n    }\n    for (index = 0; length > index; ++index) {\n      if (this.hasOwnProperty(index)) {\n        if (isValueSet) {\n          value = callback(value, this[index], index, this);\n        }\n        else {\n          value = this[index];\n          isValueSet = true;\n        }\n      }\n    }\n    if (!isValueSet) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    return value;\n  };\n}\n```\n\n### 浏览器兼容性\n**Desktop**\n\n| Feature       | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari |\n| ------------- | ------ | --------------- | ----------------- | ----- | ------ |\n| Basic support | (Yes)  | 3.0(1.9)        | 9                 | 10.5  | 4.0    |\n\n**Mobile**\n\n| Feature       | Android | Chrome for Android | Firefox Mobile (Gecko) | IE Mobile | Opera Mobile | Safari Mobile |\n| ------------- | ------- | ------------------ | ---------------------- | --------- | ------------ | ------------- |\n| Basic support | (Yes)   | (Yes)              | (Yes)                  | (Yes)     | (Yes)        | (Yes)         |\n","source":"_posts/Array.prototype.reduce函数.md","raw":"---\ntitle: Array.prototype.reduce函数\ntags: [javascript]\ndate: 2016/04/10\n---\n\n### 概述\n\nreduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\n### 语法\n\n`arr.reduce(callback,[initialValue])`\n\n**参数**\n\n*callback 执行数组中每个值的函数，包含四个参数*\n\n> *previousValue*\n> 上一次调用回调返回的值，或者是提供的初始值（initialValue）\n> *currentValue*\n> 数组中当前被处理的元素\n> *index*\n> 当前元素在数组中的索引\n> *array*\n> 调用 reduce 的数组\n> *initialValue*\n> 作为第一次调用 callback 的第一个参数。\n\n### 描述\n\nreduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。\n\n回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。\n\n例如执行下面的代码\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n});\n```\n\n回调被执行四次，每次的参数和返回值如下表：\n\n| previousValue | currentValue | index | array | return | value       |\n| ------------- | ------------ | ----- | ----- | ------ | ----------- |\n| first         | call         | 0     | 1     | 1      | [0,1,2,3,4] |\n| second        | call         | 1     | 2     | 2      | [0,1,2,3,4] |\n| third         | call         | 3     | 3     | 3      | [0,1,2,3,4] |\n| fourth        | call         | 6     | 4     | 4      | [0,1,2,3,4] |\n\nreduce 的返回值是回调函数最后一次被调用的返回值（10）。\n\n如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n}, 10);\n```\n\n| previousValue | currentValue | index | array | return      | value |\n| ------------- | ------------ | ----- | ----- | ----------- | ----- |\n| 第一次调用         | 10           | 0     | 0     | [0,1,2,3,4] | 10    |\n| 第二次调用         | 10           | 1     | 1     | [0,1,2,3,4] | 11    |\n| 第三次调用         | 11           | 2     | 2     | [0,1,2,3,4] | 13    |\n| 第四次调用         | 13           | 3     | 3     | [0,1,2,3,4] | 16    |\n| 第五次调用         | 16           | 4     | 4     | [0,1,2,3,4] | 20    |\n\n### 例子\n\n例子:将数组所有项相加\n\n```\nvar total = [0, 1, 2, 3].reduce(function(a, b) {\n    return a + b;\n});\n// total == 6\n```\n\n例子: 数组扁平化\n\n```\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n    return a.concat(b);\n});\n// flattened is [0, 1, 2, 3, 4, 5]\n```\n\n### 兼容旧环境（Polyfill）\n\nArray.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。\n\n```\nif ('function' !== typeof Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback, opt_initialValue){\n    'use strict';\n    if (null === this || 'undefined' === typeof this) {\n      // At the moment all modern browsers, that support strict mode, have\n      // native implementation of Array.prototype.reduce. For instance, IE8\n      // does not support strict mode, so this check is actually useless.\n      throw new TypeError(\n          'Array.prototype.reduce called on null or undefined');\n    }\n    if ('function' !== typeof callback) {\n      throw new TypeError(callback + ' is not a function');\n    }\n    var index, value,\n        length = this.length >>> 0,\n        isValueSet = false;\n    if (1 < arguments.length) {\n      value = opt_initialValue;\n      isValueSet = true;\n    }\n    for (index = 0; length > index; ++index) {\n      if (this.hasOwnProperty(index)) {\n        if (isValueSet) {\n          value = callback(value, this[index], index, this);\n        }\n        else {\n          value = this[index];\n          isValueSet = true;\n        }\n      }\n    }\n    if (!isValueSet) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    return value;\n  };\n}\n```\n\n### 浏览器兼容性\n**Desktop**\n\n| Feature       | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari |\n| ------------- | ------ | --------------- | ----------------- | ----- | ------ |\n| Basic support | (Yes)  | 3.0(1.9)        | 9                 | 10.5  | 4.0    |\n\n**Mobile**\n\n| Feature       | Android | Chrome for Android | Firefox Mobile (Gecko) | IE Mobile | Opera Mobile | Safari Mobile |\n| ------------- | ------- | ------------------ | ---------------------- | --------- | ------------ | ------------- |\n| Basic support | (Yes)   | (Yes)              | (Yes)                  | (Yes)     | (Yes)        | (Yes)         |\n","slug":"Array.prototype.reduce函数","published":1,"updated":"2016-08-17T06:22:19.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpi2000r68ddq87w6zgp","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>arr.reduce(callback,[initialValue])</code></p>\n<p><strong>参数</strong></p>\n<p><em>callback 执行数组中每个值的函数，包含四个参数</em></p>\n<blockquote>\n<p><em>previousValue</em><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）<br><em>currentValue</em><br>数组中当前被处理的元素<br><em>index</em><br>当前元素在数组中的索引<br><em>array</em><br>调用 reduce 的数组<br><em>initialValue</em><br>作为第一次调用 callback 的第一个参数。</p>\n</blockquote>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>\n<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>\n<p>例如执行下面的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</div><div class=\"line\">  return previousValue + currentValue;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>回调被执行四次，每次的参数和返回值如下表：</p>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first</td>\n<td>call</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>second</td>\n<td>call</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>third</td>\n<td>call</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>fourth</td>\n<td>call</td>\n<td>6</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数最后一次被调用的返回值（10）。</p>\n<p>如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</div><div class=\"line\">  return previousValue + currentValue;</div><div class=\"line\">&#125;, 10);</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次调用</td>\n<td>10</td>\n<td>0</td>\n<td>0</td>\n<td>[0,1,2,3,4]</td>\n<td>10</td>\n</tr>\n<tr>\n<td>第二次调用</td>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n<td>11</td>\n</tr>\n<tr>\n<td>第三次调用</td>\n<td>11</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n<td>13</td>\n</tr>\n<tr>\n<td>第四次调用</td>\n<td>13</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n<td>16</td>\n</tr>\n<tr>\n<td>第五次调用</td>\n<td>16</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>例子:将数组所有项相加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var total = [0, 1, 2, 3].reduce(function(a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;);</div><div class=\"line\">// total == 6</div></pre></td></tr></table></figure>\n<p>例子: 数组扁平化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</div><div class=\"line\">    return a.concat(b);</div><div class=\"line\">&#125;);</div><div class=\"line\">// flattened is [0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>\n<h3 id=\"兼容旧环境（Polyfill）\"><a href=\"#兼容旧环境（Polyfill）\" class=\"headerlink\" title=\"兼容旧环境（Polyfill）\"></a>兼容旧环境（Polyfill）</h3><p>Array.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (&apos;function&apos; !== typeof Array.prototype.reduce) &#123;</div><div class=\"line\">  Array.prototype.reduce = function(callback, opt_initialValue)&#123;</div><div class=\"line\">    &apos;use strict&apos;;</div><div class=\"line\">    if (null === this || &apos;undefined&apos; === typeof this) &#123;</div><div class=\"line\">      // At the moment all modern browsers, that support strict mode, have</div><div class=\"line\">      // native implementation of Array.prototype.reduce. For instance, IE8</div><div class=\"line\">      // does not support strict mode, so this check is actually useless.</div><div class=\"line\">      throw new TypeError(</div><div class=\"line\">          &apos;Array.prototype.reduce called on null or undefined&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (&apos;function&apos; !== typeof callback) &#123;</div><div class=\"line\">      throw new TypeError(callback + &apos; is not a function&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    var index, value,</div><div class=\"line\">        length = this.length &gt;&gt;&gt; 0,</div><div class=\"line\">        isValueSet = false;</div><div class=\"line\">    if (1 &lt; arguments.length) &#123;</div><div class=\"line\">      value = opt_initialValue;</div><div class=\"line\">      isValueSet = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (index = 0; length &gt; index; ++index) &#123;</div><div class=\"line\">      if (this.hasOwnProperty(index)) &#123;</div><div class=\"line\">        if (isValueSet) &#123;</div><div class=\"line\">          value = callback(value, this[index], index, this);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">          value = this[index];</div><div class=\"line\">          isValueSet = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!isValueSet) &#123;</div><div class=\"line\">      throw new TypeError(&apos;Reduce of empty array with no initial value&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return value;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p><strong>Desktop</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Chrome</th>\n<th>Firefox (Gecko)</th>\n<th>Internet Explorer</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>3.0(1.9)</td>\n<td>9</td>\n<td>10.5</td>\n<td>4.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mobile</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Android</th>\n<th>Chrome for Android</th>\n<th>Firefox Mobile (Gecko)</th>\n<th>IE Mobile</th>\n<th>Opera Mobile</th>\n<th>Safari Mobile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>arr.reduce(callback,[initialValue])</code></p>\n<p><strong>参数</strong></p>\n<p><em>callback 执行数组中每个值的函数，包含四个参数</em></p>\n<blockquote>\n<p><em>previousValue</em><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）<br><em>currentValue</em><br>数组中当前被处理的元素<br><em>index</em><br>当前元素在数组中的索引<br><em>array</em><br>调用 reduce 的数组<br><em>initialValue</em><br>作为第一次调用 callback 的第一个参数。</p>\n</blockquote>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>\n<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>\n<p>例如执行下面的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</div><div class=\"line\">  return previousValue + currentValue;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>回调被执行四次，每次的参数和返回值如下表：</p>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first</td>\n<td>call</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>second</td>\n<td>call</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>third</td>\n<td>call</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>fourth</td>\n<td>call</td>\n<td>6</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数最后一次被调用的返回值（10）。</p>\n<p>如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</div><div class=\"line\">  return previousValue + currentValue;</div><div class=\"line\">&#125;, 10);</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次调用</td>\n<td>10</td>\n<td>0</td>\n<td>0</td>\n<td>[0,1,2,3,4]</td>\n<td>10</td>\n</tr>\n<tr>\n<td>第二次调用</td>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n<td>11</td>\n</tr>\n<tr>\n<td>第三次调用</td>\n<td>11</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n<td>13</td>\n</tr>\n<tr>\n<td>第四次调用</td>\n<td>13</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n<td>16</td>\n</tr>\n<tr>\n<td>第五次调用</td>\n<td>16</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>例子:将数组所有项相加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var total = [0, 1, 2, 3].reduce(function(a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;);</div><div class=\"line\">// total == 6</div></pre></td></tr></table></figure>\n<p>例子: 数组扁平化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</div><div class=\"line\">    return a.concat(b);</div><div class=\"line\">&#125;);</div><div class=\"line\">// flattened is [0, 1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>\n<h3 id=\"兼容旧环境（Polyfill）\"><a href=\"#兼容旧环境（Polyfill）\" class=\"headerlink\" title=\"兼容旧环境（Polyfill）\"></a>兼容旧环境（Polyfill）</h3><p>Array.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (&apos;function&apos; !== typeof Array.prototype.reduce) &#123;</div><div class=\"line\">  Array.prototype.reduce = function(callback, opt_initialValue)&#123;</div><div class=\"line\">    &apos;use strict&apos;;</div><div class=\"line\">    if (null === this || &apos;undefined&apos; === typeof this) &#123;</div><div class=\"line\">      // At the moment all modern browsers, that support strict mode, have</div><div class=\"line\">      // native implementation of Array.prototype.reduce. For instance, IE8</div><div class=\"line\">      // does not support strict mode, so this check is actually useless.</div><div class=\"line\">      throw new TypeError(</div><div class=\"line\">          &apos;Array.prototype.reduce called on null or undefined&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (&apos;function&apos; !== typeof callback) &#123;</div><div class=\"line\">      throw new TypeError(callback + &apos; is not a function&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    var index, value,</div><div class=\"line\">        length = this.length &gt;&gt;&gt; 0,</div><div class=\"line\">        isValueSet = false;</div><div class=\"line\">    if (1 &lt; arguments.length) &#123;</div><div class=\"line\">      value = opt_initialValue;</div><div class=\"line\">      isValueSet = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (index = 0; length &gt; index; ++index) &#123;</div><div class=\"line\">      if (this.hasOwnProperty(index)) &#123;</div><div class=\"line\">        if (isValueSet) &#123;</div><div class=\"line\">          value = callback(value, this[index], index, this);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">          value = this[index];</div><div class=\"line\">          isValueSet = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (!isValueSet) &#123;</div><div class=\"line\">      throw new TypeError(&apos;Reduce of empty array with no initial value&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return value;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p><strong>Desktop</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Chrome</th>\n<th>Firefox (Gecko)</th>\n<th>Internet Explorer</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>3.0(1.9)</td>\n<td>9</td>\n<td>10.5</td>\n<td>4.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mobile</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Android</th>\n<th>Chrome for Android</th>\n<th>Firefox Mobile (Gecko)</th>\n<th>IE Mobile</th>\n<th>Opera Mobile</th>\n<th>Safari Mobile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Angularjs知识点2","date":"2016-04-10T16:00:00.000Z","_content":"\n### 知识点\n\n+ ng-show\n+ ng-hide\n+ ng-switch\n\n### 代码及演示\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/jor7q4eq/)\n","source":"_posts/Angularjs知识点2.md","raw":"---\ntitle: Angularjs知识点2\ntags: [javascript,angularjs]\ndate: 2016/04/11\n---\n\n### 知识点\n\n+ ng-show\n+ ng-hide\n+ ng-switch\n\n### 代码及演示\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/jor7q4eq/)\n","slug":"Angularjs知识点2","published":1,"updated":"2016-08-17T06:22:19.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpi5000t68ddneiu7n55","content":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>ng-show</li>\n<li>ng-hide</li>\n<li>ng-switch</li>\n</ul>\n<h3 id=\"代码及演示\"><a href=\"#代码及演示\" class=\"headerlink\" title=\"代码及演示\"></a>代码及演示</h3><p><a href=\"https://jsfiddle.net/Lionney/jor7q4eq/\" target=\"_blank\" rel=\"external\">jsfiddle.net</a></p>\n","excerpt":"","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>ng-show</li>\n<li>ng-hide</li>\n<li>ng-switch</li>\n</ul>\n<h3 id=\"代码及演示\"><a href=\"#代码及演示\" class=\"headerlink\" title=\"代码及演示\"></a>代码及演示</h3><p><a href=\"https://jsfiddle.net/Lionney/jor7q4eq/\">jsfiddle.net</a></p>\n"},{"title":"CSS“隐藏”元素的几种方法的对比","date":"2015-10-25T16:00:00.000Z","_content":"\n一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！\n\n几种方法的简单介绍\n\n首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。\n\n`display:none`\n\n### 设置元素的display为none是最常用的隐藏元素的方法。\n\n```\n.hide {\n     display:none;\n}\n```\n\n将元素设置为`display:none`后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。\n\n```\nvisibility:hidden\n```\n\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和`display:none`的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。\n\n```\n.hidden{\n   visibility:hidden\n}\n```\n`visibility:hidden`适用于那些元素隐藏后不希望页面布局会发生变化的场景\n\n```\nopacity:0\n```\n\nopacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。\n\n```\n.transparent {\n   opacity:0;\n}\n```\n\n这种方法和`visibility:hidden`的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。\n\n### 设置height，width等盒模型属性为0\n\n这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其`overflow:hidden`来隐藏其子元素，这算是一种奇技淫巧。\n\n```\n.hiddenBox {\n   margin:0;\n   border:0;\n   padding:0;\n   height:0;\n   width:0;\n   overflow:hidden;\n}\n```\n\n这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的`overflow:hidden`后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。\n\n### 元素隐藏后的事件响应\n\n如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n    }\n    .none { display: none; }\n    .hidden { visibility: hidden; }\n    .opacity0 { opacity: 0; }\n    .height0 { height: 0; }  \n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n    $(\".none\").on(\"click\", function () {\n        console.log(\"none clicked\");\n    })\n    $(\".hidden\").on(\"click\", function () {\n        console.log(\"hidden clicked\");\n    })\n    $(\".opacity0\").on(\"click\", function () {\n        console.log(\"opacity0 clicked\");\n    })\n    $(\".height0\").on(\"click\", function () {\n        console.log(\"height0 clicked\");\n    })\n</script>\n```\n\n这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：\n\n1、`display:none`：元素彻底消失，很显然不会触发其点击事件\n\n2、`visibility:hidden`：无法触发其点击事件，有一种说法是`display:none`是元素看不见摸不着，而`visibility:hidden`是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。\n\n3、`opacity:0`：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件\n\n4、`height:0`：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。\n\n但是这些结论真的准确吗？\n我们在上面的代码中添加这样一句代码：\n\n```\n$(\".none\").click();\n```\n\n结果发现，触发了click事件，也就是通过JS可以触发被设置为`display:none`的元素的事件。\n所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！\n\n### CSS3 transition对这几种方法的影响\n\nCSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n        transition: all linear 2s;  \n    }\n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n$(\".none\").on(\"click\", function () {\n    console.log(\"none clicked\");\n    $(this).css(\"display\", \"none\");\n})\n$(\".hidden\").on(\"click\", function () {\n    console.log(\"hidden clicked\");\n    $(this).css(\"visibility\", \"hidden\");\n})\n$(\".opacity0\").on(\"click\", function () {\n    console.log(\"opacity0 clicked\");\n    $(this).css(\"opacity\", 0);\n})\n$(\".height0\").on(\"click\", function () {\n    console.log(\"height0 clicked\");\n    $(this).css({\n        \"height\": 0,\n    });\n})\n</script>\n```\n\n经过测试，可以看到：\n1、`display:none`：完全不受transition属性的影响，元素立即消失\n2、`visibility:hidden`：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果\n3、opacity和height等属性能够进行正常的动画效果\n\n假设我们要通过CSS3来做一个淡出的动画效果，应该如下：\n\n```\n.fadeOut { visibility: visible; opacity: 1; transition: all linear 2s; }\n.fadeOut:hover { visibility: hidden; opacity: 0; }\n```\n\n应该同时设置元素的visibility和opacity属性。\n\n### 总结说明\n\n本文总结说明了“隐藏”元素的几种方式，其中最常用的还是`display:none`和`visibility:hidden`。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！\n\n### 补充\n\n来自评论区小伙伴们补充的技巧：\n\n1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外\n\n2、设置元素的position与z-index，将z-index设置成尽量小的负数\n","source":"_posts/CSS“隐藏”元素的几种方法的对比.md","raw":"---\ntitle: CSS“隐藏”元素的几种方法的对比\ntags: [css]\ndate: 2015/10/26\n---\n\n一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！\n\n几种方法的简单介绍\n\n首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。\n\n`display:none`\n\n### 设置元素的display为none是最常用的隐藏元素的方法。\n\n```\n.hide {\n     display:none;\n}\n```\n\n将元素设置为`display:none`后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。\n\n```\nvisibility:hidden\n```\n\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和`display:none`的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。\n\n```\n.hidden{\n   visibility:hidden\n}\n```\n`visibility:hidden`适用于那些元素隐藏后不希望页面布局会发生变化的场景\n\n```\nopacity:0\n```\n\nopacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。\n\n```\n.transparent {\n   opacity:0;\n}\n```\n\n这种方法和`visibility:hidden`的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。\n\n### 设置height，width等盒模型属性为0\n\n这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其`overflow:hidden`来隐藏其子元素，这算是一种奇技淫巧。\n\n```\n.hiddenBox {\n   margin:0;\n   border:0;\n   padding:0;\n   height:0;\n   width:0;\n   overflow:hidden;\n}\n```\n\n这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的`overflow:hidden`后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。\n\n### 元素隐藏后的事件响应\n\n如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n    }\n    .none { display: none; }\n    .hidden { visibility: hidden; }\n    .opacity0 { opacity: 0; }\n    .height0 { height: 0; }  \n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n    $(\".none\").on(\"click\", function () {\n        console.log(\"none clicked\");\n    })\n    $(\".hidden\").on(\"click\", function () {\n        console.log(\"hidden clicked\");\n    })\n    $(\".opacity0\").on(\"click\", function () {\n        console.log(\"opacity0 clicked\");\n    })\n    $(\".height0\").on(\"click\", function () {\n        console.log(\"height0 clicked\");\n    })\n</script>\n```\n\n这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：\n\n1、`display:none`：元素彻底消失，很显然不会触发其点击事件\n\n2、`visibility:hidden`：无法触发其点击事件，有一种说法是`display:none`是元素看不见摸不着，而`visibility:hidden`是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。\n\n3、`opacity:0`：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件\n\n4、`height:0`：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。\n\n但是这些结论真的准确吗？\n我们在上面的代码中添加这样一句代码：\n\n```\n$(\".none\").click();\n```\n\n结果发现，触发了click事件，也就是通过JS可以触发被设置为`display:none`的元素的事件。\n所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！\n\n### CSS3 transition对这几种方法的影响\n\nCSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n        transition: all linear 2s;  \n    }\n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n$(\".none\").on(\"click\", function () {\n    console.log(\"none clicked\");\n    $(this).css(\"display\", \"none\");\n})\n$(\".hidden\").on(\"click\", function () {\n    console.log(\"hidden clicked\");\n    $(this).css(\"visibility\", \"hidden\");\n})\n$(\".opacity0\").on(\"click\", function () {\n    console.log(\"opacity0 clicked\");\n    $(this).css(\"opacity\", 0);\n})\n$(\".height0\").on(\"click\", function () {\n    console.log(\"height0 clicked\");\n    $(this).css({\n        \"height\": 0,\n    });\n})\n</script>\n```\n\n经过测试，可以看到：\n1、`display:none`：完全不受transition属性的影响，元素立即消失\n2、`visibility:hidden`：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果\n3、opacity和height等属性能够进行正常的动画效果\n\n假设我们要通过CSS3来做一个淡出的动画效果，应该如下：\n\n```\n.fadeOut { visibility: visible; opacity: 1; transition: all linear 2s; }\n.fadeOut:hover { visibility: hidden; opacity: 0; }\n```\n\n应该同时设置元素的visibility和opacity属性。\n\n### 总结说明\n\n本文总结说明了“隐藏”元素的几种方式，其中最常用的还是`display:none`和`visibility:hidden`。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！\n\n### 补充\n\n来自评论区小伙伴们补充的技巧：\n\n1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外\n\n2、设置元素的position与z-index，将z-index设置成尽量小的负数\n","slug":"CSS“隐藏”元素的几种方法的对比","published":1,"updated":"2016-08-17T06:22:19.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpi7000w68ddq3em2cpd","content":"<p>一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！</p>\n<p>几种方法的简单介绍</p>\n<p>首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。</p>\n<p><code>display:none</code></p>\n<h3 id=\"设置元素的display为none是最常用的隐藏元素的方法。\"><a href=\"#设置元素的display为none是最常用的隐藏元素的方法。\" class=\"headerlink\" title=\"设置元素的display为none是最常用的隐藏元素的方法。\"></a>设置元素的display为none是最常用的隐藏元素的方法。</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hide &#123;</div><div class=\"line\">     display:none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">visibility:hidden</div></pre></td></tr></table></figure>\n<p>设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和<code>display:none</code>的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hidden&#123;</div><div class=\"line\">   visibility:hidden</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>visibility:hidden</code>适用于那些元素隐藏后不希望页面布局会发生变化的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">opacity:0</div></pre></td></tr></table></figure>\n<p>opacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.transparent &#123;</div><div class=\"line\">   opacity:0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法和<code>visibility:hidden</code>的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。</p>\n<h3 id=\"设置height，width等盒模型属性为0\"><a href=\"#设置height，width等盒模型属性为0\" class=\"headerlink\" title=\"设置height，width等盒模型属性为0\"></a>设置height，width等盒模型属性为0</h3><p>这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素，这算是一种奇技淫巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hiddenBox &#123;</div><div class=\"line\">   margin:0;</div><div class=\"line\">   border:0;</div><div class=\"line\">   padding:0;</div><div class=\"line\">   height:0;</div><div class=\"line\">   width:0;</div><div class=\"line\">   overflow:hidden;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的<code>overflow:hidden</code>后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。</p>\n<h3 id=\"元素隐藏后的事件响应\"><a href=\"#元素隐藏后的事件响应\" class=\"headerlink\" title=\"元素隐藏后的事件响应\"></a>元素隐藏后的事件响应</h3><p>如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">    div &#123; </div><div class=\"line\">        width: 100px; </div><div class=\"line\">        height: 100px; </div><div class=\"line\">        background: red; </div><div class=\"line\">        margin: 15px; </div><div class=\"line\">        padding: 10px; </div><div class=\"line\">        border: 5px solid green; </div><div class=\"line\">        display: inline-block; </div><div class=\"line\">        overflow: hidden; </div><div class=\"line\">    &#125;</div><div class=\"line\">    .none &#123; display: none; &#125;</div><div class=\"line\">    .hidden &#123; visibility: hidden; &#125;</div><div class=\"line\">    .opacity0 &#123; opacity: 0; &#125;</div><div class=\"line\">    .height0 &#123; height: 0; &#125;  </div><div class=\"line\">&lt;/style&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    $(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;none clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;hidden clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;opacity0 clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;height0 clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：</p>\n<p>1、<code>display:none</code>：元素彻底消失，很显然不会触发其点击事件</p>\n<p>2、<code>visibility:hidden</code>：无法触发其点击事件，有一种说法是<code>display:none</code>是元素看不见摸不着，而<code>visibility:hidden</code>是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。</p>\n<p>3、<code>opacity:0</code>：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件</p>\n<p>4、<code>height:0</code>：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。</p>\n<p>但是这些结论真的准确吗？<br>我们在上面的代码中添加这样一句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&quot;.none&quot;).click();</div></pre></td></tr></table></figure>\n<p>结果发现，触发了click事件，也就是通过JS可以触发被设置为<code>display:none</code>的元素的事件。<br>所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！</p>\n<h3 id=\"CSS3-transition对这几种方法的影响\"><a href=\"#CSS3-transition对这几种方法的影响\" class=\"headerlink\" title=\"CSS3 transition对这几种方法的影响\"></a>CSS3 transition对这几种方法的影响</h3><p>CSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">    div &#123; </div><div class=\"line\">        width: 100px; </div><div class=\"line\">        height: 100px; </div><div class=\"line\">        background: red; </div><div class=\"line\">        margin: 15px; </div><div class=\"line\">        padding: 10px; </div><div class=\"line\">        border: 5px solid green; </div><div class=\"line\">        display: inline-block; </div><div class=\"line\">        overflow: hidden; </div><div class=\"line\">        transition: all linear 2s;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&lt;/style&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">$(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;none clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;display&quot;, &quot;none&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;hidden clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;visibility&quot;, &quot;hidden&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;opacity0 clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;opacity&quot;, 0);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;height0 clicked&quot;);</div><div class=\"line\">    $(this).css(&#123;</div><div class=\"line\">        &quot;height&quot;: 0,</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;)</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>经过测试，可以看到：<br>1、<code>display:none</code>：完全不受transition属性的影响，元素立即消失<br>2、<code>visibility:hidden</code>：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果<br>3、opacity和height等属性能够进行正常的动画效果</p>\n<p>假设我们要通过CSS3来做一个淡出的动画效果，应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.fadeOut &#123; visibility: visible; opacity: 1; transition: all linear 2s; &#125;</div><div class=\"line\">.fadeOut:hover &#123; visibility: hidden; opacity: 0; &#125;</div></pre></td></tr></table></figure>\n<p>应该同时设置元素的visibility和opacity属性。</p>\n<h3 id=\"总结说明\"><a href=\"#总结说明\" class=\"headerlink\" title=\"总结说明\"></a>总结说明</h3><p>本文总结说明了“隐藏”元素的几种方式，其中最常用的还是<code>display:none</code>和<code>visibility:hidden</code>。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>来自评论区小伙伴们补充的技巧：</p>\n<p>1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外</p>\n<p>2、设置元素的position与z-index，将z-index设置成尽量小的负数</p>\n","excerpt":"","more":"<p>一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！</p>\n<p>几种方法的简单介绍</p>\n<p>首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。</p>\n<p><code>display:none</code></p>\n<h3 id=\"设置元素的display为none是最常用的隐藏元素的方法。\"><a href=\"#设置元素的display为none是最常用的隐藏元素的方法。\" class=\"headerlink\" title=\"设置元素的display为none是最常用的隐藏元素的方法。\"></a>设置元素的display为none是最常用的隐藏元素的方法。</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hide &#123;</div><div class=\"line\">     display:none;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">visibility:hidden</div></pre></td></tr></table></figure>\n<p>设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和<code>display:none</code>的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hidden&#123;</div><div class=\"line\">   visibility:hidden</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>visibility:hidden</code>适用于那些元素隐藏后不希望页面布局会发生变化的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">opacity:0</div></pre></td></tr></table></figure>\n<p>opacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.transparent &#123;</div><div class=\"line\">   opacity:0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方法和<code>visibility:hidden</code>的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。</p>\n<h3 id=\"设置height，width等盒模型属性为0\"><a href=\"#设置height，width等盒模型属性为0\" class=\"headerlink\" title=\"设置height，width等盒模型属性为0\"></a>设置height，width等盒模型属性为0</h3><p>这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素，这算是一种奇技淫巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.hiddenBox &#123;</div><div class=\"line\">   margin:0;</div><div class=\"line\">   border:0;</div><div class=\"line\">   padding:0;</div><div class=\"line\">   height:0;</div><div class=\"line\">   width:0;</div><div class=\"line\">   overflow:hidden;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的<code>overflow:hidden</code>后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。</p>\n<h3 id=\"元素隐藏后的事件响应\"><a href=\"#元素隐藏后的事件响应\" class=\"headerlink\" title=\"元素隐藏后的事件响应\"></a>元素隐藏后的事件响应</h3><p>如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">    div &#123; </div><div class=\"line\">        width: 100px; </div><div class=\"line\">        height: 100px; </div><div class=\"line\">        background: red; </div><div class=\"line\">        margin: 15px; </div><div class=\"line\">        padding: 10px; </div><div class=\"line\">        border: 5px solid green; </div><div class=\"line\">        display: inline-block; </div><div class=\"line\">        overflow: hidden; </div><div class=\"line\">    &#125;</div><div class=\"line\">    .none &#123; display: none; &#125;</div><div class=\"line\">    .hidden &#123; visibility: hidden; &#125;</div><div class=\"line\">    .opacity0 &#123; opacity: 0; &#125;</div><div class=\"line\">    .height0 &#123; height: 0; &#125;  </div><div class=\"line\">&lt;/style&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">    $(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;none clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;hidden clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;opacity0 clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">    $(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">        console.log(&quot;height0 clicked&quot;);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：</p>\n<p>1、<code>display:none</code>：元素彻底消失，很显然不会触发其点击事件</p>\n<p>2、<code>visibility:hidden</code>：无法触发其点击事件，有一种说法是<code>display:none</code>是元素看不见摸不着，而<code>visibility:hidden</code>是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。</p>\n<p>3、<code>opacity:0</code>：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件</p>\n<p>4、<code>height:0</code>：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。</p>\n<p>但是这些结论真的准确吗？<br>我们在上面的代码中添加这样一句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&quot;.none&quot;).click();</div></pre></td></tr></table></figure>\n<p>结果发现，触发了click事件，也就是通过JS可以触发被设置为<code>display:none</code>的元素的事件。<br>所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！</p>\n<h3 id=\"CSS3-transition对这几种方法的影响\"><a href=\"#CSS3-transition对这几种方法的影响\" class=\"headerlink\" title=\"CSS3 transition对这几种方法的影响\"></a>CSS3 transition对这几种方法的影响</h3><p>CSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;style&gt;</div><div class=\"line\">    div &#123; </div><div class=\"line\">        width: 100px; </div><div class=\"line\">        height: 100px; </div><div class=\"line\">        background: red; </div><div class=\"line\">        margin: 15px; </div><div class=\"line\">        padding: 10px; </div><div class=\"line\">        border: 5px solid green; </div><div class=\"line\">        display: inline-block; </div><div class=\"line\">        overflow: hidden; </div><div class=\"line\">        transition: all linear 2s;  </div><div class=\"line\">    &#125;</div><div class=\"line\">&lt;/style&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </div><div class=\"line\"></div><div class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">$(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;none clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;display&quot;, &quot;none&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;hidden clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;visibility&quot;, &quot;hidden&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;opacity0 clicked&quot;);</div><div class=\"line\">    $(this).css(&quot;opacity&quot;, 0);</div><div class=\"line\">&#125;)</div><div class=\"line\">$(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</div><div class=\"line\">    console.log(&quot;height0 clicked&quot;);</div><div class=\"line\">    $(this).css(&#123;</div><div class=\"line\">        &quot;height&quot;: 0,</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;)</div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>经过测试，可以看到：<br>1、<code>display:none</code>：完全不受transition属性的影响，元素立即消失<br>2、<code>visibility:hidden</code>：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果<br>3、opacity和height等属性能够进行正常的动画效果</p>\n<p>假设我们要通过CSS3来做一个淡出的动画效果，应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.fadeOut &#123; visibility: visible; opacity: 1; transition: all linear 2s; &#125;</div><div class=\"line\">.fadeOut:hover &#123; visibility: hidden; opacity: 0; &#125;</div></pre></td></tr></table></figure>\n<p>应该同时设置元素的visibility和opacity属性。</p>\n<h3 id=\"总结说明\"><a href=\"#总结说明\" class=\"headerlink\" title=\"总结说明\"></a>总结说明</h3><p>本文总结说明了“隐藏”元素的几种方式，其中最常用的还是<code>display:none</code>和<code>visibility:hidden</code>。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>来自评论区小伙伴们补充的技巧：</p>\n<p>1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外</p>\n<p>2、设置元素的position与z-index，将z-index设置成尽量小的负数</p>\n"},{"title":"CSS vs JS动画：谁更快？","date":"2016-05-13T16:00:00.000Z","_content":"\n> 这篇文章翻译自 Julian Shapiro 的 [CSS vs. JS Animation: Which is Faster?](http://davidwalsh.name/css-js-animation)。Julian Shapiro 也是 [Velocity.js](http://julian.com/research/velocity/) 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。\n\nJavascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？\n\n这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。\n\n### jQuery\n\n让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n- jQuery 不能避免[layout thrashing](http://wilsonpage.co.uk/preventing-layout-thrashing/)（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。\n- jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易[让动画卡住](http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html)。\n- jQuery使用了`setInterval`而不是 `reqeustAnimationFrame(RAF)`，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）\n\n注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。\n\n### 实现样例\n\n为了避免layout thrashing，我们需要批量访问和更新DOM。\n\n```javascript\nvar currentTop,currentLeft; /* 有 layout thrashing. */\n\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */ \n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */ \n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */ \n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */ |\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：\n\n```javascript\nvar startingTop = 0; \n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {    \n\t/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */    \n\telement.style.top = (startingTop += 1/60);}, 16); \n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {    \n\telement.style.top = (startingTop += 1/60);\n} \n\t\nwindow.requestAnimationFrame(tick); \n```\n\n你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。\n\n### CSS Transition\n\nCSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：\n\n1. 通过优化 DOM 操作，避免内存消耗来减少卡顿\n2. 使用与 RAF 类似的机制\n3. 强制使用硬件加速 （通过 GPU 来提高动画性能）\n\n然而实际上Javascript也可以使用这些优化。[GSAP](http://www.greensock.com/gsap-js/) 已经做这些优化很久了。[Velocity.js](http://velocityjs.org/) 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。\n\n面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！\n\n让我们来看看CSS动画库的缺陷吧：\n\n- Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的[博客](http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/)谈到过这个问题。\n- IE 10以下的浏览器不支持transition。而目前IE8和IE9还是[很流行](http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share)的。\n- transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。\n\n反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。\n\n> 我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是[Transit](https://github.com/rstacruz/jquery.transit)。\n\n### Javascript动画\n\n所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个[3D 动画的demo](http://julian.com/research/velocity/demo.html)，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个[多媒体小动画](http://julian.com/research/velocity/playground.html)，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个[虚拟世界](http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs)，通常需要canvas才能完成。\n\n为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的[官方文档](http://velocityjs.org/)。\n\n之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：\n\n- 同步DOM ->在整个动画链中微调堆栈以达到最小的layout thrashing。\n- 缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）\n- 在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）\n- 忽略那些变动小到根本看不出来的DOM更新\n\n让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。\n\n```javascript\n$element  \n\t/* Slide the element down into view. */ \n\t.velocity({ opacity: 1, top: \"50%\" })\n\t/* After a delay of 1000ms, slide the element out of view. */    \n\t.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 }); \n```\n\n在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。\n\n浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。\n\n最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。\n\n- GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。\n- GSAP需要[付费](http://www.greensock.com/licensing/)才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。\n- 性能方面，两者几乎相当，很难区分胜负。\n\n> 我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。\n\n### Velocity.js\n\n之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。\n\n简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。\n\n更进一步从易用性的角度来讲，Velocity使用了jQuery的`$.queue()`方法，因此可以无缝过渡到jQuery的`$.animate()`、`$.fade()`和`$.delay()`方法。并且Velocity的语法和`$.animate()`一摸一样，所以我们根本不需要修改页面的现有代码。\n\n让我们快速过一下Velocity.js的例子：\n\n```javascript\n$element   \n\t.delay(1000)    \n\t/* Use Velocity to animate the element's top property over a duration of 2000ms. */    \n\t.velocity({ top: \"50%\" }, 2000)    \n\t/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */    \n\t.fadeOut(1000); \n```\n\n如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：\n\n```javascript\n$element    \n\t/* Scroll the browser to the top of this element over a duration of 1000ms. */    \n\t.velocity(\"scroll\", 1000)    \n\t/* Then rotate the element around its Y axis by 360 degrees. */    \n\t.velocity({ rotateY: \"360deg\" }, 1000); |\n```\n\n### 总结\n\nVelocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往[VelocityJS.org](http://velocityjs.org/)了解。\n\n在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：\n\n- [Jank Free](http://www.youtube.com/watch?v=n8ep4leoN9A)\n- [Rendering Without Lumps](http://www.youtube.com/watch?v=cmZqLzPy0XE)\n- [Faster Websites](http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance)\n\n转载整理：[http://web.jobbole.com](http://web.jobbole.com/86121/)","source":"_posts/CSS vs JS动画：谁更快？.md","raw":"---\ntitle: CSS vs JS动画：谁更快？\ntags: [javascript,jquery,css]\ndate: 2016/05/14\n---\n\n> 这篇文章翻译自 Julian Shapiro 的 [CSS vs. JS Animation: Which is Faster?](http://davidwalsh.name/css-js-animation)。Julian Shapiro 也是 [Velocity.js](http://julian.com/research/velocity/) 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。\n\nJavascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？\n\n这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。\n\n### jQuery\n\n让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n- jQuery 不能避免[layout thrashing](http://wilsonpage.co.uk/preventing-layout-thrashing/)（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。\n- jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易[让动画卡住](http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html)。\n- jQuery使用了`setInterval`而不是 `reqeustAnimationFrame(RAF)`，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）\n\n注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。\n\n### 实现样例\n\n为了避免layout thrashing，我们需要批量访问和更新DOM。\n\n```javascript\nvar currentTop,currentLeft; /* 有 layout thrashing. */\n\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */ \n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */ \n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */ \n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */ |\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：\n\n```javascript\nvar startingTop = 0; \n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {    \n\t/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */    \n\telement.style.top = (startingTop += 1/60);}, 16); \n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {    \n\telement.style.top = (startingTop += 1/60);\n} \n\t\nwindow.requestAnimationFrame(tick); \n```\n\n你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。\n\n### CSS Transition\n\nCSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：\n\n1. 通过优化 DOM 操作，避免内存消耗来减少卡顿\n2. 使用与 RAF 类似的机制\n3. 强制使用硬件加速 （通过 GPU 来提高动画性能）\n\n然而实际上Javascript也可以使用这些优化。[GSAP](http://www.greensock.com/gsap-js/) 已经做这些优化很久了。[Velocity.js](http://velocityjs.org/) 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。\n\n面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！\n\n让我们来看看CSS动画库的缺陷吧：\n\n- Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的[博客](http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/)谈到过这个问题。\n- IE 10以下的浏览器不支持transition。而目前IE8和IE9还是[很流行](http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share)的。\n- transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。\n\n反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。\n\n> 我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是[Transit](https://github.com/rstacruz/jquery.transit)。\n\n### Javascript动画\n\n所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个[3D 动画的demo](http://julian.com/research/velocity/demo.html)，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个[多媒体小动画](http://julian.com/research/velocity/playground.html)，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个[虚拟世界](http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs)，通常需要canvas才能完成。\n\n为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的[官方文档](http://velocityjs.org/)。\n\n之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：\n\n- 同步DOM ->在整个动画链中微调堆栈以达到最小的layout thrashing。\n- 缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）\n- 在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）\n- 忽略那些变动小到根本看不出来的DOM更新\n\n让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。\n\n```javascript\n$element  \n\t/* Slide the element down into view. */ \n\t.velocity({ opacity: 1, top: \"50%\" })\n\t/* After a delay of 1000ms, slide the element out of view. */    \n\t.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 }); \n```\n\n在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。\n\n浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。\n\n最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。\n\n- GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。\n- GSAP需要[付费](http://www.greensock.com/licensing/)才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。\n- 性能方面，两者几乎相当，很难区分胜负。\n\n> 我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。\n\n### Velocity.js\n\n之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。\n\n简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。\n\n更进一步从易用性的角度来讲，Velocity使用了jQuery的`$.queue()`方法，因此可以无缝过渡到jQuery的`$.animate()`、`$.fade()`和`$.delay()`方法。并且Velocity的语法和`$.animate()`一摸一样，所以我们根本不需要修改页面的现有代码。\n\n让我们快速过一下Velocity.js的例子：\n\n```javascript\n$element   \n\t.delay(1000)    \n\t/* Use Velocity to animate the element's top property over a duration of 2000ms. */    \n\t.velocity({ top: \"50%\" }, 2000)    \n\t/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */    \n\t.fadeOut(1000); \n```\n\n如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：\n\n```javascript\n$element    \n\t/* Scroll the browser to the top of this element over a duration of 1000ms. */    \n\t.velocity(\"scroll\", 1000)    \n\t/* Then rotate the element around its Y axis by 360 degrees. */    \n\t.velocity({ rotateY: \"360deg\" }, 1000); |\n```\n\n### 总结\n\nVelocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往[VelocityJS.org](http://velocityjs.org/)了解。\n\n在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：\n\n- [Jank Free](http://www.youtube.com/watch?v=n8ep4leoN9A)\n- [Rendering Without Lumps](http://www.youtube.com/watch?v=cmZqLzPy0XE)\n- [Faster Websites](http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance)\n\n转载整理：[http://web.jobbole.com](http://web.jobbole.com/86121/)","slug":"CSS vs JS动画：谁更快？","published":1,"updated":"2016-08-17T06:22:19.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpi9000y68ddo2uruhk8","content":"<blockquote>\n<p>这篇文章翻译自 Julian Shapiro 的 <a href=\"http://davidwalsh.name/css-js-animation\" target=\"_blank\" rel=\"external\">CSS vs. JS Animation: Which is Faster?</a>。Julian Shapiro 也是 <a href=\"http://julian.com/research/velocity/\" target=\"_blank\" rel=\"external\">Velocity.js</a> 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。</p>\n</blockquote>\n<p>Javascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？</p>\n<p>这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。</p>\n<h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><p>让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：</p>\n<ul>\n<li>jQuery 不能避免<a href=\"http://wilsonpage.co.uk/preventing-layout-thrashing/\" target=\"_blank\" rel=\"external\">layout thrashing</a>（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。</li>\n<li>jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易<a href=\"http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\" target=\"_blank\" rel=\"external\">让动画卡住</a>。</li>\n<li>jQuery使用了<code>setInterval</code>而不是 <code>reqeustAnimationFrame(RAF)</code>，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）</li>\n</ul>\n<p>注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。</p>\n<h3 id=\"实现样例\"><a href=\"#实现样例\" class=\"headerlink\" title=\"实现样例\"></a>实现样例</h3><p>为了避免layout thrashing，我们需要批量访问和更新DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currentTop,currentLeft; <span class=\"comment\">/* 有 layout thrashing. */</span></div><div class=\"line\"></div><div class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </div><div class=\"line\"></div><div class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 没有 layout thrashing. */</span></div><div class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span> </div><div class=\"line\"></div><div class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span></div><div class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> |</div></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startingTop = <span class=\"number\">0</span>; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span></div><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </div><div class=\"line\">\t<span class=\"comment\">/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */</span>    </div><div class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);&#125;, <span class=\"number\">16</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span> (<span class=\"params\"></span>) </span>&#123;    </div><div class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);</div><div class=\"line\">&#125; </div><div class=\"line\">\t</div><div class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(tick);</div></pre></td></tr></table></figure>\n<p>你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。</p>\n<h3 id=\"CSS-Transition\"><a href=\"#CSS-Transition\" class=\"headerlink\" title=\"CSS Transition\"></a>CSS Transition</h3><p>CSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：</p>\n<ol>\n<li>通过优化 DOM 操作，避免内存消耗来减少卡顿</li>\n<li>使用与 RAF 类似的机制</li>\n<li>强制使用硬件加速 （通过 GPU 来提高动画性能）</li>\n</ol>\n<p>然而实际上Javascript也可以使用这些优化。<a href=\"http://www.greensock.com/gsap-js/\" target=\"_blank\" rel=\"external\">GSAP</a> 已经做这些优化很久了。<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">Velocity.js</a> 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。</p>\n<p>面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！</p>\n<p>让我们来看看CSS动画库的缺陷吧：</p>\n<ul>\n<li>Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的<a href=\"http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/\" target=\"_blank\" rel=\"external\">博客</a>谈到过这个问题。</li>\n<li>IE 10以下的浏览器不支持transition。而目前IE8和IE9还是<a href=\"http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share\" target=\"_blank\" rel=\"external\">很流行</a>的。</li>\n<li>transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。</li>\n</ul>\n<p>反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。</p>\n<blockquote>\n<p>我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是<a href=\"https://github.com/rstacruz/jquery.transit\" target=\"_blank\" rel=\"external\">Transit</a>。</p>\n</blockquote>\n<h3 id=\"Javascript动画\"><a href=\"#Javascript动画\" class=\"headerlink\" title=\"Javascript动画\"></a>Javascript动画</h3><p>所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个<a href=\"http://julian.com/research/velocity/demo.html\" target=\"_blank\" rel=\"external\">3D 动画的demo</a>，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个<a href=\"http://julian.com/research/velocity/playground.html\" target=\"_blank\" rel=\"external\">多媒体小动画</a>，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个<a href=\"http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs\" target=\"_blank\" rel=\"external\">虚拟世界</a>，通常需要canvas才能完成。</p>\n<p>为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n<p>之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：</p>\n<ul>\n<li>同步DOM -&gt;在整个动画链中微调堆栈以达到最小的layout thrashing。</li>\n<li>缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）</li>\n<li>在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）</li>\n<li>忽略那些变动小到根本看不出来的DOM更新</li>\n</ul>\n<p>让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element  </div><div class=\"line\">\t<span class=\"comment\">/* Slide the element down into view. */</span> </div><div class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">1</span>, top: <span class=\"string\">\"50%\"</span> &#125;)</div><div class=\"line\">\t<span class=\"comment\">/* After a delay of 1000ms, slide the element out of view. */</span>    </div><div class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">0</span>, top: <span class=\"string\">\"-50%\"</span> &#125;, &#123; delay: <span class=\"number\">1000</span> &#125;);</div></pre></td></tr></table></figure>\n<p>在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。</p>\n<p>浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。</p>\n<p>最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。</p>\n<ul>\n<li>GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。</li>\n<li>GSAP需要<a href=\"http://www.greensock.com/licensing/\" target=\"_blank\" rel=\"external\">付费</a>才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。</li>\n<li>性能方面，两者几乎相当，很难区分胜负。</li>\n</ul>\n<blockquote>\n<p>我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。</p>\n</blockquote>\n<h3 id=\"Velocity-js\"><a href=\"#Velocity-js\" class=\"headerlink\" title=\"Velocity.js\"></a>Velocity.js</h3><p>之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。</p>\n<p>简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。</p>\n<p>更进一步从易用性的角度来讲，Velocity使用了jQuery的<code>$.queue()</code>方法，因此可以无缝过渡到jQuery的<code>$.animate()</code>、<code>$.fade()</code>和<code>$.delay()</code>方法。并且Velocity的语法和<code>$.animate()</code>一摸一样，所以我们根本不需要修改页面的现有代码。</p>\n<p>让我们快速过一下Velocity.js的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element   </div><div class=\"line\">\t.delay(<span class=\"number\">1000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Use Velocity to animate the element's top property over a duration of 2000ms. */</span>    </div><div class=\"line\">\t.velocity(&#123; top: <span class=\"string\">\"50%\"</span> &#125;, <span class=\"number\">2000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */</span>    </div><div class=\"line\">\t.fadeOut(<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element    </div><div class=\"line\">\t<span class=\"comment\">/* Scroll the browser to the top of this element over a duration of 1000ms. */</span>    </div><div class=\"line\">\t.velocity(<span class=\"string\">\"scroll\"</span>, <span class=\"number\">1000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Then rotate the element around its Y axis by 360 degrees. */</span>    </div><div class=\"line\">\t.velocity(&#123; rotateY: <span class=\"string\">\"360deg\"</span> &#125;, <span class=\"number\">1000</span>); |</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Velocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">VelocityJS.org</a>了解。</p>\n<p>在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：</p>\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=n8ep4leoN9A\" target=\"_blank\" rel=\"external\">Jank Free</a></li>\n<li><a href=\"http://www.youtube.com/watch?v=cmZqLzPy0XE\" target=\"_blank\" rel=\"external\">Rendering Without Lumps</a></li>\n<li><a href=\"http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance\" target=\"_blank\" rel=\"external\">Faster Websites</a></li>\n</ul>\n<p>转载整理：<a href=\"http://web.jobbole.com/86121/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<blockquote>\n<p>这篇文章翻译自 Julian Shapiro 的 <a href=\"http://davidwalsh.name/css-js-animation\">CSS vs. JS Animation: Which is Faster?</a>。Julian Shapiro 也是 <a href=\"http://julian.com/research/velocity/\">Velocity.js</a> 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。</p>\n</blockquote>\n<p>Javascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？</p>\n<p>这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。</p>\n<h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><p>让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：</p>\n<ul>\n<li>jQuery 不能避免<a href=\"http://wilsonpage.co.uk/preventing-layout-thrashing/\">layout thrashing</a>（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。</li>\n<li>jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易<a href=\"http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\">让动画卡住</a>。</li>\n<li>jQuery使用了<code>setInterval</code>而不是 <code>reqeustAnimationFrame(RAF)</code>，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）</li>\n</ul>\n<p>注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。</p>\n<h3 id=\"实现样例\"><a href=\"#实现样例\" class=\"headerlink\" title=\"实现样例\"></a>实现样例</h3><p>为了避免layout thrashing，我们需要批量访问和更新DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currentTop,currentLeft; <span class=\"comment\">/* 有 layout thrashing. */</span></div><div class=\"line\"></div><div class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </div><div class=\"line\"></div><div class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 没有 layout thrashing. */</span></div><div class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></div><div class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span> </div><div class=\"line\"></div><div class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span></div><div class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> |</div></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> startingTop = <span class=\"number\">0</span>; </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span></div><div class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </div><div class=\"line\">\t<span class=\"comment\">/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */</span>    </div><div class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);&#125;, <span class=\"number\">16</span>); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span> (<span class=\"params\"></span>) </span>&#123;    </div><div class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);</div><div class=\"line\">&#125; </div><div class=\"line\">\t</div><div class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(tick);</div></pre></td></tr></table></figure>\n<p>你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。</p>\n<h3 id=\"CSS-Transition\"><a href=\"#CSS-Transition\" class=\"headerlink\" title=\"CSS Transition\"></a>CSS Transition</h3><p>CSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：</p>\n<ol>\n<li>通过优化 DOM 操作，避免内存消耗来减少卡顿</li>\n<li>使用与 RAF 类似的机制</li>\n<li>强制使用硬件加速 （通过 GPU 来提高动画性能）</li>\n</ol>\n<p>然而实际上Javascript也可以使用这些优化。<a href=\"http://www.greensock.com/gsap-js/\">GSAP</a> 已经做这些优化很久了。<a href=\"http://velocityjs.org/\">Velocity.js</a> 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。</p>\n<p>面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！</p>\n<p>让我们来看看CSS动画库的缺陷吧：</p>\n<ul>\n<li>Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的<a href=\"http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/\">博客</a>谈到过这个问题。</li>\n<li>IE 10以下的浏览器不支持transition。而目前IE8和IE9还是<a href=\"http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share\">很流行</a>的。</li>\n<li>transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。</li>\n</ul>\n<p>反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。</p>\n<blockquote>\n<p>我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是<a href=\"https://github.com/rstacruz/jquery.transit\">Transit</a>。</p>\n</blockquote>\n<h3 id=\"Javascript动画\"><a href=\"#Javascript动画\" class=\"headerlink\" title=\"Javascript动画\"></a>Javascript动画</h3><p>所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个<a href=\"http://julian.com/research/velocity/demo.html\">3D 动画的demo</a>，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个<a href=\"http://julian.com/research/velocity/playground.html\">多媒体小动画</a>，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个<a href=\"http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs\">虚拟世界</a>，通常需要canvas才能完成。</p>\n<p>为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的<a href=\"http://velocityjs.org/\">官方文档</a>。</p>\n<p>之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：</p>\n<ul>\n<li>同步DOM -&gt;在整个动画链中微调堆栈以达到最小的layout thrashing。</li>\n<li>缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）</li>\n<li>在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）</li>\n<li>忽略那些变动小到根本看不出来的DOM更新</li>\n</ul>\n<p>让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element  </div><div class=\"line\">\t<span class=\"comment\">/* Slide the element down into view. */</span> </div><div class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">1</span>, top: <span class=\"string\">\"50%\"</span> &#125;)</div><div class=\"line\">\t<span class=\"comment\">/* After a delay of 1000ms, slide the element out of view. */</span>    </div><div class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">0</span>, top: <span class=\"string\">\"-50%\"</span> &#125;, &#123; delay: <span class=\"number\">1000</span> &#125;);</div></pre></td></tr></table></figure>\n<p>在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。</p>\n<p>浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。</p>\n<p>最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。</p>\n<ul>\n<li>GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。</li>\n<li>GSAP需要<a href=\"http://www.greensock.com/licensing/\">付费</a>才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。</li>\n<li>性能方面，两者几乎相当，很难区分胜负。</li>\n</ul>\n<blockquote>\n<p>我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。</p>\n</blockquote>\n<h3 id=\"Velocity-js\"><a href=\"#Velocity-js\" class=\"headerlink\" title=\"Velocity.js\"></a>Velocity.js</h3><p>之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。</p>\n<p>简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。</p>\n<p>更进一步从易用性的角度来讲，Velocity使用了jQuery的<code>$.queue()</code>方法，因此可以无缝过渡到jQuery的<code>$.animate()</code>、<code>$.fade()</code>和<code>$.delay()</code>方法。并且Velocity的语法和<code>$.animate()</code>一摸一样，所以我们根本不需要修改页面的现有代码。</p>\n<p>让我们快速过一下Velocity.js的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element   </div><div class=\"line\">\t.delay(<span class=\"number\">1000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Use Velocity to animate the element's top property over a duration of 2000ms. */</span>    </div><div class=\"line\">\t.velocity(&#123; top: <span class=\"string\">\"50%\"</span> &#125;, <span class=\"number\">2000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */</span>    </div><div class=\"line\">\t.fadeOut(<span class=\"number\">1000</span>);</div></pre></td></tr></table></figure>\n<p>如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">$element    </div><div class=\"line\">\t<span class=\"comment\">/* Scroll the browser to the top of this element over a duration of 1000ms. */</span>    </div><div class=\"line\">\t.velocity(<span class=\"string\">\"scroll\"</span>, <span class=\"number\">1000</span>)    </div><div class=\"line\">\t<span class=\"comment\">/* Then rotate the element around its Y axis by 360 degrees. */</span>    </div><div class=\"line\">\t.velocity(&#123; rotateY: <span class=\"string\">\"360deg\"</span> &#125;, <span class=\"number\">1000</span>); |</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Velocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往<a href=\"http://velocityjs.org/\">VelocityJS.org</a>了解。</p>\n<p>在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：</p>\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=n8ep4leoN9A\">Jank Free</a></li>\n<li><a href=\"http://www.youtube.com/watch?v=cmZqLzPy0XE\">Rendering Without Lumps</a></li>\n<li><a href=\"http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance\">Faster Websites</a></li>\n</ul>\n<p>转载整理：<a href=\"http://web.jobbole.com/86121/\">http://web.jobbole.com</a></p>\n"},{"title":"CSS实现垂直居中的常用方法","date":"2016-03-05T16:00:00.000Z","_content":"\n在前端开发过程中，盒子居中是常常用到的。\n\n其中，居中又可以分为水平居中和垂直居中。\n\n水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。\n\n但是垂直居中相对来说是比较复杂一些的。\n\n下面我们一起来讨论一下实现垂直居中的方法。\n\n首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-001](resource/css-ju-zhong-001.png)\n\n我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-002](resource/css-ju-zhong-002.png)\n\n\n很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。\n\n不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0; \n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下图所示：\n\n![css-ju-zhong-003](resource/css-ju-zhong-003.png)\n\ndiv垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：\n\n![css-ju-zhong-004](resource/css-ju-zhong-004.png)\n\n通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            margin-top: -150px; \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-005](resource/css-ju-zhong-005.png)\n\n确实已经居中了。好兴奋！有木有？！\n\n除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            transform: translateY(-50%);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-006](resource/css-ju-zhong-006.png)\n\n上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            display: flex;\n            align-items: center; /*定义body的元素垂直居中*/\n            justify-content: center; /*定义body的里的元素水平居中*/\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;        \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果：\n\n![css-ju-zhong-007](resource/css-ju-zhong-007.png)\n\n除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？\n\n[http://www.codeceo.com/article/css-vertical-align-center.html](http://www.codeceo.com/article/css-vertical-align-center.html)\n","source":"_posts/CSS实现垂直居中的常用方法.md","raw":"---\ntitle: CSS实现垂直居中的常用方法\ntags: [css]\ndate: 2016/03/06\n---\n\n在前端开发过程中，盒子居中是常常用到的。\n\n其中，居中又可以分为水平居中和垂直居中。\n\n水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。\n\n但是垂直居中相对来说是比较复杂一些的。\n\n下面我们一起来讨论一下实现垂直居中的方法。\n\n首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-001](resource/css-ju-zhong-001.png)\n\n我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-002](resource/css-ju-zhong-002.png)\n\n\n很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。\n\n不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0; \n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下图所示：\n\n![css-ju-zhong-003](resource/css-ju-zhong-003.png)\n\ndiv垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：\n\n![css-ju-zhong-004](resource/css-ju-zhong-004.png)\n\n通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            margin-top: -150px; \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-005](resource/css-ju-zhong-005.png)\n\n确实已经居中了。好兴奋！有木有？！\n\n除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            transform: translateY(-50%);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-006](resource/css-ju-zhong-006.png)\n\n上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            display: flex;\n            align-items: center; /*定义body的元素垂直居中*/\n            justify-content: center; /*定义body的里的元素水平居中*/\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;        \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果：\n\n![css-ju-zhong-007](resource/css-ju-zhong-007.png)\n\n除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？\n\n[http://www.codeceo.com/article/css-vertical-align-center.html](http://www.codeceo.com/article/css-vertical-align-center.html)\n","slug":"CSS实现垂直居中的常用方法","published":1,"updated":"2016-08-17T06:22:19.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpib001168ddxq5rcz1z","content":"<p>在前端开发过程中，盒子居中是常常用到的。</p>\n<p>其中，居中又可以分为水平居中和垂直居中。</p>\n<p>水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。</p>\n<p>但是垂直居中相对来说是比较复杂一些的。</p>\n<p>下面我们一起来讨论一下实现垂直居中的方法。</p>\n<p>首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-001.png\" alt=\"css-ju-zhong-001\"></p>\n<p>我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-002.png\" alt=\"css-ju-zhong-002\"></p>\n<p>很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。</p>\n<p>不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html, body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0; </div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html, body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下图所示：</p>\n<p><img src=\"resource/css-ju-zhong-003.png\" alt=\"css-ju-zhong-003\"></p>\n<p>div垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：</p>\n<p><img src=\"resource/css-ju-zhong-004.png\" alt=\"css-ju-zhong-004\"></p>\n<p>通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">            margin-top: -150px; </div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-005.png\" alt=\"css-ju-zhong-005\"></p>\n<p>确实已经居中了。好兴奋！有木有？！</p>\n<p>除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">            transform: translateY(-50%);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-006.png\" alt=\"css-ju-zhong-006\"></p>\n<p>上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        body &#123;</div><div class=\"line\">            display: flex;</div><div class=\"line\">            align-items: center; /*定义body的元素垂直居中*/</div><div class=\"line\">            justify-content: center; /*定义body的里的元素水平居中*/</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;        </div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"resource/css-ju-zhong-007.png\" alt=\"css-ju-zhong-007\"></p>\n<p>除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？</p>\n<p><a href=\"http://www.codeceo.com/article/css-vertical-align-center.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/css-vertical-align-center.html</a></p>\n","excerpt":"","more":"<p>在前端开发过程中，盒子居中是常常用到的。</p>\n<p>其中，居中又可以分为水平居中和垂直居中。</p>\n<p>水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。</p>\n<p>但是垂直居中相对来说是比较复杂一些的。</p>\n<p>下面我们一起来讨论一下实现垂直居中的方法。</p>\n<p>首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-001.png\" alt=\"css-ju-zhong-001\"></p>\n<p>我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-002.png\" alt=\"css-ju-zhong-002\"></p>\n<p>很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。</p>\n<p>不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html, body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0; </div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html, body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下图所示：</p>\n<p><img src=\"resource/css-ju-zhong-003.png\" alt=\"css-ju-zhong-003\"></p>\n<p>div垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：</p>\n<p><img src=\"resource/css-ju-zhong-004.png\" alt=\"css-ju-zhong-004\"></p>\n<p>通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">            margin-top: -150px; </div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-005.png\" alt=\"css-ju-zhong-005\"></p>\n<p>确实已经居中了。好兴奋！有木有？！</p>\n<p>除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;</div><div class=\"line\">            margin: 0 auto; /*水平居中*/</div><div class=\"line\">            position: relative; /*脱离文档流*/</div><div class=\"line\">            top: 50%; /*偏移*/</div><div class=\"line\">            transform: translateY(-50%);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-006.png\" alt=\"css-ju-zhong-006\"></p>\n<p>上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html lang=&quot;en&quot;&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class=\"line\">    &lt;title&gt;index&lt;/title&gt;</div><div class=\"line\">    &lt;style&gt;</div><div class=\"line\">        html,body &#123;</div><div class=\"line\">            width: 100%;</div><div class=\"line\">            height: 100%;</div><div class=\"line\">            margin: 0;</div><div class=\"line\">            padding: 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        body &#123;</div><div class=\"line\">            display: flex;</div><div class=\"line\">            align-items: center; /*定义body的元素垂直居中*/</div><div class=\"line\">            justify-content: center; /*定义body的里的元素水平居中*/</div><div class=\"line\">        &#125;</div><div class=\"line\">        .content &#123;</div><div class=\"line\">            width: 300px;</div><div class=\"line\">            height: 300px;</div><div class=\"line\">            background: orange;        </div><div class=\"line\">        &#125;</div><div class=\"line\">    &lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"resource/css-ju-zhong-007.png\" alt=\"css-ju-zhong-007\"></p>\n<p>除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？</p>\n<p><a href=\"http://www.codeceo.com/article/css-vertical-align-center.html\">http://www.codeceo.com/article/css-vertical-align-center.html</a></p>\n"},{"title":"GET和POST有什么区别？及为什么网上多数答案都是错的","date":"2016-05-31T16:00:00.000Z","_content":"\n> 如果有人问你，GET和POST，有什么区别？你会如何回答？\n\n### 我的经历\n\n前几天有人问我这个问题。我说GET是用于获取数据的，POST，一般用于将数据发给服务器之用。\n\n这个答案好像并不是他想要的。于是他继续追问有没有别的区别？我说这就是个名字而已，如果服务器支持，他完全可以把GET改个名字叫GET2。他反问道，那就是单纯的名字上的区别喽？我想了想，我觉得如果说再具体的区别，只能去看RFC文档了，还要取决于服务器（指Apache，IIS）的具体实现。但我不得不承认，我的确没有仔细看过HTTP的RFC文档。于是我说，我对HTTP协议不太熟悉。这个问题也就结束了。\n\n### 最普遍的答案\n\n回来之后寻思了很久，他到底是想问我什么？我一直就觉得GET和POST没有什么除了语义之外的区别，自打我开始学习Web编程开始就是这么理解的。\n\n可能很多人都已经猜到了，他要的答案是：\n\n1. GET使用URL或Cookie传参。而POST将数据放在BODY中。\n\n2. GET的URL会有长度上的限制，则POST的数据则可以非常大。\n\n3. POST比GET安全，因为数据在地址栏上不可见。\n\n但是很不幸，这些区别全是错误的，更不幸的是，这个答案还是Google搜索的头版头条，然而我根本没想着这些是答案，因为在我看来他们都是错的。我来一一解释一下。\n\n### GET和POST与数据如何传递没有关系\n\nGET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。\n\nHTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。\n\n那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？\n\n而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。\n\n知道这个有什么用？我不想解释了，有时候就得自己痛一次才记得住。\n\n### HTTP协议对GET和POST都没有对长度的限制\n\nHTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：\n\n1. 浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。\n\n2. 服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。\n\n### 安全不安全和GET、POST没有关系\n\n我觉得这真是中国特色。我讲个小段子，大家应该可以体会出这个说法多么的可笑。\n\n觉得POST数据比GET数据安全的人会说\n\n> “防君子不防小人；中国小白多，能防小白用户就行了。”\n> “哼，”我不以为然，“那你怎么不说，URL参数都Encode过了，或是Base64一下，小白也看不懂啊。”\n> 那人反驳道，“Encode太简单了，聪明点儿的小白很容易就可以Decode并修改掉。”\n> 我笑道，“五十步笑百步耳，再聪明点儿的小白还会截包并重发呢，Opera就有这功能。”\n> 那人阴险地祭出神器——最终解释权，说，“这个不算小白。”\n\n我日啊。\n\n### 最后一点儿感想\n\n我之前一直做Windows桌面应用，对Web开发无甚了解，直到一年多前转做服务器端开发，才开始接触到HTTP。（注意，我说的是HTTP，不是HTML。服务器开放接口是基于REST理念设计的，使用的协议是HTTP，但是传输的内容不是HTML。这不是Web Server，而是一个Web Service）\n\n所以我对于GET和POST的理解，是纯粹地来源于HTTP协议。他们只有一点根本区别，简单点儿说，一个用于获取数据，一个用于修改数据。具体的请参考RFC文档。\n\n如果一个人一开始就做Web开发，很可能把HTML对HTTP协议的使用方式，当成HTTP协议的唯一的合理使用方式。从而犯了以偏概全的错误。\n\n可能有人会觉得我钻牛角尖。我只是不喜欢模棱两可，不喜欢边界不清、概念不明，不喜欢“拿来主义”，也不喜欢被其它喜欢钻牛角尖的人奚落得无地自容。\n\n“知之为知之，不知为不知，是知也。”\n\n转载整理自：[http://web.jobbole.com](http://web.jobbole.com/86298/)","source":"_posts/GET和POST有什么区别？及为什么网上多数答案都是错的.md","raw":"---\ntitle: GET和POST有什么区别？及为什么网上多数答案都是错的\ntags: [http]\ndate: 2016/06/01\n---\n\n> 如果有人问你，GET和POST，有什么区别？你会如何回答？\n\n### 我的经历\n\n前几天有人问我这个问题。我说GET是用于获取数据的，POST，一般用于将数据发给服务器之用。\n\n这个答案好像并不是他想要的。于是他继续追问有没有别的区别？我说这就是个名字而已，如果服务器支持，他完全可以把GET改个名字叫GET2。他反问道，那就是单纯的名字上的区别喽？我想了想，我觉得如果说再具体的区别，只能去看RFC文档了，还要取决于服务器（指Apache，IIS）的具体实现。但我不得不承认，我的确没有仔细看过HTTP的RFC文档。于是我说，我对HTTP协议不太熟悉。这个问题也就结束了。\n\n### 最普遍的答案\n\n回来之后寻思了很久，他到底是想问我什么？我一直就觉得GET和POST没有什么除了语义之外的区别，自打我开始学习Web编程开始就是这么理解的。\n\n可能很多人都已经猜到了，他要的答案是：\n\n1. GET使用URL或Cookie传参。而POST将数据放在BODY中。\n\n2. GET的URL会有长度上的限制，则POST的数据则可以非常大。\n\n3. POST比GET安全，因为数据在地址栏上不可见。\n\n但是很不幸，这些区别全是错误的，更不幸的是，这个答案还是Google搜索的头版头条，然而我根本没想着这些是答案，因为在我看来他们都是错的。我来一一解释一下。\n\n### GET和POST与数据如何传递没有关系\n\nGET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。\n\nHTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。\n\n那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？\n\n而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。\n\n知道这个有什么用？我不想解释了，有时候就得自己痛一次才记得住。\n\n### HTTP协议对GET和POST都没有对长度的限制\n\nHTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：\n\n1. 浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。\n\n2. 服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。\n\n### 安全不安全和GET、POST没有关系\n\n我觉得这真是中国特色。我讲个小段子，大家应该可以体会出这个说法多么的可笑。\n\n觉得POST数据比GET数据安全的人会说\n\n> “防君子不防小人；中国小白多，能防小白用户就行了。”\n> “哼，”我不以为然，“那你怎么不说，URL参数都Encode过了，或是Base64一下，小白也看不懂啊。”\n> 那人反驳道，“Encode太简单了，聪明点儿的小白很容易就可以Decode并修改掉。”\n> 我笑道，“五十步笑百步耳，再聪明点儿的小白还会截包并重发呢，Opera就有这功能。”\n> 那人阴险地祭出神器——最终解释权，说，“这个不算小白。”\n\n我日啊。\n\n### 最后一点儿感想\n\n我之前一直做Windows桌面应用，对Web开发无甚了解，直到一年多前转做服务器端开发，才开始接触到HTTP。（注意，我说的是HTTP，不是HTML。服务器开放接口是基于REST理念设计的，使用的协议是HTTP，但是传输的内容不是HTML。这不是Web Server，而是一个Web Service）\n\n所以我对于GET和POST的理解，是纯粹地来源于HTTP协议。他们只有一点根本区别，简单点儿说，一个用于获取数据，一个用于修改数据。具体的请参考RFC文档。\n\n如果一个人一开始就做Web开发，很可能把HTML对HTTP协议的使用方式，当成HTTP协议的唯一的合理使用方式。从而犯了以偏概全的错误。\n\n可能有人会觉得我钻牛角尖。我只是不喜欢模棱两可，不喜欢边界不清、概念不明，不喜欢“拿来主义”，也不喜欢被其它喜欢钻牛角尖的人奚落得无地自容。\n\n“知之为知之，不知为不知，是知也。”\n\n转载整理自：[http://web.jobbole.com](http://web.jobbole.com/86298/)","slug":"GET和POST有什么区别？及为什么网上多数答案都是错的","published":1,"updated":"2016-08-17T06:22:19.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpid001368ddgkoo9dmx","content":"<blockquote>\n<p>如果有人问你，GET和POST，有什么区别？你会如何回答？</p>\n</blockquote>\n<h3 id=\"我的经历\"><a href=\"#我的经历\" class=\"headerlink\" title=\"我的经历\"></a>我的经历</h3><p>前几天有人问我这个问题。我说GET是用于获取数据的，POST，一般用于将数据发给服务器之用。</p>\n<p>这个答案好像并不是他想要的。于是他继续追问有没有别的区别？我说这就是个名字而已，如果服务器支持，他完全可以把GET改个名字叫GET2。他反问道，那就是单纯的名字上的区别喽？我想了想，我觉得如果说再具体的区别，只能去看RFC文档了，还要取决于服务器（指Apache，IIS）的具体实现。但我不得不承认，我的确没有仔细看过HTTP的RFC文档。于是我说，我对HTTP协议不太熟悉。这个问题也就结束了。</p>\n<h3 id=\"最普遍的答案\"><a href=\"#最普遍的答案\" class=\"headerlink\" title=\"最普遍的答案\"></a>最普遍的答案</h3><p>回来之后寻思了很久，他到底是想问我什么？我一直就觉得GET和POST没有什么除了语义之外的区别，自打我开始学习Web编程开始就是这么理解的。</p>\n<p>可能很多人都已经猜到了，他要的答案是：</p>\n<ol>\n<li><p>GET使用URL或Cookie传参。而POST将数据放在BODY中。</p>\n</li>\n<li><p>GET的URL会有长度上的限制，则POST的数据则可以非常大。</p>\n</li>\n<li><p>POST比GET安全，因为数据在地址栏上不可见。</p>\n</li>\n</ol>\n<p>但是很不幸，这些区别全是错误的，更不幸的是，这个答案还是Google搜索的头版头条，然而我根本没想着这些是答案，因为在我看来他们都是错的。我来一一解释一下。</p>\n<h3 id=\"GET和POST与数据如何传递没有关系\"><a href=\"#GET和POST与数据如何传递没有关系\" class=\"headerlink\" title=\"GET和POST与数据如何传递没有关系\"></a>GET和POST与数据如何传递没有关系</h3><p>GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。</p>\n<p>HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。</p>\n<p>那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？</p>\n<p>而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。</p>\n<p>知道这个有什么用？我不想解释了，有时候就得自己痛一次才记得住。</p>\n<h3 id=\"HTTP协议对GET和POST都没有对长度的限制\"><a href=\"#HTTP协议对GET和POST都没有对长度的限制\" class=\"headerlink\" title=\"HTTP协议对GET和POST都没有对长度的限制\"></a>HTTP协议对GET和POST都没有对长度的限制</h3><p>HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：</p>\n<ol>\n<li><p>浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。</p>\n</li>\n<li><p>服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。</p>\n</li>\n</ol>\n<h3 id=\"安全不安全和GET、POST没有关系\"><a href=\"#安全不安全和GET、POST没有关系\" class=\"headerlink\" title=\"安全不安全和GET、POST没有关系\"></a>安全不安全和GET、POST没有关系</h3><p>我觉得这真是中国特色。我讲个小段子，大家应该可以体会出这个说法多么的可笑。</p>\n<p>觉得POST数据比GET数据安全的人会说</p>\n<blockquote>\n<p>“防君子不防小人；中国小白多，能防小白用户就行了。”<br>“哼，”我不以为然，“那你怎么不说，URL参数都Encode过了，或是Base64一下，小白也看不懂啊。”<br>那人反驳道，“Encode太简单了，聪明点儿的小白很容易就可以Decode并修改掉。”<br>我笑道，“五十步笑百步耳，再聪明点儿的小白还会截包并重发呢，Opera就有这功能。”<br>那人阴险地祭出神器——最终解释权，说，“这个不算小白。”</p>\n</blockquote>\n<p>我日啊。</p>\n<h3 id=\"最后一点儿感想\"><a href=\"#最后一点儿感想\" class=\"headerlink\" title=\"最后一点儿感想\"></a>最后一点儿感想</h3><p>我之前一直做Windows桌面应用，对Web开发无甚了解，直到一年多前转做服务器端开发，才开始接触到HTTP。（注意，我说的是HTTP，不是HTML。服务器开放接口是基于REST理念设计的，使用的协议是HTTP，但是传输的内容不是HTML。这不是Web Server，而是一个Web Service）</p>\n<p>所以我对于GET和POST的理解，是纯粹地来源于HTTP协议。他们只有一点根本区别，简单点儿说，一个用于获取数据，一个用于修改数据。具体的请参考RFC文档。</p>\n<p>如果一个人一开始就做Web开发，很可能把HTML对HTTP协议的使用方式，当成HTTP协议的唯一的合理使用方式。从而犯了以偏概全的错误。</p>\n<p>可能有人会觉得我钻牛角尖。我只是不喜欢模棱两可，不喜欢边界不清、概念不明，不喜欢“拿来主义”，也不喜欢被其它喜欢钻牛角尖的人奚落得无地自容。</p>\n<p>“知之为知之，不知为不知，是知也。”</p>\n<p>转载整理自：<a href=\"http://web.jobbole.com/86298/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<blockquote>\n<p>如果有人问你，GET和POST，有什么区别？你会如何回答？</p>\n</blockquote>\n<h3 id=\"我的经历\"><a href=\"#我的经历\" class=\"headerlink\" title=\"我的经历\"></a>我的经历</h3><p>前几天有人问我这个问题。我说GET是用于获取数据的，POST，一般用于将数据发给服务器之用。</p>\n<p>这个答案好像并不是他想要的。于是他继续追问有没有别的区别？我说这就是个名字而已，如果服务器支持，他完全可以把GET改个名字叫GET2。他反问道，那就是单纯的名字上的区别喽？我想了想，我觉得如果说再具体的区别，只能去看RFC文档了，还要取决于服务器（指Apache，IIS）的具体实现。但我不得不承认，我的确没有仔细看过HTTP的RFC文档。于是我说，我对HTTP协议不太熟悉。这个问题也就结束了。</p>\n<h3 id=\"最普遍的答案\"><a href=\"#最普遍的答案\" class=\"headerlink\" title=\"最普遍的答案\"></a>最普遍的答案</h3><p>回来之后寻思了很久，他到底是想问我什么？我一直就觉得GET和POST没有什么除了语义之外的区别，自打我开始学习Web编程开始就是这么理解的。</p>\n<p>可能很多人都已经猜到了，他要的答案是：</p>\n<ol>\n<li><p>GET使用URL或Cookie传参。而POST将数据放在BODY中。</p>\n</li>\n<li><p>GET的URL会有长度上的限制，则POST的数据则可以非常大。</p>\n</li>\n<li><p>POST比GET安全，因为数据在地址栏上不可见。</p>\n</li>\n</ol>\n<p>但是很不幸，这些区别全是错误的，更不幸的是，这个答案还是Google搜索的头版头条，然而我根本没想着这些是答案，因为在我看来他们都是错的。我来一一解释一下。</p>\n<h3 id=\"GET和POST与数据如何传递没有关系\"><a href=\"#GET和POST与数据如何传递没有关系\" class=\"headerlink\" title=\"GET和POST与数据如何传递没有关系\"></a>GET和POST与数据如何传递没有关系</h3><p>GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。</p>\n<p>HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。</p>\n<p>那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？</p>\n<p>而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。</p>\n<p>知道这个有什么用？我不想解释了，有时候就得自己痛一次才记得住。</p>\n<h3 id=\"HTTP协议对GET和POST都没有对长度的限制\"><a href=\"#HTTP协议对GET和POST都没有对长度的限制\" class=\"headerlink\" title=\"HTTP协议对GET和POST都没有对长度的限制\"></a>HTTP协议对GET和POST都没有对长度的限制</h3><p>HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：</p>\n<ol>\n<li><p>浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。</p>\n</li>\n<li><p>服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。</p>\n</li>\n</ol>\n<h3 id=\"安全不安全和GET、POST没有关系\"><a href=\"#安全不安全和GET、POST没有关系\" class=\"headerlink\" title=\"安全不安全和GET、POST没有关系\"></a>安全不安全和GET、POST没有关系</h3><p>我觉得这真是中国特色。我讲个小段子，大家应该可以体会出这个说法多么的可笑。</p>\n<p>觉得POST数据比GET数据安全的人会说</p>\n<blockquote>\n<p>“防君子不防小人；中国小白多，能防小白用户就行了。”<br>“哼，”我不以为然，“那你怎么不说，URL参数都Encode过了，或是Base64一下，小白也看不懂啊。”<br>那人反驳道，“Encode太简单了，聪明点儿的小白很容易就可以Decode并修改掉。”<br>我笑道，“五十步笑百步耳，再聪明点儿的小白还会截包并重发呢，Opera就有这功能。”<br>那人阴险地祭出神器——最终解释权，说，“这个不算小白。”</p>\n</blockquote>\n<p>我日啊。</p>\n<h3 id=\"最后一点儿感想\"><a href=\"#最后一点儿感想\" class=\"headerlink\" title=\"最后一点儿感想\"></a>最后一点儿感想</h3><p>我之前一直做Windows桌面应用，对Web开发无甚了解，直到一年多前转做服务器端开发，才开始接触到HTTP。（注意，我说的是HTTP，不是HTML。服务器开放接口是基于REST理念设计的，使用的协议是HTTP，但是传输的内容不是HTML。这不是Web Server，而是一个Web Service）</p>\n<p>所以我对于GET和POST的理解，是纯粹地来源于HTTP协议。他们只有一点根本区别，简单点儿说，一个用于获取数据，一个用于修改数据。具体的请参考RFC文档。</p>\n<p>如果一个人一开始就做Web开发，很可能把HTML对HTTP协议的使用方式，当成HTTP协议的唯一的合理使用方式。从而犯了以偏概全的错误。</p>\n<p>可能有人会觉得我钻牛角尖。我只是不喜欢模棱两可，不喜欢边界不清、概念不明，不喜欢“拿来主义”，也不喜欢被其它喜欢钻牛角尖的人奚落得无地自容。</p>\n<p>“知之为知之，不知为不知，是知也。”</p>\n<p>转载整理自：<a href=\"http://web.jobbole.com/86298/\">http://web.jobbole.com</a></p>\n"},{"title":"CentOS6.6升级gcc4.8教程","date":"2016-03-02T16:00:00.000Z","_content":"\ncentOS6.6最高版本的gcc也只到4.4.7版本,只好手动升级一下了。\n\n***下载4.8.2源码***\n\n下载依赖(gmp-4.3.2、mpfr-2.4.2、mpc-0.8.1)\n\n```\nwget ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/gmp/gmp-4.3.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/mpfr/mpfr-2.4.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/mpc/mpc-1.0.1.tar.gz\n```\n\n***依次编译安装依赖***\n\n```\ncd /usr/gmp\n./configure --prefix=/usr/local/gcc/gmp-4.3.2\nsudo make\nsudo make install\n```\n\n```\ncd /usr/mpfr\n./configure --prefix=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  \nsudo make\nsudo make install\n```\n\n```\ncd /usr/mpc\n../configure --prefix=/usr/local/gcc/mpc-0.8.1 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  \nsudo make\nsudo make install\n```\n\n***编译安装gcc4.8.2***\n\n```\ncd /usr/gcc-4.8.2\n./configure --prefix=/usr/local/gcc --enable-threads=posix --disable-checking --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gcc/gmp-4.3.2 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-mpc=/usr/local/gcc/mpc-0.8.1\nsudo make\nsudo make install\n```\n\n***卸载旧版本***\n\n```\nyum remove -y gcc gcc-c++\nupdatedb\n```\n\n***链接新版本***\n\n```\ncd /usr/bin  \nln -s /usr/local/gcc/bin/gcc gcc  \nln -s /usr/local/gcc/bin/g++ g++  \n```\n\n***检查版本***\n\n```\ngcc -v\n```\n\ndone\n\n转载自：[http://www.centoscn.com/image-text/config/2015/0823/6041.html](http://www.centoscn.com/image-text/config/2015/0823/6041.html)","source":"_posts/CentOS6.6升级gcc4.8教程.md","raw":"---\ntitle: CentOS6.6升级gcc4.8教程\ntags: [linux,centos]\ndate: 2016/03/03\n---\n\ncentOS6.6最高版本的gcc也只到4.4.7版本,只好手动升级一下了。\n\n***下载4.8.2源码***\n\n下载依赖(gmp-4.3.2、mpfr-2.4.2、mpc-0.8.1)\n\n```\nwget ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/gmp/gmp-4.3.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/mpfr/mpfr-2.4.2.tar.bz2\nwget http://ftp.gnu.org/pub/gnu/mpc/mpc-1.0.1.tar.gz\n```\n\n***依次编译安装依赖***\n\n```\ncd /usr/gmp\n./configure --prefix=/usr/local/gcc/gmp-4.3.2\nsudo make\nsudo make install\n```\n\n```\ncd /usr/mpfr\n./configure --prefix=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  \nsudo make\nsudo make install\n```\n\n```\ncd /usr/mpc\n../configure --prefix=/usr/local/gcc/mpc-0.8.1 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  \nsudo make\nsudo make install\n```\n\n***编译安装gcc4.8.2***\n\n```\ncd /usr/gcc-4.8.2\n./configure --prefix=/usr/local/gcc --enable-threads=posix --disable-checking --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gcc/gmp-4.3.2 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-mpc=/usr/local/gcc/mpc-0.8.1\nsudo make\nsudo make install\n```\n\n***卸载旧版本***\n\n```\nyum remove -y gcc gcc-c++\nupdatedb\n```\n\n***链接新版本***\n\n```\ncd /usr/bin  \nln -s /usr/local/gcc/bin/gcc gcc  \nln -s /usr/local/gcc/bin/g++ g++  \n```\n\n***检查版本***\n\n```\ngcc -v\n```\n\ndone\n\n转载自：[http://www.centoscn.com/image-text/config/2015/0823/6041.html](http://www.centoscn.com/image-text/config/2015/0823/6041.html)","slug":"CentOS6.6升级gcc4.8教程","published":1,"updated":"2016-08-17T06:22:19.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpif001668dd5ilnzf13","content":"<p>centOS6.6最高版本的gcc也只到4.4.7版本,只好手动升级一下了。</p>\n<p><strong><em>下载4.8.2源码</em></strong></p>\n<p>下载依赖(gmp-4.3.2、mpfr-2.4.2、mpc-0.8.1)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wget ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/gmp/gmp-4.3.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/mpfr/mpfr-2.4.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/mpc/mpc-1.0.1.tar.gz</div></pre></td></tr></table></figure>\n<p><strong><em>依次编译安装依赖</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/gmp</div><div class=\"line\">./configure --prefix=/usr/local/gcc/gmp-4.3.2</div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/mpfr</div><div class=\"line\">./configure --prefix=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  </div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/mpc</div><div class=\"line\">../configure --prefix=/usr/local/gcc/mpc-0.8.1 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  </div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<p><strong><em>编译安装gcc4.8.2</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/gcc-4.8.2</div><div class=\"line\">./configure --prefix=/usr/local/gcc --enable-threads=posix --disable-checking --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gcc/gmp-4.3.2 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-mpc=/usr/local/gcc/mpc-0.8.1</div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<p><strong><em>卸载旧版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">yum remove -y gcc gcc-c++</div><div class=\"line\">updatedb</div></pre></td></tr></table></figure>\n<p><strong><em>链接新版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/bin  </div><div class=\"line\">ln -s /usr/local/gcc/bin/gcc gcc  </div><div class=\"line\">ln -s /usr/local/gcc/bin/g++ g++</div></pre></td></tr></table></figure>\n<p><strong><em>检查版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">gcc -v</div></pre></td></tr></table></figure>\n<p>done</p>\n<p>转载自：<a href=\"http://www.centoscn.com/image-text/config/2015/0823/6041.html\" target=\"_blank\" rel=\"external\">http://www.centoscn.com/image-text/config/2015/0823/6041.html</a></p>\n","excerpt":"","more":"<p>centOS6.6最高版本的gcc也只到4.4.7版本,只好手动升级一下了。</p>\n<p><strong><em>下载4.8.2源码</em></strong></p>\n<p>下载依赖(gmp-4.3.2、mpfr-2.4.2、mpc-0.8.1)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">wget ftp://gcc.gnu.org/pub/gcc/releases/gcc-4.8.2/gcc-4.8.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/gmp/gmp-4.3.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/mpfr/mpfr-2.4.2.tar.bz2</div><div class=\"line\">wget http://ftp.gnu.org/pub/gnu/mpc/mpc-1.0.1.tar.gz</div></pre></td></tr></table></figure>\n<p><strong><em>依次编译安装依赖</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/gmp</div><div class=\"line\">./configure --prefix=/usr/local/gcc/gmp-4.3.2</div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/mpfr</div><div class=\"line\">./configure --prefix=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  </div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/mpc</div><div class=\"line\">../configure --prefix=/usr/local/gcc/mpc-0.8.1 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-gmp=/usr/local/gcc/gmp-4.3.2  </div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<p><strong><em>编译安装gcc4.8.2</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/gcc-4.8.2</div><div class=\"line\">./configure --prefix=/usr/local/gcc --enable-threads=posix --disable-checking --enable-languages=c,c++ --disable-multilib --with-gmp=/usr/local/gcc/gmp-4.3.2 --with-mpfr=/usr/local/gcc/mpfr-2.4.2 --with-mpc=/usr/local/gcc/mpc-0.8.1</div><div class=\"line\">sudo make</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure>\n<p><strong><em>卸载旧版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">yum remove -y gcc gcc-c++</div><div class=\"line\">updatedb</div></pre></td></tr></table></figure>\n<p><strong><em>链接新版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">cd /usr/bin  </div><div class=\"line\">ln -s /usr/local/gcc/bin/gcc gcc  </div><div class=\"line\">ln -s /usr/local/gcc/bin/g++ g++</div></pre></td></tr></table></figure>\n<p><strong><em>检查版本</em></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">gcc -v</div></pre></td></tr></table></figure>\n<p>done</p>\n<p>转载自：<a href=\"http://www.centoscn.com/image-text/config/2015/0823/6041.html\">http://www.centoscn.com/image-text/config/2015/0823/6041.html</a></p>\n"},{"title":"Git详解之Git分支","date":"2016-03-01T16:00:00.000Z","_content":"\n这篇文章对Git分支讲的很详实，很好，推荐给大家，也整理出来给自己学习之用。\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。\n\n有人把Git的分支模型称为“必杀技特性”，而正是因为它，将Git从版本控制系统家族里区分出来。Git有何特别之处呢？Git的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。\n\n\n\n###3.1何谓分支\n\n为了理解Git分支的实现方式，我们需要回顾一下Git是如何储存数据的。或许你还记得第一章的内容，Git保存的不是文件差异或者变化量，而只是一系列文件快照。\n\n在Git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。\n\n为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的SHA-1哈希字串），然后把当前版本的文件快照保存到Git仓库中（Git使用blob类型的对象存储这些快照），并将校验和加入暂存区域：\n\n```\n$ git add README test.rb LICENSE\n$ git commit -m 'initial commit of my project'\n```\n\n当使用gitcommit新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在Git仓库中将这些目录保存为树（tree）对象。之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。\n\n现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象；一个记录着目录树内容及其中各个文件对应blob对象索引的tree对象；以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图3-1所示：\n\n![Git详解之Git分支](resource/2016031101.png)\n\n图3-1.单个提交对象在仓库中的数据结构\n\n作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的parent对象）。两次提交后，仓库历史会变成图3-2的样子：\n\n![Git详解之Git分支](resource/2016031102.png)\n\n图3-2.多个提交对象之间的链接关系\n\n现在来谈分支。Git中的分支，其实本质上仅仅是个指向commit对象的可变指针。Git会使用master作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的master分支，它在每次提交的时候都会自动向前移动。\n\n![Git详解之Git分支](resource/2016031103.png)\n\n图3-3.分支其实就是从某个提交对象往回看的历史\n\n那么，Git又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个testing 分支，可以使用`git branch`命令：\n\n`$ git branch testing`\n\n这会在当前commit对象上新建一个分支指针（见图3-4）。\n\n![Git详解之Git分支](resource/2016031104.png)\n\n图3-4.多个分支指向提交数据的历史\n\n那么，Git是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为HEAD的特别指针。请注意它和你熟知的许多其他版本控制系统（比如Subversion或CVS）里的HEAD概念大不相同。在Git中，它是一个指向你正在工作中的本地分支的指针（译注：将HEAD想象为当前分支的别名。）。运行`git branch`命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在master分支里工作（参考图3-5）。\n\n![Git详解之Git分支](resource/2016031105.png)\n\n图3-5.HEAD指向当前所在的分支\n\n要切换到其他分支，可以执行`git checkout`命令。我们现在转换到新建的testing分支：\n\n`$ git checkout testing`\n\n这样HEAD就指向了testing分支（见图3-6）。\n\n![Git详解之Git分支](resource/2016031106.png)\n\n图3-6.HEAD在你转换分支时指向新的分支\n\n这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：\n\n`$ vim test.rb $ git commit -a -m 'made a change'`\n\n图3-7展示了提交后的结果。\n\n![Git详解之Git分支](resource/2016031107.png)\n\n图3-7.每次提交后HEAD随着分支一起向前移动\n\n非常有趣，现在testing分支向前移动了一格，而master分支仍然指向原先`git checkout`时所在的commit对象。现在我们回到master分支看看：\n\n`$ git checkout master`\n\n图3-8显示了结果。\n\n![Git详解之Git分支](resource/2016031108.png)\n\n图3-8.HEAD在一次checkout之后移动到了另一个分支\n\n这条命令做了两件事。它把HEAD指针移回到master分支，并把工作目录中的文件换成了master分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将testing分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。\n\n我们作些修改后再次提交：\n\n`$ vim test.rb $ git commit -a -m 'made other changes'`\n\n现在我们的项目提交历史产生了分叉（如图3-9所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch和checkout这两条命令就可以完成。\n\n![Git详解之Git分支](resource/2016031109.png)\n\n图 3-9.不同流向的分支历史\n\n由于Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（外加一个换行符）那么简单，当然也就很快了。\n\n这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git鼓励开发者频繁使用分支，正是因为有着这些特性作保障。\n\n接下来看看，我们为什么应该频繁使用分支。\n\n###3.2分支的新建与合并\n\n现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：\n\n1.开发某个网站。\n2.为实现某个新的需求，创建一个分支。\n3.在这个分支上开展工作。\n\n假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：\n\n1.返回到原先已经发布到生产服务器上的分支。\n2.为这次紧急修补建立一个新分支，并在其中修复问题。\n3.通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。\n4.切换到之前实现新需求的分支，继续工作。\n\n**分支的新建与切换**\n\n首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图3-10）。\n\n![Git详解之Git分支](resource/2016031110.png)\n\n图3-10.一个简短的提交历史\n\n现在，你决定要修补问题追踪系统上的#53问题。顺带说明下，Git并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为iss53。要新建并切换到该分支，运行gitcheckout并加上-b参数：\n\n```\n$ git checkout -b iss53 # Switched to a new branch \"iss53\"\n```\n\n这相当于执行下面这两条命令：\n\n```\n$ git branch iss53\n$ git checkout iss53\n```\n\n图3-11示意该命令的执行结果。\n\n![Git详解之Git分支](resource/2016031111.png)\n\n图3-11.创建了一个新分支的指针\n\n接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的HEAD指针正指向iss53，见图3-12）：\n\n```\n$ vim index.html \n$ git commit -a -m 'added a new footer [issue 53]'\n```\n\n![Git详解之Git分支](resource/2016031112.png)\n\n图3-12.iss53分支随工作进展向前推进\n\n现在你就接到了那个网站问题的紧急电话，需要马上修补。有了Git，我们就不需要同时发布这个补丁和iss53里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master分支。\n\n不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止Git为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做stashing和commitamending）。目前已经提交了所有的修改，所以接下来可以正常转换到master分支：\n\n```\n$ git checkout master # Switched to branch \"master\"\n```\n\n此时工作目录中的内容和你在解决问题#53之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。\n\n接下来，你得进行紧急修补。我们创建一个紧急修补分支hotfix来开展工作，直到搞定（见图3-13）：\n\n```\n$ git checkout -b 'hotfix' # Switched to a new branch \"hotfix\" \n$ vim index.html \n$ git commit -a -m 'fixed the broken email address' \n\n[hotfix]: created 3a0874c: \"fixed the broken email address\" \n1 files changed, 0 insertions(+), 1 deletions(-)\n```\n\n![Git详解之Git分支](resource/2016031113.png) \n\n图3-13.hotfix分支是从master分支所在点分化出来的\n\n有必要作些测试，确保修补是成功的，然后回到master分支并把它合并进来，然后发布到生产服务器。用`gitmerge`命令来进行合并：\n\n```\n$ git checkout master \n$ git merge hotfix \n\nUpdating f42c576..3a0874c \nFast forward \nREADME | 1 - 1 files changed, 0 insertions(+), 1 deletions(-)\n```\n\n请注意，合并时出现了“Fast forward”的提示。由于当前master分支所在的提交对象是要并入的hotfix分支的直接上游，Git只需把master分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。\n\n现在最新的修改已经在当前master分支所指向的提交对象中了，可以部署到生产服务器上去了（见图3-14）。\n\n![Git详解之Git分支](resource/2016031114.png)\n\n图3-14.合并之后，master分支和hotfix分支指向同一位置。\n\n在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前hotfix分支和master都指向相同的提交对象，所以hotfix已经完成了历史使命，可以删掉了。使用`git branch`的 -d 选项执行删除操作：\n\n```\n$ git branch -d hotfix Deleted branch hotfix (3a0874c).\n```\n\n现在回到之前未完成的#53问题修复分支上继续工作（图3-15）：\n\n```\n$ git checkout iss53 # Switched to branch \"iss53\" \n$ vim index.html \n$ git commit -a -m 'finished the new footer [issue 53]' \n\n[iss53]: created ad82d7a: \"finished the new footer [issue 53]\" \n1 files changed, 1 insertions(+), 0 deletions(-)\n```\n\n![Git详解之Git分支](resource/2016031115.png) \n\n图3-15.iss53分支可以不受影响继续推进。\n\n不用担心之前hotfix分支的修改内容尚未包含到iss53中来。如果确实需要纳入此次修补，可以用`git merge master`把master分支合并到iss53；或者等iss53完成之后，再将iss53分支中的更新并入master。\n\n**分支的合并**\n\n在问题#53相关的工作完成之后，可以合并回master分支。实际操作同前面合并hotfix分支差不多，只需回到master分支，运行`git merge`命令指定要合并进来的分支：\n\n```\n$ git checkout master \n$ git merge iss53 # Merge made by recursive. \n\nREADME | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)\n```\n\n请注意，这次合并操作的底层实现，并不同于之前hotfix的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前master分支所指向的提交对象（C4）并不是iss53分支的直接祖先，Git不得不进行一些额外处理。就此例而言，Git会用两个分支的末端（C4和C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图3-16用红框标出了Git用于合并的三个提交对象：\n\n![Git详解之Git分支](resource/2016031116.png)\n\n图3-16.Git为分支合并自动识别出最佳的同源合并点。\n\n这次，Git没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图3-17）。这个提交对象比较特殊，它有两个祖先（C4和C5）。\n\n值得一提的是Git可以自己裁决哪个共同祖先才是最佳合并基础；这和CVS或Subversion（1.5以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让Git的合并操作比其他系统都要简单不少。\n\n![Git详解之Git分支](resource/2016031117.png)\n\n图3-17.Git自动创建了一个包含了合并结果的提交对象。\n\n既然之前的工作成果已经合并到master了，那么iss53也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。\n\n```\n$ git branch -d iss53\n```\n\n**遇到冲突时的分支合并**\n\n有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题#53的过程中修改了hotfix中修改的部分，将得到类似下面的结果：\n\n```\n$ git merge iss53 #Auto-merging index.html \n\nCONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.\n```\n\nGit作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用`git status`查阅：\n\n```\n[master*]$ git status \n# index.html: needs merge \n# On branch master \n# Changed but not updated: \n# (use \"git add ...\" to update what will be committed) \n# (use \"git checkout -- ...\" to discard changes in working directory) # \n# unmerged: index.html #\n```\n\n任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：\n\n```\n<<<<<<< HEAD:index.html\ncontact : email.support@github.com\n=======\nplease contact us at support@github.com\n>>>>>>> iss53:index.html\n```\n\n可以看到=======隔开的上半部分，是HEAD（即master分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在iss53分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：\n\n```\nplease contact us at email.support@github.com\n```\n\n这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了`<<<<<<<`，`=======`和`>>>>>>>`这些行。在解决了所有文件里的所有冲突后，运行`git add`将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行`git mergetool`，它会调用一个可视化的合并工具并引导你解决所有冲突：\n\n```\n$ git mergetool #merge tool \n\ncandidates: kdiff3 \n\t\t\ttkdiff\n\t\t\txxdiff \n\t\t\tmeld \n\t\t\tgvimdiff \n\t\t\topendiff \n\t\t\temerge \n\t\t\tvimdiff \nMerging the files: index.html Normal merge conflict for 'index.html': {local}: modified {remote}: modified Hit return to start merge resolution tool (opendiff):\n```\n\n如果不想用默认的合并工具（Git为我默认选择了opendiff，因为我在Mac上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。\n\n退出合并工具以后，Git会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。\n\n再运行一次git status来确认所有冲突都已解决：\n\n```\n$ git status # On branch master # Changes to be committed: # (use \"git reset HEAD ...\" to unstage) # #\tmodified: index.html #\n```\n如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用`git commit`来完成这次合并提交。提交的记录差不多是这样：\n\n```\nMerge branch 'iss53' Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. #\n```\n\n如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。\n\n###3.3  分支的管理\n\n到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。\n\n`git branch`命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：\n\n```\n$ git branch iss53 * master testing\n```\n\n注意看master分支前的*字符：它表示当前所在的分支。也就是说，如果现在提交更新，master分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行`git branch -v`：\n\n```\n$ git branch -v iss53 # 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes\n```\n\n要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用--merge和--no-merged选项（Git1.5.6以上版本）。比如用`git branch --merge`查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：\n\n```\n$ git branch --merged iss53 * master\n```\n\n之前我们已经合并了iss53，所以在这里会看到它。一般来说，列表中没有*的分支通常都可以用`git branch -d`来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。\n\n另外可以用`git branch --no-merged`查看尚未合并的工作：\n\n```\n$ git branch --no-merged testing\n```\n\n它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用`git branch -d`删除该分支会提示错误，因为那样做会丢失数据：\n\n```\n$ git branch -d # testing error: The branch 'testing' is not an ancestor of your current HEAD. If you are sure you want to delete it, run 'git branch -D testing'.\n```\n\n不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项-D强制执行，就像上面提示信息中给出的那样。\n\n###3.4利用分支进行开发的工作流程\n\n现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。\n\n**长期分支**\n\n由于Git使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。\n\n许多使用Git的开发者都喜欢用这种方式来开展工作，比如仅在master分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop或next的平行分支，专门用于后续的开发，或仅用于稳定性测试—当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master里。这样，在确保这些已完成的特性分支（短期分支，比如之前的iss53分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。\n\n本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图3-18）。\n\n![Git详解之Git分支](resource/2016031118.png)\n\n图3-18.稳定分支总是比较老旧。\n\n或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图3-19）。\n\n![Git详解之Git分支](resource/2016031119.png)\n\n图3-19.想象成流水线可能会容易点。\n\n你可以用这招维护不同层次的稳定性。某些大项目还会有个proposed（建议）或pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next或 master的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。\n\n**特性分支**\n\n在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在Git中，一天之内建立、使用、合并再删除多个分支是常见的事。\n\n我们在上节的例子里已经见过这种用法了。我们创建了iss53和hotfix这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换—因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。\n\n现在我们来看一个实际的例子。请看图3-20，由下往上，起先我们在master工作到C1，然后开始一个新分支iss91尝试修复91号缺陷，提交到C6的时候，又冒出一个解决该问题的新办法，于是从之前C4的地方又分出一个分支iss91v2，干到C8的时候，又回到主干master中提交了C9和C10，再回到iss91v2继续工作，提交C11，接着，又冒出个不太确定的想法，从master的最新提交C10处开了个新的分支dumbidea做些试验。\n\n![Git详解之Git分支](resource/2016031120.png)\n\n图3-20.拥有多个特性分支的提交历史。\n\n现在，假定两件事情：我们最终决定使用第二个解决方案，即iss91v2中的办法；另外，我们把dumbidea分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91分支（实际上会丢弃C5和C6），直接在主干中并入另外两个分支。最终的提交历史将变成图3-21这样：\n\n![Git详解之Git分支](resource/2016031121.png)\n\n图3-21.合并了dumbidea和iss91v2后的分支历史。\n\n请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的Git仓库中进行的—完全不涉及与服务器的交互。\n\n\n###3.5 远程分支\n\n远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在Git进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。\n\n我们用(远程仓库名)/(分支名)这样的形式表示远程分支。比如我们想看看上次同origin仓库通讯时master的样子，就应该查看origin/master分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53分支到远程仓库，虽然你可能也有一个本地的iss53分支，但指向服务器上最新更新的却应该是origin/iss53分支。\n\n可能有点乱，我们不妨举例说明。假设你们团队有个地址为git.ourcompany.com的Git服务器。如果你从这里克隆，Git会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的master分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git建立一个属于你自己的本地master分支，始于origin上master分支相同的位置，你可以就此开始工作（见图3-22）：\n\n![Git详解之Git分支](resource/2016031122.png)\n\n图3-22.一次Git克隆会建立你自己的本地分支master和远程分支origin/master，它们都指向origin/master分支的最后一次提交。\n\n如果你在本地master分支做了些改动，与此同时，其他人向git.ourcompany.com推送了他们的更新，那么服务器上的master分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的origin/master指针仍然保持原位不会移动（见图3-23）。\n\n![Git详解之Git分支](resource/2016031123.png)\n\n图3-23.在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。\n\n可以运行`git fetch origin`来同步远程服务器上的数据到本地。该命令首先找到origin是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把origin/master的指针移到它最新的位置上（见图3-24）。\n\n![Git详解之Git分支](resource/2016031124.png)\n\n图3-24.gitfetch命令会更新remote索引。\n\n为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器git.team1.ourcompany.com。可以用第二章中提到的`git remote add`命令把它加为当前项目的远程分支之一。我们把它命名为teamone，以便代替原始的Git地址（见图3-25）。\n\n![Git详解之Git分支](resource/2016031125.png)\n\n图3-25.把另一个服务器加为远程仓库\n\n现在你可以用`git fetch teamone`来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你origin服务器上的子集，Git不会下载任何数据，而只是简单地创建一个名为teamone/master的分支，指向teamone服务器上master分支所在的提交对象31b8e（见图3-26）。\n\n![Git详解之Git分支](resource/2016031126.png)\n\n图3-26.你在本地有了一个指向teamone服务器上master分支的索引。\n\n**推送本地分支**\n\n要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。\n\n如果你有个叫serverfix的分支需要和他人一起开发，可以运行`git push(远程仓库名) (分支名)`：\n\n```\n$ git push origin serverfix \n\nCounting objects: 20, done. \nCompressing objects: 100% (14/14), done. \nWriting objects: 100% (15/15), 1.74 KiB, done. \nTotal 15 (delta 5), reused 0 (delta 0) \nTo git@github.com:schacon/simplegit.git \n* [new branch] serverfix -> serverfix\n```\n\n这其实有点像条捷径。Git自动把serverfix分支名扩展为refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的serverfix分支，推送到远程仓库的serverfix分支中去”。我们将在第九章进一步介绍refs/heads/部分的细节，不过一般使用的时候都可以省略它。也可以运行`git push origin serverfix:serferfix`来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用`git push origin serverfix:awesomebranch`来推送数据。\n\n接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支origin/serverfix：\n\n```\n$ git fetch origin \n\nremote: Counting \nobjects: 20, done. \nremote: Compressing \nobjects: 100% (14/14), done. \nremote: Total 15 (delta 5), reused 0 (delta 0) \nUnpacking objects: 100% (15/15), done. \nFrom git@github.com:schacon/simplegit \n* [new branch] serverfix -> origin/serverfix\n```\n\n值得注意的是，在fetch操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix分支，有的只是一个你无法移动的origin/serverfix指针。\n\n如果要把该内容合并到当前分支，可以运行`git merge origin/serverfix`。如果想要一份自己的serverfix来开发，可以在远程分支的基础上分化出一个新的分支来：\n\n```\n$ git checkout -b serverfix origin/serverfix \n\nBranch serverfix set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"serverfix\"\n```\n这会切换到新建的serverfix本地分支，其内容同远程分支origin/serverfix一致，这样你就可以在里面继续开发了。\n\n**跟踪远程分支**\n\n从远程分支checkout出来的本地分支，称为_跟踪分支(tracking branch)_。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入`git push`，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行`git pull`会获取所有远程索引，并把它们的数据都合并到本地分支中来。\n\n在克隆仓库时，Git通常会自动创建一个名为master的分支来跟踪origin/master。这正是`git push`和`git pull`一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin上除了master之外的其它分支。刚才我们已经看到了这样的一个例子：`git checkout -b [分支名] [远程名]/[分支名]`。如果你有1.6.2以上版本的Git，还可以用--track选项简化：\n\n```\n$ git checkout --track origin/serverfix \n\nBranch serverfix set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"serverfix\"\n```\n\n要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：\n\n```\n$ git checkout -b sf origin/serverfix \n\nBranch sf set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"sf\"\n```\n\n现在你的本地分支sf会自动向origin/serverfix推送和抓取数据了。\n\n**删除远程分支**\n\n如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的master分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：`git push [远程名] :[分支名]`。如果想在服务器上删除serverfix 分支，运行下面的命令：\n\n```\n$ git push origin:serverfix \n\nTo git@github.com:schacon/simplegit.git - [deleted] serverfix\n```\n\n咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 `git push [远程名] [本地分支]:[远程分支]` 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。\n\n###3.6  分支的衍合\n\n把一个分支整合到另一个分支的办法有两种：merge和rebase（译注：rebase的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。\n\n基本的衍合操作\n请回顾之前有关合并的一节（见图3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。\n\n![Git详解之Git分支](resource/2016031127.png)\n\n图3-27.最初分叉的提交历史。\n\n之前介绍过，最容易的整合分支的方法是merge命令，它会把两个分支最新的快照（C3和C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图3-28所示：\n\n![Git详解之Git分支](resource/2016031128.png)\n\n图3-28.通过合并一个分支来整合分叉了的历史。\n其实，还有另外一个选择：你可以把在C3里产生的变化补丁在C4的基础上重新打一遍。在Git里，这种操作叫做_衍合（rebase）_。有了rebase命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。\n\n在上面这个例子中，运行：\n\n```\n$ git checkout experiment \n$ git rebase master \n\nFirst, rewinding head to replay your work on top of it... Applying: added staged command\n```\n\n它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支experiment）后续的历次提交对象（这里只有一个C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写experiment的提交历史，使它成为master分支的直接下游，如图3-29所示：\n\n![Git详解之Git分支](resource/2016031129.png)\n\n图3-29.把C3里产生的改变到C4上重演一遍。\n\n现在回到master分支，进行一次快进合并（见图3-30）：\n\n![Git详解之Git分支](resource/2016031130.png)\n\n图3-30.master分支的快进。\n\n现在的C3’对应的快照，其实和普通的三方合并，即上个例子中的C5对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\n\n一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁—比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。\n\n请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。\n\n**有趣的衍合**\n\n衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图3-31的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支server，然后提交C3和C4。然后又从C3的地方再增加一个client分支来对客户端代码进行一些相应修改，所以提交了C8和C9。最后，又回到server分支提交了C10。\n\n![Git详解之Git分支](resource/2016031131.png)\n\n图3-31.从一个特性分支里再分出一个特性分支的历史。\n\n假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于server分支而非master分支的改变（即C8和C9），跳过server直接放到master分支中重演一遍，但这需要用git rebase的--onto选项指定新的基底分支master：\n\n```\n$ git rebase --onto master server client\n```\n\n这好比在说：“取出client分支，找出client分支和server分支的共同祖先之后的变化，然后把它们在master上重演一遍”。是不是有点复杂？不过它的结果如图3-32所示，非常酷（译注：虽然client里的C8,C9在C3之后，但这仅表明时间上的先后，而非在C3修改的基础上进一步改动，因为server和client这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在C3时间点之后，对另外的文件所做的C8，C9修改，放到主干重演。）：\n\n![Git详解之Git分支](resource/2016031132.png)\n\n图3-32.将特性分支上的另一个特性分支衍合到其他分支。\n\n现在可以快进master分支了（见图3-33）：\n\n```\n$ git checkout master $ git merge client\n```\n\n![Git详解之Git分支](resource/2016031133.png)\n\n图3-33.快进master分支，使之包含client分支的变化。\n\n现在我们决定把server分支的变化也包含进来。我们可以直接把server分支衍合到master，而不用手工切换到server分支后再执行衍合操作`git rebase [主分支] [特性分支]`命令会先取出特性分支server，然后在主分支master上重演：\n\n```\n$ git rebase master server\n```\n\n于是，server的进度应用到master的基础上，如图3-34所示：\n\n![Git详解之Git分支](resource/2016031134.png)\n\n图3-34.在master分支上衍合server分支。\n\n然后就可以快进主干分支master了：\n\n```\n$ git checkout master $ git merge server\n```\n\n现在client和server分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图3-35的样子：\n\n```\n$ git branch -d client $ git branch -d server\n```\n\n![Git详解之Git分支](resource/2016031135.png) \n\n图3-35.最终的提交历史\n\n**衍合的风险**\n\n呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：\n\n**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。**\n\n如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。\n\n下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图3-36所示：\n\n![Git详解之Git分支](resource/2016031136.png)\n\n图3-36.克隆一个仓库，在其基础上工作一番。\n\n现在，某人在C1的基础上做了些改变，并合并他自己的分支得到结果C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果C7，历史提交会变成图3-37这样：\n\n![Git详解之Git分支](resource/2016031137.png)\n\n图3-37.抓取他人提交，并入自己主干。\n\n接下来，那个推送C6上来的人决定用衍合取代之前的合并操作；继而又用git push --force覆盖了服务器上的历史，得到C4’。而之后当你再从服务器上下载最新提交后，会得到：\n\n![Git详解之Git分支](resource/2016031138.png)\n\n图3-38.有人推送了衍合后得到的C4’，丢弃了你作为开发基础的C4和C6。\n\n下载更新后需要合并，但此时衍合产生的提交对象C4’的SHA-1校验值和之前C4完全不同，所以Git会把它们当作新的提交对象处理，而实际上此刻你的提交历史C7中早已经包含了C4的修改内容，于是合并操作会把C7和C4’合并为C8（见图3-39）:\n\n![Git详解之Git分支](resource/2016031139.png)\n\n图3-39.你把相同的内容又合并了一遍，生成一个新的提交C8。\n\nC8这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在C8之后，你的提交历史里就会同时包含C4和C4’，两者有着不同的SHA-1校验值，如果用git log查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了C6后又用衍合发布C4’的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。\n\n如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。\n\n###3.7小结\n\n读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。","source":"_posts/Git详解之Git分支.md","raw":"---\ntitle: Git详解之Git分支\ntags: [git]\ndate: 2016/03/02\n---\n\n这篇文章对Git分支讲的很详实，很好，推荐给大家，也整理出来给自己学习之用。\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。\n\n有人把Git的分支模型称为“必杀技特性”，而正是因为它，将Git从版本控制系统家族里区分出来。Git有何特别之处呢？Git的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。\n\n\n\n###3.1何谓分支\n\n为了理解Git分支的实现方式，我们需要回顾一下Git是如何储存数据的。或许你还记得第一章的内容，Git保存的不是文件差异或者变化量，而只是一系列文件快照。\n\n在Git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。\n\n为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的SHA-1哈希字串），然后把当前版本的文件快照保存到Git仓库中（Git使用blob类型的对象存储这些快照），并将校验和加入暂存区域：\n\n```\n$ git add README test.rb LICENSE\n$ git commit -m 'initial commit of my project'\n```\n\n当使用gitcommit新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在Git仓库中将这些目录保存为树（tree）对象。之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。\n\n现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象；一个记录着目录树内容及其中各个文件对应blob对象索引的tree对象；以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图3-1所示：\n\n![Git详解之Git分支](resource/2016031101.png)\n\n图3-1.单个提交对象在仓库中的数据结构\n\n作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的parent对象）。两次提交后，仓库历史会变成图3-2的样子：\n\n![Git详解之Git分支](resource/2016031102.png)\n\n图3-2.多个提交对象之间的链接关系\n\n现在来谈分支。Git中的分支，其实本质上仅仅是个指向commit对象的可变指针。Git会使用master作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的master分支，它在每次提交的时候都会自动向前移动。\n\n![Git详解之Git分支](resource/2016031103.png)\n\n图3-3.分支其实就是从某个提交对象往回看的历史\n\n那么，Git又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个testing 分支，可以使用`git branch`命令：\n\n`$ git branch testing`\n\n这会在当前commit对象上新建一个分支指针（见图3-4）。\n\n![Git详解之Git分支](resource/2016031104.png)\n\n图3-4.多个分支指向提交数据的历史\n\n那么，Git是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为HEAD的特别指针。请注意它和你熟知的许多其他版本控制系统（比如Subversion或CVS）里的HEAD概念大不相同。在Git中，它是一个指向你正在工作中的本地分支的指针（译注：将HEAD想象为当前分支的别名。）。运行`git branch`命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在master分支里工作（参考图3-5）。\n\n![Git详解之Git分支](resource/2016031105.png)\n\n图3-5.HEAD指向当前所在的分支\n\n要切换到其他分支，可以执行`git checkout`命令。我们现在转换到新建的testing分支：\n\n`$ git checkout testing`\n\n这样HEAD就指向了testing分支（见图3-6）。\n\n![Git详解之Git分支](resource/2016031106.png)\n\n图3-6.HEAD在你转换分支时指向新的分支\n\n这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：\n\n`$ vim test.rb $ git commit -a -m 'made a change'`\n\n图3-7展示了提交后的结果。\n\n![Git详解之Git分支](resource/2016031107.png)\n\n图3-7.每次提交后HEAD随着分支一起向前移动\n\n非常有趣，现在testing分支向前移动了一格，而master分支仍然指向原先`git checkout`时所在的commit对象。现在我们回到master分支看看：\n\n`$ git checkout master`\n\n图3-8显示了结果。\n\n![Git详解之Git分支](resource/2016031108.png)\n\n图3-8.HEAD在一次checkout之后移动到了另一个分支\n\n这条命令做了两件事。它把HEAD指针移回到master分支，并把工作目录中的文件换成了master分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将testing分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。\n\n我们作些修改后再次提交：\n\n`$ vim test.rb $ git commit -a -m 'made other changes'`\n\n现在我们的项目提交历史产生了分叉（如图3-9所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch和checkout这两条命令就可以完成。\n\n![Git详解之Git分支](resource/2016031109.png)\n\n图 3-9.不同流向的分支历史\n\n由于Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（外加一个换行符）那么简单，当然也就很快了。\n\n这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git鼓励开发者频繁使用分支，正是因为有着这些特性作保障。\n\n接下来看看，我们为什么应该频繁使用分支。\n\n###3.2分支的新建与合并\n\n现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：\n\n1.开发某个网站。\n2.为实现某个新的需求，创建一个分支。\n3.在这个分支上开展工作。\n\n假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：\n\n1.返回到原先已经发布到生产服务器上的分支。\n2.为这次紧急修补建立一个新分支，并在其中修复问题。\n3.通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。\n4.切换到之前实现新需求的分支，继续工作。\n\n**分支的新建与切换**\n\n首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图3-10）。\n\n![Git详解之Git分支](resource/2016031110.png)\n\n图3-10.一个简短的提交历史\n\n现在，你决定要修补问题追踪系统上的#53问题。顺带说明下，Git并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为iss53。要新建并切换到该分支，运行gitcheckout并加上-b参数：\n\n```\n$ git checkout -b iss53 # Switched to a new branch \"iss53\"\n```\n\n这相当于执行下面这两条命令：\n\n```\n$ git branch iss53\n$ git checkout iss53\n```\n\n图3-11示意该命令的执行结果。\n\n![Git详解之Git分支](resource/2016031111.png)\n\n图3-11.创建了一个新分支的指针\n\n接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的HEAD指针正指向iss53，见图3-12）：\n\n```\n$ vim index.html \n$ git commit -a -m 'added a new footer [issue 53]'\n```\n\n![Git详解之Git分支](resource/2016031112.png)\n\n图3-12.iss53分支随工作进展向前推进\n\n现在你就接到了那个网站问题的紧急电话，需要马上修补。有了Git，我们就不需要同时发布这个补丁和iss53里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master分支。\n\n不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止Git为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做stashing和commitamending）。目前已经提交了所有的修改，所以接下来可以正常转换到master分支：\n\n```\n$ git checkout master # Switched to branch \"master\"\n```\n\n此时工作目录中的内容和你在解决问题#53之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。\n\n接下来，你得进行紧急修补。我们创建一个紧急修补分支hotfix来开展工作，直到搞定（见图3-13）：\n\n```\n$ git checkout -b 'hotfix' # Switched to a new branch \"hotfix\" \n$ vim index.html \n$ git commit -a -m 'fixed the broken email address' \n\n[hotfix]: created 3a0874c: \"fixed the broken email address\" \n1 files changed, 0 insertions(+), 1 deletions(-)\n```\n\n![Git详解之Git分支](resource/2016031113.png) \n\n图3-13.hotfix分支是从master分支所在点分化出来的\n\n有必要作些测试，确保修补是成功的，然后回到master分支并把它合并进来，然后发布到生产服务器。用`gitmerge`命令来进行合并：\n\n```\n$ git checkout master \n$ git merge hotfix \n\nUpdating f42c576..3a0874c \nFast forward \nREADME | 1 - 1 files changed, 0 insertions(+), 1 deletions(-)\n```\n\n请注意，合并时出现了“Fast forward”的提示。由于当前master分支所在的提交对象是要并入的hotfix分支的直接上游，Git只需把master分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。\n\n现在最新的修改已经在当前master分支所指向的提交对象中了，可以部署到生产服务器上去了（见图3-14）。\n\n![Git详解之Git分支](resource/2016031114.png)\n\n图3-14.合并之后，master分支和hotfix分支指向同一位置。\n\n在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前hotfix分支和master都指向相同的提交对象，所以hotfix已经完成了历史使命，可以删掉了。使用`git branch`的 -d 选项执行删除操作：\n\n```\n$ git branch -d hotfix Deleted branch hotfix (3a0874c).\n```\n\n现在回到之前未完成的#53问题修复分支上继续工作（图3-15）：\n\n```\n$ git checkout iss53 # Switched to branch \"iss53\" \n$ vim index.html \n$ git commit -a -m 'finished the new footer [issue 53]' \n\n[iss53]: created ad82d7a: \"finished the new footer [issue 53]\" \n1 files changed, 1 insertions(+), 0 deletions(-)\n```\n\n![Git详解之Git分支](resource/2016031115.png) \n\n图3-15.iss53分支可以不受影响继续推进。\n\n不用担心之前hotfix分支的修改内容尚未包含到iss53中来。如果确实需要纳入此次修补，可以用`git merge master`把master分支合并到iss53；或者等iss53完成之后，再将iss53分支中的更新并入master。\n\n**分支的合并**\n\n在问题#53相关的工作完成之后，可以合并回master分支。实际操作同前面合并hotfix分支差不多，只需回到master分支，运行`git merge`命令指定要合并进来的分支：\n\n```\n$ git checkout master \n$ git merge iss53 # Merge made by recursive. \n\nREADME | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)\n```\n\n请注意，这次合并操作的底层实现，并不同于之前hotfix的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前master分支所指向的提交对象（C4）并不是iss53分支的直接祖先，Git不得不进行一些额外处理。就此例而言，Git会用两个分支的末端（C4和C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图3-16用红框标出了Git用于合并的三个提交对象：\n\n![Git详解之Git分支](resource/2016031116.png)\n\n图3-16.Git为分支合并自动识别出最佳的同源合并点。\n\n这次，Git没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图3-17）。这个提交对象比较特殊，它有两个祖先（C4和C5）。\n\n值得一提的是Git可以自己裁决哪个共同祖先才是最佳合并基础；这和CVS或Subversion（1.5以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让Git的合并操作比其他系统都要简单不少。\n\n![Git详解之Git分支](resource/2016031117.png)\n\n图3-17.Git自动创建了一个包含了合并结果的提交对象。\n\n既然之前的工作成果已经合并到master了，那么iss53也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。\n\n```\n$ git branch -d iss53\n```\n\n**遇到冲突时的分支合并**\n\n有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题#53的过程中修改了hotfix中修改的部分，将得到类似下面的结果：\n\n```\n$ git merge iss53 #Auto-merging index.html \n\nCONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.\n```\n\nGit作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用`git status`查阅：\n\n```\n[master*]$ git status \n# index.html: needs merge \n# On branch master \n# Changed but not updated: \n# (use \"git add ...\" to update what will be committed) \n# (use \"git checkout -- ...\" to discard changes in working directory) # \n# unmerged: index.html #\n```\n\n任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：\n\n```\n<<<<<<< HEAD:index.html\ncontact : email.support@github.com\n=======\nplease contact us at support@github.com\n>>>>>>> iss53:index.html\n```\n\n可以看到=======隔开的上半部分，是HEAD（即master分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在iss53分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：\n\n```\nplease contact us at email.support@github.com\n```\n\n这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了`<<<<<<<`，`=======`和`>>>>>>>`这些行。在解决了所有文件里的所有冲突后，运行`git add`将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行`git mergetool`，它会调用一个可视化的合并工具并引导你解决所有冲突：\n\n```\n$ git mergetool #merge tool \n\ncandidates: kdiff3 \n\t\t\ttkdiff\n\t\t\txxdiff \n\t\t\tmeld \n\t\t\tgvimdiff \n\t\t\topendiff \n\t\t\temerge \n\t\t\tvimdiff \nMerging the files: index.html Normal merge conflict for 'index.html': {local}: modified {remote}: modified Hit return to start merge resolution tool (opendiff):\n```\n\n如果不想用默认的合并工具（Git为我默认选择了opendiff，因为我在Mac上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。\n\n退出合并工具以后，Git会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。\n\n再运行一次git status来确认所有冲突都已解决：\n\n```\n$ git status # On branch master # Changes to be committed: # (use \"git reset HEAD ...\" to unstage) # #\tmodified: index.html #\n```\n如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用`git commit`来完成这次合并提交。提交的记录差不多是这样：\n\n```\nMerge branch 'iss53' Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. #\n```\n\n如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。\n\n###3.3  分支的管理\n\n到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。\n\n`git branch`命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：\n\n```\n$ git branch iss53 * master testing\n```\n\n注意看master分支前的*字符：它表示当前所在的分支。也就是说，如果现在提交更新，master分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行`git branch -v`：\n\n```\n$ git branch -v iss53 # 93b412c fix javascript issue * master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes\n```\n\n要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用--merge和--no-merged选项（Git1.5.6以上版本）。比如用`git branch --merge`查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：\n\n```\n$ git branch --merged iss53 * master\n```\n\n之前我们已经合并了iss53，所以在这里会看到它。一般来说，列表中没有*的分支通常都可以用`git branch -d`来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。\n\n另外可以用`git branch --no-merged`查看尚未合并的工作：\n\n```\n$ git branch --no-merged testing\n```\n\n它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用`git branch -d`删除该分支会提示错误，因为那样做会丢失数据：\n\n```\n$ git branch -d # testing error: The branch 'testing' is not an ancestor of your current HEAD. If you are sure you want to delete it, run 'git branch -D testing'.\n```\n\n不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项-D强制执行，就像上面提示信息中给出的那样。\n\n###3.4利用分支进行开发的工作流程\n\n现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。\n\n**长期分支**\n\n由于Git使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。\n\n许多使用Git的开发者都喜欢用这种方式来开展工作，比如仅在master分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop或next的平行分支，专门用于后续的开发，或仅用于稳定性测试—当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master里。这样，在确保这些已完成的特性分支（短期分支，比如之前的iss53分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。\n\n本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图3-18）。\n\n![Git详解之Git分支](resource/2016031118.png)\n\n图3-18.稳定分支总是比较老旧。\n\n或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图3-19）。\n\n![Git详解之Git分支](resource/2016031119.png)\n\n图3-19.想象成流水线可能会容易点。\n\n你可以用这招维护不同层次的稳定性。某些大项目还会有个proposed（建议）或pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next或 master的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。\n\n**特性分支**\n\n在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在Git中，一天之内建立、使用、合并再删除多个分支是常见的事。\n\n我们在上节的例子里已经见过这种用法了。我们创建了iss53和hotfix这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换—因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。\n\n现在我们来看一个实际的例子。请看图3-20，由下往上，起先我们在master工作到C1，然后开始一个新分支iss91尝试修复91号缺陷，提交到C6的时候，又冒出一个解决该问题的新办法，于是从之前C4的地方又分出一个分支iss91v2，干到C8的时候，又回到主干master中提交了C9和C10，再回到iss91v2继续工作，提交C11，接着，又冒出个不太确定的想法，从master的最新提交C10处开了个新的分支dumbidea做些试验。\n\n![Git详解之Git分支](resource/2016031120.png)\n\n图3-20.拥有多个特性分支的提交历史。\n\n现在，假定两件事情：我们最终决定使用第二个解决方案，即iss91v2中的办法；另外，我们把dumbidea分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91分支（实际上会丢弃C5和C6），直接在主干中并入另外两个分支。最终的提交历史将变成图3-21这样：\n\n![Git详解之Git分支](resource/2016031121.png)\n\n图3-21.合并了dumbidea和iss91v2后的分支历史。\n\n请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的Git仓库中进行的—完全不涉及与服务器的交互。\n\n\n###3.5 远程分支\n\n远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在Git进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。\n\n我们用(远程仓库名)/(分支名)这样的形式表示远程分支。比如我们想看看上次同origin仓库通讯时master的样子，就应该查看origin/master分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53分支到远程仓库，虽然你可能也有一个本地的iss53分支，但指向服务器上最新更新的却应该是origin/iss53分支。\n\n可能有点乱，我们不妨举例说明。假设你们团队有个地址为git.ourcompany.com的Git服务器。如果你从这里克隆，Git会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的master分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git建立一个属于你自己的本地master分支，始于origin上master分支相同的位置，你可以就此开始工作（见图3-22）：\n\n![Git详解之Git分支](resource/2016031122.png)\n\n图3-22.一次Git克隆会建立你自己的本地分支master和远程分支origin/master，它们都指向origin/master分支的最后一次提交。\n\n如果你在本地master分支做了些改动，与此同时，其他人向git.ourcompany.com推送了他们的更新，那么服务器上的master分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的origin/master指针仍然保持原位不会移动（见图3-23）。\n\n![Git详解之Git分支](resource/2016031123.png)\n\n图3-23.在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。\n\n可以运行`git fetch origin`来同步远程服务器上的数据到本地。该命令首先找到origin是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把origin/master的指针移到它最新的位置上（见图3-24）。\n\n![Git详解之Git分支](resource/2016031124.png)\n\n图3-24.gitfetch命令会更新remote索引。\n\n为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器git.team1.ourcompany.com。可以用第二章中提到的`git remote add`命令把它加为当前项目的远程分支之一。我们把它命名为teamone，以便代替原始的Git地址（见图3-25）。\n\n![Git详解之Git分支](resource/2016031125.png)\n\n图3-25.把另一个服务器加为远程仓库\n\n现在你可以用`git fetch teamone`来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你origin服务器上的子集，Git不会下载任何数据，而只是简单地创建一个名为teamone/master的分支，指向teamone服务器上master分支所在的提交对象31b8e（见图3-26）。\n\n![Git详解之Git分支](resource/2016031126.png)\n\n图3-26.你在本地有了一个指向teamone服务器上master分支的索引。\n\n**推送本地分支**\n\n要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。\n\n如果你有个叫serverfix的分支需要和他人一起开发，可以运行`git push(远程仓库名) (分支名)`：\n\n```\n$ git push origin serverfix \n\nCounting objects: 20, done. \nCompressing objects: 100% (14/14), done. \nWriting objects: 100% (15/15), 1.74 KiB, done. \nTotal 15 (delta 5), reused 0 (delta 0) \nTo git@github.com:schacon/simplegit.git \n* [new branch] serverfix -> serverfix\n```\n\n这其实有点像条捷径。Git自动把serverfix分支名扩展为refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的serverfix分支，推送到远程仓库的serverfix分支中去”。我们将在第九章进一步介绍refs/heads/部分的细节，不过一般使用的时候都可以省略它。也可以运行`git push origin serverfix:serferfix`来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用`git push origin serverfix:awesomebranch`来推送数据。\n\n接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支origin/serverfix：\n\n```\n$ git fetch origin \n\nremote: Counting \nobjects: 20, done. \nremote: Compressing \nobjects: 100% (14/14), done. \nremote: Total 15 (delta 5), reused 0 (delta 0) \nUnpacking objects: 100% (15/15), done. \nFrom git@github.com:schacon/simplegit \n* [new branch] serverfix -> origin/serverfix\n```\n\n值得注意的是，在fetch操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix分支，有的只是一个你无法移动的origin/serverfix指针。\n\n如果要把该内容合并到当前分支，可以运行`git merge origin/serverfix`。如果想要一份自己的serverfix来开发，可以在远程分支的基础上分化出一个新的分支来：\n\n```\n$ git checkout -b serverfix origin/serverfix \n\nBranch serverfix set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"serverfix\"\n```\n这会切换到新建的serverfix本地分支，其内容同远程分支origin/serverfix一致，这样你就可以在里面继续开发了。\n\n**跟踪远程分支**\n\n从远程分支checkout出来的本地分支，称为_跟踪分支(tracking branch)_。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入`git push`，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行`git pull`会获取所有远程索引，并把它们的数据都合并到本地分支中来。\n\n在克隆仓库时，Git通常会自动创建一个名为master的分支来跟踪origin/master。这正是`git push`和`git pull`一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin上除了master之外的其它分支。刚才我们已经看到了这样的一个例子：`git checkout -b [分支名] [远程名]/[分支名]`。如果你有1.6.2以上版本的Git，还可以用--track选项简化：\n\n```\n$ git checkout --track origin/serverfix \n\nBranch serverfix set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"serverfix\"\n```\n\n要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：\n\n```\n$ git checkout -b sf origin/serverfix \n\nBranch sf set up to track remote branch refs/remotes/origin/serverfix. \nSwitched to a new branch \"sf\"\n```\n\n现在你的本地分支sf会自动向origin/serverfix推送和抓取数据了。\n\n**删除远程分支**\n\n如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的master分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：`git push [远程名] :[分支名]`。如果想在服务器上删除serverfix 分支，运行下面的命令：\n\n```\n$ git push origin:serverfix \n\nTo git@github.com:schacon/simplegit.git - [deleted] serverfix\n```\n\n咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 `git push [远程名] [本地分支]:[远程分支]` 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。\n\n###3.6  分支的衍合\n\n把一个分支整合到另一个分支的办法有两种：merge和rebase（译注：rebase的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。\n\n基本的衍合操作\n请回顾之前有关合并的一节（见图3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。\n\n![Git详解之Git分支](resource/2016031127.png)\n\n图3-27.最初分叉的提交历史。\n\n之前介绍过，最容易的整合分支的方法是merge命令，它会把两个分支最新的快照（C3和C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图3-28所示：\n\n![Git详解之Git分支](resource/2016031128.png)\n\n图3-28.通过合并一个分支来整合分叉了的历史。\n其实，还有另外一个选择：你可以把在C3里产生的变化补丁在C4的基础上重新打一遍。在Git里，这种操作叫做_衍合（rebase）_。有了rebase命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。\n\n在上面这个例子中，运行：\n\n```\n$ git checkout experiment \n$ git rebase master \n\nFirst, rewinding head to replay your work on top of it... Applying: added staged command\n```\n\n它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支experiment）后续的历次提交对象（这里只有一个C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写experiment的提交历史，使它成为master分支的直接下游，如图3-29所示：\n\n![Git详解之Git分支](resource/2016031129.png)\n\n图3-29.把C3里产生的改变到C4上重演一遍。\n\n现在回到master分支，进行一次快进合并（见图3-30）：\n\n![Git详解之Git分支](resource/2016031130.png)\n\n图3-30.master分支的快进。\n\n现在的C3’对应的快照，其实和普通的三方合并，即上个例子中的C5对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\n\n一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁—比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。\n\n请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。\n\n**有趣的衍合**\n\n衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图3-31的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支server，然后提交C3和C4。然后又从C3的地方再增加一个client分支来对客户端代码进行一些相应修改，所以提交了C8和C9。最后，又回到server分支提交了C10。\n\n![Git详解之Git分支](resource/2016031131.png)\n\n图3-31.从一个特性分支里再分出一个特性分支的历史。\n\n假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于server分支而非master分支的改变（即C8和C9），跳过server直接放到master分支中重演一遍，但这需要用git rebase的--onto选项指定新的基底分支master：\n\n```\n$ git rebase --onto master server client\n```\n\n这好比在说：“取出client分支，找出client分支和server分支的共同祖先之后的变化，然后把它们在master上重演一遍”。是不是有点复杂？不过它的结果如图3-32所示，非常酷（译注：虽然client里的C8,C9在C3之后，但这仅表明时间上的先后，而非在C3修改的基础上进一步改动，因为server和client这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在C3时间点之后，对另外的文件所做的C8，C9修改，放到主干重演。）：\n\n![Git详解之Git分支](resource/2016031132.png)\n\n图3-32.将特性分支上的另一个特性分支衍合到其他分支。\n\n现在可以快进master分支了（见图3-33）：\n\n```\n$ git checkout master $ git merge client\n```\n\n![Git详解之Git分支](resource/2016031133.png)\n\n图3-33.快进master分支，使之包含client分支的变化。\n\n现在我们决定把server分支的变化也包含进来。我们可以直接把server分支衍合到master，而不用手工切换到server分支后再执行衍合操作`git rebase [主分支] [特性分支]`命令会先取出特性分支server，然后在主分支master上重演：\n\n```\n$ git rebase master server\n```\n\n于是，server的进度应用到master的基础上，如图3-34所示：\n\n![Git详解之Git分支](resource/2016031134.png)\n\n图3-34.在master分支上衍合server分支。\n\n然后就可以快进主干分支master了：\n\n```\n$ git checkout master $ git merge server\n```\n\n现在client和server分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图3-35的样子：\n\n```\n$ git branch -d client $ git branch -d server\n```\n\n![Git详解之Git分支](resource/2016031135.png) \n\n图3-35.最终的提交历史\n\n**衍合的风险**\n\n呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：\n\n**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。**\n\n如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。\n\n下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图3-36所示：\n\n![Git详解之Git分支](resource/2016031136.png)\n\n图3-36.克隆一个仓库，在其基础上工作一番。\n\n现在，某人在C1的基础上做了些改变，并合并他自己的分支得到结果C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果C7，历史提交会变成图3-37这样：\n\n![Git详解之Git分支](resource/2016031137.png)\n\n图3-37.抓取他人提交，并入自己主干。\n\n接下来，那个推送C6上来的人决定用衍合取代之前的合并操作；继而又用git push --force覆盖了服务器上的历史，得到C4’。而之后当你再从服务器上下载最新提交后，会得到：\n\n![Git详解之Git分支](resource/2016031138.png)\n\n图3-38.有人推送了衍合后得到的C4’，丢弃了你作为开发基础的C4和C6。\n\n下载更新后需要合并，但此时衍合产生的提交对象C4’的SHA-1校验值和之前C4完全不同，所以Git会把它们当作新的提交对象处理，而实际上此刻你的提交历史C7中早已经包含了C4的修改内容，于是合并操作会把C7和C4’合并为C8（见图3-39）:\n\n![Git详解之Git分支](resource/2016031139.png)\n\n图3-39.你把相同的内容又合并了一遍，生成一个新的提交C8。\n\nC8这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在C8之后，你的提交历史里就会同时包含C4和C4’，两者有着不同的SHA-1校验值，如果用git log查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了C6后又用衍合发布C4’的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。\n\n如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。\n\n###3.7小结\n\n读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。","slug":"Git详解之Git分支","published":1,"updated":"2016-08-17T06:22:19.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpii001868ddbvu5zj57","content":"<p>这篇文章对Git分支讲的很详实，很好，推荐给大家，也整理出来给自己学习之用。</p>\n<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>\n<p>有人把Git的分支模型称为“必杀技特性”，而正是因为它，将Git从版本控制系统家族里区分出来。Git有何特别之处呢？Git的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>\n<p>###3.1何谓分支</p>\n<p>为了理解Git分支的实现方式，我们需要回顾一下Git是如何储存数据的。或许你还记得第一章的内容，Git保存的不是文件差异或者变化量，而只是一系列文件快照。</p>\n<p>在Git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>\n<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的SHA-1哈希字串），然后把当前版本的文件快照保存到Git仓库中（Git使用blob类型的对象存储这些快照），并将校验和加入暂存区域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git add README test.rb LICENSE</div><div class=\"line\">$ git commit -m &apos;initial commit of my project&apos;</div></pre></td></tr></table></figure>\n<p>当使用gitcommit新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在Git仓库中将这些目录保存为树（tree）对象。之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>\n<p>现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象；一个记录着目录树内容及其中各个文件对应blob对象索引的tree对象；以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图3-1所示：</p>\n<p><img src=\"resource/2016031101.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-1.单个提交对象在仓库中的数据结构</p>\n<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的parent对象）。两次提交后，仓库历史会变成图3-2的样子：</p>\n<p><img src=\"resource/2016031102.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-2.多个提交对象之间的链接关系</p>\n<p>现在来谈分支。Git中的分支，其实本质上仅仅是个指向commit对象的可变指针。Git会使用master作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的master分支，它在每次提交的时候都会自动向前移动。</p>\n<p><img src=\"resource/2016031103.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-3.分支其实就是从某个提交对象往回看的历史</p>\n<p>那么，Git又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个testing 分支，可以使用<code>git branch</code>命令：</p>\n<p><code>$ git branch testing</code></p>\n<p>这会在当前commit对象上新建一个分支指针（见图3-4）。</p>\n<p><img src=\"resource/2016031104.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-4.多个分支指向提交数据的历史</p>\n<p>那么，Git是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为HEAD的特别指针。请注意它和你熟知的许多其他版本控制系统（比如Subversion或CVS）里的HEAD概念大不相同。在Git中，它是一个指向你正在工作中的本地分支的指针（译注：将HEAD想象为当前分支的别名。）。运行<code>git branch</code>命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在master分支里工作（参考图3-5）。</p>\n<p><img src=\"resource/2016031105.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-5.HEAD指向当前所在的分支</p>\n<p>要切换到其他分支，可以执行<code>git checkout</code>命令。我们现在转换到新建的testing分支：</p>\n<p><code>$ git checkout testing</code></p>\n<p>这样HEAD就指向了testing分支（见图3-6）。</p>\n<p><img src=\"resource/2016031106.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-6.HEAD在你转换分支时指向新的分支</p>\n<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p>\n<p><code>$ vim test.rb $ git commit -a -m &#39;made a change&#39;</code></p>\n<p>图3-7展示了提交后的结果。</p>\n<p><img src=\"resource/2016031107.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-7.每次提交后HEAD随着分支一起向前移动</p>\n<p>非常有趣，现在testing分支向前移动了一格，而master分支仍然指向原先<code>git checkout</code>时所在的commit对象。现在我们回到master分支看看：</p>\n<p><code>$ git checkout master</code></p>\n<p>图3-8显示了结果。</p>\n<p><img src=\"resource/2016031108.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-8.HEAD在一次checkout之后移动到了另一个分支</p>\n<p>这条命令做了两件事。它把HEAD指针移回到master分支，并把工作目录中的文件换成了master分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将testing分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>\n<p>我们作些修改后再次提交：</p>\n<p><code>$ vim test.rb $ git commit -a -m &#39;made other changes&#39;</code></p>\n<p>现在我们的项目提交历史产生了分叉（如图3-9所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch和checkout这两条命令就可以完成。</p>\n<p><img src=\"resource/2016031109.png\" alt=\"Git详解之Git分支\"></p>\n<p>图 3-9.不同流向的分支历史</p>\n<p>由于Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（外加一个换行符）那么简单，当然也就很快了。</p>\n<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>\n<p>接下来看看，我们为什么应该频繁使用分支。</p>\n<p>###3.2分支的新建与合并</p>\n<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>\n<p>1.开发某个网站。<br>2.为实现某个新的需求，创建一个分支。<br>3.在这个分支上开展工作。</p>\n<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>\n<p>1.返回到原先已经发布到生产服务器上的分支。<br>2.为这次紧急修补建立一个新分支，并在其中修复问题。<br>3.通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。<br>4.切换到之前实现新需求的分支，继续工作。</p>\n<p><strong>分支的新建与切换</strong></p>\n<p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图3-10）。</p>\n<p><img src=\"resource/2016031110.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-10.一个简短的提交历史</p>\n<p>现在，你决定要修补问题追踪系统上的#53问题。顺带说明下，Git并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为iss53。要新建并切换到该分支，运行gitcheckout并加上-b参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b iss53 # Switched to a new branch &quot;iss53&quot;</div></pre></td></tr></table></figure>\n<p>这相当于执行下面这两条命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch iss53</div><div class=\"line\">$ git checkout iss53</div></pre></td></tr></table></figure>\n<p>图3-11示意该命令的执行结果。</p>\n<p><img src=\"resource/2016031111.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-11.创建了一个新分支的指针</p>\n<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的HEAD指针正指向iss53，见图3-12）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031112.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-12.iss53分支随工作进展向前推进</p>\n<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了Git，我们就不需要同时发布这个补丁和iss53里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master分支。</p>\n<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止Git为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做stashing和commitamending）。目前已经提交了所有的修改，所以接下来可以正常转换到master分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master # Switched to branch &quot;master&quot;</div></pre></td></tr></table></figure>\n<p>此时工作目录中的内容和你在解决问题#53之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>\n<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支hotfix来开展工作，直到搞定（见图3-13）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b &apos;hotfix&apos; # Switched to a new branch &quot;hotfix&quot; </div><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;fixed the broken email address&apos; </div><div class=\"line\"></div><div class=\"line\">[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot; </div><div class=\"line\">1 files changed, 0 insertions(+), 1 deletions(-)</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031113.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-13.hotfix分支是从master分支所在点分化出来的</p>\n<p>有必要作些测试，确保修补是成功的，然后回到master分支并把它合并进来，然后发布到生产服务器。用<code>gitmerge</code>命令来进行合并：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master </div><div class=\"line\">$ git merge hotfix </div><div class=\"line\"></div><div class=\"line\">Updating f42c576..3a0874c </div><div class=\"line\">Fast forward </div><div class=\"line\">README | 1 - 1 files changed, 0 insertions(+), 1 deletions(-)</div></pre></td></tr></table></figure>\n<p>请注意，合并时出现了“Fast forward”的提示。由于当前master分支所在的提交对象是要并入的hotfix分支的直接上游，Git只需把master分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>\n<p>现在最新的修改已经在当前master分支所指向的提交对象中了，可以部署到生产服务器上去了（见图3-14）。</p>\n<p><img src=\"resource/2016031114.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-14.合并之后，master分支和hotfix分支指向同一位置。</p>\n<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前hotfix分支和master都指向相同的提交对象，所以hotfix已经完成了历史使命，可以删掉了。使用<code>git branch</code>的 -d 选项执行删除操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d hotfix Deleted branch hotfix (3a0874c).</div></pre></td></tr></table></figure>\n<p>现在回到之前未完成的#53问题修复分支上继续工作（图3-15）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout iss53 # Switched to branch &quot;iss53&quot; </div><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;finished the new footer [issue 53]&apos; </div><div class=\"line\"></div><div class=\"line\">[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot; </div><div class=\"line\">1 files changed, 1 insertions(+), 0 deletions(-)</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031115.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-15.iss53分支可以不受影响继续推进。</p>\n<p>不用担心之前hotfix分支的修改内容尚未包含到iss53中来。如果确实需要纳入此次修补，可以用<code>git merge master</code>把master分支合并到iss53；或者等iss53完成之后，再将iss53分支中的更新并入master。</p>\n<p><strong>分支的合并</strong></p>\n<p>在问题#53相关的工作完成之后，可以合并回master分支。实际操作同前面合并hotfix分支差不多，只需回到master分支，运行<code>git merge</code>命令指定要合并进来的分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master </div><div class=\"line\">$ git merge iss53 # Merge made by recursive. </div><div class=\"line\"></div><div class=\"line\">README | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)</div></pre></td></tr></table></figure>\n<p>请注意，这次合并操作的底层实现，并不同于之前hotfix的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前master分支所指向的提交对象（C4）并不是iss53分支的直接祖先，Git不得不进行一些额外处理。就此例而言，Git会用两个分支的末端（C4和C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图3-16用红框标出了Git用于合并的三个提交对象：</p>\n<p><img src=\"resource/2016031116.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-16.Git为分支合并自动识别出最佳的同源合并点。</p>\n<p>这次，Git没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图3-17）。这个提交对象比较特殊，它有两个祖先（C4和C5）。</p>\n<p>值得一提的是Git可以自己裁决哪个共同祖先才是最佳合并基础；这和CVS或Subversion（1.5以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让Git的合并操作比其他系统都要简单不少。</p>\n<p><img src=\"resource/2016031117.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-17.Git自动创建了一个包含了合并结果的提交对象。</p>\n<p>既然之前的工作成果已经合并到master了，那么iss53也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d iss53</div></pre></td></tr></table></figure>\n<p><strong>遇到冲突时的分支合并</strong></p>\n<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题#53的过程中修改了hotfix中修改的部分，将得到类似下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git merge iss53 #Auto-merging index.html </div><div class=\"line\"></div><div class=\"line\">CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>\n<p>Git作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用<code>git status</code>查阅：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[master*]$ git status </div><div class=\"line\"># index.html: needs merge </div><div class=\"line\"># On branch master </div><div class=\"line\"># Changed but not updated: </div><div class=\"line\"># (use &quot;git add ...&quot; to update what will be committed) </div><div class=\"line\"># (use &quot;git checkout -- ...&quot; to discard changes in working directory) # </div><div class=\"line\"># unmerged: index.html #</div></pre></td></tr></table></figure>\n<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</div><div class=\"line\">contact : email.support@github.com</div><div class=\"line\">=======</div><div class=\"line\">please contact us at support@github.com</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</div></pre></td></tr></table></figure>\n<p>可以看到=======隔开的上半部分，是HEAD（即master分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在iss53分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">please contact us at email.support@github.com</div></pre></td></tr></table></figure>\n<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行。在解决了所有文件里的所有冲突后，运行<code>git add</code>将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行<code>git mergetool</code>，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git mergetool #merge tool </div><div class=\"line\"></div><div class=\"line\">candidates: kdiff3 </div><div class=\"line\">\t\t\ttkdiff</div><div class=\"line\">\t\t\txxdiff </div><div class=\"line\">\t\t\tmeld </div><div class=\"line\">\t\t\tgvimdiff </div><div class=\"line\">\t\t\topendiff </div><div class=\"line\">\t\t\temerge </div><div class=\"line\">\t\t\tvimdiff </div><div class=\"line\">Merging the files: index.html Normal merge conflict for &apos;index.html&apos;: &#123;local&#125;: modified &#123;remote&#125;: modified Hit return to start merge resolution tool (opendiff):</div></pre></td></tr></table></figure>\n<p>如果不想用默认的合并工具（Git为我默认选择了opendiff，因为我在Mac上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>\n<p>退出合并工具以后，Git会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>\n<p>再运行一次git status来确认所有冲突都已解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD ...&quot; to unstage) # #\tmodified: index.html #</div></pre></td></tr></table></figure>\n<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用<code>git commit</code>来完成这次合并提交。提交的记录差不多是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Merge branch &apos;iss53&apos; Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. #</div></pre></td></tr></table></figure>\n<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>\n<p>###3.3  分支的管理</p>\n<p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。</p>\n<p><code>git branch</code>命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch iss53 * master testing</div></pre></td></tr></table></figure>\n<p>注意看master分支前的*字符：它表示当前所在的分支。也就是说，如果现在提交更新，master分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行<code>git branch -v</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -v iss53 # 93b412c fix javascript issue * master 7a98805 Merge branch &apos;iss53&apos; testing 782fd34 add scott to the author list in the readmes</div></pre></td></tr></table></figure>\n<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用–merge和–no-merged选项（Git1.5.6以上版本）。比如用<code>git branch --merge</code>查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch --merged iss53 * master</div></pre></td></tr></table></figure>\n<p>之前我们已经合并了iss53，所以在这里会看到它。一般来说，列表中没有*的分支通常都可以用<code>git branch -d</code>来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p>\n<p>另外可以用<code>git branch --no-merged</code>查看尚未合并的工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch --no-merged testing</div></pre></td></tr></table></figure>\n<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用<code>git branch -d</code>删除该分支会提示错误，因为那样做会丢失数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d # testing error: The branch &apos;testing&apos; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &apos;git branch -D testing&apos;.</div></pre></td></tr></table></figure>\n<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项-D强制执行，就像上面提示信息中给出的那样。</p>\n<p>###3.4利用分支进行开发的工作流程</p>\n<p>现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。</p>\n<p><strong>长期分支</strong></p>\n<p>由于Git使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p>\n<p>许多使用Git的开发者都喜欢用这种方式来开展工作，比如仅在master分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop或next的平行分支，专门用于后续的开发，或仅用于稳定性测试—当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master里。这样，在确保这些已完成的特性分支（短期分支，比如之前的iss53分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。</p>\n<p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图3-18）。</p>\n<p><img src=\"resource/2016031118.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-18.稳定分支总是比较老旧。</p>\n<p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图3-19）。</p>\n<p><img src=\"resource/2016031119.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-19.想象成流水线可能会容易点。</p>\n<p>你可以用这招维护不同层次的稳定性。某些大项目还会有个proposed（建议）或pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next或 master的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>\n<p><strong>特性分支</strong></p>\n<p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在Git中，一天之内建立、使用、合并再删除多个分支是常见的事。</p>\n<p>我们在上节的例子里已经见过这种用法了。我们创建了iss53和hotfix这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换—因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p>\n<p>现在我们来看一个实际的例子。请看图3-20，由下往上，起先我们在master工作到C1，然后开始一个新分支iss91尝试修复91号缺陷，提交到C6的时候，又冒出一个解决该问题的新办法，于是从之前C4的地方又分出一个分支iss91v2，干到C8的时候，又回到主干master中提交了C9和C10，再回到iss91v2继续工作，提交C11，接着，又冒出个不太确定的想法，从master的最新提交C10处开了个新的分支dumbidea做些试验。</p>\n<p><img src=\"resource/2016031120.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-20.拥有多个特性分支的提交历史。</p>\n<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即iss91v2中的办法；另外，我们把dumbidea分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91分支（实际上会丢弃C5和C6），直接在主干中并入另外两个分支。最终的提交历史将变成图3-21这样：</p>\n<p><img src=\"resource/2016031121.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-21.合并了dumbidea和iss91v2后的分支历史。</p>\n<p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的Git仓库中进行的—完全不涉及与服务器的交互。</p>\n<p>###3.5 远程分支</p>\n<p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在Git进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>\n<p>我们用(远程仓库名)/(分支名)这样的形式表示远程分支。比如我们想看看上次同origin仓库通讯时master的样子，就应该查看origin/master分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53分支到远程仓库，虽然你可能也有一个本地的iss53分支，但指向服务器上最新更新的却应该是origin/iss53分支。</p>\n<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为git.ourcompany.com的Git服务器。如果你从这里克隆，Git会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的master分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git建立一个属于你自己的本地master分支，始于origin上master分支相同的位置，你可以就此开始工作（见图3-22）：</p>\n<p><img src=\"resource/2016031122.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-22.一次Git克隆会建立你自己的本地分支master和远程分支origin/master，它们都指向origin/master分支的最后一次提交。</p>\n<p>如果你在本地master分支做了些改动，与此同时，其他人向git.ourcompany.com推送了他们的更新，那么服务器上的master分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的origin/master指针仍然保持原位不会移动（见图3-23）。</p>\n<p><img src=\"resource/2016031123.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-23.在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。</p>\n<p>可以运行<code>git fetch origin</code>来同步远程服务器上的数据到本地。该命令首先找到origin是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把origin/master的指针移到它最新的位置上（见图3-24）。</p>\n<p><img src=\"resource/2016031124.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-24.gitfetch命令会更新remote索引。</p>\n<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器git.team1.ourcompany.com。可以用第二章中提到的<code>git remote add</code>命令把它加为当前项目的远程分支之一。我们把它命名为teamone，以便代替原始的Git地址（见图3-25）。</p>\n<p><img src=\"resource/2016031125.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-25.把另一个服务器加为远程仓库</p>\n<p>现在你可以用<code>git fetch teamone</code>来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你origin服务器上的子集，Git不会下载任何数据，而只是简单地创建一个名为teamone/master的分支，指向teamone服务器上master分支所在的提交对象31b8e（见图3-26）。</p>\n<p><img src=\"resource/2016031126.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-26.你在本地有了一个指向teamone服务器上master分支的索引。</p>\n<p><strong>推送本地分支</strong></p>\n<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>\n<p>如果你有个叫serverfix的分支需要和他人一起开发，可以运行<code>git push(远程仓库名) (分支名)</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git push origin serverfix </div><div class=\"line\"></div><div class=\"line\">Counting objects: 20, done. </div><div class=\"line\">Compressing objects: 100% (14/14), done. </div><div class=\"line\">Writing objects: 100% (15/15), 1.74 KiB, done. </div><div class=\"line\">Total 15 (delta 5), reused 0 (delta 0) </div><div class=\"line\">To git@github.com:schacon/simplegit.git </div><div class=\"line\">* [new branch] serverfix -&gt; serverfix</div></pre></td></tr></table></figure>\n<p>这其实有点像条捷径。Git自动把serverfix分支名扩展为refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的serverfix分支，推送到远程仓库的serverfix分支中去”。我们将在第九章进一步介绍refs/heads/部分的细节，不过一般使用的时候都可以省略它。也可以运行<code>git push origin serverfix:serferfix</code>来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用<code>git push origin serverfix:awesomebranch</code>来推送数据。</p>\n<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支origin/serverfix：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git fetch origin </div><div class=\"line\"></div><div class=\"line\">remote: Counting </div><div class=\"line\">objects: 20, done. </div><div class=\"line\">remote: Compressing </div><div class=\"line\">objects: 100% (14/14), done. </div><div class=\"line\">remote: Total 15 (delta 5), reused 0 (delta 0) </div><div class=\"line\">Unpacking objects: 100% (15/15), done. </div><div class=\"line\">From git@github.com:schacon/simplegit </div><div class=\"line\">* [new branch] serverfix -&gt; origin/serverfix</div></pre></td></tr></table></figure>\n<p>值得注意的是，在fetch操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix分支，有的只是一个你无法移动的origin/serverfix指针。</p>\n<p>如果要把该内容合并到当前分支，可以运行<code>git merge origin/serverfix</code>。如果想要一份自己的serverfix来开发，可以在远程分支的基础上分化出一个新的分支来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b serverfix origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;serverfix&quot;</div></pre></td></tr></table></figure>\n<p>这会切换到新建的serverfix本地分支，其内容同远程分支origin/serverfix一致，这样你就可以在里面继续开发了。</p>\n<p><strong>跟踪远程分支</strong></p>\n<p>从远程分支checkout出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入<code>git push</code>，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行<code>git pull</code>会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>\n<p>在克隆仓库时，Git通常会自动创建一个名为master的分支来跟踪origin/master。这正是<code>git push</code>和<code>git pull</code>一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin上除了master之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有1.6.2以上版本的Git，还可以用–track选项简化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout --track origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;serverfix&quot;</div></pre></td></tr></table></figure>\n<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b sf origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch sf set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;sf&quot;</div></pre></td></tr></table></figure>\n<p>现在你的本地分支sf会自动向origin/serverfix推送和抓取数据了。</p>\n<p><strong>删除远程分支</strong></p>\n<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的master分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除serverfix 分支，运行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git push origin:serverfix </div><div class=\"line\"></div><div class=\"line\">To git@github.com:schacon/simplegit.git - [deleted] serverfix</div></pre></td></tr></table></figure>\n<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>\n<p>###3.6  分支的衍合</p>\n<p>把一个分支整合到另一个分支的办法有两种：merge和rebase（译注：rebase的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>\n<p>基本的衍合操作<br>请回顾之前有关合并的一节（见图3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p>\n<p><img src=\"resource/2016031127.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-27.最初分叉的提交历史。</p>\n<p>之前介绍过，最容易的整合分支的方法是merge命令，它会把两个分支最新的快照（C3和C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图3-28所示：</p>\n<p><img src=\"resource/2016031128.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-28.通过合并一个分支来整合分叉了的历史。<br>其实，还有另外一个选择：你可以把在C3里产生的变化补丁在C4的基础上重新打一遍。在Git里，这种操作叫做<em>衍合（rebase）</em>。有了rebase命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>\n<p>在上面这个例子中，运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout experiment </div><div class=\"line\">$ git rebase master </div><div class=\"line\"></div><div class=\"line\">First, rewinding head to replay your work on top of it... Applying: added staged command</div></pre></td></tr></table></figure>\n<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支experiment）后续的历次提交对象（这里只有一个C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写experiment的提交历史，使它成为master分支的直接下游，如图3-29所示：</p>\n<p><img src=\"resource/2016031129.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-29.把C3里产生的改变到C4上重演一遍。</p>\n<p>现在回到master分支，进行一次快进合并（见图3-30）：</p>\n<p><img src=\"resource/2016031130.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-30.master分支的快进。</p>\n<p>现在的C3’对应的快照，其实和普通的三方合并，即上个例子中的C5对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>\n<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁—比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>\n<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>\n<p><strong>有趣的衍合</strong></p>\n<p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图3-31的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支server，然后提交C3和C4。然后又从C3的地方再增加一个client分支来对客户端代码进行一些相应修改，所以提交了C8和C9。最后，又回到server分支提交了C10。</p>\n<p><img src=\"resource/2016031131.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-31.从一个特性分支里再分出一个特性分支的历史。</p>\n<p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于server分支而非master分支的改变（即C8和C9），跳过server直接放到master分支中重演一遍，但这需要用git rebase的–onto选项指定新的基底分支master：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git rebase --onto master server client</div></pre></td></tr></table></figure>\n<p>这好比在说：“取出client分支，找出client分支和server分支的共同祖先之后的变化，然后把它们在master上重演一遍”。是不是有点复杂？不过它的结果如图3-32所示，非常酷（译注：虽然client里的C8,C9在C3之后，但这仅表明时间上的先后，而非在C3修改的基础上进一步改动，因为server和client这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在C3时间点之后，对另外的文件所做的C8，C9修改，放到主干重演。）：</p>\n<p><img src=\"resource/2016031132.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-32.将特性分支上的另一个特性分支衍合到其他分支。</p>\n<p>现在可以快进master分支了（见图3-33）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master $ git merge client</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031133.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-33.快进master分支，使之包含client分支的变化。</p>\n<p>现在我们决定把server分支的变化也包含进来。我们可以直接把server分支衍合到master，而不用手工切换到server分支后再执行衍合操作<code>git rebase [主分支] [特性分支]</code>命令会先取出特性分支server，然后在主分支master上重演：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git rebase master server</div></pre></td></tr></table></figure>\n<p>于是，server的进度应用到master的基础上，如图3-34所示：</p>\n<p><img src=\"resource/2016031134.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-34.在master分支上衍合server分支。</p>\n<p>然后就可以快进主干分支master了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master $ git merge server</div></pre></td></tr></table></figure>\n<p>现在client和server分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图3-35的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d client $ git branch -d server</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031135.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-35.最终的提交历史</p>\n<p><strong>衍合的风险</strong></p>\n<p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>\n<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>\n<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>\n<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>\n<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图3-36所示：</p>\n<p><img src=\"resource/2016031136.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-36.克隆一个仓库，在其基础上工作一番。</p>\n<p>现在，某人在C1的基础上做了些改变，并合并他自己的分支得到结果C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果C7，历史提交会变成图3-37这样：</p>\n<p><img src=\"resource/2016031137.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-37.抓取他人提交，并入自己主干。</p>\n<p>接下来，那个推送C6上来的人决定用衍合取代之前的合并操作；继而又用git push –force覆盖了服务器上的历史，得到C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>\n<p><img src=\"resource/2016031138.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-38.有人推送了衍合后得到的C4’，丢弃了你作为开发基础的C4和C6。</p>\n<p>下载更新后需要合并，但此时衍合产生的提交对象C4’的SHA-1校验值和之前C4完全不同，所以Git会把它们当作新的提交对象处理，而实际上此刻你的提交历史C7中早已经包含了C4的修改内容，于是合并操作会把C7和C4’合并为C8（见图3-39）:</p>\n<p><img src=\"resource/2016031139.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-39.你把相同的内容又合并了一遍，生成一个新的提交C8。</p>\n<p>C8这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在C8之后，你的提交历史里就会同时包含C4和C4’，两者有着不同的SHA-1校验值，如果用git log查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了C6后又用衍合发布C4’的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>\n<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>\n<p>###3.7小结</p>\n<p>读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。</p>\n","excerpt":"","more":"<p>这篇文章对Git分支讲的很详实，很好，推荐给大家，也整理出来给自己学习之用。</p>\n<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>\n<p>有人把Git的分支模型称为“必杀技特性”，而正是因为它，将Git从版本控制系统家族里区分出来。Git有何特别之处呢？Git的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>\n<p>###3.1何谓分支</p>\n<p>为了理解Git分支的实现方式，我们需要回顾一下Git是如何储存数据的。或许你还记得第一章的内容，Git保存的不是文件差异或者变化量，而只是一系列文件快照。</p>\n<p>在Git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>\n<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的SHA-1哈希字串），然后把当前版本的文件快照保存到Git仓库中（Git使用blob类型的对象存储这些快照），并将校验和加入暂存区域：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git add README test.rb LICENSE</div><div class=\"line\">$ git commit -m &apos;initial commit of my project&apos;</div></pre></td></tr></table></figure>\n<p>当使用gitcommit新建一个提交对象前，Git会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在Git仓库中将这些目录保存为树（tree）对象。之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>\n<p>现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象；一个记录着目录树内容及其中各个文件对应blob对象索引的tree对象；以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图3-1所示：</p>\n<p><img src=\"resource/2016031101.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-1.单个提交对象在仓库中的数据结构</p>\n<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的parent对象）。两次提交后，仓库历史会变成图3-2的样子：</p>\n<p><img src=\"resource/2016031102.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-2.多个提交对象之间的链接关系</p>\n<p>现在来谈分支。Git中的分支，其实本质上仅仅是个指向commit对象的可变指针。Git会使用master作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的master分支，它在每次提交的时候都会自动向前移动。</p>\n<p><img src=\"resource/2016031103.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-3.分支其实就是从某个提交对象往回看的历史</p>\n<p>那么，Git又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个testing 分支，可以使用<code>git branch</code>命令：</p>\n<p><code>$ git branch testing</code></p>\n<p>这会在当前commit对象上新建一个分支指针（见图3-4）。</p>\n<p><img src=\"resource/2016031104.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-4.多个分支指向提交数据的历史</p>\n<p>那么，Git是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为HEAD的特别指针。请注意它和你熟知的许多其他版本控制系统（比如Subversion或CVS）里的HEAD概念大不相同。在Git中，它是一个指向你正在工作中的本地分支的指针（译注：将HEAD想象为当前分支的别名。）。运行<code>git branch</code>命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在master分支里工作（参考图3-5）。</p>\n<p><img src=\"resource/2016031105.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-5.HEAD指向当前所在的分支</p>\n<p>要切换到其他分支，可以执行<code>git checkout</code>命令。我们现在转换到新建的testing分支：</p>\n<p><code>$ git checkout testing</code></p>\n<p>这样HEAD就指向了testing分支（见图3-6）。</p>\n<p><img src=\"resource/2016031106.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-6.HEAD在你转换分支时指向新的分支</p>\n<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p>\n<p><code>$ vim test.rb $ git commit -a -m &#39;made a change&#39;</code></p>\n<p>图3-7展示了提交后的结果。</p>\n<p><img src=\"resource/2016031107.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-7.每次提交后HEAD随着分支一起向前移动</p>\n<p>非常有趣，现在testing分支向前移动了一格，而master分支仍然指向原先<code>git checkout</code>时所在的commit对象。现在我们回到master分支看看：</p>\n<p><code>$ git checkout master</code></p>\n<p>图3-8显示了结果。</p>\n<p><img src=\"resource/2016031108.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-8.HEAD在一次checkout之后移动到了另一个分支</p>\n<p>这条命令做了两件事。它把HEAD指针移回到master分支，并把工作目录中的文件换成了master分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将testing分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>\n<p>我们作些修改后再次提交：</p>\n<p><code>$ vim test.rb $ git commit -a -m &#39;made other changes&#39;</code></p>\n<p>现在我们的项目提交历史产生了分叉（如图3-9所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch和checkout这两条命令就可以完成。</p>\n<p><img src=\"resource/2016031109.png\" alt=\"Git详解之Git分支\"></p>\n<p>图 3-9.不同流向的分支历史</p>\n<p>由于Git中的分支实际上仅是一个包含所指对象校验和（40个字符长度SHA-1字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入41个字节（外加一个换行符）那么简单，当然也就很快了。</p>\n<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间也会有相当大的差别，快则几秒，慢则数分钟。而Git的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>\n<p>接下来看看，我们为什么应该频繁使用分支。</p>\n<p>###3.2分支的新建与合并</p>\n<p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>\n<p>1.开发某个网站。<br>2.为实现某个新的需求，创建一个分支。<br>3.在这个分支上开展工作。</p>\n<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>\n<p>1.返回到原先已经发布到生产服务器上的分支。<br>2.为这次紧急修补建立一个新分支，并在其中修复问题。<br>3.通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。<br>4.切换到之前实现新需求的分支，继续工作。</p>\n<p><strong>分支的新建与切换</strong></p>\n<p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新（见图3-10）。</p>\n<p><img src=\"resource/2016031110.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-10.一个简短的提交历史</p>\n<p>现在，你决定要修补问题追踪系统上的#53问题。顺带说明下，Git并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为iss53。要新建并切换到该分支，运行gitcheckout并加上-b参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b iss53 # Switched to a new branch &quot;iss53&quot;</div></pre></td></tr></table></figure>\n<p>这相当于执行下面这两条命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch iss53</div><div class=\"line\">$ git checkout iss53</div></pre></td></tr></table></figure>\n<p>图3-11示意该命令的执行结果。</p>\n<p><img src=\"resource/2016031111.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-11.创建了一个新分支的指针</p>\n<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的HEAD指针正指向iss53，见图3-12）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;added a new footer [issue 53]&apos;</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031112.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-12.iss53分支随工作进展向前推进</p>\n<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了Git，我们就不需要同时发布这个补丁和iss53里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master分支。</p>\n<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止Git为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做stashing和commitamending）。目前已经提交了所有的修改，所以接下来可以正常转换到master分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master # Switched to branch &quot;master&quot;</div></pre></td></tr></table></figure>\n<p>此时工作目录中的内容和你在解决问题#53之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>\n<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支hotfix来开展工作，直到搞定（见图3-13）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b &apos;hotfix&apos; # Switched to a new branch &quot;hotfix&quot; </div><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;fixed the broken email address&apos; </div><div class=\"line\"></div><div class=\"line\">[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot; </div><div class=\"line\">1 files changed, 0 insertions(+), 1 deletions(-)</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031113.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-13.hotfix分支是从master分支所在点分化出来的</p>\n<p>有必要作些测试，确保修补是成功的，然后回到master分支并把它合并进来，然后发布到生产服务器。用<code>gitmerge</code>命令来进行合并：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master </div><div class=\"line\">$ git merge hotfix </div><div class=\"line\"></div><div class=\"line\">Updating f42c576..3a0874c </div><div class=\"line\">Fast forward </div><div class=\"line\">README | 1 - 1 files changed, 0 insertions(+), 1 deletions(-)</div></pre></td></tr></table></figure>\n<p>请注意，合并时出现了“Fast forward”的提示。由于当前master分支所在的提交对象是要并入的hotfix分支的直接上游，Git只需把master分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么Git在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p>\n<p>现在最新的修改已经在当前master分支所指向的提交对象中了，可以部署到生产服务器上去了（见图3-14）。</p>\n<p><img src=\"resource/2016031114.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-14.合并之后，master分支和hotfix分支指向同一位置。</p>\n<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前hotfix分支和master都指向相同的提交对象，所以hotfix已经完成了历史使命，可以删掉了。使用<code>git branch</code>的 -d 选项执行删除操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d hotfix Deleted branch hotfix (3a0874c).</div></pre></td></tr></table></figure>\n<p>现在回到之前未完成的#53问题修复分支上继续工作（图3-15）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout iss53 # Switched to branch &quot;iss53&quot; </div><div class=\"line\">$ vim index.html </div><div class=\"line\">$ git commit -a -m &apos;finished the new footer [issue 53]&apos; </div><div class=\"line\"></div><div class=\"line\">[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot; </div><div class=\"line\">1 files changed, 1 insertions(+), 0 deletions(-)</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031115.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-15.iss53分支可以不受影响继续推进。</p>\n<p>不用担心之前hotfix分支的修改内容尚未包含到iss53中来。如果确实需要纳入此次修补，可以用<code>git merge master</code>把master分支合并到iss53；或者等iss53完成之后，再将iss53分支中的更新并入master。</p>\n<p><strong>分支的合并</strong></p>\n<p>在问题#53相关的工作完成之后，可以合并回master分支。实际操作同前面合并hotfix分支差不多，只需回到master分支，运行<code>git merge</code>命令指定要合并进来的分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master </div><div class=\"line\">$ git merge iss53 # Merge made by recursive. </div><div class=\"line\"></div><div class=\"line\">README | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)</div></pre></td></tr></table></figure>\n<p>请注意，这次合并操作的底层实现，并不同于之前hotfix的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前master分支所指向的提交对象（C4）并不是iss53分支的直接祖先，Git不得不进行一些额外处理。就此例而言，Git会用两个分支的末端（C4和C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图3-16用红框标出了Git用于合并的三个提交对象：</p>\n<p><img src=\"resource/2016031116.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-16.Git为分支合并自动识别出最佳的同源合并点。</p>\n<p>这次，Git没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）（见图3-17）。这个提交对象比较特殊，它有两个祖先（C4和C5）。</p>\n<p>值得一提的是Git可以自己裁决哪个共同祖先才是最佳合并基础；这和CVS或Subversion（1.5以后的版本）不同，它们需要开发者手工指定合并基础。所以此特性让Git的合并操作比其他系统都要简单不少。</p>\n<p><img src=\"resource/2016031117.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-17.Git自动创建了一个包含了合并结果的提交对象。</p>\n<p>既然之前的工作成果已经合并到master了，那么iss53也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d iss53</div></pre></td></tr></table></figure>\n<p><strong>遇到冲突时的分支合并</strong></p>\n<p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题#53的过程中修改了hotfix中修改的部分，将得到类似下面的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git merge iss53 #Auto-merging index.html </div><div class=\"line\"></div><div class=\"line\">CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>\n<p>Git作了合并，但没有提交，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用<code>git status</code>查阅：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[master*]$ git status </div><div class=\"line\"># index.html: needs merge </div><div class=\"line\"># On branch master </div><div class=\"line\"># Changed but not updated: </div><div class=\"line\"># (use &quot;git add ...&quot; to update what will be committed) </div><div class=\"line\"># (use &quot;git checkout -- ...&quot; to discard changes in working directory) # </div><div class=\"line\"># unmerged: index.html #</div></pre></td></tr></table></figure>\n<p>任何包含未解决冲突的文件都会以未合并（unmerged）的状态列出。Git会在有冲突的文件里加入标准的冲突解决标记，可以通过它们来手工定位并解决这些冲突。可以看到此文件包含类似下面这样的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</div><div class=\"line\">contact : email.support@github.com</div><div class=\"line\">=======</div><div class=\"line\">please contact us at support@github.com</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</div></pre></td></tr></table></figure>\n<p>可以看到=======隔开的上半部分，是HEAD（即master分支，在运行merge命令时所切换到的分支）中的内容，下半部分是在iss53分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。比如你可以通过把这段内容替换为下面这样来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">please contact us at email.support@github.com</div></pre></td></tr></table></figure>\n<p>这个解决方案各采纳了两个分支中的一部分内容，而且我还删除了<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>这些行。在解决了所有文件里的所有冲突后，运行<code>git add</code>将把它们标记为已解决状态（译注：实际上就是来一次快照保存到暂存区域。）。因为一旦暂存，就表示冲突已经解决。如果你想用一个有图形界面的工具来解决这些问题，不妨运行<code>git mergetool</code>，它会调用一个可视化的合并工具并引导你解决所有冲突：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git mergetool #merge tool </div><div class=\"line\"></div><div class=\"line\">candidates: kdiff3 </div><div class=\"line\">\t\t\ttkdiff</div><div class=\"line\">\t\t\txxdiff </div><div class=\"line\">\t\t\tmeld </div><div class=\"line\">\t\t\tgvimdiff </div><div class=\"line\">\t\t\topendiff </div><div class=\"line\">\t\t\temerge </div><div class=\"line\">\t\t\tvimdiff </div><div class=\"line\">Merging the files: index.html Normal merge conflict for &apos;index.html&apos;: &#123;local&#125;: modified &#123;remote&#125;: modified Hit return to start merge resolution tool (opendiff):</div></pre></td></tr></table></figure>\n<p>如果不想用默认的合并工具（Git为我默认选择了opendiff，因为我在Mac上运行了该命令），你可以在上方”merge tool candidates”里找到可用的合并工具列表，输入你想用的工具名。我们将在第七章讨论怎样改变环境中的默认值。</p>\n<p>退出合并工具以后，Git会询问你合并是否成功。如果回答是，它会为你把相关文件暂存起来，以表明状态为已解决。</p>\n<p>再运行一次git status来确认所有冲突都已解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git status # On branch master # Changes to be committed: # (use &quot;git reset HEAD ...&quot; to unstage) # #\tmodified: index.html #</div></pre></td></tr></table></figure>\n<p>如果觉得满意了，并且确认所有冲突都已解决，也就是进入了暂存区，就可以用<code>git commit</code>来完成这次合并提交。提交的记录差不多是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Merge branch &apos;iss53&apos; Conflicts: index.html # # It looks like you may be committing a MERGE. # If this is not correct, please remove the file # .git/MERGE_HEAD # and try again. #</div></pre></td></tr></table></figure>\n<p>如果想给将来看这次合并的人一些方便，可以修改该信息，提供更多合并细节。比如你都作了哪些改动，以及这么做的原因。有时候裁决冲突的理由并不直接或明显，有必要略加注解。</p>\n<p>###3.3  分支的管理</p>\n<p>到目前为止，你已经学会了如何创建、合并和删除分支。除此之外，我们还需要学习如何管理分支，在日后的常规工作中会经常用到下面介绍的管理命令。</p>\n<p><code>git branch</code>命令不仅仅能创建和删除分支，如果不加任何参数，它会给出当前所有分支的清单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch iss53 * master testing</div></pre></td></tr></table></figure>\n<p>注意看master分支前的*字符：它表示当前所在的分支。也就是说，如果现在提交更新，master分支将随着开发进度前移。若要查看各个分支最后一个提交对象的信息，运行<code>git branch -v</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -v iss53 # 93b412c fix javascript issue * master 7a98805 Merge branch &apos;iss53&apos; testing 782fd34 add scott to the author list in the readmes</div></pre></td></tr></table></figure>\n<p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用–merge和–no-merged选项（Git1.5.6以上版本）。比如用<code>git branch --merge</code>查看哪些分支已被并入当前分支（译注：也就是说哪些分支是当前分支的直接上游。）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch --merged iss53 * master</div></pre></td></tr></table></figure>\n<p>之前我们已经合并了iss53，所以在这里会看到它。一般来说，列表中没有*的分支通常都可以用<code>git branch -d</code>来删掉。原因很简单，既然已经把它们所包含的工作整合到了其他分支，删掉也不会损失什么。</p>\n<p>另外可以用<code>git branch --no-merged</code>查看尚未合并的工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch --no-merged testing</div></pre></td></tr></table></figure>\n<p>它会显示还未合并进来的分支。由于这些分支中还包含着尚未合并进来的工作成果，所以简单地用<code>git branch -d</code>删除该分支会提示错误，因为那样做会丢失数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d # testing error: The branch &apos;testing&apos; is not an ancestor of your current HEAD. If you are sure you want to delete it, run &apos;git branch -D testing&apos;.</div></pre></td></tr></table></figure>\n<p>不过，如果你确实想要删除该分支上的改动，可以用大写的删除选项-D强制执行，就像上面提示信息中给出的那样。</p>\n<p>###3.4利用分支进行开发的工作流程</p>\n<p>现在我们已经学会了新建分支和合并分支，可以（或应该）用它来做点什么呢？在本节，我们会介绍一些利用分支进行开发的工作流程。而正是由于分支管理的便捷，才衍生出了这类典型的工作模式，你可以根据项目的实际情况选择一种用用看。</p>\n<p><strong>长期分支</strong></p>\n<p>由于Git使用简单的三方合并，所以就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不是什么难事。也就是说，你可以同时拥有多个开放的分支，每个分支用于完成特定的任务，随着开发的推进，你可以随时把某个特性分支的成果并到其他分支中。</p>\n<p>许多使用Git的开发者都喜欢用这种方式来开展工作，比如仅在master分支中保留完全稳定的代码，即已经发布或即将发布的代码。与此同时，他们还有一个名为develop或next的平行分支，专门用于后续的开发，或仅用于稳定性测试—当然并不是说一定要绝对稳定，不过一旦进入某种稳定状态，便可以把它合并到master里。这样，在确保这些已完成的特性分支（短期分支，比如之前的iss53分支）能够通过所有测试，并且不会引入更多错误之后，就可以并到主干分支中，等待下一次的发布。</p>\n<p>本质上我们刚才谈论的，是随着提交对象不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支总是比较靠前（见图3-18）。</p>\n<p><img src=\"resource/2016031118.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-18.稳定分支总是比较老旧。</p>\n<p>或者把它们想象成工作流水线，或许更好理解一些，经过测试的提交对象集合被遴选到更稳定的流水线（见图3-19）。</p>\n<p><img src=\"resource/2016031119.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-19.想象成流水线可能会容易点。</p>\n<p>你可以用这招维护不同层次的稳定性。某些大项目还会有个proposed（建议）或pu（proposed updates，建议更新）分支，它包含着那些可能还没有成熟到进入next或 master的内容。这么做的目的是拥有不同层次的稳定性：当这些分支进入到更稳定的水平时，再把它们合并到更高层分支中去。再次说明下，使用多个长期分支的做法并非必需，不过一般来说，对于特大型项目或特复杂的项目，这么做确实更容易管理。</p>\n<p><strong>特性分支</strong></p>\n<p>在任何规模的项目中都可以使用特性（Topic）分支。一个特性分支是指一个短期的，用来实现单一特性或与其相关工作的分支。可能你在以前的版本控制系统里从未做过类似这样的事情，因为通常创建与合并分支消耗太大。然而在Git中，一天之内建立、使用、合并再删除多个分支是常见的事。</p>\n<p>我们在上节的例子里已经见过这种用法了。我们创建了iss53和hotfix这两个特性分支，在提交了若干更新后，把它们合并到主干分支，然后删除。该技术允许你迅速且完全的进行语境切换—因为你的工作分散在不同的流水线里，每个分支里的改变都和它的目标特性相关，浏览代码之类的事情因而变得更简单了。你可以把作出的改变保持在特性分支中几分钟，几天甚至几个月，等它们成熟以后再合并，而不用在乎它们建立的顺序或者进度。</p>\n<p>现在我们来看一个实际的例子。请看图3-20，由下往上，起先我们在master工作到C1，然后开始一个新分支iss91尝试修复91号缺陷，提交到C6的时候，又冒出一个解决该问题的新办法，于是从之前C4的地方又分出一个分支iss91v2，干到C8的时候，又回到主干master中提交了C9和C10，再回到iss91v2继续工作，提交C11，接着，又冒出个不太确定的想法，从master的最新提交C10处开了个新的分支dumbidea做些试验。</p>\n<p><img src=\"resource/2016031120.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-20.拥有多个特性分支的提交历史。</p>\n<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即iss91v2中的办法；另外，我们把dumbidea分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91分支（实际上会丢弃C5和C6），直接在主干中并入另外两个分支。最终的提交历史将变成图3-21这样：</p>\n<p><img src=\"resource/2016031121.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-21.合并了dumbidea和iss91v2后的分支历史。</p>\n<p>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的Git仓库中进行的—完全不涉及与服务器的交互。</p>\n<p>###3.5 远程分支</p>\n<p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在Git进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>\n<p>我们用(远程仓库名)/(分支名)这样的形式表示远程分支。比如我们想看看上次同origin仓库通讯时master的样子，就应该查看origin/master分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53分支到远程仓库，虽然你可能也有一个本地的iss53分支，但指向服务器上最新更新的却应该是origin/iss53分支。</p>\n<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为git.ourcompany.com的Git服务器。如果你从这里克隆，Git会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的master分支的指针，在本地命名为origin/master，但你无法在本地更改其数据。接着，Git建立一个属于你自己的本地master分支，始于origin上master分支相同的位置，你可以就此开始工作（见图3-22）：</p>\n<p><img src=\"resource/2016031122.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-22.一次Git克隆会建立你自己的本地分支master和远程分支origin/master，它们都指向origin/master分支的最后一次提交。</p>\n<p>如果你在本地master分支做了些改动，与此同时，其他人向git.ourcompany.com推送了他们的更新，那么服务器上的master分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的origin/master指针仍然保持原位不会移动（见图3-23）。</p>\n<p><img src=\"resource/2016031123.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-23.在本地工作的同时有人向远程仓库推送内容会让提交历史开始分流。</p>\n<p>可以运行<code>git fetch origin</code>来同步远程服务器上的数据到本地。该命令首先找到origin是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把origin/master的指针移到它最新的位置上（见图3-24）。</p>\n<p><img src=\"resource/2016031124.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-24.gitfetch命令会更新remote索引。</p>\n<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器git.team1.ourcompany.com。可以用第二章中提到的<code>git remote add</code>命令把它加为当前项目的远程分支之一。我们把它命名为teamone，以便代替原始的Git地址（见图3-25）。</p>\n<p><img src=\"resource/2016031125.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-25.把另一个服务器加为远程仓库</p>\n<p>现在你可以用<code>git fetch teamone</code>来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你origin服务器上的子集，Git不会下载任何数据，而只是简单地创建一个名为teamone/master的分支，指向teamone服务器上master分支所在的提交对象31b8e（见图3-26）。</p>\n<p><img src=\"resource/2016031126.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-26.你在本地有了一个指向teamone服务器上master分支的索引。</p>\n<p><strong>推送本地分支</strong></p>\n<p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>\n<p>如果你有个叫serverfix的分支需要和他人一起开发，可以运行<code>git push(远程仓库名) (分支名)</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git push origin serverfix </div><div class=\"line\"></div><div class=\"line\">Counting objects: 20, done. </div><div class=\"line\">Compressing objects: 100% (14/14), done. </div><div class=\"line\">Writing objects: 100% (15/15), 1.74 KiB, done. </div><div class=\"line\">Total 15 (delta 5), reused 0 (delta 0) </div><div class=\"line\">To git@github.com:schacon/simplegit.git </div><div class=\"line\">* [new branch] serverfix -&gt; serverfix</div></pre></td></tr></table></figure>\n<p>这其实有点像条捷径。Git自动把serverfix分支名扩展为refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的serverfix分支，推送到远程仓库的serverfix分支中去”。我们将在第九章进一步介绍refs/heads/部分的细节，不过一般使用的时候都可以省略它。也可以运行<code>git push origin serverfix:serferfix</code>来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用<code>git push origin serverfix:awesomebranch</code>来推送数据。</p>\n<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支origin/serverfix：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git fetch origin </div><div class=\"line\"></div><div class=\"line\">remote: Counting </div><div class=\"line\">objects: 20, done. </div><div class=\"line\">remote: Compressing </div><div class=\"line\">objects: 100% (14/14), done. </div><div class=\"line\">remote: Total 15 (delta 5), reused 0 (delta 0) </div><div class=\"line\">Unpacking objects: 100% (15/15), done. </div><div class=\"line\">From git@github.com:schacon/simplegit </div><div class=\"line\">* [new branch] serverfix -&gt; origin/serverfix</div></pre></td></tr></table></figure>\n<p>值得注意的是，在fetch操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix分支，有的只是一个你无法移动的origin/serverfix指针。</p>\n<p>如果要把该内容合并到当前分支，可以运行<code>git merge origin/serverfix</code>。如果想要一份自己的serverfix来开发，可以在远程分支的基础上分化出一个新的分支来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b serverfix origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;serverfix&quot;</div></pre></td></tr></table></figure>\n<p>这会切换到新建的serverfix本地分支，其内容同远程分支origin/serverfix一致，这样你就可以在里面继续开发了。</p>\n<p><strong>跟踪远程分支</strong></p>\n<p>从远程分支checkout出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入<code>git push</code>，Git会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行<code>git pull</code>会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>\n<p>在克隆仓库时，Git通常会自动创建一个名为master的分支来跟踪origin/master。这正是<code>git push</code>和<code>git pull</code>一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin上除了master之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有1.6.2以上版本的Git，还可以用–track选项简化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout --track origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;serverfix&quot;</div></pre></td></tr></table></figure>\n<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout -b sf origin/serverfix </div><div class=\"line\"></div><div class=\"line\">Branch sf set up to track remote branch refs/remotes/origin/serverfix. </div><div class=\"line\">Switched to a new branch &quot;sf&quot;</div></pre></td></tr></table></figure>\n<p>现在你的本地分支sf会自动向origin/serverfix推送和抓取数据了。</p>\n<p><strong>删除远程分支</strong></p>\n<p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的master分支（或任何其他存放稳定代码的地方），可以用这个非常无厘头的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除serverfix 分支，运行下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git push origin:serverfix </div><div class=\"line\"></div><div class=\"line\">To git@github.com:schacon/simplegit.git - [deleted] serverfix</div></pre></td></tr></table></figure>\n<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>\n<p>###3.6  分支的衍合</p>\n<p>把一个分支整合到另一个分支的办法有两种：merge和rebase（译注：rebase的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>\n<p>基本的衍合操作<br>请回顾之前有关合并的一节（见图3-27），你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p>\n<p><img src=\"resource/2016031127.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-27.最初分叉的提交历史。</p>\n<p>之前介绍过，最容易的整合分支的方法是merge命令，它会把两个分支最新的快照（C3和C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。如图3-28所示：</p>\n<p><img src=\"resource/2016031128.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-28.通过合并一个分支来整合分叉了的历史。<br>其实，还有另外一个选择：你可以把在C3里产生的变化补丁在C4的基础上重新打一遍。在Git里，这种操作叫做<em>衍合（rebase）</em>。有了rebase命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>\n<p>在上面这个例子中，运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout experiment </div><div class=\"line\">$ git rebase master </div><div class=\"line\"></div><div class=\"line\">First, rewinding head to replay your work on top of it... Applying: added staged command</div></pre></td></tr></table></figure>\n<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支experiment）后续的历次提交对象（这里只有一个C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写experiment的提交历史，使它成为master分支的直接下游，如图3-29所示：</p>\n<p><img src=\"resource/2016031129.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-29.把C3里产生的改变到C4上重演一遍。</p>\n<p>现在回到master分支，进行一次快进合并（见图3-30）：</p>\n<p><img src=\"resource/2016031130.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-30.master分支的快进。</p>\n<p>现在的C3’对应的快照，其实和普通的三方合并，即上个例子中的C5对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>\n<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁—比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>\n<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>\n<p><strong>有趣的衍合</strong></p>\n<p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图3-31的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支server，然后提交C3和C4。然后又从C3的地方再增加一个client分支来对客户端代码进行一些相应修改，所以提交了C8和C9。最后，又回到server分支提交了C10。</p>\n<p><img src=\"resource/2016031131.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-31.从一个特性分支里再分出一个特性分支的历史。</p>\n<p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于server分支而非master分支的改变（即C8和C9），跳过server直接放到master分支中重演一遍，但这需要用git rebase的–onto选项指定新的基底分支master：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git rebase --onto master server client</div></pre></td></tr></table></figure>\n<p>这好比在说：“取出client分支，找出client分支和server分支的共同祖先之后的变化，然后把它们在master上重演一遍”。是不是有点复杂？不过它的结果如图3-32所示，非常酷（译注：虽然client里的C8,C9在C3之后，但这仅表明时间上的先后，而非在C3修改的基础上进一步改动，因为server和client这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在C3时间点之后，对另外的文件所做的C8，C9修改，放到主干重演。）：</p>\n<p><img src=\"resource/2016031132.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-32.将特性分支上的另一个特性分支衍合到其他分支。</p>\n<p>现在可以快进master分支了（见图3-33）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master $ git merge client</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031133.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-33.快进master分支，使之包含client分支的变化。</p>\n<p>现在我们决定把server分支的变化也包含进来。我们可以直接把server分支衍合到master，而不用手工切换到server分支后再执行衍合操作<code>git rebase [主分支] [特性分支]</code>命令会先取出特性分支server，然后在主分支master上重演：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git rebase master server</div></pre></td></tr></table></figure>\n<p>于是，server的进度应用到master的基础上，如图3-34所示：</p>\n<p><img src=\"resource/2016031134.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-34.在master分支上衍合server分支。</p>\n<p>然后就可以快进主干分支master了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git checkout master $ git merge server</div></pre></td></tr></table></figure>\n<p>现在client和server分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图3-35的样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git branch -d client $ git branch -d server</div></pre></td></tr></table></figure>\n<p><img src=\"resource/2016031135.png\" alt=\"Git详解之Git分支\"> </p>\n<p>图3-35.最终的提交历史</p>\n<p><strong>衍合的风险</strong></p>\n<p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>\n<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。</strong></p>\n<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>\n<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用git rebase抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>\n<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图3-36所示：</p>\n<p><img src=\"resource/2016031136.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-36.克隆一个仓库，在其基础上工作一番。</p>\n<p>现在，某人在C1的基础上做了些改变，并合并他自己的分支得到结果C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果C7，历史提交会变成图3-37这样：</p>\n<p><img src=\"resource/2016031137.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-37.抓取他人提交，并入自己主干。</p>\n<p>接下来，那个推送C6上来的人决定用衍合取代之前的合并操作；继而又用git push –force覆盖了服务器上的历史，得到C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>\n<p><img src=\"resource/2016031138.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-38.有人推送了衍合后得到的C4’，丢弃了你作为开发基础的C4和C6。</p>\n<p>下载更新后需要合并，但此时衍合产生的提交对象C4’的SHA-1校验值和之前C4完全不同，所以Git会把它们当作新的提交对象处理，而实际上此刻你的提交历史C7中早已经包含了C4的修改内容，于是合并操作会把C7和C4’合并为C8（见图3-39）:</p>\n<p><img src=\"resource/2016031139.png\" alt=\"Git详解之Git分支\"></p>\n<p>图3-39.你把相同的内容又合并了一遍，生成一个新的提交C8。</p>\n<p>C8这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在C8之后，你的提交历史里就会同时包含C4和C4’，两者有着不同的SHA-1校验值，如果用git log查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了C6后又用衍合发布C4’的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>\n<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>\n<p>###3.7小结</p>\n<p>读到这里，你应该已经学会了如何创建分支并切换到新分支，在不同分支间转换，合并本地分支，把分支推送到共享服务器上，使用共享分支与他人协作，以及在分享之前进行衍合。</p>\n"},{"title":"HTML5可互动的可视化图表js插件库","date":"2016-05-12T16:00:00.000Z","_content":"\nJointJS是一款可以进行互动的HTML5可视化图表js插件库。它可以用来创建静态图表，并且它拥有完全交互式绘图工具和应用程序生成器。jointjs可以很容易地创建各种各样的可视化工具。\n\nJointJS的事件驱动特性和MVC架构是它可以非常容易的集成到其它后台程序之中。\n\nJointJS的特点有：\n\n- 支持多种图形元素（方形、圆形、椭圆形、文本、图像和路径）\n- 支持多种知名的图表（ERD, Org chart, FSA, UML, PN, DEVS, ...）\n- 支持基于SVG或编程的方式来定制图表\n- 可以和元素及链接进行互动\n- 可以将图表元素进行链接\n- 可以自定义链接样式（链接箭头和标签）\n- 链接平滑过渡（bezier interpolation）\n- 链接点可以放置在任何地方\n- 支持图表分级\n- 支持从JSON格式序列化或反序列到JSON格式\n- 高度的事件驱动-你可以对发生在画布上的任何事件进行处理\n- 支持放大缩小\n- 支持移动触摸设备\n- 支持动画\n- 支持过滤器和渐变\n- 支持NodeJS\n- 渲染速度超快\n\nMVC架构\n\n项目主页：[http://www.jointjs.com/](http://www.jointjs.com/)\n\n演示页面：[http://www.jointjs.com/rappid](http://www.jointjs.com/rappid)\n","source":"_posts/HTML5可互动的可视化图表js插件库.md","raw":"---\ntitle: HTML5可互动的可视化图表js插件库\ntags: [html5,javascript]\ndate: 2016/05/13\n---\n\nJointJS是一款可以进行互动的HTML5可视化图表js插件库。它可以用来创建静态图表，并且它拥有完全交互式绘图工具和应用程序生成器。jointjs可以很容易地创建各种各样的可视化工具。\n\nJointJS的事件驱动特性和MVC架构是它可以非常容易的集成到其它后台程序之中。\n\nJointJS的特点有：\n\n- 支持多种图形元素（方形、圆形、椭圆形、文本、图像和路径）\n- 支持多种知名的图表（ERD, Org chart, FSA, UML, PN, DEVS, ...）\n- 支持基于SVG或编程的方式来定制图表\n- 可以和元素及链接进行互动\n- 可以将图表元素进行链接\n- 可以自定义链接样式（链接箭头和标签）\n- 链接平滑过渡（bezier interpolation）\n- 链接点可以放置在任何地方\n- 支持图表分级\n- 支持从JSON格式序列化或反序列到JSON格式\n- 高度的事件驱动-你可以对发生在画布上的任何事件进行处理\n- 支持放大缩小\n- 支持移动触摸设备\n- 支持动画\n- 支持过滤器和渐变\n- 支持NodeJS\n- 渲染速度超快\n\nMVC架构\n\n项目主页：[http://www.jointjs.com/](http://www.jointjs.com/)\n\n演示页面：[http://www.jointjs.com/rappid](http://www.jointjs.com/rappid)\n","slug":"HTML5可互动的可视化图表js插件库","published":1,"updated":"2016-08-17T06:22:19.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpil001b68dd5u1c9c6c","content":"<p>JointJS是一款可以进行互动的HTML5可视化图表js插件库。它可以用来创建静态图表，并且它拥有完全交互式绘图工具和应用程序生成器。jointjs可以很容易地创建各种各样的可视化工具。</p>\n<p>JointJS的事件驱动特性和MVC架构是它可以非常容易的集成到其它后台程序之中。</p>\n<p>JointJS的特点有：</p>\n<ul>\n<li>支持多种图形元素（方形、圆形、椭圆形、文本、图像和路径）</li>\n<li>支持多种知名的图表（ERD, Org chart, FSA, UML, PN, DEVS, …）</li>\n<li>支持基于SVG或编程的方式来定制图表</li>\n<li>可以和元素及链接进行互动</li>\n<li>可以将图表元素进行链接</li>\n<li>可以自定义链接样式（链接箭头和标签）</li>\n<li>链接平滑过渡（bezier interpolation）</li>\n<li>链接点可以放置在任何地方</li>\n<li>支持图表分级</li>\n<li>支持从JSON格式序列化或反序列到JSON格式</li>\n<li>高度的事件驱动-你可以对发生在画布上的任何事件进行处理</li>\n<li>支持放大缩小</li>\n<li>支持移动触摸设备</li>\n<li>支持动画</li>\n<li>支持过滤器和渐变</li>\n<li>支持NodeJS</li>\n<li>渲染速度超快</li>\n</ul>\n<p>MVC架构</p>\n<p>项目主页：<a href=\"http://www.jointjs.com/\" target=\"_blank\" rel=\"external\">http://www.jointjs.com/</a></p>\n<p>演示页面：<a href=\"http://www.jointjs.com/rappid\" target=\"_blank\" rel=\"external\">http://www.jointjs.com/rappid</a></p>\n","excerpt":"","more":"<p>JointJS是一款可以进行互动的HTML5可视化图表js插件库。它可以用来创建静态图表，并且它拥有完全交互式绘图工具和应用程序生成器。jointjs可以很容易地创建各种各样的可视化工具。</p>\n<p>JointJS的事件驱动特性和MVC架构是它可以非常容易的集成到其它后台程序之中。</p>\n<p>JointJS的特点有：</p>\n<ul>\n<li>支持多种图形元素（方形、圆形、椭圆形、文本、图像和路径）</li>\n<li>支持多种知名的图表（ERD, Org chart, FSA, UML, PN, DEVS, …）</li>\n<li>支持基于SVG或编程的方式来定制图表</li>\n<li>可以和元素及链接进行互动</li>\n<li>可以将图表元素进行链接</li>\n<li>可以自定义链接样式（链接箭头和标签）</li>\n<li>链接平滑过渡（bezier interpolation）</li>\n<li>链接点可以放置在任何地方</li>\n<li>支持图表分级</li>\n<li>支持从JSON格式序列化或反序列到JSON格式</li>\n<li>高度的事件驱动-你可以对发生在画布上的任何事件进行处理</li>\n<li>支持放大缩小</li>\n<li>支持移动触摸设备</li>\n<li>支持动画</li>\n<li>支持过滤器和渐变</li>\n<li>支持NodeJS</li>\n<li>渲染速度超快</li>\n</ul>\n<p>MVC架构</p>\n<p>项目主页：<a href=\"http://www.jointjs.com/\">http://www.jointjs.com/</a></p>\n<p>演示页面：<a href=\"http://www.jointjs.com/rappid\">http://www.jointjs.com/rappid</a></p>\n"},{"title":"How can i use iptables on centos 7","date":"2016-02-17T16:00:00.000Z","_content":"\nI installed CentOS 7 with minimal configuration (os + dev tools). I am trying to open 80 port for httpdservice, but something wrong with my iptables service ... what's wrong with it? What am I doing wrong?\n\n```\n$ifconfig/sbin/service iptables save\nbash: ifconfig/sbin/service: No such file or directory\n```\n\n```\n$/sbin/service iptables save\n```\n\nThe service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.\n\n```\n$sudo service iptables status\n```\n\nRedirecting to /bin/systemctl status  iptables.service\n\niptables.service\n\nLoaded: not-found (Reason: No such file or directory)\n\nActive: inactive (dead)\n\n```\n$/sbin/service iptables save\n```\n\nThe service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.\n\n```\n$sudo service iptables start\n```\n\nRedirecting to /bin/systemctl start  iptables.service\n\nFailed to issue method call: Unit iptables.service failed to load: No such file or directory.\n\nWith RHEL 7 / CentOS 7, firewalld was introduced to manage iptables. IMHO, firewalld is more suited for workstations than for server environments.\n\nIt is possible to go back to a more classic iptables setup. First, stop and mask the firewalld service:\n\n```\n$systemctl stop firewalld\n$systemctl mask firewalld\n\n```\n  \nThen, install the iptables-services package:\n\n```\n$yum install iptables-services\n```\n  \nEnable the service at boot-time:\n\n```\n$systemctl enable iptables\n```\n\nManaging the service\n\n```\n$systemctl [stop|start|restart] iptables\n```\n  \nSystemctl doesn't seem to manage the save action like you were able to do in the past with service: \n\n```\n$/usr/libexec/iptables/iptables.init save  \n```\n\nThis fixed it: \n\n```\n$yum install iptables-services\n$systemctl mask firewalld\n$systemctl enable iptables\n$systemctl enable ip6tables\n$systemctl stop firewalld\n$systemctl start iptables\n$systemctl start ip6tables\n```\n","source":"_posts/How can i use iptables on centos 7.md","raw":"---\ntitle: How can i use iptables on centos 7\ntags: [linux,centos]\ndate: 2016/02/18\n---\n\nI installed CentOS 7 with minimal configuration (os + dev tools). I am trying to open 80 port for httpdservice, but something wrong with my iptables service ... what's wrong with it? What am I doing wrong?\n\n```\n$ifconfig/sbin/service iptables save\nbash: ifconfig/sbin/service: No such file or directory\n```\n\n```\n$/sbin/service iptables save\n```\n\nThe service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.\n\n```\n$sudo service iptables status\n```\n\nRedirecting to /bin/systemctl status  iptables.service\n\niptables.service\n\nLoaded: not-found (Reason: No such file or directory)\n\nActive: inactive (dead)\n\n```\n$/sbin/service iptables save\n```\n\nThe service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.\n\n```\n$sudo service iptables start\n```\n\nRedirecting to /bin/systemctl start  iptables.service\n\nFailed to issue method call: Unit iptables.service failed to load: No such file or directory.\n\nWith RHEL 7 / CentOS 7, firewalld was introduced to manage iptables. IMHO, firewalld is more suited for workstations than for server environments.\n\nIt is possible to go back to a more classic iptables setup. First, stop and mask the firewalld service:\n\n```\n$systemctl stop firewalld\n$systemctl mask firewalld\n\n```\n  \nThen, install the iptables-services package:\n\n```\n$yum install iptables-services\n```\n  \nEnable the service at boot-time:\n\n```\n$systemctl enable iptables\n```\n\nManaging the service\n\n```\n$systemctl [stop|start|restart] iptables\n```\n  \nSystemctl doesn't seem to manage the save action like you were able to do in the past with service: \n\n```\n$/usr/libexec/iptables/iptables.init save  \n```\n\nThis fixed it: \n\n```\n$yum install iptables-services\n$systemctl mask firewalld\n$systemctl enable iptables\n$systemctl enable ip6tables\n$systemctl stop firewalld\n$systemctl start iptables\n$systemctl start ip6tables\n```\n","slug":"How can i use iptables on centos 7","published":1,"updated":"2016-08-17T06:22:19.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpiq001d68ddhb4j2igl","content":"<p>I installed CentOS 7 with minimal configuration (os + dev tools). I am trying to open 80 port for httpdservice, but something wrong with my iptables service … what’s wrong with it? What am I doing wrong?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ifconfig/sbin/service iptables save</div><div class=\"line\">bash: ifconfig/sbin/service: No such file or directory</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/sbin/service iptables save</div></pre></td></tr></table></figure>\n<p>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo service iptables status</div></pre></td></tr></table></figure>\n<p>Redirecting to /bin/systemctl status  iptables.service</p>\n<p>iptables.service</p>\n<p>Loaded: not-found (Reason: No such file or directory)</p>\n<p>Active: inactive (dead)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/sbin/service iptables save</div></pre></td></tr></table></figure>\n<p>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo service iptables start</div></pre></td></tr></table></figure>\n<p>Redirecting to /bin/systemctl start  iptables.service</p>\n<p>Failed to issue method call: Unit iptables.service failed to load: No such file or directory.</p>\n<p>With RHEL 7 / CentOS 7, firewalld was introduced to manage iptables. IMHO, firewalld is more suited for workstations than for server environments.</p>\n<p>It is possible to go back to a more classic iptables setup. First, stop and mask the firewalld service:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl stop firewalld</div><div class=\"line\">$systemctl mask firewalld</div></pre></td></tr></table></figure>\n<p>Then, install the iptables-services package:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install iptables-services</div></pre></td></tr></table></figure>\n<p>Enable the service at boot-time:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl enable iptables</div></pre></td></tr></table></figure>\n<p>Managing the service</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl [stop|start|restart] iptables</div></pre></td></tr></table></figure>\n<p>Systemctl doesn’t seem to manage the save action like you were able to do in the past with service: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/usr/libexec/iptables/iptables.init save</div></pre></td></tr></table></figure>\n<p>This fixed it: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install iptables-services</div><div class=\"line\">$systemctl mask firewalld</div><div class=\"line\">$systemctl enable iptables</div><div class=\"line\">$systemctl enable ip6tables</div><div class=\"line\">$systemctl stop firewalld</div><div class=\"line\">$systemctl start iptables</div><div class=\"line\">$systemctl start ip6tables</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>I installed CentOS 7 with minimal configuration (os + dev tools). I am trying to open 80 port for httpdservice, but something wrong with my iptables service … what’s wrong with it? What am I doing wrong?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ifconfig/sbin/service iptables save</div><div class=\"line\">bash: ifconfig/sbin/service: No such file or directory</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/sbin/service iptables save</div></pre></td></tr></table></figure>\n<p>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo service iptables status</div></pre></td></tr></table></figure>\n<p>Redirecting to /bin/systemctl status  iptables.service</p>\n<p>iptables.service</p>\n<p>Loaded: not-found (Reason: No such file or directory)</p>\n<p>Active: inactive (dead)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/sbin/service iptables save</div></pre></td></tr></table></figure>\n<p>The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo service iptables start</div></pre></td></tr></table></figure>\n<p>Redirecting to /bin/systemctl start  iptables.service</p>\n<p>Failed to issue method call: Unit iptables.service failed to load: No such file or directory.</p>\n<p>With RHEL 7 / CentOS 7, firewalld was introduced to manage iptables. IMHO, firewalld is more suited for workstations than for server environments.</p>\n<p>It is possible to go back to a more classic iptables setup. First, stop and mask the firewalld service:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl stop firewalld</div><div class=\"line\">$systemctl mask firewalld</div></pre></td></tr></table></figure>\n<p>Then, install the iptables-services package:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install iptables-services</div></pre></td></tr></table></figure>\n<p>Enable the service at boot-time:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl enable iptables</div></pre></td></tr></table></figure>\n<p>Managing the service</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$systemctl [stop|start|restart] iptables</div></pre></td></tr></table></figure>\n<p>Systemctl doesn’t seem to manage the save action like you were able to do in the past with service: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$/usr/libexec/iptables/iptables.init save</div></pre></td></tr></table></figure>\n<p>This fixed it: </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install iptables-services</div><div class=\"line\">$systemctl mask firewalld</div><div class=\"line\">$systemctl enable iptables</div><div class=\"line\">$systemctl enable ip6tables</div><div class=\"line\">$systemctl stop firewalld</div><div class=\"line\">$systemctl start iptables</div><div class=\"line\">$systemctl start ip6tables</div></pre></td></tr></table></figure>\n"},{"title":"Mac中自定义文件夹中文名","date":"2015-02-01T16:00:00.000Z","_content":"\n###修改文件：\n\n/System/\nLibrary/\nCoreServices/\nSystemFolderLocalizations/\nzh_CN.lproj/\nSystemFolderLocalizations.strings\n\n###使用系统自带软件Property List Editor就可以了，是一个XML文件修改器\n\nＯＳ：请给文件夹所有人读写权限，否则无法保存修改后的文件\n","source":"_posts/Mac中自定义文件夹中文名.md","raw":"---\ntitle: Mac中自定义文件夹中文名\ntags: [mac]\ndate: 2015/02/02\n---\n\n###修改文件：\n\n/System/\nLibrary/\nCoreServices/\nSystemFolderLocalizations/\nzh_CN.lproj/\nSystemFolderLocalizations.strings\n\n###使用系统自带软件Property List Editor就可以了，是一个XML文件修改器\n\nＯＳ：请给文件夹所有人读写权限，否则无法保存修改后的文件\n","slug":"Mac中自定义文件夹中文名","published":1,"updated":"2016-08-17T06:22:19.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpit001g68ddndr7h6vy","content":"<p>###修改文件：</p>\n<p>/System/<br>Library/<br>CoreServices/<br>SystemFolderLocalizations/<br>zh_CN.lproj/<br>SystemFolderLocalizations.strings</p>\n<p>###使用系统自带软件Property List Editor就可以了，是一个XML文件修改器</p>\n<p>ＯＳ：请给文件夹所有人读写权限，否则无法保存修改后的文件</p>\n","excerpt":"","more":"<p>###修改文件：</p>\n<p>/System/<br>Library/<br>CoreServices/<br>SystemFolderLocalizations/<br>zh_CN.lproj/<br>SystemFolderLocalizations.strings</p>\n<p>###使用系统自带软件Property List Editor就可以了，是一个XML文件修改器</p>\n<p>ＯＳ：请给文件夹所有人读写权限，否则无法保存修改后的文件</p>\n"},{"title":"JavaScript总结几个提高性能知识点","date":"2015-05-20T16:00:00.000Z","_content":"\n***更快速的数据访问***\n\n对于浏览器来说，一个标识符所处的位置越深，去读写他的速度也就越慢(对于这点，原型链亦是如此)。这个应该不难理解，简单比喻就是：杂货店离你家越远，你去打酱油所花的时间就越长。\n\n如果我们需要在当前函数内多次用到一个变量值，那么我们可以用一个局部变量先将其存储起来，案例如下：\n\n```\n//修改前\nfunction showLi(){\n    var i = 0;\n    for(;i<document.getElementsByTagName(\"li\").length;i++){    //一次访问document\n        console.log(i,document.getElementsByTagName(\"li\")[i]);  //三次访问document\n    };\n};\n//修改后\nfunction showLi(){\n    var li_s = document.getElementsByTagName(\"li\");  //一次访问document\n    var i = 0;\n    for(;i<li_s.length;i++){\n        console.log(i,li_s[i]);  //三次访问局部变量li_s\n    };\n};\n```\n\n***DOM操作的优化***\n\n众所周知的，DOM操作远比javascript的执行耗性能，虽然我们避免不了对DOM进行操作，但我们可以尽量去减少该操作对性能的消耗。\n\n让我们通过代码解释这个问题：\n\n```\nfunction innerLi_s(){\n    var i = 0;\n    for(;i<20;i++){\n        document.getElementById(\"Num\").innerHTML=\"A\"; //进行了20次循环，每次又有2次DOM元素访问：一次读取innerHTML的值，一次写入值\n    };\n};\n```\n\n针对以上方法进行一次改写：\n\n```\nfunction innerLi_s(){\n    var content =\"\";\n    var i = 0;\n    for(;i<20;i++){\n        content += \"A\";  //这里只对js的变量循环了20次\n    };\n    document.getElementById(\"Num\").innerHTML += content;  //这里值进行了一次DOM操作，又分2次DOM访问：一次读取innerHTML的值，一次写入值\n};\n```\n\n***减少Dom的重绘重排版***\n\n元素布局的改变或内容的增删改或者浏览器窗口尺寸改变都将会导致重排，而字体颜色或者背景色的修改则将导致重绘。\n对于类似以下代码的操作，据说现代浏览器大多进行了优化(将其优化成1次重排版)：\n\n```\n//修改前\nvar el = document.getElementById(\"div\");\nel.style.borderLeft = \"1px\"; //1次重排版\nel.style.borderRight = \"2px\"; //又1次重排版\nel.style.padding = \"5px\"; //还有1次重排版\n//修改后\nvar el = document.getElementById(\"div\");\nel.style.cssText = \"border-left:1px;border-right:2px;padding:5px\"; //1次重排版\n```\n\n针对多重操作，以下三种方法也可以减少重排版和重绘的次数：\n\n1.Dom先隐藏，操作后再显示 2次重排 (临时的display:none)\n\n2.document.createDocumentFragment() 创建文档片段处理，操作后追加到页面 1次重排\n\n3.var newDOM = oldDOM.cloneNode(true)创建Dom副本，修改副本后oldDOM.parentNode.replaceChild(newDOM,oldDOM)覆盖原DOM 2次重排\n\n***循环的优化***\n\n这应该是较多人都知道的写法了，简单带过即可(后面还是用代码+注释形式说明)~\n\n```\n//修改前\nvar i = 0;\nfor(;i<arr.lengthli++){  //每次循环都需要获取数组arr的length\n    console.log(arr[i]);\n}\n//修改后\nvar i = 0;\nvar len = arr.length;  //获取一次数组arr的length \nfor(;i<len;i++){\n    console.log(arr[i]);\n}\n//or\nvar i = arr.length;;\nfor(;i;i--){\n    console.log(arr[i]);\n}\n```\n\n***合理利用二进制***\n\n如：对2取模，则偶数最低位是0，奇数最低位是0，与1进行位与操作的结果是0，奇数的最低位是1，与1进行位与操作的结果是1。\n\n代码如下：\n\n```\n.odd{color:red}\n.even{color:yellow}\n\n<ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n      <li>6</li>\n</ul>\n```\n\n```\nvar i = 0;\nvar lis = document.getElementsByTagName(\"li\");\nvar len = lis.length;\nfor(;i<len;i++){\n    if(i&1){\n        lis[i].className = \"even\";\n    } else{\n        lis[i].className = \"odd\";\n    }\n};\n```\n\n\n虽说现代浏览器都已经做的很好了，但是本兽觉得这是自己对代码质量的一个追求。并且可能一个点或者两个点不注意是不会产生多大性能影响，但是从多个点进行优化后，可能产生的就会是质的飞跃了~\n","source":"_posts/JavaScript总结几个提高性能知识点.md","raw":"---\ntitle: JavaScript总结几个提高性能知识点\ntags: [javascript]\ndate: 2015/05/21\n---\n\n***更快速的数据访问***\n\n对于浏览器来说，一个标识符所处的位置越深，去读写他的速度也就越慢(对于这点，原型链亦是如此)。这个应该不难理解，简单比喻就是：杂货店离你家越远，你去打酱油所花的时间就越长。\n\n如果我们需要在当前函数内多次用到一个变量值，那么我们可以用一个局部变量先将其存储起来，案例如下：\n\n```\n//修改前\nfunction showLi(){\n    var i = 0;\n    for(;i<document.getElementsByTagName(\"li\").length;i++){    //一次访问document\n        console.log(i,document.getElementsByTagName(\"li\")[i]);  //三次访问document\n    };\n};\n//修改后\nfunction showLi(){\n    var li_s = document.getElementsByTagName(\"li\");  //一次访问document\n    var i = 0;\n    for(;i<li_s.length;i++){\n        console.log(i,li_s[i]);  //三次访问局部变量li_s\n    };\n};\n```\n\n***DOM操作的优化***\n\n众所周知的，DOM操作远比javascript的执行耗性能，虽然我们避免不了对DOM进行操作，但我们可以尽量去减少该操作对性能的消耗。\n\n让我们通过代码解释这个问题：\n\n```\nfunction innerLi_s(){\n    var i = 0;\n    for(;i<20;i++){\n        document.getElementById(\"Num\").innerHTML=\"A\"; //进行了20次循环，每次又有2次DOM元素访问：一次读取innerHTML的值，一次写入值\n    };\n};\n```\n\n针对以上方法进行一次改写：\n\n```\nfunction innerLi_s(){\n    var content =\"\";\n    var i = 0;\n    for(;i<20;i++){\n        content += \"A\";  //这里只对js的变量循环了20次\n    };\n    document.getElementById(\"Num\").innerHTML += content;  //这里值进行了一次DOM操作，又分2次DOM访问：一次读取innerHTML的值，一次写入值\n};\n```\n\n***减少Dom的重绘重排版***\n\n元素布局的改变或内容的增删改或者浏览器窗口尺寸改变都将会导致重排，而字体颜色或者背景色的修改则将导致重绘。\n对于类似以下代码的操作，据说现代浏览器大多进行了优化(将其优化成1次重排版)：\n\n```\n//修改前\nvar el = document.getElementById(\"div\");\nel.style.borderLeft = \"1px\"; //1次重排版\nel.style.borderRight = \"2px\"; //又1次重排版\nel.style.padding = \"5px\"; //还有1次重排版\n//修改后\nvar el = document.getElementById(\"div\");\nel.style.cssText = \"border-left:1px;border-right:2px;padding:5px\"; //1次重排版\n```\n\n针对多重操作，以下三种方法也可以减少重排版和重绘的次数：\n\n1.Dom先隐藏，操作后再显示 2次重排 (临时的display:none)\n\n2.document.createDocumentFragment() 创建文档片段处理，操作后追加到页面 1次重排\n\n3.var newDOM = oldDOM.cloneNode(true)创建Dom副本，修改副本后oldDOM.parentNode.replaceChild(newDOM,oldDOM)覆盖原DOM 2次重排\n\n***循环的优化***\n\n这应该是较多人都知道的写法了，简单带过即可(后面还是用代码+注释形式说明)~\n\n```\n//修改前\nvar i = 0;\nfor(;i<arr.lengthli++){  //每次循环都需要获取数组arr的length\n    console.log(arr[i]);\n}\n//修改后\nvar i = 0;\nvar len = arr.length;  //获取一次数组arr的length \nfor(;i<len;i++){\n    console.log(arr[i]);\n}\n//or\nvar i = arr.length;;\nfor(;i;i--){\n    console.log(arr[i]);\n}\n```\n\n***合理利用二进制***\n\n如：对2取模，则偶数最低位是0，奇数最低位是0，与1进行位与操作的结果是0，奇数的最低位是1，与1进行位与操作的结果是1。\n\n代码如下：\n\n```\n.odd{color:red}\n.even{color:yellow}\n\n<ul>\n      <li>1</li>\n      <li>2</li>\n      <li>3</li>\n      <li>4</li>\n      <li>5</li>\n      <li>6</li>\n</ul>\n```\n\n```\nvar i = 0;\nvar lis = document.getElementsByTagName(\"li\");\nvar len = lis.length;\nfor(;i<len;i++){\n    if(i&1){\n        lis[i].className = \"even\";\n    } else{\n        lis[i].className = \"odd\";\n    }\n};\n```\n\n\n虽说现代浏览器都已经做的很好了，但是本兽觉得这是自己对代码质量的一个追求。并且可能一个点或者两个点不注意是不会产生多大性能影响，但是从多个点进行优化后，可能产生的就会是质的飞跃了~\n","slug":"JavaScript总结几个提高性能知识点","published":1,"updated":"2016-08-17T06:22:19.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpiv001i68dduoa7x6da","content":"<p><strong><em>更快速的数据访问</em></strong></p>\n<p>对于浏览器来说，一个标识符所处的位置越深，去读写他的速度也就越慢(对于这点，原型链亦是如此)。这个应该不难理解，简单比喻就是：杂货店离你家越远，你去打酱油所花的时间就越长。</p>\n<p>如果我们需要在当前函数内多次用到一个变量值，那么我们可以用一个局部变量先将其存储起来，案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">function showLi()&#123;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;document.getElementsByTagName(&quot;li&quot;).length;i++)&#123;    //一次访问document</div><div class=\"line\">        console.log(i,document.getElementsByTagName(&quot;li&quot;)[i]);  //三次访问document</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">//修改后</div><div class=\"line\">function showLi()&#123;</div><div class=\"line\">    var li_s = document.getElementsByTagName(&quot;li&quot;);  //一次访问document</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;li_s.length;i++)&#123;</div><div class=\"line\">        console.log(i,li_s[i]);  //三次访问局部变量li_s</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong><em>DOM操作的优化</em></strong></p>\n<p>众所周知的，DOM操作远比javascript的执行耗性能，虽然我们避免不了对DOM进行操作，但我们可以尽量去减少该操作对性能的消耗。</p>\n<p>让我们通过代码解释这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function innerLi_s()&#123;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;20;i++)&#123;</div><div class=\"line\">        document.getElementById(&quot;Num&quot;).innerHTML=&quot;A&quot;; //进行了20次循环，每次又有2次DOM元素访问：一次读取innerHTML的值，一次写入值</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>针对以上方法进行一次改写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function innerLi_s()&#123;</div><div class=\"line\">    var content =&quot;&quot;;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;20;i++)&#123;</div><div class=\"line\">        content += &quot;A&quot;;  //这里只对js的变量循环了20次</div><div class=\"line\">    &#125;;</div><div class=\"line\">    document.getElementById(&quot;Num&quot;).innerHTML += content;  //这里值进行了一次DOM操作，又分2次DOM访问：一次读取innerHTML的值，一次写入值</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong><em>减少Dom的重绘重排版</em></strong></p>\n<p>元素布局的改变或内容的增删改或者浏览器窗口尺寸改变都将会导致重排，而字体颜色或者背景色的修改则将导致重绘。<br>对于类似以下代码的操作，据说现代浏览器大多进行了优化(将其优化成1次重排版)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">var el = document.getElementById(&quot;div&quot;);</div><div class=\"line\">el.style.borderLeft = &quot;1px&quot;; //1次重排版</div><div class=\"line\">el.style.borderRight = &quot;2px&quot;; //又1次重排版</div><div class=\"line\">el.style.padding = &quot;5px&quot;; //还有1次重排版</div><div class=\"line\">//修改后</div><div class=\"line\">var el = document.getElementById(&quot;div&quot;);</div><div class=\"line\">el.style.cssText = &quot;border-left:1px;border-right:2px;padding:5px&quot;; //1次重排版</div></pre></td></tr></table></figure>\n<p>针对多重操作，以下三种方法也可以减少重排版和重绘的次数：</p>\n<p>1.Dom先隐藏，操作后再显示 2次重排 (临时的display:none)</p>\n<p>2.document.createDocumentFragment() 创建文档片段处理，操作后追加到页面 1次重排</p>\n<p>3.var newDOM = oldDOM.cloneNode(true)创建Dom副本，修改副本后oldDOM.parentNode.replaceChild(newDOM,oldDOM)覆盖原DOM 2次重排</p>\n<p><strong><em>循环的优化</em></strong></p>\n<p>这应该是较多人都知道的写法了，简单带过即可(后面还是用代码+注释形式说明)~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(;i&lt;arr.lengthli++)&#123;  //每次循环都需要获取数组arr的length</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">//修改后</div><div class=\"line\">var i = 0;</div><div class=\"line\">var len = arr.length;  //获取一次数组arr的length </div><div class=\"line\">for(;i&lt;len;i++)&#123;</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">//or</div><div class=\"line\">var i = arr.length;;</div><div class=\"line\">for(;i;i--)&#123;</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong><em>合理利用二进制</em></strong></p>\n<p>如：对2取模，则偶数最低位是0，奇数最低位是0，与1进行位与操作的结果是0，奇数的最低位是1，与1进行位与操作的结果是1。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.odd&#123;color:red&#125;</div><div class=\"line\">.even&#123;color:yellow&#125;</div><div class=\"line\"></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">      &lt;li&gt;1&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;2&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;3&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;4&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;5&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;6&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var i = 0;</div><div class=\"line\">var lis = document.getElementsByTagName(&quot;li&quot;);</div><div class=\"line\">var len = lis.length;</div><div class=\"line\">for(;i&lt;len;i++)&#123;</div><div class=\"line\">    if(i&amp;1)&#123;</div><div class=\"line\">        lis[i].className = &quot;even&quot;;</div><div class=\"line\">    &#125; else&#123;</div><div class=\"line\">        lis[i].className = &quot;odd&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>虽说现代浏览器都已经做的很好了，但是本兽觉得这是自己对代码质量的一个追求。并且可能一个点或者两个点不注意是不会产生多大性能影响，但是从多个点进行优化后，可能产生的就会是质的飞跃了~</p>\n","excerpt":"","more":"<p><strong><em>更快速的数据访问</em></strong></p>\n<p>对于浏览器来说，一个标识符所处的位置越深，去读写他的速度也就越慢(对于这点，原型链亦是如此)。这个应该不难理解，简单比喻就是：杂货店离你家越远，你去打酱油所花的时间就越长。</p>\n<p>如果我们需要在当前函数内多次用到一个变量值，那么我们可以用一个局部变量先将其存储起来，案例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">function showLi()&#123;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;document.getElementsByTagName(&quot;li&quot;).length;i++)&#123;    //一次访问document</div><div class=\"line\">        console.log(i,document.getElementsByTagName(&quot;li&quot;)[i]);  //三次访问document</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\">//修改后</div><div class=\"line\">function showLi()&#123;</div><div class=\"line\">    var li_s = document.getElementsByTagName(&quot;li&quot;);  //一次访问document</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;li_s.length;i++)&#123;</div><div class=\"line\">        console.log(i,li_s[i]);  //三次访问局部变量li_s</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong><em>DOM操作的优化</em></strong></p>\n<p>众所周知的，DOM操作远比javascript的执行耗性能，虽然我们避免不了对DOM进行操作，但我们可以尽量去减少该操作对性能的消耗。</p>\n<p>让我们通过代码解释这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function innerLi_s()&#123;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;20;i++)&#123;</div><div class=\"line\">        document.getElementById(&quot;Num&quot;).innerHTML=&quot;A&quot;; //进行了20次循环，每次又有2次DOM元素访问：一次读取innerHTML的值，一次写入值</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>针对以上方法进行一次改写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function innerLi_s()&#123;</div><div class=\"line\">    var content =&quot;&quot;;</div><div class=\"line\">    var i = 0;</div><div class=\"line\">    for(;i&lt;20;i++)&#123;</div><div class=\"line\">        content += &quot;A&quot;;  //这里只对js的变量循环了20次</div><div class=\"line\">    &#125;;</div><div class=\"line\">    document.getElementById(&quot;Num&quot;).innerHTML += content;  //这里值进行了一次DOM操作，又分2次DOM访问：一次读取innerHTML的值，一次写入值</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong><em>减少Dom的重绘重排版</em></strong></p>\n<p>元素布局的改变或内容的增删改或者浏览器窗口尺寸改变都将会导致重排，而字体颜色或者背景色的修改则将导致重绘。<br>对于类似以下代码的操作，据说现代浏览器大多进行了优化(将其优化成1次重排版)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">var el = document.getElementById(&quot;div&quot;);</div><div class=\"line\">el.style.borderLeft = &quot;1px&quot;; //1次重排版</div><div class=\"line\">el.style.borderRight = &quot;2px&quot;; //又1次重排版</div><div class=\"line\">el.style.padding = &quot;5px&quot;; //还有1次重排版</div><div class=\"line\">//修改后</div><div class=\"line\">var el = document.getElementById(&quot;div&quot;);</div><div class=\"line\">el.style.cssText = &quot;border-left:1px;border-right:2px;padding:5px&quot;; //1次重排版</div></pre></td></tr></table></figure>\n<p>针对多重操作，以下三种方法也可以减少重排版和重绘的次数：</p>\n<p>1.Dom先隐藏，操作后再显示 2次重排 (临时的display:none)</p>\n<p>2.document.createDocumentFragment() 创建文档片段处理，操作后追加到页面 1次重排</p>\n<p>3.var newDOM = oldDOM.cloneNode(true)创建Dom副本，修改副本后oldDOM.parentNode.replaceChild(newDOM,oldDOM)覆盖原DOM 2次重排</p>\n<p><strong><em>循环的优化</em></strong></p>\n<p>这应该是较多人都知道的写法了，简单带过即可(后面还是用代码+注释形式说明)~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//修改前</div><div class=\"line\">var i = 0;</div><div class=\"line\">for(;i&lt;arr.lengthli++)&#123;  //每次循环都需要获取数组arr的length</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">//修改后</div><div class=\"line\">var i = 0;</div><div class=\"line\">var len = arr.length;  //获取一次数组arr的length </div><div class=\"line\">for(;i&lt;len;i++)&#123;</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">//or</div><div class=\"line\">var i = arr.length;;</div><div class=\"line\">for(;i;i--)&#123;</div><div class=\"line\">    console.log(arr[i]);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong><em>合理利用二进制</em></strong></p>\n<p>如：对2取模，则偶数最低位是0，奇数最低位是0，与1进行位与操作的结果是0，奇数的最低位是1，与1进行位与操作的结果是1。</p>\n<p>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.odd&#123;color:red&#125;</div><div class=\"line\">.even&#123;color:yellow&#125;</div><div class=\"line\"></div><div class=\"line\">&lt;ul&gt;</div><div class=\"line\">      &lt;li&gt;1&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;2&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;3&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;4&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;5&lt;/li&gt;</div><div class=\"line\">      &lt;li&gt;6&lt;/li&gt;</div><div class=\"line\">&lt;/ul&gt;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var i = 0;</div><div class=\"line\">var lis = document.getElementsByTagName(&quot;li&quot;);</div><div class=\"line\">var len = lis.length;</div><div class=\"line\">for(;i&lt;len;i++)&#123;</div><div class=\"line\">    if(i&amp;1)&#123;</div><div class=\"line\">        lis[i].className = &quot;even&quot;;</div><div class=\"line\">    &#125; else&#123;</div><div class=\"line\">        lis[i].className = &quot;odd&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>虽说现代浏览器都已经做的很好了，但是本兽觉得这是自己对代码质量的一个追求。并且可能一个点或者两个点不注意是不会产生多大性能影响，但是从多个点进行优化后，可能产生的就会是质的飞跃了~</p>\n"},{"title":"Nodejs学习笔记1——socket.io模块、url模块","date":"2016-02-04T16:00:00.000Z","_content":"\n### socket.io\n\n>该模块主要应用于实时的长连接多请求项目中，例如在线联网游戏、实时聊天、实时股票查看、二维扫描登录等。\n\n**Server:**\n\n```\nvar io = require('socket.io').listen(3000);\n\nio.sockets.on('connection', function(socket){\n  socket.on('server', function(data){\n\tio.sockets.emit('client', data);//io.sockets.emit()用于群发广播，io.socket.emit()点对点发送广播。\n  });\n  io.sockets.emit('client', 'index is connectioned!');\n});\n```\n\n**Client:**\n\n```\n<h3>is running!</h3>\n\t\n\t<input type=\"text\" id=\"msg\" value=\"\" />\n\t<input type=\"button\" id=\"sendMsg\" value=\"send message\" onclick=\"sendMsg()\" />\n\t\n\t<textarea id=\"msgList\"></textarea>\n\t\n\t<script src=\"//cdn.bootcss.com/socket.io/1.3.6/socket.io.min.js\"></script>\n\t<script>\n\tvar socket=io.connect('http://localhost:3000');\n\t\n\tvar msg='';\n\tvar flag=false;\n\t\n\tsocket.on('connect',function(){\n\t\tsocket.on('client',function(data){\n\t\t\tconsole.log(data);\n\t\t\t\n\t\t\tvar obj=document.getElementById('msgList');\n\t\t\t\n\t\t\tvar msgs=obj.value+data;\n\t\t\tobj.value=msgs;\n\t\t});\n\t});\n\t\n\tsocket.emit('server','i am come in.');\n\t\n\tfunction sendMsg(){\n\t\tvar obj=document.getElementById('msg');\n\t\tmsg=obj.value;\n\t\t\n\t\tif(msg==''){\n\t\t\talert('is empty!');\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tflag=true;\n\t\t\n\t\tsocket.emit('server',msg);\n\t}\n\t</script>\n```\n\n### url\n\n>解释url的模块。\n\n### querystring\n\n>转换地址参数格式的模块。\n\n```\nvar url=require('url');\nvar http=require('http');\nvar querystring=require('querystring');\n\n//以localhost:1737/index.html?key=1&value=2为例\nhttp.createServer(function(req,res){\n\tvar reqUrl=req.url;\n\t\n\tconsole.log(url.parse(reqUrl));\n\tconsole.log(url.parse(reqUrl).pathname);//返回/index.html\n\tconsole.log(querystring.parse(url.parse(reqUrl).query));//返回{key:1,value:2}\n\t\n\tres.writeHead(200,{'Content-Type':'text/html'});\n\tres.end('Hello!');\n}).listen(1737);\n\nconsole.log('is running: localhost:1737');\n```\n\n### POST请求\n\n>Node.js为了使整个过程非阻塞，会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块有序传递给加调函数。\n\n\n\n>这部分涉及request对象中的addListener方法，该方法有两个事件参数data和end，data表示数据传输开始，end表示数据传输结束。\n\n```\nvar http=require('http');\nvar querystring=require('querystring');\n\nhttp.createServer(function(req,res){\n\tvar postData='';\n\t\n\treq.setEncoding('utf8');\n\t\n\treq.addListener('data',function(data){\n\t\tpostData+=data;\n\t});\n\t\n\treq.addListener('end',function(data){\n\t\tconsole.log(querystring.parse(postData));\n\t});\n\t\n\tres.writeHead(200,{'Content-Type':'text/plain'});\n\tres.end('Hello World\\n');\n}).listen(1737);\n\nconsole.log('is runing post.js: localhost:1737');\n```\n\n","source":"_posts/Nodejs学习笔记1——socket.io模块、url模块.md","raw":"---\ntitle: Nodejs学习笔记1——socket.io模块、url模块\ntags: [nodejs]\ndate: 2016/02/05\n---\n\n### socket.io\n\n>该模块主要应用于实时的长连接多请求项目中，例如在线联网游戏、实时聊天、实时股票查看、二维扫描登录等。\n\n**Server:**\n\n```\nvar io = require('socket.io').listen(3000);\n\nio.sockets.on('connection', function(socket){\n  socket.on('server', function(data){\n\tio.sockets.emit('client', data);//io.sockets.emit()用于群发广播，io.socket.emit()点对点发送广播。\n  });\n  io.sockets.emit('client', 'index is connectioned!');\n});\n```\n\n**Client:**\n\n```\n<h3>is running!</h3>\n\t\n\t<input type=\"text\" id=\"msg\" value=\"\" />\n\t<input type=\"button\" id=\"sendMsg\" value=\"send message\" onclick=\"sendMsg()\" />\n\t\n\t<textarea id=\"msgList\"></textarea>\n\t\n\t<script src=\"//cdn.bootcss.com/socket.io/1.3.6/socket.io.min.js\"></script>\n\t<script>\n\tvar socket=io.connect('http://localhost:3000');\n\t\n\tvar msg='';\n\tvar flag=false;\n\t\n\tsocket.on('connect',function(){\n\t\tsocket.on('client',function(data){\n\t\t\tconsole.log(data);\n\t\t\t\n\t\t\tvar obj=document.getElementById('msgList');\n\t\t\t\n\t\t\tvar msgs=obj.value+data;\n\t\t\tobj.value=msgs;\n\t\t});\n\t});\n\t\n\tsocket.emit('server','i am come in.');\n\t\n\tfunction sendMsg(){\n\t\tvar obj=document.getElementById('msg');\n\t\tmsg=obj.value;\n\t\t\n\t\tif(msg==''){\n\t\t\talert('is empty!');\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tflag=true;\n\t\t\n\t\tsocket.emit('server',msg);\n\t}\n\t</script>\n```\n\n### url\n\n>解释url的模块。\n\n### querystring\n\n>转换地址参数格式的模块。\n\n```\nvar url=require('url');\nvar http=require('http');\nvar querystring=require('querystring');\n\n//以localhost:1737/index.html?key=1&value=2为例\nhttp.createServer(function(req,res){\n\tvar reqUrl=req.url;\n\t\n\tconsole.log(url.parse(reqUrl));\n\tconsole.log(url.parse(reqUrl).pathname);//返回/index.html\n\tconsole.log(querystring.parse(url.parse(reqUrl).query));//返回{key:1,value:2}\n\t\n\tres.writeHead(200,{'Content-Type':'text/html'});\n\tres.end('Hello!');\n}).listen(1737);\n\nconsole.log('is running: localhost:1737');\n```\n\n### POST请求\n\n>Node.js为了使整个过程非阻塞，会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块有序传递给加调函数。\n\n\n\n>这部分涉及request对象中的addListener方法，该方法有两个事件参数data和end，data表示数据传输开始，end表示数据传输结束。\n\n```\nvar http=require('http');\nvar querystring=require('querystring');\n\nhttp.createServer(function(req,res){\n\tvar postData='';\n\t\n\treq.setEncoding('utf8');\n\t\n\treq.addListener('data',function(data){\n\t\tpostData+=data;\n\t});\n\t\n\treq.addListener('end',function(data){\n\t\tconsole.log(querystring.parse(postData));\n\t});\n\t\n\tres.writeHead(200,{'Content-Type':'text/plain'});\n\tres.end('Hello World\\n');\n}).listen(1737);\n\nconsole.log('is runing post.js: localhost:1737');\n```\n\n","slug":"Nodejs学习笔记1——socket.io模块、url模块","published":1,"updated":"2016-08-17T06:22:19.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpiy001l68ddhylfd14h","content":"<h3 id=\"socket-io\"><a href=\"#socket-io\" class=\"headerlink\" title=\"socket.io\"></a>socket.io</h3><blockquote>\n<p>该模块主要应用于实时的长连接多请求项目中，例如在线联网游戏、实时聊天、实时股票查看、二维扫描登录等。</p>\n</blockquote>\n<p><strong>Server:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var io = require(&apos;socket.io&apos;).listen(3000);</div><div class=\"line\"></div><div class=\"line\">io.sockets.on(&apos;connection&apos;, function(socket)&#123;</div><div class=\"line\">  socket.on(&apos;server&apos;, function(data)&#123;</div><div class=\"line\">\tio.sockets.emit(&apos;client&apos;, data);//io.sockets.emit()用于群发广播，io.socket.emit()点对点发送广播。</div><div class=\"line\">  &#125;);</div><div class=\"line\">  io.sockets.emit(&apos;client&apos;, &apos;index is connectioned!&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>Client:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;h3&gt;is running!&lt;/h3&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;input type=&quot;text&quot; id=&quot;msg&quot; value=&quot;&quot; /&gt;</div><div class=\"line\">\t&lt;input type=&quot;button&quot; id=&quot;sendMsg&quot; value=&quot;send message&quot; onclick=&quot;sendMsg()&quot; /&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;textarea id=&quot;msgList&quot;&gt;&lt;/textarea&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;script src=&quot;//cdn.bootcss.com/socket.io/1.3.6/socket.io.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">\t&lt;script&gt;</div><div class=\"line\">\tvar socket=io.connect(&apos;http://localhost:3000&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\tvar msg=&apos;&apos;;</div><div class=\"line\">\tvar flag=false;</div><div class=\"line\">\t</div><div class=\"line\">\tsocket.on(&apos;connect&apos;,function()&#123;</div><div class=\"line\">\t\tsocket.on(&apos;client&apos;,function(data)&#123;</div><div class=\"line\">\t\t\tconsole.log(data);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tvar obj=document.getElementById(&apos;msgList&apos;);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tvar msgs=obj.value+data;</div><div class=\"line\">\t\t\tobj.value=msgs;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\tsocket.emit(&apos;server&apos;,&apos;i am come in.&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\tfunction sendMsg()&#123;</div><div class=\"line\">\t\tvar obj=document.getElementById(&apos;msg&apos;);</div><div class=\"line\">\t\tmsg=obj.value;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tif(msg==&apos;&apos;)&#123;</div><div class=\"line\">\t\t\talert(&apos;is empty!&apos;);</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tflag=true;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsocket.emit(&apos;server&apos;,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/script&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><blockquote>\n<p>解释url的模块。</p>\n</blockquote>\n<h3 id=\"querystring\"><a href=\"#querystring\" class=\"headerlink\" title=\"querystring\"></a>querystring</h3><blockquote>\n<p>转换地址参数格式的模块。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var url=require(&apos;url&apos;);</div><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var querystring=require(&apos;querystring&apos;);</div><div class=\"line\"></div><div class=\"line\">//以localhost:1737/index.html?key=1&amp;value=2为例</div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">\tvar reqUrl=req.url;</div><div class=\"line\">\t</div><div class=\"line\">\tconsole.log(url.parse(reqUrl));</div><div class=\"line\">\tconsole.log(url.parse(reqUrl).pathname);//返回/index.html</div><div class=\"line\">\tconsole.log(querystring.parse(url.parse(reqUrl).query));//返回&#123;key:1,value:2&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tres.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html&apos;&#125;);</div><div class=\"line\">\tres.end(&apos;Hello!&apos;);</div><div class=\"line\">&#125;).listen(1737);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;is running: localhost:1737&apos;);</div></pre></td></tr></table></figure>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><blockquote>\n<p>Node.js为了使整个过程非阻塞，会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块有序传递给加调函数。</p>\n<p>这部分涉及request对象中的addListener方法，该方法有两个事件参数data和end，data表示数据传输开始，end表示数据传输结束。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var querystring=require(&apos;querystring&apos;);</div><div class=\"line\"></div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">\tvar postData=&apos;&apos;;</div><div class=\"line\">\t</div><div class=\"line\">\treq.setEncoding(&apos;utf8&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\treq.addListener(&apos;data&apos;,function(data)&#123;</div><div class=\"line\">\t\tpostData+=data;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\treq.addListener(&apos;end&apos;,function(data)&#123;</div><div class=\"line\">\t\tconsole.log(querystring.parse(postData));</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\tres.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;);</div><div class=\"line\">\tres.end(&apos;Hello World\\n&apos;);</div><div class=\"line\">&#125;).listen(1737);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;is runing post.js: localhost:1737&apos;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h3 id=\"socket-io\"><a href=\"#socket-io\" class=\"headerlink\" title=\"socket.io\"></a>socket.io</h3><blockquote>\n<p>该模块主要应用于实时的长连接多请求项目中，例如在线联网游戏、实时聊天、实时股票查看、二维扫描登录等。</p>\n</blockquote>\n<p><strong>Server:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var io = require(&apos;socket.io&apos;).listen(3000);</div><div class=\"line\"></div><div class=\"line\">io.sockets.on(&apos;connection&apos;, function(socket)&#123;</div><div class=\"line\">  socket.on(&apos;server&apos;, function(data)&#123;</div><div class=\"line\">\tio.sockets.emit(&apos;client&apos;, data);//io.sockets.emit()用于群发广播，io.socket.emit()点对点发送广播。</div><div class=\"line\">  &#125;);</div><div class=\"line\">  io.sockets.emit(&apos;client&apos;, &apos;index is connectioned!&apos;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>Client:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;h3&gt;is running!&lt;/h3&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;input type=&quot;text&quot; id=&quot;msg&quot; value=&quot;&quot; /&gt;</div><div class=\"line\">\t&lt;input type=&quot;button&quot; id=&quot;sendMsg&quot; value=&quot;send message&quot; onclick=&quot;sendMsg()&quot; /&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;textarea id=&quot;msgList&quot;&gt;&lt;/textarea&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;script src=&quot;//cdn.bootcss.com/socket.io/1.3.6/socket.io.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">\t&lt;script&gt;</div><div class=\"line\">\tvar socket=io.connect(&apos;http://localhost:3000&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\tvar msg=&apos;&apos;;</div><div class=\"line\">\tvar flag=false;</div><div class=\"line\">\t</div><div class=\"line\">\tsocket.on(&apos;connect&apos;,function()&#123;</div><div class=\"line\">\t\tsocket.on(&apos;client&apos;,function(data)&#123;</div><div class=\"line\">\t\t\tconsole.log(data);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tvar obj=document.getElementById(&apos;msgList&apos;);</div><div class=\"line\">\t\t\t</div><div class=\"line\">\t\t\tvar msgs=obj.value+data;</div><div class=\"line\">\t\t\tobj.value=msgs;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\tsocket.emit(&apos;server&apos;,&apos;i am come in.&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\tfunction sendMsg()&#123;</div><div class=\"line\">\t\tvar obj=document.getElementById(&apos;msg&apos;);</div><div class=\"line\">\t\tmsg=obj.value;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tif(msg==&apos;&apos;)&#123;</div><div class=\"line\">\t\t\talert(&apos;is empty!&apos;);</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tflag=true;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tsocket.emit(&apos;server&apos;,msg);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/script&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"url\"><a href=\"#url\" class=\"headerlink\" title=\"url\"></a>url</h3><blockquote>\n<p>解释url的模块。</p>\n</blockquote>\n<h3 id=\"querystring\"><a href=\"#querystring\" class=\"headerlink\" title=\"querystring\"></a>querystring</h3><blockquote>\n<p>转换地址参数格式的模块。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var url=require(&apos;url&apos;);</div><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var querystring=require(&apos;querystring&apos;);</div><div class=\"line\"></div><div class=\"line\">//以localhost:1737/index.html?key=1&amp;value=2为例</div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">\tvar reqUrl=req.url;</div><div class=\"line\">\t</div><div class=\"line\">\tconsole.log(url.parse(reqUrl));</div><div class=\"line\">\tconsole.log(url.parse(reqUrl).pathname);//返回/index.html</div><div class=\"line\">\tconsole.log(querystring.parse(url.parse(reqUrl).query));//返回&#123;key:1,value:2&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tres.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/html&apos;&#125;);</div><div class=\"line\">\tres.end(&apos;Hello!&apos;);</div><div class=\"line\">&#125;).listen(1737);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;is running: localhost:1737&apos;);</div></pre></td></tr></table></figure>\n<h3 id=\"POST请求\"><a href=\"#POST请求\" class=\"headerlink\" title=\"POST请求\"></a>POST请求</h3><blockquote>\n<p>Node.js为了使整个过程非阻塞，会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块有序传递给加调函数。</p>\n<p>这部分涉及request对象中的addListener方法，该方法有两个事件参数data和end，data表示数据传输开始，end表示数据传输结束。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var querystring=require(&apos;querystring&apos;);</div><div class=\"line\"></div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">\tvar postData=&apos;&apos;;</div><div class=\"line\">\t</div><div class=\"line\">\treq.setEncoding(&apos;utf8&apos;);</div><div class=\"line\">\t</div><div class=\"line\">\treq.addListener(&apos;data&apos;,function(data)&#123;</div><div class=\"line\">\t\tpostData+=data;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\treq.addListener(&apos;end&apos;,function(data)&#123;</div><div class=\"line\">\t\tconsole.log(querystring.parse(postData));</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t</div><div class=\"line\">\tres.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;);</div><div class=\"line\">\tres.end(&apos;Hello World\\n&apos;);</div><div class=\"line\">&#125;).listen(1737);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;is runing post.js: localhost:1737&apos;);</div></pre></td></tr></table></figure>\n"},{"title":"Nodejs学习笔记2——文件上传","date":"2016-02-05T16:00:00.000Z","_content":"\n使用的模块：\n\n+ http\n+ node-static\n+ formidable\n+ fs\n\n代码：\n\n```\nvar http=require('http');\nvar nstatic = require('node-static');//静态页面访问\nvar formidable = require('formidable');//文件上传\nvar fs=require('fs');//文件操作\n\nvar fileServer = new nstatic.Server('./');//静态页面存放路径\n\nhttp.createServer(function(req,res){\n    var form = new formidable.IncomingForm();//初始化方文件上传模块\n    \n    form.uploadDir = \"./upload/\";//配置上传文件存放路径\n    \n    //从request中获取上传的文件信息，处理\n    form.parse(req, function(err, fields, files) {\n        if(err){\n            console.log(err.message);\n            throw err;\n        }\n        \n        console.log(files);\n        \n        for(var i in files){\n            var f=files[i];//存放文件信息的对象\n            var size=f.size;//文件大小\n            var type=f.type.split('/')[1];//文件类型，image/jpeg，取斜线后的字符串作为判断基准\n            var path=f.path;//文件存放路径\n            \n            console.log(type);\n            \n            switch (type) {\n                case 'jpeg':\n                \t//增加扩展名\n                    fs.rename(path,path+'.jpg',function(err){\n                        if(err) throw err;\n                    });\n                    break;\n                case 'png':\n                \t//增加扩展名\n                    fs.rename(path,path+'.png',function(err){\n                        if(err) throw err;\n                    });\n                    break;\n                default:\n                \t//其它类型的文件删除\n                    var exists=fs.existsSync(path);//文件是否存在\n                    \n                    if(exists){\n                    \t//文件删除\n                        fs.unlink(path,function(err){\n                            if(err) throw err;\n                            \n                            console.log('successfully deleted ',path);\n                        });\n                    } \n            }\n        }\n    });\n    \n    //监听end事件，使用node-static模块，返回静态页面\n    req.addListener('end', function () {\n        fileServer.serve(req, res);\n    }).resume();\n}).listen(8080);\n\nconsole.log('current listen:','0.0.0.0:8080');\n```\n","source":"_posts/Nodejs学习笔记2——文件上传.md","raw":"---\ntitle: Nodejs学习笔记2——文件上传\ntags: [nodejs]\ndate: 2016/02/06\n---\n\n使用的模块：\n\n+ http\n+ node-static\n+ formidable\n+ fs\n\n代码：\n\n```\nvar http=require('http');\nvar nstatic = require('node-static');//静态页面访问\nvar formidable = require('formidable');//文件上传\nvar fs=require('fs');//文件操作\n\nvar fileServer = new nstatic.Server('./');//静态页面存放路径\n\nhttp.createServer(function(req,res){\n    var form = new formidable.IncomingForm();//初始化方文件上传模块\n    \n    form.uploadDir = \"./upload/\";//配置上传文件存放路径\n    \n    //从request中获取上传的文件信息，处理\n    form.parse(req, function(err, fields, files) {\n        if(err){\n            console.log(err.message);\n            throw err;\n        }\n        \n        console.log(files);\n        \n        for(var i in files){\n            var f=files[i];//存放文件信息的对象\n            var size=f.size;//文件大小\n            var type=f.type.split('/')[1];//文件类型，image/jpeg，取斜线后的字符串作为判断基准\n            var path=f.path;//文件存放路径\n            \n            console.log(type);\n            \n            switch (type) {\n                case 'jpeg':\n                \t//增加扩展名\n                    fs.rename(path,path+'.jpg',function(err){\n                        if(err) throw err;\n                    });\n                    break;\n                case 'png':\n                \t//增加扩展名\n                    fs.rename(path,path+'.png',function(err){\n                        if(err) throw err;\n                    });\n                    break;\n                default:\n                \t//其它类型的文件删除\n                    var exists=fs.existsSync(path);//文件是否存在\n                    \n                    if(exists){\n                    \t//文件删除\n                        fs.unlink(path,function(err){\n                            if(err) throw err;\n                            \n                            console.log('successfully deleted ',path);\n                        });\n                    } \n            }\n        }\n    });\n    \n    //监听end事件，使用node-static模块，返回静态页面\n    req.addListener('end', function () {\n        fileServer.serve(req, res);\n    }).resume();\n}).listen(8080);\n\nconsole.log('current listen:','0.0.0.0:8080');\n```\n","slug":"Nodejs学习笔记2——文件上传","published":1,"updated":"2016-08-17T06:22:19.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpj0001n68ddar8g36kl","content":"<p>使用的模块：</p>\n<ul>\n<li>http</li>\n<li>node-static</li>\n<li>formidable</li>\n<li>fs</li>\n</ul>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var nstatic = require(&apos;node-static&apos;);//静态页面访问</div><div class=\"line\">var formidable = require(&apos;formidable&apos;);//文件上传</div><div class=\"line\">var fs=require(&apos;fs&apos;);//文件操作</div><div class=\"line\"></div><div class=\"line\">var fileServer = new nstatic.Server(&apos;./&apos;);//静态页面存放路径</div><div class=\"line\"></div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">    var form = new formidable.IncomingForm();//初始化方文件上传模块</div><div class=\"line\">    </div><div class=\"line\">    form.uploadDir = &quot;./upload/&quot;;//配置上传文件存放路径</div><div class=\"line\">    </div><div class=\"line\">    //从request中获取上传的文件信息，处理</div><div class=\"line\">    form.parse(req, function(err, fields, files) &#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            console.log(err.message);</div><div class=\"line\">            throw err;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        console.log(files);</div><div class=\"line\">        </div><div class=\"line\">        for(var i in files)&#123;</div><div class=\"line\">            var f=files[i];//存放文件信息的对象</div><div class=\"line\">            var size=f.size;//文件大小</div><div class=\"line\">            var type=f.type.split(&apos;/&apos;)[1];//文件类型，image/jpeg，取斜线后的字符串作为判断基准</div><div class=\"line\">            var path=f.path;//文件存放路径</div><div class=\"line\">            </div><div class=\"line\">            console.log(type);</div><div class=\"line\">            </div><div class=\"line\">            switch (type) &#123;</div><div class=\"line\">                case &apos;jpeg&apos;:</div><div class=\"line\">                \t//增加扩展名</div><div class=\"line\">                    fs.rename(path,path+&apos;.jpg&apos;,function(err)&#123;</div><div class=\"line\">                        if(err) throw err;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                    break;</div><div class=\"line\">                case &apos;png&apos;:</div><div class=\"line\">                \t//增加扩展名</div><div class=\"line\">                    fs.rename(path,path+&apos;.png&apos;,function(err)&#123;</div><div class=\"line\">                        if(err) throw err;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                \t//其它类型的文件删除</div><div class=\"line\">                    var exists=fs.existsSync(path);//文件是否存在</div><div class=\"line\">                    </div><div class=\"line\">                    if(exists)&#123;</div><div class=\"line\">                    \t//文件删除</div><div class=\"line\">                        fs.unlink(path,function(err)&#123;</div><div class=\"line\">                            if(err) throw err;</div><div class=\"line\">                            </div><div class=\"line\">                            console.log(&apos;successfully deleted &apos;,path);</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125; </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //监听end事件，使用node-static模块，返回静态页面</div><div class=\"line\">    req.addListener(&apos;end&apos;, function () &#123;</div><div class=\"line\">        fileServer.serve(req, res);</div><div class=\"line\">    &#125;).resume();</div><div class=\"line\">&#125;).listen(8080);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;current listen:&apos;,&apos;0.0.0.0:8080&apos;);</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>使用的模块：</p>\n<ul>\n<li>http</li>\n<li>node-static</li>\n<li>formidable</li>\n<li>fs</li>\n</ul>\n<p>代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var http=require(&apos;http&apos;);</div><div class=\"line\">var nstatic = require(&apos;node-static&apos;);//静态页面访问</div><div class=\"line\">var formidable = require(&apos;formidable&apos;);//文件上传</div><div class=\"line\">var fs=require(&apos;fs&apos;);//文件操作</div><div class=\"line\"></div><div class=\"line\">var fileServer = new nstatic.Server(&apos;./&apos;);//静态页面存放路径</div><div class=\"line\"></div><div class=\"line\">http.createServer(function(req,res)&#123;</div><div class=\"line\">    var form = new formidable.IncomingForm();//初始化方文件上传模块</div><div class=\"line\">    </div><div class=\"line\">    form.uploadDir = &quot;./upload/&quot;;//配置上传文件存放路径</div><div class=\"line\">    </div><div class=\"line\">    //从request中获取上传的文件信息，处理</div><div class=\"line\">    form.parse(req, function(err, fields, files) &#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            console.log(err.message);</div><div class=\"line\">            throw err;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        console.log(files);</div><div class=\"line\">        </div><div class=\"line\">        for(var i in files)&#123;</div><div class=\"line\">            var f=files[i];//存放文件信息的对象</div><div class=\"line\">            var size=f.size;//文件大小</div><div class=\"line\">            var type=f.type.split(&apos;/&apos;)[1];//文件类型，image/jpeg，取斜线后的字符串作为判断基准</div><div class=\"line\">            var path=f.path;//文件存放路径</div><div class=\"line\">            </div><div class=\"line\">            console.log(type);</div><div class=\"line\">            </div><div class=\"line\">            switch (type) &#123;</div><div class=\"line\">                case &apos;jpeg&apos;:</div><div class=\"line\">                \t//增加扩展名</div><div class=\"line\">                    fs.rename(path,path+&apos;.jpg&apos;,function(err)&#123;</div><div class=\"line\">                        if(err) throw err;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                    break;</div><div class=\"line\">                case &apos;png&apos;:</div><div class=\"line\">                \t//增加扩展名</div><div class=\"line\">                    fs.rename(path,path+&apos;.png&apos;,function(err)&#123;</div><div class=\"line\">                        if(err) throw err;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                \t//其它类型的文件删除</div><div class=\"line\">                    var exists=fs.existsSync(path);//文件是否存在</div><div class=\"line\">                    </div><div class=\"line\">                    if(exists)&#123;</div><div class=\"line\">                    \t//文件删除</div><div class=\"line\">                        fs.unlink(path,function(err)&#123;</div><div class=\"line\">                            if(err) throw err;</div><div class=\"line\">                            </div><div class=\"line\">                            console.log(&apos;successfully deleted &apos;,path);</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125; </div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    //监听end事件，使用node-static模块，返回静态页面</div><div class=\"line\">    req.addListener(&apos;end&apos;, function () &#123;</div><div class=\"line\">        fileServer.serve(req, res);</div><div class=\"line\">    &#125;).resume();</div><div class=\"line\">&#125;).listen(8080);</div><div class=\"line\"></div><div class=\"line\">console.log(&apos;current listen:&apos;,&apos;0.0.0.0:8080&apos;);</div></pre></td></tr></table></figure>\n"},{"title":"Nodejs学习笔记3——基础路由的实现","date":"2016-02-06T16:00:00.000Z","_content":"\n### module/view.m.js\n>为模板加载模块。参数：file:模板名称；data:模板数据；callback(err,html):回调函数，html为数据加载后的网页内容。\n\n```\nvar path=require('path');//路径处理模块\nvar ejs=require('ejs');//模板引擎模块\nvar fs=require('fs');//文件操作模块\n\nfunction view(file,data,callback){\n    var baseDir='template/';//模板目录路径\n    \n    //如果模板文件名为空，则加载index.html模板文件\n    if(!file){\n        file=baseDir+'index.html';   \n    }else{\n        file=baseDir+file;   \n    }\n    \n    //读取指定模板文件，此处没有对模板文件的存在性处理\n    fs.readFile(file,{'encoding':'utf8'},function(err,d){\n        if(err){\n            callback(err,html);\n        }\n        \n        var html=ejs.render(d,data);//将模板数据写入模板文件，返回生成的字符串。\n    \n        callback(false,html);\n    });\n}\n\nmodule.exports=view;\n```\n\n### module/core.m.js\n>框架核心文件。现在只有路由功能。\n\n```\nvar path=require('path');\nvar url=require('url');//URL处理模块\nvar fs=require('fs');\n\nmodule.exports=function(req,res){\n    var pathname=url.parse(req.url,true).pathname;//获取路由\n    var query=url.parse(req.url,true).query;//获取参数\n    var dirname=path.dirname(pathname).split('/');//将路径各部分存为数组，以用来做跳转\n    var basename=path.basename(pathname,'.html');//获取以.html结尾的文件名\n    var controllPath='controll/';//控制器目录\n    var filename=controllPath+'index.c.js';//生成控制器文件名\n    var method='index';//默认调用index方法\n    \n    //此处为路由规则，详见最后说明。\n    if(dirname.length>1){\n        if(dirname[1]){\n            filename=controllPath+dirname[1]+'.c.js';\n        }\n        \n        if(dirname[2]){\n            method=dirname[2];\n        }\n        \n        for(var i=3;i<dirname.length;i=i+2){\n            if(dirname[i] && dirname[i+1]){\n                query[dirname[i]]=dirname[i+1];\n            }\n        }\n    }\n    \n    fs.open(filename,'r',function(err,df){\n       if(err){\n           res.writeHead(404);\n           res.end('not the page!');\n       }\n       \n       var inControll=require('../'+filename);\n       \n       if(!inControll[method]){\n           res.writeHead(404);\n           res.end('not the page!');\n       }\n       \n       inControll[method](req,res,query);\n    });\n}\n```\n\n### template/\n>模板目录\n\n### controll/\n>控制器目录。\n\n### controll/index.c.js\n>默认控制器。访问网站时默认加载的控制器。\n\n```\nvar view=require('../module/view.m.js');\n\nfunction controll(){}\n\ncontroll.prototype.index=function(req,res,params){\n    view('../template/index.html',{data:{name:'Lion'}},function(err,html){\n        if(err){\n            console.log(err.message);\n            throw err;\n        }\n       \n       res.end(html);\n    });    \n}\n\nmodule.exports=new controll();\n\n```\n\n> 控制器说明：以localhost:8080/index/index/index.html为例\n\n1. 路径部分的第一位为控制器名，第二位为控制器中的方法名，第三位之后为参数，会以key-value的JSON对象形式按一定顺序（见第3条）传给方法。\n2. 控制器中的方法会默认传三个参数，第一个第二个为http.createServer中的requrest与response对象，第三个为参数JSON对象。\n3. 对于参数的说明：\n\n+ /index/index/a/b，此路径表示没有参数，b以文件名处理，a为key，但此key没有value，所以，忽略。\n+ /index/index/a/b/，此路径与上同，b仍然以文件名处理。\n+ /index/index/a/b/c，此路径中，a为key，b为value，c为文件名，参数返回：```{\"a\":\"b\"}```\n+ /index/index/a/1/b/2/index.html?c=3&d=4，此路径中，a、b、c、d为key，1、2、3、4为value。\n+ 在上述路径中，参数返回（顺序）：```{\"c\":\"3\",\"d\":\"4\",\"a\":\"1\",\"b\":\"2\"}```","source":"_posts/Nodejs学习笔记3——基础路由的实现.md","raw":"---\ntitle: Nodejs学习笔记3——基础路由的实现\ntags: [nodejs]\ndate: 2016/02/07\n---\n\n### module/view.m.js\n>为模板加载模块。参数：file:模板名称；data:模板数据；callback(err,html):回调函数，html为数据加载后的网页内容。\n\n```\nvar path=require('path');//路径处理模块\nvar ejs=require('ejs');//模板引擎模块\nvar fs=require('fs');//文件操作模块\n\nfunction view(file,data,callback){\n    var baseDir='template/';//模板目录路径\n    \n    //如果模板文件名为空，则加载index.html模板文件\n    if(!file){\n        file=baseDir+'index.html';   \n    }else{\n        file=baseDir+file;   \n    }\n    \n    //读取指定模板文件，此处没有对模板文件的存在性处理\n    fs.readFile(file,{'encoding':'utf8'},function(err,d){\n        if(err){\n            callback(err,html);\n        }\n        \n        var html=ejs.render(d,data);//将模板数据写入模板文件，返回生成的字符串。\n    \n        callback(false,html);\n    });\n}\n\nmodule.exports=view;\n```\n\n### module/core.m.js\n>框架核心文件。现在只有路由功能。\n\n```\nvar path=require('path');\nvar url=require('url');//URL处理模块\nvar fs=require('fs');\n\nmodule.exports=function(req,res){\n    var pathname=url.parse(req.url,true).pathname;//获取路由\n    var query=url.parse(req.url,true).query;//获取参数\n    var dirname=path.dirname(pathname).split('/');//将路径各部分存为数组，以用来做跳转\n    var basename=path.basename(pathname,'.html');//获取以.html结尾的文件名\n    var controllPath='controll/';//控制器目录\n    var filename=controllPath+'index.c.js';//生成控制器文件名\n    var method='index';//默认调用index方法\n    \n    //此处为路由规则，详见最后说明。\n    if(dirname.length>1){\n        if(dirname[1]){\n            filename=controllPath+dirname[1]+'.c.js';\n        }\n        \n        if(dirname[2]){\n            method=dirname[2];\n        }\n        \n        for(var i=3;i<dirname.length;i=i+2){\n            if(dirname[i] && dirname[i+1]){\n                query[dirname[i]]=dirname[i+1];\n            }\n        }\n    }\n    \n    fs.open(filename,'r',function(err,df){\n       if(err){\n           res.writeHead(404);\n           res.end('not the page!');\n       }\n       \n       var inControll=require('../'+filename);\n       \n       if(!inControll[method]){\n           res.writeHead(404);\n           res.end('not the page!');\n       }\n       \n       inControll[method](req,res,query);\n    });\n}\n```\n\n### template/\n>模板目录\n\n### controll/\n>控制器目录。\n\n### controll/index.c.js\n>默认控制器。访问网站时默认加载的控制器。\n\n```\nvar view=require('../module/view.m.js');\n\nfunction controll(){}\n\ncontroll.prototype.index=function(req,res,params){\n    view('../template/index.html',{data:{name:'Lion'}},function(err,html){\n        if(err){\n            console.log(err.message);\n            throw err;\n        }\n       \n       res.end(html);\n    });    \n}\n\nmodule.exports=new controll();\n\n```\n\n> 控制器说明：以localhost:8080/index/index/index.html为例\n\n1. 路径部分的第一位为控制器名，第二位为控制器中的方法名，第三位之后为参数，会以key-value的JSON对象形式按一定顺序（见第3条）传给方法。\n2. 控制器中的方法会默认传三个参数，第一个第二个为http.createServer中的requrest与response对象，第三个为参数JSON对象。\n3. 对于参数的说明：\n\n+ /index/index/a/b，此路径表示没有参数，b以文件名处理，a为key，但此key没有value，所以，忽略。\n+ /index/index/a/b/，此路径与上同，b仍然以文件名处理。\n+ /index/index/a/b/c，此路径中，a为key，b为value，c为文件名，参数返回：```{\"a\":\"b\"}```\n+ /index/index/a/1/b/2/index.html?c=3&d=4，此路径中，a、b、c、d为key，1、2、3、4为value。\n+ 在上述路径中，参数返回（顺序）：```{\"c\":\"3\",\"d\":\"4\",\"a\":\"1\",\"b\":\"2\"}```","slug":"Nodejs学习笔记3——基础路由的实现","published":1,"updated":"2016-08-17T06:22:19.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpj2001p68dd8arto6yb","content":"<h3 id=\"module-view-m-js\"><a href=\"#module-view-m-js\" class=\"headerlink\" title=\"module/view.m.js\"></a>module/view.m.js</h3><blockquote>\n<p>为模板加载模块。参数：file:模板名称；data:模板数据；callback(err,html):回调函数，html为数据加载后的网页内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var path=require(&apos;path&apos;);//路径处理模块</div><div class=\"line\">var ejs=require(&apos;ejs&apos;);//模板引擎模块</div><div class=\"line\">var fs=require(&apos;fs&apos;);//文件操作模块</div><div class=\"line\"></div><div class=\"line\">function view(file,data,callback)&#123;</div><div class=\"line\">    var baseDir=&apos;template/&apos;;//模板目录路径</div><div class=\"line\">    </div><div class=\"line\">    //如果模板文件名为空，则加载index.html模板文件</div><div class=\"line\">    if(!file)&#123;</div><div class=\"line\">        file=baseDir+&apos;index.html&apos;;   </div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        file=baseDir+file;   </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //读取指定模板文件，此处没有对模板文件的存在性处理</div><div class=\"line\">    fs.readFile(file,&#123;&apos;encoding&apos;:&apos;utf8&apos;&#125;,function(err,d)&#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            callback(err,html);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        var html=ejs.render(d,data);//将模板数据写入模板文件，返回生成的字符串。</div><div class=\"line\">    </div><div class=\"line\">        callback(false,html);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports=view;</div></pre></td></tr></table></figure>\n<h3 id=\"module-core-m-js\"><a href=\"#module-core-m-js\" class=\"headerlink\" title=\"module/core.m.js\"></a>module/core.m.js</h3><blockquote>\n<p>框架核心文件。现在只有路由功能。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var path=require(&apos;path&apos;);</div><div class=\"line\">var url=require(&apos;url&apos;);//URL处理模块</div><div class=\"line\">var fs=require(&apos;fs&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports=function(req,res)&#123;</div><div class=\"line\">    var pathname=url.parse(req.url,true).pathname;//获取路由</div><div class=\"line\">    var query=url.parse(req.url,true).query;//获取参数</div><div class=\"line\">    var dirname=path.dirname(pathname).split(&apos;/&apos;);//将路径各部分存为数组，以用来做跳转</div><div class=\"line\">    var basename=path.basename(pathname,&apos;.html&apos;);//获取以.html结尾的文件名</div><div class=\"line\">    var controllPath=&apos;controll/&apos;;//控制器目录</div><div class=\"line\">    var filename=controllPath+&apos;index.c.js&apos;;//生成控制器文件名</div><div class=\"line\">    var method=&apos;index&apos;;//默认调用index方法</div><div class=\"line\">    </div><div class=\"line\">    //此处为路由规则，详见最后说明。</div><div class=\"line\">    if(dirname.length&gt;1)&#123;</div><div class=\"line\">        if(dirname[1])&#123;</div><div class=\"line\">            filename=controllPath+dirname[1]+&apos;.c.js&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if(dirname[2])&#123;</div><div class=\"line\">            method=dirname[2];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        for(var i=3;i&lt;dirname.length;i=i+2)&#123;</div><div class=\"line\">            if(dirname[i] &amp;&amp; dirname[i+1])&#123;</div><div class=\"line\">                query[dirname[i]]=dirname[i+1];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    fs.open(filename,&apos;r&apos;,function(err,df)&#123;</div><div class=\"line\">       if(err)&#123;</div><div class=\"line\">           res.writeHead(404);</div><div class=\"line\">           res.end(&apos;not the page!&apos;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       var inControll=require(&apos;../&apos;+filename);</div><div class=\"line\">       </div><div class=\"line\">       if(!inControll[method])&#123;</div><div class=\"line\">           res.writeHead(404);</div><div class=\"line\">           res.end(&apos;not the page!&apos;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       inControll[method](req,res,query);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template/\"></a>template/</h3><blockquote>\n<p>模板目录</p>\n</blockquote>\n<h3 id=\"controll\"><a href=\"#controll\" class=\"headerlink\" title=\"controll/\"></a>controll/</h3><blockquote>\n<p>控制器目录。</p>\n</blockquote>\n<h3 id=\"controll-index-c-js\"><a href=\"#controll-index-c-js\" class=\"headerlink\" title=\"controll/index.c.js\"></a>controll/index.c.js</h3><blockquote>\n<p>默认控制器。访问网站时默认加载的控制器。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var view=require(&apos;../module/view.m.js&apos;);</div><div class=\"line\"></div><div class=\"line\">function controll()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">controll.prototype.index=function(req,res,params)&#123;</div><div class=\"line\">    view(&apos;../template/index.html&apos;,&#123;data:&#123;name:&apos;Lion&apos;&#125;&#125;,function(err,html)&#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            console.log(err.message);</div><div class=\"line\">            throw err;</div><div class=\"line\">        &#125;</div><div class=\"line\">       </div><div class=\"line\">       res.end(html);</div><div class=\"line\">    &#125;);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports=new controll();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>控制器说明：以localhost:8080/index/index/index.html为例</p>\n</blockquote>\n<ol>\n<li>路径部分的第一位为控制器名，第二位为控制器中的方法名，第三位之后为参数，会以key-value的JSON对象形式按一定顺序（见第3条）传给方法。</li>\n<li>控制器中的方法会默认传三个参数，第一个第二个为http.createServer中的requrest与response对象，第三个为参数JSON对象。</li>\n<li>对于参数的说明：</li>\n</ol>\n<ul>\n<li>/index/index/a/b，此路径表示没有参数，b以文件名处理，a为key，但此key没有value，所以，忽略。</li>\n<li>/index/index/a/b/，此路径与上同，b仍然以文件名处理。</li>\n<li>/index/index/a/b/c，此路径中，a为key，b为value，c为文件名，参数返回：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ /index/index/a/1/b/2/index.html?c=3&amp;d=4，此路径中，a、b、c、d为key，1、2、3、4为value。</div><div class=\"line\">+ 在上述路径中，参数返回（顺序）：```&#123;&quot;c&quot;:&quot;3&quot;,&quot;d&quot;:&quot;4&quot;,&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n","excerpt":"","more":"<h3 id=\"module-view-m-js\"><a href=\"#module-view-m-js\" class=\"headerlink\" title=\"module/view.m.js\"></a>module/view.m.js</h3><blockquote>\n<p>为模板加载模块。参数：file:模板名称；data:模板数据；callback(err,html):回调函数，html为数据加载后的网页内容。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var path=require(&apos;path&apos;);//路径处理模块</div><div class=\"line\">var ejs=require(&apos;ejs&apos;);//模板引擎模块</div><div class=\"line\">var fs=require(&apos;fs&apos;);//文件操作模块</div><div class=\"line\"></div><div class=\"line\">function view(file,data,callback)&#123;</div><div class=\"line\">    var baseDir=&apos;template/&apos;;//模板目录路径</div><div class=\"line\">    </div><div class=\"line\">    //如果模板文件名为空，则加载index.html模板文件</div><div class=\"line\">    if(!file)&#123;</div><div class=\"line\">        file=baseDir+&apos;index.html&apos;;   </div><div class=\"line\">    &#125;else&#123;</div><div class=\"line\">        file=baseDir+file;   </div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    //读取指定模板文件，此处没有对模板文件的存在性处理</div><div class=\"line\">    fs.readFile(file,&#123;&apos;encoding&apos;:&apos;utf8&apos;&#125;,function(err,d)&#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            callback(err,html);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        var html=ejs.render(d,data);//将模板数据写入模板文件，返回生成的字符串。</div><div class=\"line\">    </div><div class=\"line\">        callback(false,html);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports=view;</div></pre></td></tr></table></figure>\n<h3 id=\"module-core-m-js\"><a href=\"#module-core-m-js\" class=\"headerlink\" title=\"module/core.m.js\"></a>module/core.m.js</h3><blockquote>\n<p>框架核心文件。现在只有路由功能。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var path=require(&apos;path&apos;);</div><div class=\"line\">var url=require(&apos;url&apos;);//URL处理模块</div><div class=\"line\">var fs=require(&apos;fs&apos;);</div><div class=\"line\"></div><div class=\"line\">module.exports=function(req,res)&#123;</div><div class=\"line\">    var pathname=url.parse(req.url,true).pathname;//获取路由</div><div class=\"line\">    var query=url.parse(req.url,true).query;//获取参数</div><div class=\"line\">    var dirname=path.dirname(pathname).split(&apos;/&apos;);//将路径各部分存为数组，以用来做跳转</div><div class=\"line\">    var basename=path.basename(pathname,&apos;.html&apos;);//获取以.html结尾的文件名</div><div class=\"line\">    var controllPath=&apos;controll/&apos;;//控制器目录</div><div class=\"line\">    var filename=controllPath+&apos;index.c.js&apos;;//生成控制器文件名</div><div class=\"line\">    var method=&apos;index&apos;;//默认调用index方法</div><div class=\"line\">    </div><div class=\"line\">    //此处为路由规则，详见最后说明。</div><div class=\"line\">    if(dirname.length&gt;1)&#123;</div><div class=\"line\">        if(dirname[1])&#123;</div><div class=\"line\">            filename=controllPath+dirname[1]+&apos;.c.js&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        if(dirname[2])&#123;</div><div class=\"line\">            method=dirname[2];</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        for(var i=3;i&lt;dirname.length;i=i+2)&#123;</div><div class=\"line\">            if(dirname[i] &amp;&amp; dirname[i+1])&#123;</div><div class=\"line\">                query[dirname[i]]=dirname[i+1];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    fs.open(filename,&apos;r&apos;,function(err,df)&#123;</div><div class=\"line\">       if(err)&#123;</div><div class=\"line\">           res.writeHead(404);</div><div class=\"line\">           res.end(&apos;not the page!&apos;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       var inControll=require(&apos;../&apos;+filename);</div><div class=\"line\">       </div><div class=\"line\">       if(!inControll[method])&#123;</div><div class=\"line\">           res.writeHead(404);</div><div class=\"line\">           res.end(&apos;not the page!&apos;);</div><div class=\"line\">       &#125;</div><div class=\"line\">       </div><div class=\"line\">       inControll[method](req,res,query);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template/\"></a>template/</h3><blockquote>\n<p>模板目录</p>\n</blockquote>\n<h3 id=\"controll\"><a href=\"#controll\" class=\"headerlink\" title=\"controll/\"></a>controll/</h3><blockquote>\n<p>控制器目录。</p>\n</blockquote>\n<h3 id=\"controll-index-c-js\"><a href=\"#controll-index-c-js\" class=\"headerlink\" title=\"controll/index.c.js\"></a>controll/index.c.js</h3><blockquote>\n<p>默认控制器。访问网站时默认加载的控制器。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var view=require(&apos;../module/view.m.js&apos;);</div><div class=\"line\"></div><div class=\"line\">function controll()&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">controll.prototype.index=function(req,res,params)&#123;</div><div class=\"line\">    view(&apos;../template/index.html&apos;,&#123;data:&#123;name:&apos;Lion&apos;&#125;&#125;,function(err,html)&#123;</div><div class=\"line\">        if(err)&#123;</div><div class=\"line\">            console.log(err.message);</div><div class=\"line\">            throw err;</div><div class=\"line\">        &#125;</div><div class=\"line\">       </div><div class=\"line\">       res.end(html);</div><div class=\"line\">    &#125;);    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">module.exports=new controll();</div></pre></td></tr></table></figure>\n<blockquote>\n<p>控制器说明：以localhost:8080/index/index/index.html为例</p>\n</blockquote>\n<ol>\n<li>路径部分的第一位为控制器名，第二位为控制器中的方法名，第三位之后为参数，会以key-value的JSON对象形式按一定顺序（见第3条）传给方法。</li>\n<li>控制器中的方法会默认传三个参数，第一个第二个为http.createServer中的requrest与response对象，第三个为参数JSON对象。</li>\n<li>对于参数的说明：</li>\n</ol>\n<ul>\n<li>/index/index/a/b，此路径表示没有参数，b以文件名处理，a为key，但此key没有value，所以，忽略。</li>\n<li>/index/index/a/b/，此路径与上同，b仍然以文件名处理。</li>\n<li>/index/index/a/b/c，此路径中，a为key，b为value，c为文件名，参数返回：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">+ /index/index/a/1/b/2/index.html?c=3&amp;d=4，此路径中，a、b、c、d为key，1、2、3、4为value。</div><div class=\"line\">+ 在上述路径中，参数返回（顺序）：```&#123;&quot;c&quot;:&quot;3&quot;,&quot;d&quot;:&quot;4&quot;,&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;&#125;</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Nodejs模板引擎关联扩展名","date":"2016-02-03T16:00:00.000Z","_content":"\nengine注册模板引擎的函数，处理指定的后缀名文件。\n\n```\n// 修改模板文件的后缀名为html\napp.set( 'view engine', 'html' );\n// 运行ejs模块\napp.engine( '.html', require( 'ejs' ).__express );\n```\n\n> \"__express\"，ejs模块的一个公共属性，表示要渲染的文件扩展名。\n","source":"_posts/Nodejs模板引擎关联扩展名.md","raw":"---\ntitle: Nodejs模板引擎关联扩展名\ntags: [nodejs]\ndate: 2016/02/04\n---\n\nengine注册模板引擎的函数，处理指定的后缀名文件。\n\n```\n// 修改模板文件的后缀名为html\napp.set( 'view engine', 'html' );\n// 运行ejs模块\napp.engine( '.html', require( 'ejs' ).__express );\n```\n\n> \"__express\"，ejs模块的一个公共属性，表示要渲染的文件扩展名。\n","slug":"Nodejs模板引擎关联扩展名","published":1,"updated":"2016-08-17T06:22:19.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpj4001s68ddbumvfkgn","content":"<p>engine注册模板引擎的函数，处理指定的后缀名文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 修改模板文件的后缀名为html</div><div class=\"line\">app.set( &apos;view engine&apos;, &apos;html&apos; );</div><div class=\"line\">// 运行ejs模块</div><div class=\"line\">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</div></pre></td></tr></table></figure>\n<blockquote>\n<p>“__express”，ejs模块的一个公共属性，表示要渲染的文件扩展名。</p>\n</blockquote>\n","excerpt":"","more":"<p>engine注册模板引擎的函数，处理指定的后缀名文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 修改模板文件的后缀名为html</div><div class=\"line\">app.set( &apos;view engine&apos;, &apos;html&apos; );</div><div class=\"line\">// 运行ejs模块</div><div class=\"line\">app.engine( &apos;.html&apos;, require( &apos;ejs&apos; ).__express );</div></pre></td></tr></table></figure>\n<blockquote>\n<p>“__express”，ejs模块的一个公共属性，表示要渲染的文件扩展名。</p>\n</blockquote>\n"},{"title":"SVN的Hooks功能——强制添加注释","date":"2013-09-08T16:00:00.000Z","_content":"\n1. 强制添加注释信息\n \n用户提交代码的动作，对应的是pre-commit。因此，可以修改pre-commit.tmpl文件。\n\n文 件名修改为pre-commit, Windows下可以修改为pre-commit.bat。这样可以让系统知道该文件时可执行文件。\n\n将文件中以下几行内容注释掉， 前面添加'#'\n\n```\n$SVN LOOK log -t \"$TXN\" \"$REPOS\" | \ngrep \"[a-zA-Z0-9]\" > /dev/null || exit 1 \ncommit-access-control.pl \"$REPOS\" \"$TXN\" commit-access-control.cfg || exit 1 \n```\n\n并在此位置添加如下几行： \n\n```\nLOGMSG=`$SVNLOOK log -t \"$TXN\" \"$REPOS\" | grep \"[a-zA-Z0-9]\" | wc -c` \nif [ \"$LOGMSG\" -lt 5 ];#要求注释不能少于5个字符（数字和字母），您可自定义 \nthen \n   echo -e \"nLog message cann't be empty! you must input more than 5 chars as comment!.\" 1>&2 \n   exit 1 \nfi\n```\n\n保存，退出。 \n\n给pre-commit添加可执行权限：\n\n``` \nchmod +x pre-commit \n```\n\n经过该设置，用户提交代码时注释信息小于5个字符将会得到警告，并且代码不会被提交到版本看\n","source":"_posts/SVN的Hooks功能——强制添加注释.md","raw":"---\ntitle: SVN的Hooks功能——强制添加注释\ntags: [linux,svn]\ndate: 2013/09/09\n---\n\n1. 强制添加注释信息\n \n用户提交代码的动作，对应的是pre-commit。因此，可以修改pre-commit.tmpl文件。\n\n文 件名修改为pre-commit, Windows下可以修改为pre-commit.bat。这样可以让系统知道该文件时可执行文件。\n\n将文件中以下几行内容注释掉， 前面添加'#'\n\n```\n$SVN LOOK log -t \"$TXN\" \"$REPOS\" | \ngrep \"[a-zA-Z0-9]\" > /dev/null || exit 1 \ncommit-access-control.pl \"$REPOS\" \"$TXN\" commit-access-control.cfg || exit 1 \n```\n\n并在此位置添加如下几行： \n\n```\nLOGMSG=`$SVNLOOK log -t \"$TXN\" \"$REPOS\" | grep \"[a-zA-Z0-9]\" | wc -c` \nif [ \"$LOGMSG\" -lt 5 ];#要求注释不能少于5个字符（数字和字母），您可自定义 \nthen \n   echo -e \"nLog message cann't be empty! you must input more than 5 chars as comment!.\" 1>&2 \n   exit 1 \nfi\n```\n\n保存，退出。 \n\n给pre-commit添加可执行权限：\n\n``` \nchmod +x pre-commit \n```\n\n经过该设置，用户提交代码时注释信息小于5个字符将会得到警告，并且代码不会被提交到版本看\n","slug":"SVN的Hooks功能——强制添加注释","published":1,"updated":"2016-08-17T06:22:19.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpj8001u68ddqb1j9g7u","content":"<ol>\n<li>强制添加注释信息</li>\n</ol>\n<p>用户提交代码的动作，对应的是pre-commit。因此，可以修改pre-commit.tmpl文件。</p>\n<p>文 件名修改为pre-commit, Windows下可以修改为pre-commit.bat。这样可以让系统知道该文件时可执行文件。</p>\n<p>将文件中以下几行内容注释掉， 前面添加’#’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$SVN LOOK log -t &quot;$TXN&quot; &quot;$REPOS&quot; | </div><div class=\"line\">grep &quot;[a-zA-Z0-9]&quot; &gt; /dev/null || exit 1 </div><div class=\"line\">commit-access-control.pl &quot;$REPOS&quot; &quot;$TXN&quot; commit-access-control.cfg || exit 1</div></pre></td></tr></table></figure>\n<p>并在此位置添加如下几行： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOGMSG=`$SVNLOOK log -t &quot;$TXN&quot; &quot;$REPOS&quot; | grep &quot;[a-zA-Z0-9]&quot; | wc -c` </div><div class=\"line\">if [ &quot;$LOGMSG&quot; -lt 5 ];#要求注释不能少于5个字符（数字和字母），您可自定义 </div><div class=\"line\">then </div><div class=\"line\">   echo -e &quot;nLog message cann&apos;t be empty! you must input more than 5 chars as comment!.&quot; 1&gt;&amp;2 </div><div class=\"line\">   exit 1 </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>保存，退出。 </p>\n<p>给pre-commit添加可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">chmod +x pre-commit</div></pre></td></tr></table></figure>\n<p>经过该设置，用户提交代码时注释信息小于5个字符将会得到警告，并且代码不会被提交到版本看</p>\n","excerpt":"","more":"<ol>\n<li>强制添加注释信息</li>\n</ol>\n<p>用户提交代码的动作，对应的是pre-commit。因此，可以修改pre-commit.tmpl文件。</p>\n<p>文 件名修改为pre-commit, Windows下可以修改为pre-commit.bat。这样可以让系统知道该文件时可执行文件。</p>\n<p>将文件中以下几行内容注释掉， 前面添加’#’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$SVN LOOK log -t &quot;$TXN&quot; &quot;$REPOS&quot; | </div><div class=\"line\">grep &quot;[a-zA-Z0-9]&quot; &gt; /dev/null || exit 1 </div><div class=\"line\">commit-access-control.pl &quot;$REPOS&quot; &quot;$TXN&quot; commit-access-control.cfg || exit 1</div></pre></td></tr></table></figure>\n<p>并在此位置添加如下几行： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">LOGMSG=`$SVNLOOK log -t &quot;$TXN&quot; &quot;$REPOS&quot; | grep &quot;[a-zA-Z0-9]&quot; | wc -c` </div><div class=\"line\">if [ &quot;$LOGMSG&quot; -lt 5 ];#要求注释不能少于5个字符（数字和字母），您可自定义 </div><div class=\"line\">then </div><div class=\"line\">   echo -e &quot;nLog message cann&apos;t be empty! you must input more than 5 chars as comment!.&quot; 1&gt;&amp;2 </div><div class=\"line\">   exit 1 </div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>保存，退出。 </p>\n<p>给pre-commit添加可执行权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">chmod +x pre-commit</div></pre></td></tr></table></figure>\n<p>经过该设置，用户提交代码时注释信息小于5个字符将会得到警告，并且代码不会被提交到版本看</p>\n"},{"title":"Unslider较完美支持bootstrap 3.3.0样式方案","date":"2015-05-20T16:00:00.000Z","_content":"\n效果图：\n\n![效果图](http://limeng.u.qiniudn.com/wp_220_01.png)\n\ncss样式：\n\n```\n    .banner {\n      position: relative;\n      overflow: auto;\n      padding: 0;\n    }\n    .banner li {\n      list-style: none;\n    }\n    .banner * {\n      -webkit-margin-before: 0;\n      -webkit-margin-after: 0;\n      -webkit-margin-start: 0;\n      -webkit-margin-end: 0;\n      -webkit-padding-start: 0;\n    }\n    .banner ul li {\n      float: left;\n      height: 248px;\n    }\n    .banner .dots{\n      position: absolute;\n      bottom: 0;\n      width: 100%;\n      text-align: center;\n    }\n    .banner .dot{\n      display: inline-block;\n      width: 24px;\n      height: 24px;\n      border-radius: 12px;\n      background-color: #ccc;\n      line-height: 24px;\n      text-align: center;\n      margin: 10px;\n    }\n    .banner .dot.active{\n      background-color: #333;\n      color: #fff;\n    }\n```\n","source":"_posts/Unslider较完美支持bootstrap 3.3.0样式方案.md","raw":"---\ntitle: Unslider较完美支持bootstrap 3.3.0样式方案\ntags: [css]\ndate: 2015/05/21\n---\n\n效果图：\n\n![效果图](http://limeng.u.qiniudn.com/wp_220_01.png)\n\ncss样式：\n\n```\n    .banner {\n      position: relative;\n      overflow: auto;\n      padding: 0;\n    }\n    .banner li {\n      list-style: none;\n    }\n    .banner * {\n      -webkit-margin-before: 0;\n      -webkit-margin-after: 0;\n      -webkit-margin-start: 0;\n      -webkit-margin-end: 0;\n      -webkit-padding-start: 0;\n    }\n    .banner ul li {\n      float: left;\n      height: 248px;\n    }\n    .banner .dots{\n      position: absolute;\n      bottom: 0;\n      width: 100%;\n      text-align: center;\n    }\n    .banner .dot{\n      display: inline-block;\n      width: 24px;\n      height: 24px;\n      border-radius: 12px;\n      background-color: #ccc;\n      line-height: 24px;\n      text-align: center;\n      margin: 10px;\n    }\n    .banner .dot.active{\n      background-color: #333;\n      color: #fff;\n    }\n```\n","slug":"Unslider较完美支持bootstrap 3.3.0样式方案","published":1,"updated":"2016-08-17T06:22:19.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjb001x68ddy3cnxi51","content":"<p>效果图：</p>\n<p><img src=\"http://limeng.u.qiniudn.com/wp_220_01.png\" alt=\"效果图\"></p>\n<p>css样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.banner &#123;</div><div class=\"line\">  position: relative;</div><div class=\"line\">  overflow: auto;</div><div class=\"line\">  padding: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner li &#123;</div><div class=\"line\">  list-style: none;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner * &#123;</div><div class=\"line\">  -webkit-margin-before: 0;</div><div class=\"line\">  -webkit-margin-after: 0;</div><div class=\"line\">  -webkit-margin-start: 0;</div><div class=\"line\">  -webkit-margin-end: 0;</div><div class=\"line\">  -webkit-padding-start: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner ul li &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">  height: 248px;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dots&#123;</div><div class=\"line\">  position: absolute;</div><div class=\"line\">  bottom: 0;</div><div class=\"line\">  width: 100%;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dot&#123;</div><div class=\"line\">  display: inline-block;</div><div class=\"line\">  width: 24px;</div><div class=\"line\">  height: 24px;</div><div class=\"line\">  border-radius: 12px;</div><div class=\"line\">  background-color: #ccc;</div><div class=\"line\">  line-height: 24px;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">  margin: 10px;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dot.active&#123;</div><div class=\"line\">  background-color: #333;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>效果图：</p>\n<p><img src=\"http://limeng.u.qiniudn.com/wp_220_01.png\" alt=\"效果图\"></p>\n<p>css样式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.banner &#123;</div><div class=\"line\">  position: relative;</div><div class=\"line\">  overflow: auto;</div><div class=\"line\">  padding: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner li &#123;</div><div class=\"line\">  list-style: none;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner * &#123;</div><div class=\"line\">  -webkit-margin-before: 0;</div><div class=\"line\">  -webkit-margin-after: 0;</div><div class=\"line\">  -webkit-margin-start: 0;</div><div class=\"line\">  -webkit-margin-end: 0;</div><div class=\"line\">  -webkit-padding-start: 0;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner ul li &#123;</div><div class=\"line\">  float: left;</div><div class=\"line\">  height: 248px;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dots&#123;</div><div class=\"line\">  position: absolute;</div><div class=\"line\">  bottom: 0;</div><div class=\"line\">  width: 100%;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dot&#123;</div><div class=\"line\">  display: inline-block;</div><div class=\"line\">  width: 24px;</div><div class=\"line\">  height: 24px;</div><div class=\"line\">  border-radius: 12px;</div><div class=\"line\">  background-color: #ccc;</div><div class=\"line\">  line-height: 24px;</div><div class=\"line\">  text-align: center;</div><div class=\"line\">  margin: 10px;</div><div class=\"line\">&#125;</div><div class=\"line\">.banner .dot.active&#123;</div><div class=\"line\">  background-color: #333;</div><div class=\"line\">  color: #fff;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"Web前端面试题目及答案汇总","date":"2015-02-10T16:00:00.000Z","_content":"\n###HTML/CSS部分\n\n**1、什么是盒子模型？**\n\n在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n**2、行内元素有哪些？块级元素有哪些？空(void)元素有那些？**\n\n行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n\n块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n\n空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n**3、CSS实现垂直水平居中**\n\n一道经典的问题，实现方法有很多种，以下是其中一种实现：\n\nHTML结构：\n\n```html\n<div class=\"wrapper\">\n     <div class=\"content\"></div>\n</div>\n```\n\nCSS：\n\n```css\n.wrapper{position:relative;}\n.content{\n\tbackground-color:#6699FF;\n\twidth:200px;\n\theight:200px;\n\tposition: absolute;        //父元素需要相对定位\n\ttop: 50%;\n\tleft: 50%;\n\tmargin-top:-100px ;   //二分之一的height，width\n\tmargin-left: -100px;\n}\n```\n\n**4、简述一下src与href的区别**\n\nhref是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。\n\nsrc是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。\n\n**5、什么是CSS Hack?**\n\n一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。\n\nIE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：\n\n*1、条件Hack*\n\n```html\n<!--[if IE]>\n  <style>\n\t\t.test{color:red;}\n  </style>\n<![endif]-->\n```\n\n*2、属性Hack*\n\n```css\n.test{\ncolor:#090\\9; /* For IE8+ */\n*color:#f00;  /* For IE7 and earlier */\n_color:#ff0;  /* For IE6 and earlier */\n}\n```\n\n*3、选择符Hack*\n\n```css\n* html .test{color:#090;}       /* For IE6 and earlier */\n* + html .test{color:#ff0;}     /* For IE7 */\n```\n\n**6、简述同步和异步的区别**\n\n同步是阻塞模式，异步是非阻塞模式。\n\n同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；\n\n异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。\n\n**7、px和em的区别**\n\npx和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。\n\n浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em\n\n**8、什么叫优雅降级和渐进增强？**\n\n*渐进增强 progressive enhancement：*\n\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n*优雅降级 graceful degradation：*\n\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n区别：\n\na. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给\n\nb. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要\n\nc. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n**9、浏览器的内核分别是什么?**\n\nIE: trident内核\n\nFirefox：gecko内核\n\nSafari：webkit内核\n\nOpera：以前是presto内核，Opera现已改用Google Chrome的Blink内核\n\nChrome：Blink(基于webkit，Google与Opera Software共同开发)\n\n###JavaScript部分\n\n**1、怎样添加、移除、移动、复制、创建和查找节点？**\n\n1）创建新节点\n\n```javascript\ncreateDocumentFragment() //创建一个DOM片段\ncreateElement() //创建一个具体的元素\ncreateTextNode() //创建一个文本节点\n```\n\n2）添加、移除、替换、插入\n\n```javascript\nappendChild() //添加\nremoveChild() //移除\nreplaceChild() //替换\ninsertBefore() //插入\n```\n\n3）查找\n\n```\ngetElementsByTagName() //通过标签名称\ngetElementsByName() //通过元素的Name属性的值\ngetElementById() //通过元素Id，唯一性\n```\n\n**2、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。**\n\n```javascript\n/**\n * 对象克隆\n * 支持基本数据类型及对象\n * 递归方法\n */\nfunction clone(obj) {\n    var o;\n    switch (typeof obj) {\n        case \"undefined\":\n            break;\n        case \"string\":\n            o = obj + \"\";\n            break;\n        case \"number\":\n            o = obj - 0;\n            break;\n        case \"boolean\":\n            o = obj;\n            break;\n        case \"object\": // object 分为两种情况 对象（Object）或数组（Array）\n            if (obj === null) {\n                o = null;\n            } else {\n                if (Object.prototype.toString.call(obj).slice(8, -1) === \"Array\") {\n                    o = [];\n                    for (var i = 0; i < obj.length; i++) {\n                        o.push(clone(obj[i]));\n                    }\n                } else {\n                    o = {};\n                    for (var k in obj) {\n                        o[k] = clone(obj[k]);\n                    }\n                }\n            }\n            break;\n        default:\n            o = obj;\n            break;\n    }\n    return o;\n}\n```\n\n**3、如何消除一个数组里面重复的元素？**\n\n*方法一：*\n\n```javascript\nvar arr1 =[1,2,2,2,3,3,3,4,5,6],\n    arr2 = [];\nfor(var i = 0,len = arr1.length; i< len; i++){\n    if(arr2.indexOf(arr1[i]) < 0){\n        arr2.push(arr1[i]);\n    }\n}\ndocument.write(arr2); // 1,2,3,4,5,6\n```\n\n**4、想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。**\n\n**5、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？**\n\n伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。\n\n```javascript\nfunction log(){\n      var args = Array.prototype.slice.call(arguments);  \n//为了使用unshift数组方法，将argument转化为真正的数组\n      args.unshift('(app)');\n\n      console.log.apply(console, args);\n};\n```\n\n**6、Javascript中callee和caller的作用？**\n\ncaller是返回一个对函数的引用，该函数调用了当前函数；\n\ncallee是返回正在被执行的function函数，也就是所指定的function对象的正文。\n\n**7、请描述一下cookies，sessionStorage和localStorage的区别**\n\nsessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。\n\n*web storage和cookie的区别*\n\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\n\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\n\n**8、手写数组快速排序**\n\n关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序\n\n“快速排序”的思想很简单，整个排序过程只需要三步：\n\n（1）在数据集之中，选择一个元素作为”基准”（pivot）。\n（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。\n（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\n**9、统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。**\n\n```javascript\nvar str = \"aaaabbbccccddfgh\";\nvar obj  = {};\nfor(var i=0;i<str.length;i++){\n    var v = str.charAt(i);\n    if(obj[v] && obj[v].value == v){\n        obj[v].count = ++ obj[v].count;\n    }else{\n        obj[v] = {};\n        obj[v].count = 1;\n        obj[v].value = v;\n    }\n}\nfor(key in obj){\n    document.write(obj[key].value +'='+obj[key].count+' '); // a=4  b=3  c=4  d=2  f=1  g=1  h=1 \n}\n```\n\n**10、写一个function，清除字符串前后的空格。（兼容所有浏览器）**\n\n```javascript\nfunction trim(str) {\n    if (str && typeof str === \"string\") {\n        return str.replace(/(^\\s*)|(\\s*)$/g,\"\"); //去除前后空白符\n    }\n}\n```\n\n###其他\n\n**1、一次完整的HTTP事务是怎样的一个过程？**\n\n基本流程：\n\na. 域名解析\n\nb. 发起TCP的3次握手\n\nc. 建立TCP连接后发起http请求\n\nd. 服务器端响应http请求，浏览器得到html代码\n\ne. 浏览器解析html代码，并请求html代码中的资源\n\nf. 浏览器对页面进行渲染呈现给用户\n\n2、对前端工程师这个职位你是怎么样理解的？\n\na. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好\n\nb. 参与项目，快速高质量完成实现效果图，精确到1px；\n\nc. 与团队成员，UI设计，产品经理的沟通；\n\nd. 做好的页面结构，页面重构和用户体验；\n\ne. 处理hack，兼容、写出优美的代码格式；\n\nf. 针对服务器的优化、拥抱最新前端技术。","source":"_posts/Web前端面试题目及答案汇总.md","raw":"---\ntitle: Web前端面试题目及答案汇总\ntags: [html,css]\ndate: 2015/02/11\n---\n\n###HTML/CSS部分\n\n**1、什么是盒子模型？**\n\n在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。\n\n**2、行内元素有哪些？块级元素有哪些？空(void)元素有那些？**\n\n行内元素：a、b、span、img、input、strong、select、label、em、button、textarea\n\n块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote\n\n空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img\n\n**3、CSS实现垂直水平居中**\n\n一道经典的问题，实现方法有很多种，以下是其中一种实现：\n\nHTML结构：\n\n```html\n<div class=\"wrapper\">\n     <div class=\"content\"></div>\n</div>\n```\n\nCSS：\n\n```css\n.wrapper{position:relative;}\n.content{\n\tbackground-color:#6699FF;\n\twidth:200px;\n\theight:200px;\n\tposition: absolute;        //父元素需要相对定位\n\ttop: 50%;\n\tleft: 50%;\n\tmargin-top:-100px ;   //二分之一的height，width\n\tmargin-left: -100px;\n}\n```\n\n**4、简述一下src与href的区别**\n\nhref是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。\n\nsrc是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。\n\n**5、什么是CSS Hack?**\n\n一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。\n\nIE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：\n\n*1、条件Hack*\n\n```html\n<!--[if IE]>\n  <style>\n\t\t.test{color:red;}\n  </style>\n<![endif]-->\n```\n\n*2、属性Hack*\n\n```css\n.test{\ncolor:#090\\9; /* For IE8+ */\n*color:#f00;  /* For IE7 and earlier */\n_color:#ff0;  /* For IE6 and earlier */\n}\n```\n\n*3、选择符Hack*\n\n```css\n* html .test{color:#090;}       /* For IE6 and earlier */\n* + html .test{color:#ff0;}     /* For IE7 */\n```\n\n**6、简述同步和异步的区别**\n\n同步是阻塞模式，异步是非阻塞模式。\n\n同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；\n\n异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。\n\n**7、px和em的区别**\n\npx和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。\n\n浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em\n\n**8、什么叫优雅降级和渐进增强？**\n\n*渐进增强 progressive enhancement：*\n\n针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n\n*优雅降级 graceful degradation：*\n\n一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n区别：\n\na. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给\n\nb. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要\n\nc. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n**9、浏览器的内核分别是什么?**\n\nIE: trident内核\n\nFirefox：gecko内核\n\nSafari：webkit内核\n\nOpera：以前是presto内核，Opera现已改用Google Chrome的Blink内核\n\nChrome：Blink(基于webkit，Google与Opera Software共同开发)\n\n###JavaScript部分\n\n**1、怎样添加、移除、移动、复制、创建和查找节点？**\n\n1）创建新节点\n\n```javascript\ncreateDocumentFragment() //创建一个DOM片段\ncreateElement() //创建一个具体的元素\ncreateTextNode() //创建一个文本节点\n```\n\n2）添加、移除、替换、插入\n\n```javascript\nappendChild() //添加\nremoveChild() //移除\nreplaceChild() //替换\ninsertBefore() //插入\n```\n\n3）查找\n\n```\ngetElementsByTagName() //通过标签名称\ngetElementsByName() //通过元素的Name属性的值\ngetElementById() //通过元素Id，唯一性\n```\n\n**2、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。**\n\n```javascript\n/**\n * 对象克隆\n * 支持基本数据类型及对象\n * 递归方法\n */\nfunction clone(obj) {\n    var o;\n    switch (typeof obj) {\n        case \"undefined\":\n            break;\n        case \"string\":\n            o = obj + \"\";\n            break;\n        case \"number\":\n            o = obj - 0;\n            break;\n        case \"boolean\":\n            o = obj;\n            break;\n        case \"object\": // object 分为两种情况 对象（Object）或数组（Array）\n            if (obj === null) {\n                o = null;\n            } else {\n                if (Object.prototype.toString.call(obj).slice(8, -1) === \"Array\") {\n                    o = [];\n                    for (var i = 0; i < obj.length; i++) {\n                        o.push(clone(obj[i]));\n                    }\n                } else {\n                    o = {};\n                    for (var k in obj) {\n                        o[k] = clone(obj[k]);\n                    }\n                }\n            }\n            break;\n        default:\n            o = obj;\n            break;\n    }\n    return o;\n}\n```\n\n**3、如何消除一个数组里面重复的元素？**\n\n*方法一：*\n\n```javascript\nvar arr1 =[1,2,2,2,3,3,3,4,5,6],\n    arr2 = [];\nfor(var i = 0,len = arr1.length; i< len; i++){\n    if(arr2.indexOf(arr1[i]) < 0){\n        arr2.push(arr1[i]);\n    }\n}\ndocument.write(arr2); // 1,2,3,4,5,6\n```\n\n**4、想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。**\n\n**5、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？**\n\n伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。\n\n```javascript\nfunction log(){\n      var args = Array.prototype.slice.call(arguments);  \n//为了使用unshift数组方法，将argument转化为真正的数组\n      args.unshift('(app)');\n\n      console.log.apply(console, args);\n};\n```\n\n**6、Javascript中callee和caller的作用？**\n\ncaller是返回一个对函数的引用，该函数调用了当前函数；\n\ncallee是返回正在被执行的function函数，也就是所指定的function对象的正文。\n\n**7、请描述一下cookies，sessionStorage和localStorage的区别**\n\nsessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。\n\n*web storage和cookie的区别*\n\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。\n\n除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。\n\n**8、手写数组快速排序**\n\n关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序\n\n“快速排序”的思想很简单，整个排序过程只需要三步：\n\n（1）在数据集之中，选择一个元素作为”基准”（pivot）。\n（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。\n（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\n**9、统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。**\n\n```javascript\nvar str = \"aaaabbbccccddfgh\";\nvar obj  = {};\nfor(var i=0;i<str.length;i++){\n    var v = str.charAt(i);\n    if(obj[v] && obj[v].value == v){\n        obj[v].count = ++ obj[v].count;\n    }else{\n        obj[v] = {};\n        obj[v].count = 1;\n        obj[v].value = v;\n    }\n}\nfor(key in obj){\n    document.write(obj[key].value +'='+obj[key].count+' '); // a=4  b=3  c=4  d=2  f=1  g=1  h=1 \n}\n```\n\n**10、写一个function，清除字符串前后的空格。（兼容所有浏览器）**\n\n```javascript\nfunction trim(str) {\n    if (str && typeof str === \"string\") {\n        return str.replace(/(^\\s*)|(\\s*)$/g,\"\"); //去除前后空白符\n    }\n}\n```\n\n###其他\n\n**1、一次完整的HTTP事务是怎样的一个过程？**\n\n基本流程：\n\na. 域名解析\n\nb. 发起TCP的3次握手\n\nc. 建立TCP连接后发起http请求\n\nd. 服务器端响应http请求，浏览器得到html代码\n\ne. 浏览器解析html代码，并请求html代码中的资源\n\nf. 浏览器对页面进行渲染呈现给用户\n\n2、对前端工程师这个职位你是怎么样理解的？\n\na. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好\n\nb. 参与项目，快速高质量完成实现效果图，精确到1px；\n\nc. 与团队成员，UI设计，产品经理的沟通；\n\nd. 做好的页面结构，页面重构和用户体验；\n\ne. 处理hack，兼容、写出优美的代码格式；\n\nf. 针对服务器的优化、拥抱最新前端技术。","slug":"Web前端面试题目及答案汇总","published":1,"updated":"2016-08-17T06:22:19.858Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjd001z68dde3j0niny","content":"<p>###HTML/CSS部分</p>\n<p><strong>1、什么是盒子模型？</strong></p>\n<p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<p><strong>2、行内元素有哪些？块级元素有哪些？空(void)元素有那些？</strong></p>\n<p>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</p>\n<p>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</p>\n<p>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</p>\n<p><strong>3、CSS实现垂直水平居中</strong></p>\n<p>一道经典的问题，实现方法有很多种，以下是其中一种实现：</p>\n<p>HTML结构：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">.wrapper&#123;position:relative;&#125;</div><div class=\"line\">.content&#123;</div><div class=\"line\">\tbackground-color:#6699FF;</div><div class=\"line\">\twidth:200px;</div><div class=\"line\">\theight:200px;</div><div class=\"line\">\tposition: absolute;        //父元素需要相对定位</div><div class=\"line\">\ttop: 50%;</div><div class=\"line\">\tleft: 50%;</div><div class=\"line\">\tmargin-top:-100px ;   //二分之一的height，width</div><div class=\"line\">\tmargin-left: -100px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>4、简述一下src与href的区别</strong></p>\n<p>href是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</p>\n<p>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p>\n<p><strong>5、什么是CSS Hack?</strong></p>\n<p>一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。</p>\n<p>IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：</p>\n<p><em>1、条件Hack</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</span></div><div class=\"line\">  &lt;style&gt;</div><div class=\"line\">\t\t.test&#123;color:red;&#125;</div><div class=\"line\">  &lt;/style&gt;</div><div class=\"line\">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>\n<p><em>2、属性Hack</em></p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">.test&#123;</div><div class=\"line\">color:#090\\9; /* For IE8+ */</div><div class=\"line\">*color:#f00;  /* For IE7 and earlier */</div><div class=\"line\">_color:#ff0;  /* For IE6 and earlier */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>3、选择符Hack</em></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\">* <span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#090</span>;&#125;       <span class=\"comment\">/* For IE6 and earlier */</span></div><div class=\"line\">* + <span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#ff0</span>;&#125;     <span class=\"comment\">/* For IE7 */</span></div></pre></td></tr></table></figure>\n<p><strong>6、简述同步和异步的区别</strong></p>\n<p>同步是阻塞模式，异步是非阻塞模式。</p>\n<p>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p>\n<p>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>\n<p><strong>7、px和em的区别</strong></p>\n<p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p>\n<p>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em</p>\n<p><strong>8、什么叫优雅降级和渐进增强？</strong></p>\n<p><em>渐进增强 progressive enhancement：</em></p>\n<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>\n<p><em>优雅降级 graceful degradation：</em></p>\n<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<p>区别：</p>\n<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>\n<p>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>\n<p>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>\n<p><strong>9、浏览器的内核分别是什么?</strong></p>\n<p>IE: trident内核</p>\n<p>Firefox：gecko内核</p>\n<p>Safari：webkit内核</p>\n<p>Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核</p>\n<p>Chrome：Blink(基于webkit，Google与Opera Software共同开发)</p>\n<p>###JavaScript部分</p>\n<p><strong>1、怎样添加、移除、移动、复制、创建和查找节点？</strong></p>\n<p>1）创建新节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">createDocumentFragment() <span class=\"comment\">//创建一个DOM片段</span></div><div class=\"line\">createElement() <span class=\"comment\">//创建一个具体的元素</span></div><div class=\"line\">createTextNode() <span class=\"comment\">//创建一个文本节点</span></div></pre></td></tr></table></figure>\n<p>2）添加、移除、替换、插入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">appendChild() <span class=\"comment\">//添加</span></div><div class=\"line\">removeChild() <span class=\"comment\">//移除</span></div><div class=\"line\">replaceChild() <span class=\"comment\">//替换</span></div><div class=\"line\">insertBefore() <span class=\"comment\">//插入</span></div></pre></td></tr></table></figure>\n<p>3）查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">getElementsByTagName() //通过标签名称</div><div class=\"line\">getElementsByName() //通过元素的Name属性的值</div><div class=\"line\">getElementById() //通过元素Id，唯一性</div></pre></td></tr></table></figure>\n<p><strong>2、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * 对象克隆</div><div class=\"line\"> * 支持基本数据类型及对象</div><div class=\"line\"> * 递归方法</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> o;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">typeof</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"undefined\"</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"string\"</span>:</div><div class=\"line\">            o = obj + <span class=\"string\">\"\"</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"number\"</span>:</div><div class=\"line\">            o = obj - <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"boolean\"</span>:</div><div class=\"line\">            o = obj;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"object\"</span>: <span class=\"comment\">// object 分为两种情况 对象（Object）或数组（Array）</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">                o = <span class=\"literal\">null</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">\"Array\"</span>) &#123;</div><div class=\"line\">                    o = [];</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; obj.length; i++) &#123;</div><div class=\"line\">                        o.push(clone(obj[i]));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    o = &#123;&#125;;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">                        o[k] = clone(obj[k]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            o = obj;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3、如何消除一个数组里面重复的元素？</strong></p>\n<p><em>方法一：</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1 =[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],</div><div class=\"line\">    arr2 = [];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = arr1.length; i&lt; len; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr2.indexOf(arr1[i]) &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        arr2.push(arr1[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">document</span>.write(arr2); <span class=\"comment\">// 1,2,3,4,5,6</span></div></pre></td></tr></table></figure>\n<p><strong>4、想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。</strong></p>\n<p><strong>5、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</strong></p>\n<p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);  </div><div class=\"line\"><span class=\"comment\">//为了使用unshift数组方法，将argument转化为真正的数组</span></div><div class=\"line\">      args.unshift(<span class=\"string\">'(app)'</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>6、Javascript中callee和caller的作用？</strong></p>\n<p>caller是返回一个对函数的引用，该函数调用了当前函数；</p>\n<p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p>\n<p><strong>7、请描述一下cookies，sessionStorage和localStorage的区别</strong></p>\n<p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>\n<p><em>web storage和cookie的区别</em></p>\n<p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>\n<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>\n<p><strong>8、手写数组快速排序</strong></p>\n<p>关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序</p>\n<p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>\n<p>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>\n<p><strong>9、统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"aaaabbbccccddfgh\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj  = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;str.length;i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> v = str.charAt(i);</div><div class=\"line\">    <span class=\"keyword\">if</span>(obj[v] &amp;&amp; obj[v].value == v)&#123;</div><div class=\"line\">        obj[v].count = ++ obj[v].count;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        obj[v] = &#123;&#125;;</div><div class=\"line\">        obj[v].count = <span class=\"number\">1</span>;</div><div class=\"line\">        obj[v].value = v;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.write(obj[key].value +<span class=\"string\">'='</span>+obj[key].count+<span class=\"string\">' '</span>); <span class=\"comment\">// a=4  b=3  c=4  d=2  f=1  g=1  h=1 </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>10、写一个function，清除字符串前后的空格。（兼容所有浏览器）</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trim</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (str &amp;&amp; <span class=\"keyword\">typeof</span> str === <span class=\"string\">\"string\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/(^\\s*)|(\\s*)$/g</span>,<span class=\"string\">\"\"</span>); <span class=\"comment\">//去除前后空白符</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###其他</p>\n<p><strong>1、一次完整的HTTP事务是怎样的一个过程？</strong></p>\n<p>基本流程：</p>\n<p>a. 域名解析</p>\n<p>b. 发起TCP的3次握手</p>\n<p>c. 建立TCP连接后发起http请求</p>\n<p>d. 服务器端响应http请求，浏览器得到html代码</p>\n<p>e. 浏览器解析html代码，并请求html代码中的资源</p>\n<p>f. 浏览器对页面进行渲染呈现给用户</p>\n<p>2、对前端工程师这个职位你是怎么样理解的？</p>\n<p>a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p>\n<p>b. 参与项目，快速高质量完成实现效果图，精确到1px；</p>\n<p>c. 与团队成员，UI设计，产品经理的沟通；</p>\n<p>d. 做好的页面结构，页面重构和用户体验；</p>\n<p>e. 处理hack，兼容、写出优美的代码格式；</p>\n<p>f. 针对服务器的优化、拥抱最新前端技术。</p>\n","excerpt":"","more":"<p>###HTML/CSS部分</p>\n<p><strong>1、什么是盒子模型？</strong></p>\n<p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p>\n<p><strong>2、行内元素有哪些？块级元素有哪些？空(void)元素有那些？</strong></p>\n<p>行内元素：a、b、span、img、input、strong、select、label、em、button、textarea</p>\n<p>块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote</p>\n<p>空元素：即系没有内容的HTML元素，例如：br、meta、hr、link、input、img</p>\n<p><strong>3、CSS实现垂直水平居中</strong></p>\n<p>一道经典的问题，实现方法有很多种，以下是其中一种实现：</p>\n<p>HTML结构：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"wrapper\"</span>&gt;</span></div><div class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">.wrapper&#123;position:relative;&#125;</div><div class=\"line\">.content&#123;</div><div class=\"line\">\tbackground-color:#6699FF;</div><div class=\"line\">\twidth:200px;</div><div class=\"line\">\theight:200px;</div><div class=\"line\">\tposition: absolute;        //父元素需要相对定位</div><div class=\"line\">\ttop: 50%;</div><div class=\"line\">\tleft: 50%;</div><div class=\"line\">\tmargin-top:-100px ;   //二分之一的height，width</div><div class=\"line\">\tmargin-left: -100px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>4、简述一下src与href的区别</strong></p>\n<p>href是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</p>\n<p>src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p>\n<p><strong>5、什么是CSS Hack?</strong></p>\n<p>一般来说是针对不同的浏览器写不同的CSS,就是 CSS Hack。</p>\n<p>IE浏览器Hack一般又分为三种，条件Hack、属性级Hack、选择符Hack（详细参考CSS文档：css文档）。例如：</p>\n<p><em>1、条件Hack</em></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!--[if IE]&gt;</div><div class=\"line\">  &lt;style&gt;</div><div class=\"line\">\t\t.test&#123;color:red;&#125;</div><div class=\"line\">  &lt;/style&gt;</div><div class=\"line\">&lt;![endif]--&gt;</span></div></pre></td></tr></table></figure>\n<p><em>2、属性Hack</em></p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">.test&#123;</div><div class=\"line\">color:#090\\9; /* For IE8+ */</div><div class=\"line\">*color:#f00;  /* For IE7 and earlier */</div><div class=\"line\">_color:#ff0;  /* For IE6 and earlier */</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><em>3、选择符Hack</em></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\">* <span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#090</span>;&#125;       <span class=\"comment\">/* For IE6 and earlier */</span></div><div class=\"line\">* + <span class=\"selector-tag\">html</span> <span class=\"selector-class\">.test</span>&#123;<span class=\"attribute\">color</span>:<span class=\"number\">#ff0</span>;&#125;     <span class=\"comment\">/* For IE7 */</span></div></pre></td></tr></table></figure>\n<p><strong>6、简述同步和异步的区别</strong></p>\n<p>同步是阻塞模式，异步是非阻塞模式。</p>\n<p>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p>\n<p>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</p>\n<p><strong>7、px和em的区别</strong></p>\n<p>px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。</p>\n<p>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em</p>\n<p><strong>8、什么叫优雅降级和渐进增强？</strong></p>\n<p><em>渐进增强 progressive enhancement：</em></p>\n<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>\n<p><em>优雅降级 graceful degradation：</em></p>\n<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>\n<p>区别：</p>\n<p>a. 优雅降级是从复杂的现状开始，并试图减少用户体验的供给</p>\n<p>b. 渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要</p>\n<p>c. 降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>\n<p><strong>9、浏览器的内核分别是什么?</strong></p>\n<p>IE: trident内核</p>\n<p>Firefox：gecko内核</p>\n<p>Safari：webkit内核</p>\n<p>Opera：以前是presto内核，Opera现已改用Google Chrome的Blink内核</p>\n<p>Chrome：Blink(基于webkit，Google与Opera Software共同开发)</p>\n<p>###JavaScript部分</p>\n<p><strong>1、怎样添加、移除、移动、复制、创建和查找节点？</strong></p>\n<p>1）创建新节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">createDocumentFragment() <span class=\"comment\">//创建一个DOM片段</span></div><div class=\"line\">createElement() <span class=\"comment\">//创建一个具体的元素</span></div><div class=\"line\">createTextNode() <span class=\"comment\">//创建一个文本节点</span></div></pre></td></tr></table></figure>\n<p>2）添加、移除、替换、插入</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">appendChild() <span class=\"comment\">//添加</span></div><div class=\"line\">removeChild() <span class=\"comment\">//移除</span></div><div class=\"line\">replaceChild() <span class=\"comment\">//替换</span></div><div class=\"line\">insertBefore() <span class=\"comment\">//插入</span></div></pre></td></tr></table></figure>\n<p>3）查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">getElementsByTagName() //通过标签名称</div><div class=\"line\">getElementsByName() //通过元素的Name属性的值</div><div class=\"line\">getElementById() //通过元素Id，唯一性</div></pre></td></tr></table></figure>\n<p><strong>2、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * 对象克隆</div><div class=\"line\"> * 支持基本数据类型及对象</div><div class=\"line\"> * 递归方法</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">obj</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> o;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">typeof</span> obj) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"undefined\"</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"string\"</span>:</div><div class=\"line\">            o = obj + <span class=\"string\">\"\"</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"number\"</span>:</div><div class=\"line\">            o = obj - <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"boolean\"</span>:</div><div class=\"line\">            o = obj;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"object\"</span>: <span class=\"comment\">// object 分为两种情况 对象（Object）或数组（Array）</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (obj === <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">                o = <span class=\"literal\">null</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(obj).slice(<span class=\"number\">8</span>, <span class=\"number\">-1</span>) === <span class=\"string\">\"Array\"</span>) &#123;</div><div class=\"line\">                    o = [];</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; obj.length; i++) &#123;</div><div class=\"line\">                        o.push(clone(obj[i]));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    o = &#123;&#125;;</div><div class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> obj) &#123;</div><div class=\"line\">                        o[k] = clone(obj[k]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            o = obj;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> o;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>3、如何消除一个数组里面重复的元素？</strong></p>\n<p><em>方法一：</em></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> arr1 =[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],</div><div class=\"line\">    arr2 = [];</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>,len = arr1.length; i&lt; len; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(arr2.indexOf(arr1[i]) &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        arr2.push(arr1[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">document</span>.write(arr2); <span class=\"comment\">// 1,2,3,4,5,6</span></div></pre></td></tr></table></figure>\n<p><strong>4、想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。</strong></p>\n<p><strong>5、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</strong></p>\n<p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);  </div><div class=\"line\"><span class=\"comment\">//为了使用unshift数组方法，将argument转化为真正的数组</span></div><div class=\"line\">      args.unshift(<span class=\"string\">'(app)'</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"built_in\">console</span>.log.apply(<span class=\"built_in\">console</span>, args);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>6、Javascript中callee和caller的作用？</strong></p>\n<p>caller是返回一个对函数的引用，该函数调用了当前函数；</p>\n<p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p>\n<p><strong>7、请描述一下cookies，sessionStorage和localStorage的区别</strong></p>\n<p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>\n<p><em>web storage和cookie的区别</em></p>\n<p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p>\n<p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p>\n<p><strong>8、手写数组快速排序</strong></p>\n<p>关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序</p>\n<p>“快速排序”的思想很简单，整个排序过程只需要三步：</p>\n<p>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p>\n<p><strong>9、统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"aaaabbbccccddfgh\"</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj  = &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;str.length;i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> v = str.charAt(i);</div><div class=\"line\">    <span class=\"keyword\">if</span>(obj[v] &amp;&amp; obj[v].value == v)&#123;</div><div class=\"line\">        obj[v].count = ++ obj[v].count;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        obj[v] = &#123;&#125;;</div><div class=\"line\">        obj[v].count = <span class=\"number\">1</span>;</div><div class=\"line\">        obj[v].value = v;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</div><div class=\"line\">    <span class=\"built_in\">document</span>.write(obj[key].value +<span class=\"string\">'='</span>+obj[key].count+<span class=\"string\">' '</span>); <span class=\"comment\">// a=4  b=3  c=4  d=2  f=1  g=1  h=1 </span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>10、写一个function，清除字符串前后的空格。（兼容所有浏览器）</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trim</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (str &amp;&amp; <span class=\"keyword\">typeof</span> str === <span class=\"string\">\"string\"</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/(^\\s*)|(\\s*)$/g</span>,<span class=\"string\">\"\"</span>); <span class=\"comment\">//去除前后空白符</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>###其他</p>\n<p><strong>1、一次完整的HTTP事务是怎样的一个过程？</strong></p>\n<p>基本流程：</p>\n<p>a. 域名解析</p>\n<p>b. 发起TCP的3次握手</p>\n<p>c. 建立TCP连接后发起http请求</p>\n<p>d. 服务器端响应http请求，浏览器得到html代码</p>\n<p>e. 浏览器解析html代码，并请求html代码中的资源</p>\n<p>f. 浏览器对页面进行渲染呈现给用户</p>\n<p>2、对前端工程师这个职位你是怎么样理解的？</p>\n<p>a. 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p>\n<p>b. 参与项目，快速高质量完成实现效果图，精确到1px；</p>\n<p>c. 与团队成员，UI设计，产品经理的沟通；</p>\n<p>d. 做好的页面结构，页面重构和用户体验；</p>\n<p>e. 处理hack，兼容、写出优美的代码格式；</p>\n<p>f. 针对服务器的优化、拥抱最新前端技术。</p>\n"},{"title":"getJSON在PHP环境下实现跨域数据加载","date":"2014-06-05T16:00:00.000Z","_content":"\ngetJSON在PHP环境下实现跨域数据加载，此方法适合方便自己写服务端的程序员，如果非自管服务器，返回数据应该遵循此规则，否则无法实现。\n\n网页：\n\n```\ngetJson=function(){\n    alert(123);\n}\n$.getJSON('http://127.0.0.1/json/index.php?callback=?',function(data){\n    console.log(data);\n});\n```\n\nPHP：\n\n```\n$callback=$_GET['callback'];\n\n$jsonData=json_encode(array(\n    'a'=>'abc',\n    'b'=>'bcd',\n    'c'=>'cde',\n));\n\necho $callback.'('.$jsonData.')';\n```\n","source":"_posts/getJSON在PHP环境下实现跨域数据加载.md","raw":"---\ntitle: getJSON在PHP环境下实现跨域数据加载\ntags: [javascript,json]\ndate: 2014/06/06\n---\n\ngetJSON在PHP环境下实现跨域数据加载，此方法适合方便自己写服务端的程序员，如果非自管服务器，返回数据应该遵循此规则，否则无法实现。\n\n网页：\n\n```\ngetJson=function(){\n    alert(123);\n}\n$.getJSON('http://127.0.0.1/json/index.php?callback=?',function(data){\n    console.log(data);\n});\n```\n\nPHP：\n\n```\n$callback=$_GET['callback'];\n\n$jsonData=json_encode(array(\n    'a'=>'abc',\n    'b'=>'bcd',\n    'c'=>'cde',\n));\n\necho $callback.'('.$jsonData.')';\n```\n","slug":"getJSON在PHP环境下实现跨域数据加载","published":1,"updated":"2016-08-17T06:22:19.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpji002268dd48fqsdp4","content":"<p>getJSON在PHP环境下实现跨域数据加载，此方法适合方便自己写服务端的程序员，如果非自管服务器，返回数据应该遵循此规则，否则无法实现。</p>\n<p>网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">getJson=function()&#123;</div><div class=\"line\">    alert(123);</div><div class=\"line\">&#125;</div><div class=\"line\">$.getJSON(&apos;http://127.0.0.1/json/index.php?callback=?&apos;,function(data)&#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>PHP：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$callback=$_GET[&apos;callback&apos;];</div><div class=\"line\"></div><div class=\"line\">$jsonData=json_encode(array(</div><div class=\"line\">    &apos;a&apos;=&gt;&apos;abc&apos;,</div><div class=\"line\">    &apos;b&apos;=&gt;&apos;bcd&apos;,</div><div class=\"line\">    &apos;c&apos;=&gt;&apos;cde&apos;,</div><div class=\"line\">));</div><div class=\"line\"></div><div class=\"line\">echo $callback.&apos;(&apos;.$jsonData.&apos;)&apos;;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>getJSON在PHP环境下实现跨域数据加载，此方法适合方便自己写服务端的程序员，如果非自管服务器，返回数据应该遵循此规则，否则无法实现。</p>\n<p>网页：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">getJson=function()&#123;</div><div class=\"line\">    alert(123);</div><div class=\"line\">&#125;</div><div class=\"line\">$.getJSON(&apos;http://127.0.0.1/json/index.php?callback=?&apos;,function(data)&#123;</div><div class=\"line\">    console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>PHP：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$callback=$_GET[&apos;callback&apos;];</div><div class=\"line\"></div><div class=\"line\">$jsonData=json_encode(array(</div><div class=\"line\">    &apos;a&apos;=&gt;&apos;abc&apos;,</div><div class=\"line\">    &apos;b&apos;=&gt;&apos;bcd&apos;,</div><div class=\"line\">    &apos;c&apos;=&gt;&apos;cde&apos;,</div><div class=\"line\">));</div><div class=\"line\"></div><div class=\"line\">echo $callback.&apos;(&apos;.$jsonData.&apos;)&apos;;</div></pre></td></tr></table></figure>\n"},{"title":"expressjs 4.x增加对上传文件获取的支持","date":"2015-02-19T16:00:00.000Z","_content":"\nexpressjs 4.x与3.x有着很大的不同，百度上搜索的方法都是3.x的，所以，只能看文档解决问题。\n\n文档中对req.body有如下代码示例：\n\n```\nvar app = require('express')();\nvar bodyParser = require('body-parser');\nvar multer = require('multer'); \n\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded\napp.use(multer()); // for parsing multipart/form-data\n\napp.post('/', function (req, res) {\n  console.log(req.body);\n  res.json(req.body);\n})\n```\n\n这段代码的说明文字是：\n\nContains key-value pairs of data submitted in the request body. By default, it is undefined, and is populated when you use body-parsing middleware such as body-parser and multer.\n\n在req.body属性中的内容是用键-值对的数据方式表达提交的数据。默认情况下，这个值是未定义的，而且当使用相关的中间件的时候，此属性内容是不断增加的。\n\nThis example shows how to use body-parsing middleware to populate req.body.\n\n此实例展示了怎样使用相关中间件增加req.body属性内容。\n\n也就是说，当使用表单的enctype属性为multipart/form-data时，应该添加multer中间件才能实现req.files。\n","source":"_posts/expressjs 4.x增加对上传文件获取的支持.md","raw":"---\ntitle: expressjs 4.x增加对上传文件获取的支持\ntags: [nodejs,express]\ndate: 2015/2/20\n---\n\nexpressjs 4.x与3.x有着很大的不同，百度上搜索的方法都是3.x的，所以，只能看文档解决问题。\n\n文档中对req.body有如下代码示例：\n\n```\nvar app = require('express')();\nvar bodyParser = require('body-parser');\nvar multer = require('multer'); \n\napp.use(bodyParser.json()); // for parsing application/json\napp.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded\napp.use(multer()); // for parsing multipart/form-data\n\napp.post('/', function (req, res) {\n  console.log(req.body);\n  res.json(req.body);\n})\n```\n\n这段代码的说明文字是：\n\nContains key-value pairs of data submitted in the request body. By default, it is undefined, and is populated when you use body-parsing middleware such as body-parser and multer.\n\n在req.body属性中的内容是用键-值对的数据方式表达提交的数据。默认情况下，这个值是未定义的，而且当使用相关的中间件的时候，此属性内容是不断增加的。\n\nThis example shows how to use body-parsing middleware to populate req.body.\n\n此实例展示了怎样使用相关中间件增加req.body属性内容。\n\n也就是说，当使用表单的enctype属性为multipart/form-data时，应该添加multer中间件才能实现req.files。\n","slug":"expressjs 4.x增加对上传文件获取的支持","published":1,"updated":"2016-08-17T06:22:19.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjk002468dd2ahxja22","content":"<p>expressjs 4.x与3.x有着很大的不同，百度上搜索的方法都是3.x的，所以，只能看文档解决问题。</p>\n<p>文档中对req.body有如下代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = require(&apos;express&apos;)();</div><div class=\"line\">var bodyParser = require(&apos;body-parser&apos;);</div><div class=\"line\">var multer = require(&apos;multer&apos;); </div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser.json()); // for parsing application/json</div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencoded</div><div class=\"line\">app.use(multer()); // for parsing multipart/form-data</div><div class=\"line\"></div><div class=\"line\">app.post(&apos;/&apos;, function (req, res) &#123;</div><div class=\"line\">  console.log(req.body);</div><div class=\"line\">  res.json(req.body);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这段代码的说明文字是：</p>\n<p>Contains key-value pairs of data submitted in the request body. By default, it is undefined, and is populated when you use body-parsing middleware such as body-parser and multer.</p>\n<p>在req.body属性中的内容是用键-值对的数据方式表达提交的数据。默认情况下，这个值是未定义的，而且当使用相关的中间件的时候，此属性内容是不断增加的。</p>\n<p>This example shows how to use body-parsing middleware to populate req.body.</p>\n<p>此实例展示了怎样使用相关中间件增加req.body属性内容。</p>\n<p>也就是说，当使用表单的enctype属性为multipart/form-data时，应该添加multer中间件才能实现req.files。</p>\n","excerpt":"","more":"<p>expressjs 4.x与3.x有着很大的不同，百度上搜索的方法都是3.x的，所以，只能看文档解决问题。</p>\n<p>文档中对req.body有如下代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var app = require(&apos;express&apos;)();</div><div class=\"line\">var bodyParser = require(&apos;body-parser&apos;);</div><div class=\"line\">var multer = require(&apos;multer&apos;); </div><div class=\"line\"></div><div class=\"line\">app.use(bodyParser.json()); // for parsing application/json</div><div class=\"line\">app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // for parsing application/x-www-form-urlencoded</div><div class=\"line\">app.use(multer()); // for parsing multipart/form-data</div><div class=\"line\"></div><div class=\"line\">app.post(&apos;/&apos;, function (req, res) &#123;</div><div class=\"line\">  console.log(req.body);</div><div class=\"line\">  res.json(req.body);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这段代码的说明文字是：</p>\n<p>Contains key-value pairs of data submitted in the request body. By default, it is undefined, and is populated when you use body-parsing middleware such as body-parser and multer.</p>\n<p>在req.body属性中的内容是用键-值对的数据方式表达提交的数据。默认情况下，这个值是未定义的，而且当使用相关的中间件的时候，此属性内容是不断增加的。</p>\n<p>This example shows how to use body-parsing middleware to populate req.body.</p>\n<p>此实例展示了怎样使用相关中间件增加req.body属性内容。</p>\n<p>也就是说，当使用表单的enctype属性为multipart/form-data时，应该添加multer中间件才能实现req.files。</p>\n"},{"title":"jQuery animate scrollTop not working in IE 7","date":"2016-04-04T16:00:00.000Z","_content":"\nThe following works in Chrome / FF etc...\n\n```\n$('body').animate({scrollTop : 0}, 0);\n```\n\nHowever, in IE 7, it doesn't do anything.\n\nIs there an alternative?\n\n**Answers**\n\nin IE8， i use ```$(document).scrollTop()``` to get the scrollTop property, ```$('body').scrollTop()``` or ```$('html').scrollTop()``` will always return 0.\n\nMaybe you can use\n\n```\n$(document).animate({scrollTop: 0}, 0);\n$('html,body').animate({scrollTop: 0}, 0);\n```\n\nto make it works on all browser.","source":"_posts/jQuery animate scrollTop not working in IE 7.md","raw":"---\ntitle: jQuery animate scrollTop not working in IE 7\ntags: [javascript,jquery]\ndate: 2016/04/05\n---\n\nThe following works in Chrome / FF etc...\n\n```\n$('body').animate({scrollTop : 0}, 0);\n```\n\nHowever, in IE 7, it doesn't do anything.\n\nIs there an alternative?\n\n**Answers**\n\nin IE8， i use ```$(document).scrollTop()``` to get the scrollTop property, ```$('body').scrollTop()``` or ```$('html').scrollTop()``` will always return 0.\n\nMaybe you can use\n\n```\n$(document).animate({scrollTop: 0}, 0);\n$('html,body').animate({scrollTop: 0}, 0);\n```\n\nto make it works on all browser.","slug":"jQuery animate scrollTop not working in IE 7","published":1,"updated":"2016-08-17T06:22:19.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjm002768ddod375mvk","content":"<p>The following works in Chrome / FF etc…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;body&apos;).animate(&#123;scrollTop : 0&#125;, 0);</div></pre></td></tr></table></figure>\n<p>However, in IE 7, it doesn’t do anything.</p>\n<p>Is there an alternative?</p>\n<p><strong>Answers</strong></p>\n<p>in IE8， i use <figure class=\"highlight plain\"><figcaption><span>to get the scrollTop property, ```$('body').scrollTop()``` or ```$('html').scrollTop()``` will always return 0.</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Maybe you can use</div></pre></td></tr></table></figure></p>\n<p>$(document).animate({scrollTop: 0}, 0);<br>$(‘html,body’).animate({scrollTop: 0}, 0);<br>```</p>\n<p>to make it works on all browser.</p>\n","excerpt":"","more":"<p>The following works in Chrome / FF etc…</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;body&apos;).animate(&#123;scrollTop : 0&#125;, 0);</div></pre></td></tr></table></figure>\n<p>However, in IE 7, it doesn’t do anything.</p>\n<p>Is there an alternative?</p>\n<p><strong>Answers</strong></p>\n<p>in IE8， i use <figure class=\"highlight plain\"><figcaption><span>to get the scrollTop property, ```$('body').scrollTop()``` or ```$('html').scrollTop()``` will always return 0.</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Maybe you can use</div></pre></td></tr></table></figure></p>\n<p>$(document).animate({scrollTop: 0}, 0);<br>$(‘html,body’).animate({scrollTop: 0}, 0);<br>```</p>\n<p>to make it works on all browser.</p>\n"},{"title":"jQuery.each()的5个案例","date":"2016-04-03T16:00:00.000Z","_content":"\n本文将对 jQuery each() 函数作一个比较全面的介绍。 each() 函数是 jQuery 中最重要也是最常用的函数之一。通过本文你将明白为什么 each() 函数如此大放异彩，同时还将详细介绍如何使用 each() 函数。\n\n### 什么是 jQuery .each()\n\njQuery 的 each() 函数用来遍历目标 jQuery 对象中的所有元素。在这里解释一下什么是 jQuery 对象，以防有读者还不太清楚。 jQuery 对象指的是包含一个或多个 DOM 元素的对象，并且暴露出所有的 jQuery 函数。 each() 函数非常适合操作多元素的 DOM 、任意数组的循环以及对象的属性。除了这个函数， jQuery 里还有一个同名的辅助函数，不需要事先选择或创建 DOM 元素就可以调用这个辅助函数。在接下来的部分将更详细地介绍它们。\n\n### jQuery 的 .each() 语法\n\n这里将结合实际例子讲解 .each() 的不同用法。\n\n下面这个例子选中了网页上所有 div 标签，并打印每个 div 标签的 index 和 ID。输出的结果可能是： “div0:header”、 “div1:body”、 “div2:footer”。 jQuery 中 each() 函数的这种用法和效用函数的用法完全不同。\n\n```\n// DOM ELEMENTS\n$('div').each(function (index, value) { \n  console.log('div' + index + ':' + $(this).attr('id')); \n});\n```\n\n下一个例子展示了效用函数的用法。在这个例子当中，把被循环的对象当作 each() 函数的第一个参数。这个例子展示了如何遍历一个数组：\n\n```\n// ARRAYS\nvar arr = [\n   'one',\n   'two',\n   'three',\n   'four',\n   'five'\n];\n$.each(arr, function (index, value) {\n  console.log(value);\n \n  // Will stop running after \"three\"\n  return (value !== 'three');\n});\n// Outputs: one two three\n```\n\n最后这个例子中，遍历了一个对象中的所有属性：\n\n```\n// OBJECTS\nvar obj = {\n   one: 1,\n   two: 2,\n   three: 3,\n   four: 4,\n   five: 5\n};\n$.each(obj, function (index, value) {\n  console.log(value);\n});\n// Outputs: 1 2 3 4 5\n```\n\n这一切都归结为提供了适当的回调函数。这个回调函数的上下文， this ，等于它的第二个参数，也就是当前的 value 值。通常上下文都是一个对象，所以得把原始值封装起来。也就是说，这个 value 值和上下文之间不存在严格相等关系。 回调函数的第一个参数是当前的 index，它可能是数组里一个数字或对象中一个字符串。\n\n### 1.基本的 jQuery.each() 实例\n\n一起来看看 each() 函数是如何处理一个 jQuery 对象的。第一个例子中选择了页面中所有的 a 标签，并打印出它们的 href 属性。\n\n```\n$('a').each(function (index, value){\n  console.log($(this).attr('href'));\n});\n```\n\n第二个例子中输出了网页上所有的外链 href 属性（这里我们假设只用了 HTTP 协议）：\n\n```\n$('a').each(function (index, value){\n  var link = $(this).attr('href');\n \n  if (link.indexOf('http://') === 0) {\n        console.log(link);\n  }\n});\n```\n\n假设当前页面中有如下这些链接：\n\n```\n<a href=\"http://www.jquery4u.com\">JQUERY4U</a>\n<a href=\"http://www.phpscripts4u.com\">PHP4U</a>\n<a href=\"http://www.blogoola.com\">BLOGOOLA</a>\n```\n\n那么第二个例子将输出如下结果：\n\n```\nhttp://jquery4u.com\nhttp://www.phpscripts4u.com\nhttp://www.blogoola.com\n```\n\n需要注意的是， 在 each() 当中使用 jQuery 对象的 DOM 元素时，必须对这些 DOM 元素再次封装。这是因为 jQuery 实际上只是将 DOM 元素封装成数组。使用 jQuery each() 方法其实就是像普通数组那样迭代这个数组。因此，无法在迭代器里得到封装好的元素。\n\n### 2. jQuery.each() 数组实例\n\n首先看看 each() 是如何处理一个普通数组的。\n\n```\nvar numbers = [1, 2, 3, 4, 5, 6];\n$.each(numbers , function (index, value){\n  console.log(index + ':' + value); \n});\n```\n\n这段代码输出的结果是：0:1、 1:2、 2:3、 3:4、 4:5, 和 5:6。\n\n这段代码没有特别的。数组带数字索引，所以我们从０开始向后取数字，一直取到 N – 1，其中 N 是这个数组中元素的个数。\n\n### 3. jQuery.each() JSON 实例\n\n有时可能遇到更复杂的数据结构，比如数组包含数组、对象包含对象、对象包含数组，或者数组包含对象。这些情况下， each() 方法是如何发挥作用的呢？\n\n```\nvar json = [ \n { 'red': '#f00' },\n { 'green': '#0f0' },\n { 'blue': '#00f' }\n];\n \n$.each(json, function () {\n   $.each(this, function (name, value) {\n      console.log(name + '=' + value);\n   });\n});\n```\n\n这个例子的输出结果是 red=#f00、 green=#0f0、 blue=#00f。\n\n我们用嵌套调用 each() 方法，来处理这种嵌套结构。外层的 each() 调用是用来处理变量名为 JSON 的数组，内层的 each() 调用是用来处理嵌套在数组中的对象。本例当中，每个对象只有一个属性，但是一般来说有多个属性也是可以的。\n\n### 4.jQuery.each() 类实例\n\n这个例子展示了在下面 HTML 代码中，如何遍历所有 class 属性为 productDescription 的元素。\n\n```\n<div class=\"productDescription\">Red</div>\n<div>Pink</div>\n<div class=\"productDescription\">Orange</div>\n<div class=\"generalDescription\">Teal</div>\n<div class=\"productDescription\">Green</div>\n```\n\n我们使用 each() 辅助函数，取代在选择器中用 each() 方法。\n\n```\n$.each($('.productDescription'), function (index, value) { \n  console.log(index + ':' + $(value).text()); \n});\n```\n\n本例中的输出结果是0:Red, 1:Orange, 2:Green。\n\n我们不一定非要带上 index 和 value。它们只是用来帮助判断当前正在迭代处理的 DOM 元素的参数。而且，这种情况下也能更方便的使用 each 方法。可以简写成这样：\n\n```\n$('.productDescription').each(function () { \n  console.log($(this).text());\n});\n```\n\n在控制台上得到的结果如下：\n\n```\nRed\nOrange\nGreen\n```\n\n同样地，必须把 DOM 元素封装到在一个新的 jQuery 实例中。使用 text() 方法将元素的文本输出。\n\n### 5. jQuery .each() 延迟实例\n\n在下面的这个例子中，当用户点击 ID 为 5demo 的元素时，所有的列表元素都会马上变成橙色。然后元素根据 index 值设置延迟时间 (0, 200, 400, … 毫秒) 逐个淡出。\n\n```\n$('#5demo').bind('click', function (e) {\n  $('li').each(function (index) {\n$(this).css('background-color', 'orange')\n  .delay(index * 200)\n  .fadeOut(1500);\n  });\n  e.preventDefault();\n});\n```\n\n### 结论\n\n编程时应该尽可能多地使用 each() 函数，这种高效的方法能为我们节省大量时间。除了 jQuery 之外，还可以使用 ECMAScript 5 数组中的 forEach() 方法。\n\n> 谨记： $.each() 和 $(selector).each() 是用不同方式定义的两种不同的方法。\n\n[http://web.jobbole.com](http://web.jobbole.com/85589/)","source":"_posts/jQuery.each()的5个案例.md","raw":"---\ntitle: jQuery.each()的5个案例\ntags: [jquery]\ndate: 2016/04/04\n---\n\n本文将对 jQuery each() 函数作一个比较全面的介绍。 each() 函数是 jQuery 中最重要也是最常用的函数之一。通过本文你将明白为什么 each() 函数如此大放异彩，同时还将详细介绍如何使用 each() 函数。\n\n### 什么是 jQuery .each()\n\njQuery 的 each() 函数用来遍历目标 jQuery 对象中的所有元素。在这里解释一下什么是 jQuery 对象，以防有读者还不太清楚。 jQuery 对象指的是包含一个或多个 DOM 元素的对象，并且暴露出所有的 jQuery 函数。 each() 函数非常适合操作多元素的 DOM 、任意数组的循环以及对象的属性。除了这个函数， jQuery 里还有一个同名的辅助函数，不需要事先选择或创建 DOM 元素就可以调用这个辅助函数。在接下来的部分将更详细地介绍它们。\n\n### jQuery 的 .each() 语法\n\n这里将结合实际例子讲解 .each() 的不同用法。\n\n下面这个例子选中了网页上所有 div 标签，并打印每个 div 标签的 index 和 ID。输出的结果可能是： “div0:header”、 “div1:body”、 “div2:footer”。 jQuery 中 each() 函数的这种用法和效用函数的用法完全不同。\n\n```\n// DOM ELEMENTS\n$('div').each(function (index, value) { \n  console.log('div' + index + ':' + $(this).attr('id')); \n});\n```\n\n下一个例子展示了效用函数的用法。在这个例子当中，把被循环的对象当作 each() 函数的第一个参数。这个例子展示了如何遍历一个数组：\n\n```\n// ARRAYS\nvar arr = [\n   'one',\n   'two',\n   'three',\n   'four',\n   'five'\n];\n$.each(arr, function (index, value) {\n  console.log(value);\n \n  // Will stop running after \"three\"\n  return (value !== 'three');\n});\n// Outputs: one two three\n```\n\n最后这个例子中，遍历了一个对象中的所有属性：\n\n```\n// OBJECTS\nvar obj = {\n   one: 1,\n   two: 2,\n   three: 3,\n   four: 4,\n   five: 5\n};\n$.each(obj, function (index, value) {\n  console.log(value);\n});\n// Outputs: 1 2 3 4 5\n```\n\n这一切都归结为提供了适当的回调函数。这个回调函数的上下文， this ，等于它的第二个参数，也就是当前的 value 值。通常上下文都是一个对象，所以得把原始值封装起来。也就是说，这个 value 值和上下文之间不存在严格相等关系。 回调函数的第一个参数是当前的 index，它可能是数组里一个数字或对象中一个字符串。\n\n### 1.基本的 jQuery.each() 实例\n\n一起来看看 each() 函数是如何处理一个 jQuery 对象的。第一个例子中选择了页面中所有的 a 标签，并打印出它们的 href 属性。\n\n```\n$('a').each(function (index, value){\n  console.log($(this).attr('href'));\n});\n```\n\n第二个例子中输出了网页上所有的外链 href 属性（这里我们假设只用了 HTTP 协议）：\n\n```\n$('a').each(function (index, value){\n  var link = $(this).attr('href');\n \n  if (link.indexOf('http://') === 0) {\n        console.log(link);\n  }\n});\n```\n\n假设当前页面中有如下这些链接：\n\n```\n<a href=\"http://www.jquery4u.com\">JQUERY4U</a>\n<a href=\"http://www.phpscripts4u.com\">PHP4U</a>\n<a href=\"http://www.blogoola.com\">BLOGOOLA</a>\n```\n\n那么第二个例子将输出如下结果：\n\n```\nhttp://jquery4u.com\nhttp://www.phpscripts4u.com\nhttp://www.blogoola.com\n```\n\n需要注意的是， 在 each() 当中使用 jQuery 对象的 DOM 元素时，必须对这些 DOM 元素再次封装。这是因为 jQuery 实际上只是将 DOM 元素封装成数组。使用 jQuery each() 方法其实就是像普通数组那样迭代这个数组。因此，无法在迭代器里得到封装好的元素。\n\n### 2. jQuery.each() 数组实例\n\n首先看看 each() 是如何处理一个普通数组的。\n\n```\nvar numbers = [1, 2, 3, 4, 5, 6];\n$.each(numbers , function (index, value){\n  console.log(index + ':' + value); \n});\n```\n\n这段代码输出的结果是：0:1、 1:2、 2:3、 3:4、 4:5, 和 5:6。\n\n这段代码没有特别的。数组带数字索引，所以我们从０开始向后取数字，一直取到 N – 1，其中 N 是这个数组中元素的个数。\n\n### 3. jQuery.each() JSON 实例\n\n有时可能遇到更复杂的数据结构，比如数组包含数组、对象包含对象、对象包含数组，或者数组包含对象。这些情况下， each() 方法是如何发挥作用的呢？\n\n```\nvar json = [ \n { 'red': '#f00' },\n { 'green': '#0f0' },\n { 'blue': '#00f' }\n];\n \n$.each(json, function () {\n   $.each(this, function (name, value) {\n      console.log(name + '=' + value);\n   });\n});\n```\n\n这个例子的输出结果是 red=#f00、 green=#0f0、 blue=#00f。\n\n我们用嵌套调用 each() 方法，来处理这种嵌套结构。外层的 each() 调用是用来处理变量名为 JSON 的数组，内层的 each() 调用是用来处理嵌套在数组中的对象。本例当中，每个对象只有一个属性，但是一般来说有多个属性也是可以的。\n\n### 4.jQuery.each() 类实例\n\n这个例子展示了在下面 HTML 代码中，如何遍历所有 class 属性为 productDescription 的元素。\n\n```\n<div class=\"productDescription\">Red</div>\n<div>Pink</div>\n<div class=\"productDescription\">Orange</div>\n<div class=\"generalDescription\">Teal</div>\n<div class=\"productDescription\">Green</div>\n```\n\n我们使用 each() 辅助函数，取代在选择器中用 each() 方法。\n\n```\n$.each($('.productDescription'), function (index, value) { \n  console.log(index + ':' + $(value).text()); \n});\n```\n\n本例中的输出结果是0:Red, 1:Orange, 2:Green。\n\n我们不一定非要带上 index 和 value。它们只是用来帮助判断当前正在迭代处理的 DOM 元素的参数。而且，这种情况下也能更方便的使用 each 方法。可以简写成这样：\n\n```\n$('.productDescription').each(function () { \n  console.log($(this).text());\n});\n```\n\n在控制台上得到的结果如下：\n\n```\nRed\nOrange\nGreen\n```\n\n同样地，必须把 DOM 元素封装到在一个新的 jQuery 实例中。使用 text() 方法将元素的文本输出。\n\n### 5. jQuery .each() 延迟实例\n\n在下面的这个例子中，当用户点击 ID 为 5demo 的元素时，所有的列表元素都会马上变成橙色。然后元素根据 index 值设置延迟时间 (0, 200, 400, … 毫秒) 逐个淡出。\n\n```\n$('#5demo').bind('click', function (e) {\n  $('li').each(function (index) {\n$(this).css('background-color', 'orange')\n  .delay(index * 200)\n  .fadeOut(1500);\n  });\n  e.preventDefault();\n});\n```\n\n### 结论\n\n编程时应该尽可能多地使用 each() 函数，这种高效的方法能为我们节省大量时间。除了 jQuery 之外，还可以使用 ECMAScript 5 数组中的 forEach() 方法。\n\n> 谨记： $.each() 和 $(selector).each() 是用不同方式定义的两种不同的方法。\n\n[http://web.jobbole.com](http://web.jobbole.com/85589/)","slug":"jQuery.each()的5个案例","published":1,"updated":"2016-08-17T06:22:19.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjo002968ddg79hati3","content":"<p>本文将对 jQuery each() 函数作一个比较全面的介绍。 each() 函数是 jQuery 中最重要也是最常用的函数之一。通过本文你将明白为什么 each() 函数如此大放异彩，同时还将详细介绍如何使用 each() 函数。</p>\n<h3 id=\"什么是-jQuery-each\"><a href=\"#什么是-jQuery-each\" class=\"headerlink\" title=\"什么是 jQuery .each()\"></a>什么是 jQuery .each()</h3><p>jQuery 的 each() 函数用来遍历目标 jQuery 对象中的所有元素。在这里解释一下什么是 jQuery 对象，以防有读者还不太清楚。 jQuery 对象指的是包含一个或多个 DOM 元素的对象，并且暴露出所有的 jQuery 函数。 each() 函数非常适合操作多元素的 DOM 、任意数组的循环以及对象的属性。除了这个函数， jQuery 里还有一个同名的辅助函数，不需要事先选择或创建 DOM 元素就可以调用这个辅助函数。在接下来的部分将更详细地介绍它们。</p>\n<h3 id=\"jQuery-的-each-语法\"><a href=\"#jQuery-的-each-语法\" class=\"headerlink\" title=\"jQuery 的 .each() 语法\"></a>jQuery 的 .each() 语法</h3><p>这里将结合实际例子讲解 .each() 的不同用法。</p>\n<p>下面这个例子选中了网页上所有 div 标签，并打印每个 div 标签的 index 和 ID。输出的结果可能是： “div0:header”、 “div1:body”、 “div2:footer”。 jQuery 中 each() 函数的这种用法和效用函数的用法完全不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// DOM ELEMENTS</div><div class=\"line\">$(&apos;div&apos;).each(function (index, value) &#123; </div><div class=\"line\">  console.log(&apos;div&apos; + index + &apos;:&apos; + $(this).attr(&apos;id&apos;)); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>下一个例子展示了效用函数的用法。在这个例子当中，把被循环的对象当作 each() 函数的第一个参数。这个例子展示了如何遍历一个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// ARRAYS</div><div class=\"line\">var arr = [</div><div class=\"line\">   &apos;one&apos;,</div><div class=\"line\">   &apos;two&apos;,</div><div class=\"line\">   &apos;three&apos;,</div><div class=\"line\">   &apos;four&apos;,</div><div class=\"line\">   &apos;five&apos;</div><div class=\"line\">];</div><div class=\"line\">$.each(arr, function (index, value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\"> </div><div class=\"line\">  // Will stop running after &quot;three&quot;</div><div class=\"line\">  return (value !== &apos;three&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">// Outputs: one two three</div></pre></td></tr></table></figure>\n<p>最后这个例子中，遍历了一个对象中的所有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// OBJECTS</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   one: 1,</div><div class=\"line\">   two: 2,</div><div class=\"line\">   three: 3,</div><div class=\"line\">   four: 4,</div><div class=\"line\">   five: 5</div><div class=\"line\">&#125;;</div><div class=\"line\">$.each(obj, function (index, value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">// Outputs: 1 2 3 4 5</div></pre></td></tr></table></figure>\n<p>这一切都归结为提供了适当的回调函数。这个回调函数的上下文， this ，等于它的第二个参数，也就是当前的 value 值。通常上下文都是一个对象，所以得把原始值封装起来。也就是说，这个 value 值和上下文之间不存在严格相等关系。 回调函数的第一个参数是当前的 index，它可能是数组里一个数字或对象中一个字符串。</p>\n<h3 id=\"1-基本的-jQuery-each-实例\"><a href=\"#1-基本的-jQuery-each-实例\" class=\"headerlink\" title=\"1.基本的 jQuery.each() 实例\"></a>1.基本的 jQuery.each() 实例</h3><p>一起来看看 each() 函数是如何处理一个 jQuery 对象的。第一个例子中选择了页面中所有的 a 标签，并打印出它们的 href 属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;a&apos;).each(function (index, value)&#123;</div><div class=\"line\">  console.log($(this).attr(&apos;href&apos;));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>第二个例子中输出了网页上所有的外链 href 属性（这里我们假设只用了 HTTP 协议）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;a&apos;).each(function (index, value)&#123;</div><div class=\"line\">  var link = $(this).attr(&apos;href&apos;);</div><div class=\"line\"> </div><div class=\"line\">  if (link.indexOf(&apos;http://&apos;) === 0) &#123;</div><div class=\"line\">        console.log(link);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>假设当前页面中有如下这些链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;http://www.jquery4u.com&quot;&gt;JQUERY4U&lt;/a&gt;</div><div class=\"line\">&lt;a href=&quot;http://www.phpscripts4u.com&quot;&gt;PHP4U&lt;/a&gt;</div><div class=\"line\">&lt;a href=&quot;http://www.blogoola.com&quot;&gt;BLOGOOLA&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>那么第二个例子将输出如下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">http://jquery4u.com</div><div class=\"line\">http://www.phpscripts4u.com</div><div class=\"line\">http://www.blogoola.com</div></pre></td></tr></table></figure>\n<p>需要注意的是， 在 each() 当中使用 jQuery 对象的 DOM 元素时，必须对这些 DOM 元素再次封装。这是因为 jQuery 实际上只是将 DOM 元素封装成数组。使用 jQuery each() 方法其实就是像普通数组那样迭代这个数组。因此，无法在迭代器里得到封装好的元素。</p>\n<h3 id=\"2-jQuery-each-数组实例\"><a href=\"#2-jQuery-each-数组实例\" class=\"headerlink\" title=\"2. jQuery.each() 数组实例\"></a>2. jQuery.each() 数组实例</h3><p>首先看看 each() 是如何处理一个普通数组的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var numbers = [1, 2, 3, 4, 5, 6];</div><div class=\"line\">$.each(numbers , function (index, value)&#123;</div><div class=\"line\">  console.log(index + &apos;:&apos; + value); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这段代码输出的结果是：0:1、 1:2、 2:3、 3:4、 4:5, 和 5:6。</p>\n<p>这段代码没有特别的。数组带数字索引，所以我们从０开始向后取数字，一直取到 N – 1，其中 N 是这个数组中元素的个数。</p>\n<h3 id=\"3-jQuery-each-JSON-实例\"><a href=\"#3-jQuery-each-JSON-实例\" class=\"headerlink\" title=\"3. jQuery.each() JSON 实例\"></a>3. jQuery.each() JSON 实例</h3><p>有时可能遇到更复杂的数据结构，比如数组包含数组、对象包含对象、对象包含数组，或者数组包含对象。这些情况下， each() 方法是如何发挥作用的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var json = [ </div><div class=\"line\"> &#123; &apos;red&apos;: &apos;#f00&apos; &#125;,</div><div class=\"line\"> &#123; &apos;green&apos;: &apos;#0f0&apos; &#125;,</div><div class=\"line\"> &#123; &apos;blue&apos;: &apos;#00f&apos; &#125;</div><div class=\"line\">];</div><div class=\"line\"> </div><div class=\"line\">$.each(json, function () &#123;</div><div class=\"line\">   $.each(this, function (name, value) &#123;</div><div class=\"line\">      console.log(name + &apos;=&apos; + value);</div><div class=\"line\">   &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这个例子的输出结果是 red=#f00、 green=#0f0、 blue=#00f。</p>\n<p>我们用嵌套调用 each() 方法，来处理这种嵌套结构。外层的 each() 调用是用来处理变量名为 JSON 的数组，内层的 each() 调用是用来处理嵌套在数组中的对象。本例当中，每个对象只有一个属性，但是一般来说有多个属性也是可以的。</p>\n<h3 id=\"4-jQuery-each-类实例\"><a href=\"#4-jQuery-each-类实例\" class=\"headerlink\" title=\"4.jQuery.each() 类实例\"></a>4.jQuery.each() 类实例</h3><p>这个例子展示了在下面 HTML 代码中，如何遍历所有 class 属性为 productDescription 的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Red&lt;/div&gt;</div><div class=\"line\">&lt;div&gt;Pink&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Orange&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;generalDescription&quot;&gt;Teal&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Green&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>我们使用 each() 辅助函数，取代在选择器中用 each() 方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$.each($(&apos;.productDescription&apos;), function (index, value) &#123; </div><div class=\"line\">  console.log(index + &apos;:&apos; + $(value).text()); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>本例中的输出结果是0:Red, 1:Orange, 2:Green。</p>\n<p>我们不一定非要带上 index 和 value。它们只是用来帮助判断当前正在迭代处理的 DOM 元素的参数。而且，这种情况下也能更方便的使用 each 方法。可以简写成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;.productDescription&apos;).each(function () &#123; </div><div class=\"line\">  console.log($(this).text());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在控制台上得到的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Red</div><div class=\"line\">Orange</div><div class=\"line\">Green</div></pre></td></tr></table></figure>\n<p>同样地，必须把 DOM 元素封装到在一个新的 jQuery 实例中。使用 text() 方法将元素的文本输出。</p>\n<h3 id=\"5-jQuery-each-延迟实例\"><a href=\"#5-jQuery-each-延迟实例\" class=\"headerlink\" title=\"5. jQuery .each() 延迟实例\"></a>5. jQuery .each() 延迟实例</h3><p>在下面的这个例子中，当用户点击 ID 为 5demo 的元素时，所有的列表元素都会马上变成橙色。然后元素根据 index 值设置延迟时间 (0, 200, 400, … 毫秒) 逐个淡出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;#5demo&apos;).bind(&apos;click&apos;, function (e) &#123;</div><div class=\"line\">  $(&apos;li&apos;).each(function (index) &#123;</div><div class=\"line\">$(this).css(&apos;background-color&apos;, &apos;orange&apos;)</div><div class=\"line\">  .delay(index * 200)</div><div class=\"line\">  .fadeOut(1500);</div><div class=\"line\">  &#125;);</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>编程时应该尽可能多地使用 each() 函数，这种高效的方法能为我们节省大量时间。除了 jQuery 之外，还可以使用 ECMAScript 5 数组中的 forEach() 方法。</p>\n<blockquote>\n<p>谨记： $.each() 和 $(selector).each() 是用不同方式定义的两种不同的方法。</p>\n</blockquote>\n<p><a href=\"http://web.jobbole.com/85589/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<p>本文将对 jQuery each() 函数作一个比较全面的介绍。 each() 函数是 jQuery 中最重要也是最常用的函数之一。通过本文你将明白为什么 each() 函数如此大放异彩，同时还将详细介绍如何使用 each() 函数。</p>\n<h3 id=\"什么是-jQuery-each\"><a href=\"#什么是-jQuery-each\" class=\"headerlink\" title=\"什么是 jQuery .each()\"></a>什么是 jQuery .each()</h3><p>jQuery 的 each() 函数用来遍历目标 jQuery 对象中的所有元素。在这里解释一下什么是 jQuery 对象，以防有读者还不太清楚。 jQuery 对象指的是包含一个或多个 DOM 元素的对象，并且暴露出所有的 jQuery 函数。 each() 函数非常适合操作多元素的 DOM 、任意数组的循环以及对象的属性。除了这个函数， jQuery 里还有一个同名的辅助函数，不需要事先选择或创建 DOM 元素就可以调用这个辅助函数。在接下来的部分将更详细地介绍它们。</p>\n<h3 id=\"jQuery-的-each-语法\"><a href=\"#jQuery-的-each-语法\" class=\"headerlink\" title=\"jQuery 的 .each() 语法\"></a>jQuery 的 .each() 语法</h3><p>这里将结合实际例子讲解 .each() 的不同用法。</p>\n<p>下面这个例子选中了网页上所有 div 标签，并打印每个 div 标签的 index 和 ID。输出的结果可能是： “div0:header”、 “div1:body”、 “div2:footer”。 jQuery 中 each() 函数的这种用法和效用函数的用法完全不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// DOM ELEMENTS</div><div class=\"line\">$(&apos;div&apos;).each(function (index, value) &#123; </div><div class=\"line\">  console.log(&apos;div&apos; + index + &apos;:&apos; + $(this).attr(&apos;id&apos;)); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>下一个例子展示了效用函数的用法。在这个例子当中，把被循环的对象当作 each() 函数的第一个参数。这个例子展示了如何遍历一个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// ARRAYS</div><div class=\"line\">var arr = [</div><div class=\"line\">   &apos;one&apos;,</div><div class=\"line\">   &apos;two&apos;,</div><div class=\"line\">   &apos;three&apos;,</div><div class=\"line\">   &apos;four&apos;,</div><div class=\"line\">   &apos;five&apos;</div><div class=\"line\">];</div><div class=\"line\">$.each(arr, function (index, value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\"> </div><div class=\"line\">  // Will stop running after &quot;three&quot;</div><div class=\"line\">  return (value !== &apos;three&apos;);</div><div class=\"line\">&#125;);</div><div class=\"line\">// Outputs: one two three</div></pre></td></tr></table></figure>\n<p>最后这个例子中，遍历了一个对象中的所有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// OBJECTS</div><div class=\"line\">var obj = &#123;</div><div class=\"line\">   one: 1,</div><div class=\"line\">   two: 2,</div><div class=\"line\">   three: 3,</div><div class=\"line\">   four: 4,</div><div class=\"line\">   five: 5</div><div class=\"line\">&#125;;</div><div class=\"line\">$.each(obj, function (index, value) &#123;</div><div class=\"line\">  console.log(value);</div><div class=\"line\">&#125;);</div><div class=\"line\">// Outputs: 1 2 3 4 5</div></pre></td></tr></table></figure>\n<p>这一切都归结为提供了适当的回调函数。这个回调函数的上下文， this ，等于它的第二个参数，也就是当前的 value 值。通常上下文都是一个对象，所以得把原始值封装起来。也就是说，这个 value 值和上下文之间不存在严格相等关系。 回调函数的第一个参数是当前的 index，它可能是数组里一个数字或对象中一个字符串。</p>\n<h3 id=\"1-基本的-jQuery-each-实例\"><a href=\"#1-基本的-jQuery-each-实例\" class=\"headerlink\" title=\"1.基本的 jQuery.each() 实例\"></a>1.基本的 jQuery.each() 实例</h3><p>一起来看看 each() 函数是如何处理一个 jQuery 对象的。第一个例子中选择了页面中所有的 a 标签，并打印出它们的 href 属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;a&apos;).each(function (index, value)&#123;</div><div class=\"line\">  console.log($(this).attr(&apos;href&apos;));</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>第二个例子中输出了网页上所有的外链 href 属性（这里我们假设只用了 HTTP 协议）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;a&apos;).each(function (index, value)&#123;</div><div class=\"line\">  var link = $(this).attr(&apos;href&apos;);</div><div class=\"line\"> </div><div class=\"line\">  if (link.indexOf(&apos;http://&apos;) === 0) &#123;</div><div class=\"line\">        console.log(link);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>假设当前页面中有如下这些链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;http://www.jquery4u.com&quot;&gt;JQUERY4U&lt;/a&gt;</div><div class=\"line\">&lt;a href=&quot;http://www.phpscripts4u.com&quot;&gt;PHP4U&lt;/a&gt;</div><div class=\"line\">&lt;a href=&quot;http://www.blogoola.com&quot;&gt;BLOGOOLA&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>那么第二个例子将输出如下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">http://jquery4u.com</div><div class=\"line\">http://www.phpscripts4u.com</div><div class=\"line\">http://www.blogoola.com</div></pre></td></tr></table></figure>\n<p>需要注意的是， 在 each() 当中使用 jQuery 对象的 DOM 元素时，必须对这些 DOM 元素再次封装。这是因为 jQuery 实际上只是将 DOM 元素封装成数组。使用 jQuery each() 方法其实就是像普通数组那样迭代这个数组。因此，无法在迭代器里得到封装好的元素。</p>\n<h3 id=\"2-jQuery-each-数组实例\"><a href=\"#2-jQuery-each-数组实例\" class=\"headerlink\" title=\"2. jQuery.each() 数组实例\"></a>2. jQuery.each() 数组实例</h3><p>首先看看 each() 是如何处理一个普通数组的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var numbers = [1, 2, 3, 4, 5, 6];</div><div class=\"line\">$.each(numbers , function (index, value)&#123;</div><div class=\"line\">  console.log(index + &apos;:&apos; + value); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这段代码输出的结果是：0:1、 1:2、 2:3、 3:4、 4:5, 和 5:6。</p>\n<p>这段代码没有特别的。数组带数字索引，所以我们从０开始向后取数字，一直取到 N – 1，其中 N 是这个数组中元素的个数。</p>\n<h3 id=\"3-jQuery-each-JSON-实例\"><a href=\"#3-jQuery-each-JSON-实例\" class=\"headerlink\" title=\"3. jQuery.each() JSON 实例\"></a>3. jQuery.each() JSON 实例</h3><p>有时可能遇到更复杂的数据结构，比如数组包含数组、对象包含对象、对象包含数组，或者数组包含对象。这些情况下， each() 方法是如何发挥作用的呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var json = [ </div><div class=\"line\"> &#123; &apos;red&apos;: &apos;#f00&apos; &#125;,</div><div class=\"line\"> &#123; &apos;green&apos;: &apos;#0f0&apos; &#125;,</div><div class=\"line\"> &#123; &apos;blue&apos;: &apos;#00f&apos; &#125;</div><div class=\"line\">];</div><div class=\"line\"> </div><div class=\"line\">$.each(json, function () &#123;</div><div class=\"line\">   $.each(this, function (name, value) &#123;</div><div class=\"line\">      console.log(name + &apos;=&apos; + value);</div><div class=\"line\">   &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这个例子的输出结果是 red=#f00、 green=#0f0、 blue=#00f。</p>\n<p>我们用嵌套调用 each() 方法，来处理这种嵌套结构。外层的 each() 调用是用来处理变量名为 JSON 的数组，内层的 each() 调用是用来处理嵌套在数组中的对象。本例当中，每个对象只有一个属性，但是一般来说有多个属性也是可以的。</p>\n<h3 id=\"4-jQuery-each-类实例\"><a href=\"#4-jQuery-each-类实例\" class=\"headerlink\" title=\"4.jQuery.each() 类实例\"></a>4.jQuery.each() 类实例</h3><p>这个例子展示了在下面 HTML 代码中，如何遍历所有 class 属性为 productDescription 的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Red&lt;/div&gt;</div><div class=\"line\">&lt;div&gt;Pink&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Orange&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;generalDescription&quot;&gt;Teal&lt;/div&gt;</div><div class=\"line\">&lt;div class=&quot;productDescription&quot;&gt;Green&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>我们使用 each() 辅助函数，取代在选择器中用 each() 方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$.each($(&apos;.productDescription&apos;), function (index, value) &#123; </div><div class=\"line\">  console.log(index + &apos;:&apos; + $(value).text()); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>本例中的输出结果是0:Red, 1:Orange, 2:Green。</p>\n<p>我们不一定非要带上 index 和 value。它们只是用来帮助判断当前正在迭代处理的 DOM 元素的参数。而且，这种情况下也能更方便的使用 each 方法。可以简写成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;.productDescription&apos;).each(function () &#123; </div><div class=\"line\">  console.log($(this).text());</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在控制台上得到的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Red</div><div class=\"line\">Orange</div><div class=\"line\">Green</div></pre></td></tr></table></figure>\n<p>同样地，必须把 DOM 元素封装到在一个新的 jQuery 实例中。使用 text() 方法将元素的文本输出。</p>\n<h3 id=\"5-jQuery-each-延迟实例\"><a href=\"#5-jQuery-each-延迟实例\" class=\"headerlink\" title=\"5. jQuery .each() 延迟实例\"></a>5. jQuery .each() 延迟实例</h3><p>在下面的这个例子中，当用户点击 ID 为 5demo 的元素时，所有的列表元素都会马上变成橙色。然后元素根据 index 值设置延迟时间 (0, 200, 400, … 毫秒) 逐个淡出。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(&apos;#5demo&apos;).bind(&apos;click&apos;, function (e) &#123;</div><div class=\"line\">  $(&apos;li&apos;).each(function (index) &#123;</div><div class=\"line\">$(this).css(&apos;background-color&apos;, &apos;orange&apos;)</div><div class=\"line\">  .delay(index * 200)</div><div class=\"line\">  .fadeOut(1500);</div><div class=\"line\">  &#125;);</div><div class=\"line\">  e.preventDefault();</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>编程时应该尽可能多地使用 each() 函数，这种高效的方法能为我们节省大量时间。除了 jQuery 之外，还可以使用 ECMAScript 5 数组中的 forEach() 方法。</p>\n<blockquote>\n<p>谨记： $.each() 和 $(selector).each() 是用不同方式定义的两种不同的方法。</p>\n</blockquote>\n<p><a href=\"http://web.jobbole.com/85589/\">http://web.jobbole.com</a></p>\n"},{"title":"jQueryMobile笔记","date":"2016-04-02T16:00:00.000Z","_content":"\n### page\n\n//页面打开后展现形式\ndata-rel=\"dialog\"\n//开始预加载\ndata-prefetch=\"true\"\n//页面跳转时动画样式，更多样式请访问官方站点\ndata-transition=\"slidefade\"\n//如果在视图中设置以下两个属性，则会默认在header与footer的左侧显示后退按钮\ndata-add-back-btn=\"true\"\ndata-back-btn-text=\"后退\"\n\n//示例\n\n```\n<a href=\"second_page.html\" data-rel=\"dialog\" data-prefetch=\"true\" data-transition=\"slidefade\">切换到第二个视图</a>\n```\n\n### button\n\n//定义元素为按钮\ndata-role=\"button\"\n//按钮上的图标\ndata-icon=\"arrow-l\"\n//图标定位\ndata-iconpost=\"left/right/top/bottom/notext\"\n//内联样式\ndata-inline=\"true\"\n//\ndata-role=\"back\"\n\n/*自定义icon*/\n\n```\n.ui-icon-icon英文名称{\n    background-image:url(18*18.png) no-repeat;\n}\n```\n\n//定义按钮组\ndata-role=\"controlgroup\"\n\n```\n<div data-role=\"controlgroup\">\n  <a href=\"#\" data-role=\"button\">确定</a>\n  <a href=\"#\" data-role=\"button\">取消</a>\n  <a href=\"#\" data-role=\"button\">返回</a>\n</div>\n```\n\n//水平排列按钮组\ndata-type=\"horizontal\"\n\n```\n<div data-role=\"controlgroup\" data-type=\"horizontal\">\n  <a href=\"#\" data-role=\"button\">确定</a>\n  <a href=\"#\" data-role=\"button\">取消</a>\n  <a href=\"#\" data-role=\"button\">返回</a>\n</div>\n```\n\n//元素浮动\ndata-position=\"fixed\"\n\n//全屏\ndata-fullscreen=\"true\"\n\n//布局\n.ui-grid-a/b/c/d\n.ui-block-a/b/c/d/e\n\n//列子，三行五列\n\n```\n<div class=\"ui-grid-d\">\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">1</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">2</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">3</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">4</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">5</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">6</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">7</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">8</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">9</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">10</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">11</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">12</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">13</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">14</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">15</a>\n\t</section>\n</div>\n```\n\n//例子 九宫格\n\n```\n<div class=\"ui-grid-b\">\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n</div>\n```\n\n//折叠块\ndata-role=\"collapsible\"\n\n//例子\n\n```\n<div data-role=\"collapsible\">\n\t<h3>折叠</h3>\n\t<p>内容</p>\n</div>\n```\n\n//手风琴\ndata-role=\"collapsible-set\"\n        data-role=\"collapsible\"\n\n//例子\n\n```\n<div data-role=\"collapsible-set\">\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容1</p>\n\t</section>\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容2</p>\n\t</section>\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容3</p>\n\t</section>\n</div>\n```\n\n//开关按钮\ndata-role=\"fieldcontain\"\n\n//例子\n\n```\n<div data-role=\"fieldcontain\">\n\t<label>toggle switches:</label>\n\t<select data-role=\"slider\">\n\t\t<option value=\"off\">off</option>\n\t\t<option value=\"on\">on</option>\n\t</select>\n</div>\n```\n\n查看demo请用手机扫描下方二维\n![img](http://www.limeng.pw/wp-content/uploads/2014/12/generate.gif)\n","source":"_posts/jQueryMobile笔记.md","raw":"---\ntitle: jQueryMobile笔记\ntags: [jquery]\ndate: 2016/04/03\n---\n\n### page\n\n//页面打开后展现形式\ndata-rel=\"dialog\"\n//开始预加载\ndata-prefetch=\"true\"\n//页面跳转时动画样式，更多样式请访问官方站点\ndata-transition=\"slidefade\"\n//如果在视图中设置以下两个属性，则会默认在header与footer的左侧显示后退按钮\ndata-add-back-btn=\"true\"\ndata-back-btn-text=\"后退\"\n\n//示例\n\n```\n<a href=\"second_page.html\" data-rel=\"dialog\" data-prefetch=\"true\" data-transition=\"slidefade\">切换到第二个视图</a>\n```\n\n### button\n\n//定义元素为按钮\ndata-role=\"button\"\n//按钮上的图标\ndata-icon=\"arrow-l\"\n//图标定位\ndata-iconpost=\"left/right/top/bottom/notext\"\n//内联样式\ndata-inline=\"true\"\n//\ndata-role=\"back\"\n\n/*自定义icon*/\n\n```\n.ui-icon-icon英文名称{\n    background-image:url(18*18.png) no-repeat;\n}\n```\n\n//定义按钮组\ndata-role=\"controlgroup\"\n\n```\n<div data-role=\"controlgroup\">\n  <a href=\"#\" data-role=\"button\">确定</a>\n  <a href=\"#\" data-role=\"button\">取消</a>\n  <a href=\"#\" data-role=\"button\">返回</a>\n</div>\n```\n\n//水平排列按钮组\ndata-type=\"horizontal\"\n\n```\n<div data-role=\"controlgroup\" data-type=\"horizontal\">\n  <a href=\"#\" data-role=\"button\">确定</a>\n  <a href=\"#\" data-role=\"button\">取消</a>\n  <a href=\"#\" data-role=\"button\">返回</a>\n</div>\n```\n\n//元素浮动\ndata-position=\"fixed\"\n\n//全屏\ndata-fullscreen=\"true\"\n\n//布局\n.ui-grid-a/b/c/d\n.ui-block-a/b/c/d/e\n\n//列子，三行五列\n\n```\n<div class=\"ui-grid-d\">\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">1</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">2</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">3</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">4</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">5</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">6</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">7</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">8</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">9</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">10</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">11</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">12</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">13</a>\n\t</section>\n\t<section class=\"ui-block-d\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\">14</a>\n\t</section>\n\t<section class=\"ui-block-e\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\">15</a>\n\t</section>\n</div>\n```\n\n//例子 九宫格\n\n```\n<div class=\"ui-grid-b\">\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-a\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"a\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-b\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"b\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n\t<section class=\"ui-block-c\">\n\t\t<a href=\"#\" data-role=\"button\" data-theme=\"c\" data-icon=\"home\" data-iconpos=\"top\">home</a>\n\t</section>\n</div>\n```\n\n//折叠块\ndata-role=\"collapsible\"\n\n//例子\n\n```\n<div data-role=\"collapsible\">\n\t<h3>折叠</h3>\n\t<p>内容</p>\n</div>\n```\n\n//手风琴\ndata-role=\"collapsible-set\"\n        data-role=\"collapsible\"\n\n//例子\n\n```\n<div data-role=\"collapsible-set\">\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容1</p>\n\t</section>\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容2</p>\n\t</section>\n\t<section data-role=\"collapsible\">\n\t\t<h3>手风琴</h3>\n\t\t<p>内容3</p>\n\t</section>\n</div>\n```\n\n//开关按钮\ndata-role=\"fieldcontain\"\n\n//例子\n\n```\n<div data-role=\"fieldcontain\">\n\t<label>toggle switches:</label>\n\t<select data-role=\"slider\">\n\t\t<option value=\"off\">off</option>\n\t\t<option value=\"on\">on</option>\n\t</select>\n</div>\n```\n\n查看demo请用手机扫描下方二维\n![img](http://www.limeng.pw/wp-content/uploads/2014/12/generate.gif)\n","slug":"jQueryMobile笔记","published":1,"updated":"2016-08-17T06:22:19.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjq002b68dd3rbkg1zg","content":"<h3 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h3><p>//页面打开后展现形式<br>data-rel=”dialog”<br>//开始预加载<br>data-prefetch=”true”<br>//页面跳转时动画样式，更多样式请访问官方站点<br>data-transition=”slidefade”<br>//如果在视图中设置以下两个属性，则会默认在header与footer的左侧显示后退按钮<br>data-add-back-btn=”true”<br>data-back-btn-text=”后退”</p>\n<p>//示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;second_page.html&quot; data-rel=&quot;dialog&quot; data-prefetch=&quot;true&quot; data-transition=&quot;slidefade&quot;&gt;切换到第二个视图&lt;/a&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"button\"><a href=\"#button\" class=\"headerlink\" title=\"button\"></a>button</h3><p>//定义元素为按钮<br>data-role=”button”<br>//按钮上的图标<br>data-icon=”arrow-l”<br>//图标定位<br>data-iconpost=”left/right/top/bottom/notext”<br>//内联样式<br>data-inline=”true”<br>//<br>data-role=”back”</p>\n<p>/<em>自定义icon</em>/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.ui-icon-icon英文名称&#123;</div><div class=\"line\">    background-image:url(18*18.png) no-repeat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>//定义按钮组<br>data-role=”controlgroup”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;controlgroup&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;确定&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;取消&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;返回&lt;/a&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//水平排列按钮组<br>data-type=”horizontal”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;controlgroup&quot; data-type=&quot;horizontal&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;确定&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;取消&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;返回&lt;/a&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//元素浮动<br>data-position=”fixed”</p>\n<p>//全屏<br>data-fullscreen=”true”</p>\n<p>//布局<br>.ui-grid-a/b/c/d<br>.ui-block-a/b/c/d/e</p>\n<p>//列子，三行五列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;ui-grid-d&quot;&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;1&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;2&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;3&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;4&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;5&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;6&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;7&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;8&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;9&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;10&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;11&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;12&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;13&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;14&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;15&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//例子 九宫格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;ui-grid-b&quot;&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//折叠块<br>data-role=”collapsible”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t&lt;h3&gt;折叠&lt;/h3&gt;</div><div class=\"line\">\t&lt;p&gt;内容&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//手风琴<br>data-role=”collapsible-set”<br>        data-role=”collapsible”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;collapsible-set&quot;&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容1&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容2&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容3&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//开关按钮<br>data-role=”fieldcontain”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;fieldcontain&quot;&gt;</div><div class=\"line\">\t&lt;label&gt;toggle switches:&lt;/label&gt;</div><div class=\"line\">\t&lt;select data-role=&quot;slider&quot;&gt;</div><div class=\"line\">\t\t&lt;option value=&quot;off&quot;&gt;off&lt;/option&gt;</div><div class=\"line\">\t\t&lt;option value=&quot;on&quot;&gt;on&lt;/option&gt;</div><div class=\"line\">\t&lt;/select&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>查看demo请用手机扫描下方二维<br><img src=\"http://www.limeng.pw/wp-content/uploads/2014/12/generate.gif\" alt=\"img\"></p>\n","excerpt":"","more":"<h3 id=\"page\"><a href=\"#page\" class=\"headerlink\" title=\"page\"></a>page</h3><p>//页面打开后展现形式<br>data-rel=”dialog”<br>//开始预加载<br>data-prefetch=”true”<br>//页面跳转时动画样式，更多样式请访问官方站点<br>data-transition=”slidefade”<br>//如果在视图中设置以下两个属性，则会默认在header与footer的左侧显示后退按钮<br>data-add-back-btn=”true”<br>data-back-btn-text=”后退”</p>\n<p>//示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;second_page.html&quot; data-rel=&quot;dialog&quot; data-prefetch=&quot;true&quot; data-transition=&quot;slidefade&quot;&gt;切换到第二个视图&lt;/a&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"button\"><a href=\"#button\" class=\"headerlink\" title=\"button\"></a>button</h3><p>//定义元素为按钮<br>data-role=”button”<br>//按钮上的图标<br>data-icon=”arrow-l”<br>//图标定位<br>data-iconpost=”left/right/top/bottom/notext”<br>//内联样式<br>data-inline=”true”<br>//<br>data-role=”back”</p>\n<p>/<em>自定义icon</em>/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.ui-icon-icon英文名称&#123;</div><div class=\"line\">    background-image:url(18*18.png) no-repeat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>//定义按钮组<br>data-role=”controlgroup”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;controlgroup&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;确定&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;取消&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;返回&lt;/a&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//水平排列按钮组<br>data-type=”horizontal”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;controlgroup&quot; data-type=&quot;horizontal&quot;&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;确定&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;取消&lt;/a&gt;</div><div class=\"line\">  &lt;a href=&quot;#&quot; data-role=&quot;button&quot;&gt;返回&lt;/a&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//元素浮动<br>data-position=”fixed”</p>\n<p>//全屏<br>data-fullscreen=”true”</p>\n<p>//布局<br>.ui-grid-a/b/c/d<br>.ui-block-a/b/c/d/e</p>\n<p>//列子，三行五列</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;ui-grid-d&quot;&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;1&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;2&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;3&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;4&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;5&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;6&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;7&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;8&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;9&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;10&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;11&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;12&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;13&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-d&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot;&gt;14&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-e&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot;&gt;15&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//例子 九宫格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;ui-grid-b&quot;&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-a&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;a&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-b&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;b&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section class=&quot;ui-block-c&quot;&gt;</div><div class=\"line\">\t\t&lt;a href=&quot;#&quot; data-role=&quot;button&quot; data-theme=&quot;c&quot; data-icon=&quot;home&quot; data-iconpos=&quot;top&quot;&gt;home&lt;/a&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//折叠块<br>data-role=”collapsible”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t&lt;h3&gt;折叠&lt;/h3&gt;</div><div class=\"line\">\t&lt;p&gt;内容&lt;/p&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//手风琴<br>data-role=”collapsible-set”<br>        data-role=”collapsible”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;collapsible-set&quot;&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容1&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容2&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">\t&lt;section data-role=&quot;collapsible&quot;&gt;</div><div class=\"line\">\t\t&lt;h3&gt;手风琴&lt;/h3&gt;</div><div class=\"line\">\t\t&lt;p&gt;内容3&lt;/p&gt;</div><div class=\"line\">\t&lt;/section&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>//开关按钮<br>data-role=”fieldcontain”</p>\n<p>//例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div data-role=&quot;fieldcontain&quot;&gt;</div><div class=\"line\">\t&lt;label&gt;toggle switches:&lt;/label&gt;</div><div class=\"line\">\t&lt;select data-role=&quot;slider&quot;&gt;</div><div class=\"line\">\t\t&lt;option value=&quot;off&quot;&gt;off&lt;/option&gt;</div><div class=\"line\">\t\t&lt;option value=&quot;on&quot;&gt;on&lt;/option&gt;</div><div class=\"line\">\t&lt;/select&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>查看demo请用手机扫描下方二维<br><img src=\"http://www.limeng.pw/wp-content/uploads/2014/12/generate.gif\" alt=\"img\"></p>\n"},{"title":"javascript深入理解js闭包","date":"2015-05-10T16:00:00.000Z","_content":"\n###一、变量的作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局变量和局部变量。\n\nJavascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n\n```\nvar n=999;\nfunction f1(){\n　　alert(n);\n}\nf1(); // 999\n```\n\n另一方面，在函数外部自然无法读取函数内的局部变量。\n\n```\nfunction f1(){\n　　var n=999;\n}\nalert(n); // error\n```\n\n这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！\n\n```\nfunction f1(){\n　　n=999;\n}\nf1();\nalert(n); // 999\n```\n\n###二、如何从外部读取局部变量？\n\n出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。\n那就是在函数的内部，再定义一个函数。\n\n```\nfunction f1(){\n　　n=999;\n　　function f2(){\n　　　　alert(n); // 999\n　　}\n}\n```\n\n在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\n\n```\nfunction f1(){\n　　n=999;\n　　function f2(){\n　　　　alert(n);\n　　}\n　　return f2;\n}\nvar result=f1();\nresult(); // 999\n```\n\n###三、闭包的概念\n\n上一节代码中的f2函数，就是闭包。\n\n各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。\n\n由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。\n\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n###四、闭包的用途\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n怎么来理解这句话呢？请看下面的代码。\n\n```\nfunction f1(){\n　　var n=999;\n　　nAdd=function(){n+=1}\n　　function f2(){\n　　　　alert(n);\n　　}\n　　return f2;\n}\nvar result=f1();\nresult(); // 999\nnAdd();\nresult(); // 1000\n```\n\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n\n为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。\n\n###五、使用闭包的注意点\n\n1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n\n2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n###六、思考题\n\n如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。\n\n```\nvar name = \"The Window\";   \nvar object = {   \n      name : \"My Object\",   \n      getNameFunc : function(){\n        return function(){   \n          return this.name;   \n　　　   };   \n      }   \n};   \nalert(object.getNameFunc()());  //The Window\n```\n\nJavaScript闭包例子\n\n```\nfunction outerFun(){\n  var a=0;\n  function innerFun(){\n    a++;\n    alert(a);\n  }    \n}\ninnerFun()\n```\n\n上面的代码是错误的。innerFun()的作用域在outerFun()内部，所在outerFun()外部调用它是错误的。\n\n改成如下,也就是闭包:\n\n```\nfunction outerFun(){\n  var a=0;\n  function innerFun(){\n    a++;\n    alert(a);\n  }\n  return innerFun;  //注意这里\n}\nvar obj=outerFun();\nobj();  //结果为1\nobj();  //结果为2\nvar obj2=outerFun();\nobj2();  //结果为1\nobj2();  //结果为2\n```\n\n###什么是闭包？\n\n当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些变量在内存不会被释放，因为闭包需要它们。\n\n再来看一个例子\n\n```\nfunction outerFun(){\n  var a =0;\n  alert(a);  \n}\nvar a=4;\nouterFun();\nalert(a);\n```\n结果是0，4。因为在函数内部使用了var关键字维护a的作用域在outFun()内部。\n\n再看下面的代码:\n\n```\nfunction outerFun(){\n  //没有var \n  a =0;\n  alert(a);  \n}\nvar a=4;\nouterFun();\nalert(a);\n```\n\n结果为0，0。真是奇怪，为什么呢？\n\n作用域链是描述一种路径的术语，沿着该路径可以确定变量的值。当执行a=0时，因为没有使用var关键字，因此赋值操作会沿着作用域链到var a=4;并改变其值。\n\n传送门：[http://www.jb51.net/article/24101.htm](http://www.jb51.net/article/24101.htm)\n","source":"_posts/javascript深入理解js闭包.md","raw":"---\ntitle: javascript深入理解js闭包\ntags: [javascript]\ndate: 2015/05/11\n---\n\n###一、变量的作用域\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局变量和局部变量。\n\nJavascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n\n```\nvar n=999;\nfunction f1(){\n　　alert(n);\n}\nf1(); // 999\n```\n\n另一方面，在函数外部自然无法读取函数内的局部变量。\n\n```\nfunction f1(){\n　　var n=999;\n}\nalert(n); // error\n```\n\n这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！\n\n```\nfunction f1(){\n　　n=999;\n}\nf1();\nalert(n); // 999\n```\n\n###二、如何从外部读取局部变量？\n\n出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。\n那就是在函数的内部，再定义一个函数。\n\n```\nfunction f1(){\n　　n=999;\n　　function f2(){\n　　　　alert(n); // 999\n　　}\n}\n```\n\n在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\n\n```\nfunction f1(){\n　　n=999;\n　　function f2(){\n　　　　alert(n);\n　　}\n　　return f2;\n}\nvar result=f1();\nresult(); // 999\n```\n\n###三、闭包的概念\n\n上一节代码中的f2函数，就是闭包。\n\n各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。\n\n由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。\n\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n###四、闭包的用途\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n怎么来理解这句话呢？请看下面的代码。\n\n```\nfunction f1(){\n　　var n=999;\n　　nAdd=function(){n+=1}\n　　function f2(){\n　　　　alert(n);\n　　}\n　　return f2;\n}\nvar result=f1();\nresult(); // 999\nnAdd();\nresult(); // 1000\n```\n\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n\n为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。\n\n###五、使用闭包的注意点\n\n1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n\n2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n###六、思考题\n\n如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。\n\n```\nvar name = \"The Window\";   \nvar object = {   \n      name : \"My Object\",   \n      getNameFunc : function(){\n        return function(){   \n          return this.name;   \n　　　   };   \n      }   \n};   \nalert(object.getNameFunc()());  //The Window\n```\n\nJavaScript闭包例子\n\n```\nfunction outerFun(){\n  var a=0;\n  function innerFun(){\n    a++;\n    alert(a);\n  }    \n}\ninnerFun()\n```\n\n上面的代码是错误的。innerFun()的作用域在outerFun()内部，所在outerFun()外部调用它是错误的。\n\n改成如下,也就是闭包:\n\n```\nfunction outerFun(){\n  var a=0;\n  function innerFun(){\n    a++;\n    alert(a);\n  }\n  return innerFun;  //注意这里\n}\nvar obj=outerFun();\nobj();  //结果为1\nobj();  //结果为2\nvar obj2=outerFun();\nobj2();  //结果为1\nobj2();  //结果为2\n```\n\n###什么是闭包？\n\n当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些变量在内存不会被释放，因为闭包需要它们。\n\n再来看一个例子\n\n```\nfunction outerFun(){\n  var a =0;\n  alert(a);  \n}\nvar a=4;\nouterFun();\nalert(a);\n```\n结果是0，4。因为在函数内部使用了var关键字维护a的作用域在outFun()内部。\n\n再看下面的代码:\n\n```\nfunction outerFun(){\n  //没有var \n  a =0;\n  alert(a);  \n}\nvar a=4;\nouterFun();\nalert(a);\n```\n\n结果为0，0。真是奇怪，为什么呢？\n\n作用域链是描述一种路径的术语，沿着该路径可以确定变量的值。当执行a=0时，因为没有使用var关键字，因此赋值操作会沿着作用域链到var a=4;并改变其值。\n\n传送门：[http://www.jb51.net/article/24101.htm](http://www.jb51.net/article/24101.htm)\n","slug":"javascript深入理解js闭包","published":1,"updated":"2016-08-17T06:22:19.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjv002e68ddwy03scl1","content":"<p>###一、变量的作用域</p>\n<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局变量和局部变量。</p>\n<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var n=999;</div><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　alert(n);</div><div class=\"line\">&#125;</div><div class=\"line\">f1(); // 999</div></pre></td></tr></table></figure>\n<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　var n=999;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(n); // error</div></pre></td></tr></table></figure>\n<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">&#125;</div><div class=\"line\">f1();</div><div class=\"line\">alert(n); // 999</div></pre></td></tr></table></figure>\n<p>###二、如何从外部读取局部变量？</p>\n<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。<br>那就是在函数的内部，再定义一个函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n); // 999</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　return f2;</div><div class=\"line\">&#125;</div><div class=\"line\">var result=f1();</div><div class=\"line\">result(); // 999</div></pre></td></tr></table></figure>\n<p>###三、闭包的概念</p>\n<p>上一节代码中的f2函数，就是闭包。</p>\n<p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>\n<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>###四、闭包的用途</p>\n<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<p>怎么来理解这句话呢？请看下面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　var n=999;</div><div class=\"line\">　　nAdd=function()&#123;n+=1&#125;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　return f2;</div><div class=\"line\">&#125;</div><div class=\"line\">var result=f1();</div><div class=\"line\">result(); // 999</div><div class=\"line\">nAdd();</div><div class=\"line\">result(); // 1000</div></pre></td></tr></table></figure>\n<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>\n<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>\n<p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>\n<p>###五、使用闭包的注意点</p>\n<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>\n<p>###六、思考题</p>\n<p>如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;   </div><div class=\"line\">var object = &#123;   </div><div class=\"line\">      name : &quot;My Object&quot;,   </div><div class=\"line\">      getNameFunc : function()&#123;</div><div class=\"line\">        return function()&#123;   </div><div class=\"line\">          return this.name;   </div><div class=\"line\">　　　   &#125;;   </div><div class=\"line\">      &#125;   </div><div class=\"line\">&#125;;   </div><div class=\"line\">alert(object.getNameFunc()());  //The Window</div></pre></td></tr></table></figure>\n<p>JavaScript闭包例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a=0;</div><div class=\"line\">  function innerFun()&#123;</div><div class=\"line\">    a++;</div><div class=\"line\">    alert(a);</div><div class=\"line\">  &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\">innerFun()</div></pre></td></tr></table></figure>\n<p>上面的代码是错误的。innerFun()的作用域在outerFun()内部，所在outerFun()外部调用它是错误的。</p>\n<p>改成如下,也就是闭包:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a=0;</div><div class=\"line\">  function innerFun()&#123;</div><div class=\"line\">    a++;</div><div class=\"line\">    alert(a);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFun;  //注意这里</div><div class=\"line\">&#125;</div><div class=\"line\">var obj=outerFun();</div><div class=\"line\">obj();  //结果为1</div><div class=\"line\">obj();  //结果为2</div><div class=\"line\">var obj2=outerFun();</div><div class=\"line\">obj2();  //结果为1</div><div class=\"line\">obj2();  //结果为2</div></pre></td></tr></table></figure>\n<p>###什么是闭包？</p>\n<p>当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些变量在内存不会被释放，因为闭包需要它们。</p>\n<p>再来看一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a =0;</div><div class=\"line\">  alert(a);  </div><div class=\"line\">&#125;</div><div class=\"line\">var a=4;</div><div class=\"line\">outerFun();</div><div class=\"line\">alert(a);</div></pre></td></tr></table></figure>\n<p>结果是0，4。因为在函数内部使用了var关键字维护a的作用域在outFun()内部。</p>\n<p>再看下面的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  //没有var </div><div class=\"line\">  a =0;</div><div class=\"line\">  alert(a);  </div><div class=\"line\">&#125;</div><div class=\"line\">var a=4;</div><div class=\"line\">outerFun();</div><div class=\"line\">alert(a);</div></pre></td></tr></table></figure>\n<p>结果为0，0。真是奇怪，为什么呢？</p>\n<p>作用域链是描述一种路径的术语，沿着该路径可以确定变量的值。当执行a=0时，因为没有使用var关键字，因此赋值操作会沿着作用域链到var a=4;并改变其值。</p>\n<p>传送门：<a href=\"http://www.jb51.net/article/24101.htm\" target=\"_blank\" rel=\"external\">http://www.jb51.net/article/24101.htm</a></p>\n","excerpt":"","more":"<p>###一、变量的作用域</p>\n<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>\n<p>变量的作用域无非就是两种：全局变量和局部变量。</p>\n<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var n=999;</div><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　alert(n);</div><div class=\"line\">&#125;</div><div class=\"line\">f1(); // 999</div></pre></td></tr></table></figure>\n<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　var n=999;</div><div class=\"line\">&#125;</div><div class=\"line\">alert(n); // error</div></pre></td></tr></table></figure>\n<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">&#125;</div><div class=\"line\">f1();</div><div class=\"line\">alert(n); // 999</div></pre></td></tr></table></figure>\n<p>###二、如何从外部读取局部变量？</p>\n<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。<br>那就是在函数的内部，再定义一个函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n); // 999</div><div class=\"line\">　　&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　n=999;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　return f2;</div><div class=\"line\">&#125;</div><div class=\"line\">var result=f1();</div><div class=\"line\">result(); // 999</div></pre></td></tr></table></figure>\n<p>###三、闭包的概念</p>\n<p>上一节代码中的f2函数，就是闭包。</p>\n<p>各种专业文献上的“闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。</p>\n<p>由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>\n<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>###四、闭包的用途</p>\n<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<p>怎么来理解这句话呢？请看下面的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function f1()&#123;</div><div class=\"line\">　　var n=999;</div><div class=\"line\">　　nAdd=function()&#123;n+=1&#125;</div><div class=\"line\">　　function f2()&#123;</div><div class=\"line\">　　　　alert(n);</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　return f2;</div><div class=\"line\">&#125;</div><div class=\"line\">var result=f1();</div><div class=\"line\">result(); // 999</div><div class=\"line\">nAdd();</div><div class=\"line\">result(); // 1000</div></pre></td></tr></table></figure>\n<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p>\n<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>\n<p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>\n<p>###五、使用闭包的注意点</p>\n<p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>\n<p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>\n<p>###六、思考题</p>\n<p>如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var name = &quot;The Window&quot;;   </div><div class=\"line\">var object = &#123;   </div><div class=\"line\">      name : &quot;My Object&quot;,   </div><div class=\"line\">      getNameFunc : function()&#123;</div><div class=\"line\">        return function()&#123;   </div><div class=\"line\">          return this.name;   </div><div class=\"line\">　　　   &#125;;   </div><div class=\"line\">      &#125;   </div><div class=\"line\">&#125;;   </div><div class=\"line\">alert(object.getNameFunc()());  //The Window</div></pre></td></tr></table></figure>\n<p>JavaScript闭包例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a=0;</div><div class=\"line\">  function innerFun()&#123;</div><div class=\"line\">    a++;</div><div class=\"line\">    alert(a);</div><div class=\"line\">  &#125;    </div><div class=\"line\">&#125;</div><div class=\"line\">innerFun()</div></pre></td></tr></table></figure>\n<p>上面的代码是错误的。innerFun()的作用域在outerFun()内部，所在outerFun()外部调用它是错误的。</p>\n<p>改成如下,也就是闭包:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a=0;</div><div class=\"line\">  function innerFun()&#123;</div><div class=\"line\">    a++;</div><div class=\"line\">    alert(a);</div><div class=\"line\">  &#125;</div><div class=\"line\">  return innerFun;  //注意这里</div><div class=\"line\">&#125;</div><div class=\"line\">var obj=outerFun();</div><div class=\"line\">obj();  //结果为1</div><div class=\"line\">obj();  //结果为2</div><div class=\"line\">var obj2=outerFun();</div><div class=\"line\">obj2();  //结果为1</div><div class=\"line\">obj2();  //结果为2</div></pre></td></tr></table></figure>\n<p>###什么是闭包？</p>\n<p>当内部函数在定义它的作用域的外部被引用时，就创建了该内部函数的闭包，如果内部函数引用了位于外部函数的变量，当外部函数调用完毕后，这些变量在内存不会被释放，因为闭包需要它们。</p>\n<p>再来看一个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  var a =0;</div><div class=\"line\">  alert(a);  </div><div class=\"line\">&#125;</div><div class=\"line\">var a=4;</div><div class=\"line\">outerFun();</div><div class=\"line\">alert(a);</div></pre></td></tr></table></figure>\n<p>结果是0，4。因为在函数内部使用了var关键字维护a的作用域在outFun()内部。</p>\n<p>再看下面的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function outerFun()&#123;</div><div class=\"line\">  //没有var </div><div class=\"line\">  a =0;</div><div class=\"line\">  alert(a);  </div><div class=\"line\">&#125;</div><div class=\"line\">var a=4;</div><div class=\"line\">outerFun();</div><div class=\"line\">alert(a);</div></pre></td></tr></table></figure>\n<p>结果为0，0。真是奇怪，为什么呢？</p>\n<p>作用域链是描述一种路径的术语，沿着该路径可以确定变量的值。当执行a=0时，因为没有使用var关键字，因此赋值操作会沿着作用域链到var a=4;并改变其值。</p>\n<p>传送门：<a href=\"http://www.jb51.net/article/24101.htm\">http://www.jb51.net/article/24101.htm</a></p>\n"},{"title":"linux下查看和添加PATH环境变量","date":"2014-07-06T16:00:00.000Z","_content":"\n通过`$ echo $PATH`查看当前的搜索路径。\n\n可用`$ export`命令查看PATH值\n\n添加PATH环境变量，可用：\n\n\n```\n$ export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH\n```\n\n###上述方法的PATH在终端关闭后就会消失。所以还是建议通过编辑/etc/profile来改PATH，也可以改家目录下的.bashrc(即：~/.bashrc)。\n\n```\n$ vim /etc/profile\n```\n\n在文档最后，添加:\n\n```\n$ export PATH=\"/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH\"\n```\n\n保存，退出，然后运行：\n\n```\n$ source /etc/profile\n```\n\n不报错则成功。\n","source":"_posts/linux下查看和添加PATH环境变量.md","raw":"---\ntitle: linux下查看和添加PATH环境变量\ntags: [linux]\ndate: 2014/07/07\n---\n\n通过`$ echo $PATH`查看当前的搜索路径。\n\n可用`$ export`命令查看PATH值\n\n添加PATH环境变量，可用：\n\n\n```\n$ export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH\n```\n\n###上述方法的PATH在终端关闭后就会消失。所以还是建议通过编辑/etc/profile来改PATH，也可以改家目录下的.bashrc(即：~/.bashrc)。\n\n```\n$ vim /etc/profile\n```\n\n在文档最后，添加:\n\n```\n$ export PATH=\"/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH\"\n```\n\n保存，退出，然后运行：\n\n```\n$ source /etc/profile\n```\n\n不报错则成功。\n","slug":"linux下查看和添加PATH环境变量","published":1,"updated":"2016-08-17T06:22:19.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjx002g68dd67zze4ow","content":"<p>通过<code>$ echo $PATH</code>查看当前的搜索路径。</p>\n<p>可用<code>$ export</code>命令查看PATH值</p>\n<p>添加PATH环境变量，可用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH</div></pre></td></tr></table></figure>\n<p>###上述方法的PATH在终端关闭后就会消失。所以还是建议通过编辑/etc/profile来改PATH，也可以改家目录下的.bashrc(即：~/.bashrc)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vim /etc/profile</div></pre></td></tr></table></figure>\n<p>在文档最后，添加:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ export PATH=&quot;/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH&quot;</div></pre></td></tr></table></figure>\n<p>保存，退出，然后运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source /etc/profile</div></pre></td></tr></table></figure>\n<p>不报错则成功。</p>\n","excerpt":"","more":"<p>通过<code>$ echo $PATH</code>查看当前的搜索路径。</p>\n<p>可用<code>$ export</code>命令查看PATH值</p>\n<p>添加PATH环境变量，可用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ export PATH=/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH</div></pre></td></tr></table></figure>\n<p>###上述方法的PATH在终端关闭后就会消失。所以还是建议通过编辑/etc/profile来改PATH，也可以改家目录下的.bashrc(即：~/.bashrc)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vim /etc/profile</div></pre></td></tr></table></figure>\n<p>在文档最后，添加:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ export PATH=&quot;/opt/STM/STLinux-2.3/devkit/sh4/bin:$PATH&quot;</div></pre></td></tr></table></figure>\n<p>保存，退出，然后运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source /etc/profile</div></pre></td></tr></table></figure>\n<p>不报错则成功。</p>\n"},{"title":"linux下如何启动SVN服务","date":"2014-05-04T16:00:00.000Z","_content":"\n先转到SVN的安装目录，比如，你安装在/home/svn 下面。\n\n然后转到bin目录下，在这里可以看见一个叫svnserve的文件，我们需要用这个来启动SVN服务。\n\n试一下svnserve --help，看看这个命令的帮组，其中有-d和-r，分别表示后台运行和数据仓库目录。\n\n数据仓库目录表示你保存数据的地方，如你将工程的信息保存在/home/svndata下面，这个svndata就是你的数据仓库目录。\n\n弄清楚了这些就可以来启动了：\n\n输入命令：\n\nsvnserve -d -r /home/svndata\n\n后面那个要跟你自己的数据仓库目录。\n\n这样我们就启动了SVN了，SVN默认监听的是3690。有时候我们需要更改一下监听的端口，这时就需要设定一下监听端口了，按照如下命令来进行：\n\nsvnserve --listen-port 9999 -d -r /opt/svndata\n\n这样我们就把监听端口改成了9999了，当然你也可以可以把9999改成你自己想监听的端口~\n\n持续学习中~~\n","source":"_posts/linux 下如何启动SVN服务.md","raw":"---\ntitle: linux下如何启动SVN服务\ntags: [linux,svn]\ndate: 2014/05/05\n---\n\n先转到SVN的安装目录，比如，你安装在/home/svn 下面。\n\n然后转到bin目录下，在这里可以看见一个叫svnserve的文件，我们需要用这个来启动SVN服务。\n\n试一下svnserve --help，看看这个命令的帮组，其中有-d和-r，分别表示后台运行和数据仓库目录。\n\n数据仓库目录表示你保存数据的地方，如你将工程的信息保存在/home/svndata下面，这个svndata就是你的数据仓库目录。\n\n弄清楚了这些就可以来启动了：\n\n输入命令：\n\nsvnserve -d -r /home/svndata\n\n后面那个要跟你自己的数据仓库目录。\n\n这样我们就启动了SVN了，SVN默认监听的是3690。有时候我们需要更改一下监听的端口，这时就需要设定一下监听端口了，按照如下命令来进行：\n\nsvnserve --listen-port 9999 -d -r /opt/svndata\n\n这样我们就把监听端口改成了9999了，当然你也可以可以把9999改成你自己想监听的端口~\n\n持续学习中~~\n","slug":"linux 下如何启动SVN服务","published":1,"updated":"2016-08-17T06:22:19.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpjz002j68dde84vsnav","content":"<p>先转到SVN的安装目录，比如，你安装在/home/svn 下面。</p>\n<p>然后转到bin目录下，在这里可以看见一个叫svnserve的文件，我们需要用这个来启动SVN服务。</p>\n<p>试一下svnserve –help，看看这个命令的帮组，其中有-d和-r，分别表示后台运行和数据仓库目录。</p>\n<p>数据仓库目录表示你保存数据的地方，如你将工程的信息保存在/home/svndata下面，这个svndata就是你的数据仓库目录。</p>\n<p>弄清楚了这些就可以来启动了：</p>\n<p>输入命令：</p>\n<p>svnserve -d -r /home/svndata</p>\n<p>后面那个要跟你自己的数据仓库目录。</p>\n<p>这样我们就启动了SVN了，SVN默认监听的是3690。有时候我们需要更改一下监听的端口，这时就需要设定一下监听端口了，按照如下命令来进行：</p>\n<p>svnserve –listen-port 9999 -d -r /opt/svndata</p>\n<p>这样我们就把监听端口改成了9999了，当然你也可以可以把9999改成你自己想监听的端口~</p>\n<p>持续学习中~~</p>\n","excerpt":"","more":"<p>先转到SVN的安装目录，比如，你安装在/home/svn 下面。</p>\n<p>然后转到bin目录下，在这里可以看见一个叫svnserve的文件，我们需要用这个来启动SVN服务。</p>\n<p>试一下svnserve –help，看看这个命令的帮组，其中有-d和-r，分别表示后台运行和数据仓库目录。</p>\n<p>数据仓库目录表示你保存数据的地方，如你将工程的信息保存在/home/svndata下面，这个svndata就是你的数据仓库目录。</p>\n<p>弄清楚了这些就可以来启动了：</p>\n<p>输入命令：</p>\n<p>svnserve -d -r /home/svndata</p>\n<p>后面那个要跟你自己的数据仓库目录。</p>\n<p>这样我们就启动了SVN了，SVN默认监听的是3690。有时候我们需要更改一下监听的端口，这时就需要设定一下监听端口了，按照如下命令来进行：</p>\n<p>svnserve –listen-port 9999 -d -r /opt/svndata</p>\n<p>这样我们就把监听端口改成了9999了，当然你也可以可以把9999改成你自己想监听的端口~</p>\n<p>持续学习中~~</p>\n"},{"title":"mongoDB设置数据库并启动","date":"2015-09-17T16:00:00.000Z","_content":"\n```\n$ mongod --dbpath blog/data\n```\n\n会输出：\n\n```\n$ waiting for connections on port 27017\n```\n\n浏览器输入：\n\nhttp://localhost:27017\n\n会输出：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n\n即为成功。\n","source":"_posts/mongoDB设置数据库并启动.md","raw":"---\ntitle: mongoDB设置数据库并启动\ntags: [database,mongodb]\ndate: 2015/09/18\n---\n\n```\n$ mongod --dbpath blog/data\n```\n\n会输出：\n\n```\n$ waiting for connections on port 27017\n```\n\n浏览器输入：\n\nhttp://localhost:27017\n\n会输出：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n\n即为成功。\n","slug":"mongoDB设置数据库并启动","published":1,"updated":"2016-08-17T06:22:19.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpk1002l68ddjw7fwk8s","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ mongod --dbpath blog/data</div></pre></td></tr></table></figure>\n<p>会输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ waiting for connections on port 27017</div></pre></td></tr></table></figure>\n<p>浏览器输入：</p>\n<p><a href=\"http://localhost:27017\" target=\"_blank\" rel=\"external\">http://localhost:27017</a></p>\n<p>会输出：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port.</p>\n<p>即为成功。</p>\n","excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ mongod --dbpath blog/data</div></pre></td></tr></table></figure>\n<p>会输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ waiting for connections on port 27017</div></pre></td></tr></table></figure>\n<p>浏览器输入：</p>\n<p><a href=\"http://localhost:27017\">http://localhost:27017</a></p>\n<p>会输出：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port.</p>\n<p>即为成功。</p>\n"},{"title":"new的返回值","date":"2016-04-24T16:00:00.000Z","_content":"\n你将会遇到在JavaScript中使用new来分配新对象的一些情况。这将会扰乱你的思绪，除非你阅读了这篇文章并理解在内部发生了什么。\n\nJavaScript中的new操作在合理的情况下然会一个新的对象实例。我们来看，我们有一个构造函数：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n}\n\nvar myThing = new Thing();\n\nmyThing.one // 1\nmyThing.two // 2\n```\n\n> 提示: this指向new产生的新对象。否则如果Thing()不适用new调用, 将不会生成新对象, 而且this 将会指向全局对象，也就是window。这意味着：你突然有两个全局变量one和two。\n\nmyThing现在为undefined，因为Thing()中没有返回任何东西。\n\n现在我们又有一个例子，而它却有些让人搞不懂。我们看我在构造函数里加了一条语句：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n\n  return 5;\n}\n\nvar myThing = new Thing();\n```\n\n现在myThing等于什么呢？5？一个对象？还是我受伤的自我价值观？或许永远不知道！\n\n除了能知道：\n\n```\nmyThing.one // 1\nmyThing.two // 2\n```\n\n很有趣，我们构造函数里返回的5怎么找不到了？这很奇怪不是吗？函数都做了什么？5呢？让我们再试试别的。\n\n我们返回一个非原始类型试一下，比如一个对象：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n\n  return {\n    three: 3,\n    four: 4\n  };\n}\n\nvar myThing = new Thing();\n```\n\n让我们试一试。直接console.log出所有内容：\n\n```\nconsole.log(myThing);\n/*\n  Object {three: 3, four: 4}\n  this.one 和 this.two发生了什么!?\n  他们被覆盖了，朋友。\n*/\n```\n\n我们了解到： \n\n当你使用new关键字调用一个函数的时候，你可以使用this关键字给其设置参数（但这些你应该已经知道了）。使用new关键字调用一个返回原始变量的函数将不会返回你指定的值，而是返回函数的实例this（你指定参数的那个对象，像 this.one = 1;).\n\n然而，返回一个非原始变量像object、array或function将会覆盖this实例，并返回那个费原始变量，有效的破坏了你分配给this的所有工作。","source":"_posts/new的返回值.md","raw":"---\ntitle: new的返回值\ntags: [javascript]\ndate: 2016/04/25\n---\n\n你将会遇到在JavaScript中使用new来分配新对象的一些情况。这将会扰乱你的思绪，除非你阅读了这篇文章并理解在内部发生了什么。\n\nJavaScript中的new操作在合理的情况下然会一个新的对象实例。我们来看，我们有一个构造函数：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n}\n\nvar myThing = new Thing();\n\nmyThing.one // 1\nmyThing.two // 2\n```\n\n> 提示: this指向new产生的新对象。否则如果Thing()不适用new调用, 将不会生成新对象, 而且this 将会指向全局对象，也就是window。这意味着：你突然有两个全局变量one和two。\n\nmyThing现在为undefined，因为Thing()中没有返回任何东西。\n\n现在我们又有一个例子，而它却有些让人搞不懂。我们看我在构造函数里加了一条语句：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n\n  return 5;\n}\n\nvar myThing = new Thing();\n```\n\n现在myThing等于什么呢？5？一个对象？还是我受伤的自我价值观？或许永远不知道！\n\n除了能知道：\n\n```\nmyThing.one // 1\nmyThing.two // 2\n```\n\n很有趣，我们构造函数里返回的5怎么找不到了？这很奇怪不是吗？函数都做了什么？5呢？让我们再试试别的。\n\n我们返回一个非原始类型试一下，比如一个对象：\n\n```\nfunction Thing() {\n  this.one = 1;\n  this.two = 2;\n\n  return {\n    three: 3,\n    four: 4\n  };\n}\n\nvar myThing = new Thing();\n```\n\n让我们试一试。直接console.log出所有内容：\n\n```\nconsole.log(myThing);\n/*\n  Object {three: 3, four: 4}\n  this.one 和 this.two发生了什么!?\n  他们被覆盖了，朋友。\n*/\n```\n\n我们了解到： \n\n当你使用new关键字调用一个函数的时候，你可以使用this关键字给其设置参数（但这些你应该已经知道了）。使用new关键字调用一个返回原始变量的函数将不会返回你指定的值，而是返回函数的实例this（你指定参数的那个对象，像 this.one = 1;).\n\n然而，返回一个非原始变量像object、array或function将会覆盖this实例，并返回那个费原始变量，有效的破坏了你分配给this的所有工作。","slug":"new的返回值","published":1,"updated":"2016-08-17T06:22:19.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpk3002o68ddfe8eo1zi","content":"<p>你将会遇到在JavaScript中使用new来分配新对象的一些情况。这将会扰乱你的思绪，除非你阅读了这篇文章并理解在内部发生了什么。</p>\n<p>JavaScript中的new操作在合理的情况下然会一个新的对象实例。我们来看，我们有一个构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div><div class=\"line\"></div><div class=\"line\">myThing.one // 1</div><div class=\"line\">myThing.two // 2</div></pre></td></tr></table></figure>\n<blockquote>\n<p>提示: this指向new产生的新对象。否则如果Thing()不适用new调用, 将不会生成新对象, 而且this 将会指向全局对象，也就是window。这意味着：你突然有两个全局变量one和two。</p>\n</blockquote>\n<p>myThing现在为undefined，因为Thing()中没有返回任何东西。</p>\n<p>现在我们又有一个例子，而它却有些让人搞不懂。我们看我在构造函数里加了一条语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\"></div><div class=\"line\">  return 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div></pre></td></tr></table></figure>\n<p>现在myThing等于什么呢？5？一个对象？还是我受伤的自我价值观？或许永远不知道！</p>\n<p>除了能知道：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myThing.one // 1</div><div class=\"line\">myThing.two // 2</div></pre></td></tr></table></figure>\n<p>很有趣，我们构造函数里返回的5怎么找不到了？这很奇怪不是吗？函数都做了什么？5呢？让我们再试试别的。</p>\n<p>我们返回一个非原始类型试一下，比如一个对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    three: 3,</div><div class=\"line\">    four: 4</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div></pre></td></tr></table></figure>\n<p>让我们试一试。直接console.log出所有内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(myThing);</div><div class=\"line\">/*</div><div class=\"line\">  Object &#123;three: 3, four: 4&#125;</div><div class=\"line\">  this.one 和 this.two发生了什么!?</div><div class=\"line\">  他们被覆盖了，朋友。</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>我们了解到： </p>\n<p>当你使用new关键字调用一个函数的时候，你可以使用this关键字给其设置参数（但这些你应该已经知道了）。使用new关键字调用一个返回原始变量的函数将不会返回你指定的值，而是返回函数的实例this（你指定参数的那个对象，像 this.one = 1;).</p>\n<p>然而，返回一个非原始变量像object、array或function将会覆盖this实例，并返回那个费原始变量，有效的破坏了你分配给this的所有工作。</p>\n","excerpt":"","more":"<p>你将会遇到在JavaScript中使用new来分配新对象的一些情况。这将会扰乱你的思绪，除非你阅读了这篇文章并理解在内部发生了什么。</p>\n<p>JavaScript中的new操作在合理的情况下然会一个新的对象实例。我们来看，我们有一个构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div><div class=\"line\"></div><div class=\"line\">myThing.one // 1</div><div class=\"line\">myThing.two // 2</div></pre></td></tr></table></figure>\n<blockquote>\n<p>提示: this指向new产生的新对象。否则如果Thing()不适用new调用, 将不会生成新对象, 而且this 将会指向全局对象，也就是window。这意味着：你突然有两个全局变量one和two。</p>\n</blockquote>\n<p>myThing现在为undefined，因为Thing()中没有返回任何东西。</p>\n<p>现在我们又有一个例子，而它却有些让人搞不懂。我们看我在构造函数里加了一条语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\"></div><div class=\"line\">  return 5;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div></pre></td></tr></table></figure>\n<p>现在myThing等于什么呢？5？一个对象？还是我受伤的自我价值观？或许永远不知道！</p>\n<p>除了能知道：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myThing.one // 1</div><div class=\"line\">myThing.two // 2</div></pre></td></tr></table></figure>\n<p>很有趣，我们构造函数里返回的5怎么找不到了？这很奇怪不是吗？函数都做了什么？5呢？让我们再试试别的。</p>\n<p>我们返回一个非原始类型试一下，比如一个对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Thing() &#123;</div><div class=\"line\">  this.one = 1;</div><div class=\"line\">  this.two = 2;</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    three: 3,</div><div class=\"line\">    four: 4</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var myThing = new Thing();</div></pre></td></tr></table></figure>\n<p>让我们试一试。直接console.log出所有内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">console.log(myThing);</div><div class=\"line\">/*</div><div class=\"line\">  Object &#123;three: 3, four: 4&#125;</div><div class=\"line\">  this.one 和 this.two发生了什么!?</div><div class=\"line\">  他们被覆盖了，朋友。</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>我们了解到： </p>\n<p>当你使用new关键字调用一个函数的时候，你可以使用this关键字给其设置参数（但这些你应该已经知道了）。使用new关键字调用一个返回原始变量的函数将不会返回你指定的值，而是返回函数的实例this（你指定参数的那个对象，像 this.one = 1;).</p>\n<p>然而，返回一个非原始变量像object、array或function将会覆盖this实例，并返回那个费原始变量，有效的破坏了你分配给this的所有工作。</p>\n"},{"title":"mongodb3.03开启认证","date":"2015-07-17T16:00:00.000Z","_content":"\n下载了最新mongodb3.03版本，当使用--auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：\n\n（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） \n\nWindows下我做了一个bat文件，用来启动mongodb，命令行如下： \n\n```\nmongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth \n```\n\n最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false \n\n1、首先关闭认证，也就是不带--auth参数，启动mongodb \n\n2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 \n\n3、use userdb  切换到自己的数据库，输入db，显示userdb \n\n4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n\n5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 \n\n```\nauthenticate db: userdb { authenticate: 1, nonce: \"xxx\", user: \"myuser\", key: \"xxx\" } \n2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document \n```\n\n此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： \n\n首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： \n\n```\n> use admin \nswitched to db admin \n>  var schema = db.system.version.findOne({\"_id\" : \"authSchema\"}) \n> schema.currentVersion = 3 \n3 \n> db.system.version.save(schema) \nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) \n```\n\n不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 \n\n```\n> use admin \nswitched to db admin \n> db.system.users.find() \n[...] \n{ \"_id\" : \"userdb.myuser\", \"user\" : \"myuser\", \"db\" : \"userdb\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"XXXXXXXXXXXXXXXXXXXXXXXX\", \"storedKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\", \"serverKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\" } }, \"roles\" : [ { \"role\" : \"dbOwner\", \"db\" : \"userdb\" } ] } \n```\n\n解决方式就是删除刚刚创建的用户，重新重建即可： \n\n```\n> use userdb \nswitched to db userdb \n> db.dropUser(\"myuser\") \ntrue \n>db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n```\n\n然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK \n\n[转载自：http://21jhf.iteye.com/blog/2216103](http://21jhf.iteye.com/blog/2216103)\n","source":"_posts/mongodb3.03开启认证.md","raw":"---\ntitle: mongodb3.03开启认证\ntags: [database,mongodb]\ndate: 2015/07/18  \n---\n\n下载了最新mongodb3.03版本，当使用--auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：\n\n（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） \n\nWindows下我做了一个bat文件，用来启动mongodb，命令行如下： \n\n```\nmongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth \n```\n\n最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false \n\n1、首先关闭认证，也就是不带--auth参数，启动mongodb \n\n2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 \n\n3、use userdb  切换到自己的数据库，输入db，显示userdb \n\n4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n\n5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 \n\n```\nauthenticate db: userdb { authenticate: 1, nonce: \"xxx\", user: \"myuser\", key: \"xxx\" } \n2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document \n```\n\n此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： \n\n首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： \n\n```\n> use admin \nswitched to db admin \n>  var schema = db.system.version.findOne({\"_id\" : \"authSchema\"}) \n> schema.currentVersion = 3 \n3 \n> db.system.version.save(schema) \nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) \n```\n\n不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 \n\n```\n> use admin \nswitched to db admin \n> db.system.users.find() \n[...] \n{ \"_id\" : \"userdb.myuser\", \"user\" : \"myuser\", \"db\" : \"userdb\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"XXXXXXXXXXXXXXXXXXXXXXXX\", \"storedKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\", \"serverKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\" } }, \"roles\" : [ { \"role\" : \"dbOwner\", \"db\" : \"userdb\" } ] } \n```\n\n解决方式就是删除刚刚创建的用户，重新重建即可： \n\n```\n> use userdb \nswitched to db userdb \n> db.dropUser(\"myuser\") \ntrue \n>db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n```\n\n然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK \n\n[转载自：http://21jhf.iteye.com/blog/2216103](http://21jhf.iteye.com/blog/2216103)\n","slug":"mongodb3.03开启认证","published":1,"updated":"2016-08-17T06:22:19.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpk4002q68ddhd2e3pdl","content":"<p>下载了最新mongodb3.03版本，当使用–auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：</p>\n<p>（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） </p>\n<p>Windows下我做了一个bat文件，用来启动mongodb，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">mongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth</div></pre></td></tr></table></figure>\n<p>最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false </p>\n<p>1、首先关闭认证，也就是不带–auth参数，启动mongodb </p>\n<p>2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 </p>\n<p>3、use userdb  切换到自己的数据库，输入db，显示userdb </p>\n<p>4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:’myuser’,pwd:’123456’,roles:[{role:’dbOwner’,db:’userdb’}]}) </p>\n<p>5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">authenticate db: userdb &#123; authenticate: 1, nonce: &quot;xxx&quot;, user: &quot;myuser&quot;, key: &quot;xxx&quot; &#125; </div><div class=\"line\">2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document</div></pre></td></tr></table></figure>\n<p>此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： </p>\n<p>首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use admin </div><div class=\"line\">switched to db admin </div><div class=\"line\">&gt;  var schema = db.system.version.findOne(&#123;&quot;_id&quot; : &quot;authSchema&quot;&#125;) </div><div class=\"line\">&gt; schema.currentVersion = 3 </div><div class=\"line\">3 </div><div class=\"line\">&gt; db.system.version.save(schema) </div><div class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div></pre></td></tr></table></figure>\n<p>不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use admin </div><div class=\"line\">switched to db admin </div><div class=\"line\">&gt; db.system.users.find() </div><div class=\"line\">[...] </div><div class=\"line\">&#123; &quot;_id&quot; : &quot;userdb.myuser&quot;, &quot;user&quot; : &quot;myuser&quot;, &quot;db&quot; : &quot;userdb&quot;, &quot;credentials&quot; : &#123; &quot;SCRAM-SHA-1&quot; : &#123; &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;storedKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;serverKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; &#125; &#125;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;userdb&quot; &#125; ] &#125;</div></pre></td></tr></table></figure>\n<p>解决方式就是删除刚刚创建的用户，重新重建即可： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use userdb </div><div class=\"line\">switched to db userdb </div><div class=\"line\">&gt; db.dropUser(&quot;myuser&quot;) </div><div class=\"line\">true </div><div class=\"line\">&gt;db.createUser(&#123;user:&apos;myuser&apos;,pwd:&apos;123456&apos;,roles:[&#123;role:&apos;dbOwner&apos;,db:&apos;userdb&apos;&#125;]&#125;)</div></pre></td></tr></table></figure>\n<p>然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK </p>\n<p><a href=\"http://21jhf.iteye.com/blog/2216103\" target=\"_blank\" rel=\"external\">转载自：http://21jhf.iteye.com/blog/2216103</a></p>\n","excerpt":"","more":"<p>下载了最新mongodb3.03版本，当使用–auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：</p>\n<p>（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） </p>\n<p>Windows下我做了一个bat文件，用来启动mongodb，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">mongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth</div></pre></td></tr></table></figure>\n<p>最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false </p>\n<p>1、首先关闭认证，也就是不带–auth参数，启动mongodb </p>\n<p>2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 </p>\n<p>3、use userdb  切换到自己的数据库，输入db，显示userdb </p>\n<p>4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:’myuser’,pwd:’123456’,roles:[{role:’dbOwner’,db:’userdb’}]}) </p>\n<p>5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">authenticate db: userdb &#123; authenticate: 1, nonce: &quot;xxx&quot;, user: &quot;myuser&quot;, key: &quot;xxx&quot; &#125; </div><div class=\"line\">2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document</div></pre></td></tr></table></figure>\n<p>此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： </p>\n<p>首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use admin </div><div class=\"line\">switched to db admin </div><div class=\"line\">&gt;  var schema = db.system.version.findOne(&#123;&quot;_id&quot; : &quot;authSchema&quot;&#125;) </div><div class=\"line\">&gt; schema.currentVersion = 3 </div><div class=\"line\">3 </div><div class=\"line\">&gt; db.system.version.save(schema) </div><div class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div></pre></td></tr></table></figure>\n<p>不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use admin </div><div class=\"line\">switched to db admin </div><div class=\"line\">&gt; db.system.users.find() </div><div class=\"line\">[...] </div><div class=\"line\">&#123; &quot;_id&quot; : &quot;userdb.myuser&quot;, &quot;user&quot; : &quot;myuser&quot;, &quot;db&quot; : &quot;userdb&quot;, &quot;credentials&quot; : &#123; &quot;SCRAM-SHA-1&quot; : &#123; &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;storedKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;serverKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; &#125; &#125;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;userdb&quot; &#125; ] &#125;</div></pre></td></tr></table></figure>\n<p>解决方式就是删除刚刚创建的用户，重新重建即可： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&gt; use userdb </div><div class=\"line\">switched to db userdb </div><div class=\"line\">&gt; db.dropUser(&quot;myuser&quot;) </div><div class=\"line\">true </div><div class=\"line\">&gt;db.createUser(&#123;user:&apos;myuser&apos;,pwd:&apos;123456&apos;,roles:[&#123;role:&apos;dbOwner&apos;,db:&apos;userdb&apos;&#125;]&#125;)</div></pre></td></tr></table></figure>\n<p>然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK </p>\n<p><a href=\"http://21jhf.iteye.com/blog/2216103\">转载自：http://21jhf.iteye.com/blog/2216103</a></p>\n"},{"title":"nodejs+express","date":"2016-02-01T16:00:00.000Z","_content":"\n准备用nodejs开发一个blog，没想有后台，只是想学习一下nodejs，而且我还有服务器。\n\n不知道这个项目能开发多久，希望不会半途而废。\n\n用自己零碎的时间，开发完整的项目。\n\n### 一、nodejs的安装\n\n去官网看一下<a href=\"http://nodejs.org\" target=\"_blank\">http://nodejs.org</a>\n\n### 二、npm的安装\n\n下载最新版本的nodejs自带npm\n\n### 三、express的安装\n\nnpm install express\n\n### 四、blog项目的建立\n\n服务器新建一个blog文件夹，之后初始化express blog项目\n\n```\n#mkdir blog\n#express blog\n#cd blog\n#npm install\n```\n\n由于默认安装的express是4版本的，4版本应用的jade模板，这个模板引擎其实很不错，但是，对于前端人员来说，需要将html代码转化为jade所规范的写法，增加了页面生成时间。如果熟悉了jade引擎，开发起来要比html快很多，因为可以少写很多字符。\n\n所以，需要安装ejs模板引擎，可以很快捷的使用html格式的文件。\n\n安装方法，可以npm直接安装，我所使用的方法是修改express中的package.json文件，增加\"ejs\":\"~1.0\"，之后\n\n```\n#npm install\n```\n\n### 五、增速开发\n\n由于node命令不会识别文件是否修改而且重启，所以，需要使用supervison工具，安装方式\n\n```\n#sudo npm -g install supervison\n```\n\n由于此工具要修改一些超权限的目录，所以，需要加上管理员权限安装此工具。\n\n安装成功后\n\n```\n#supervison app.js\n```\n\n会监视项目中的文件是否被修改，如有修改，自动重启node\n\n暂时只遇到以上问题，刚刚开始学习nodejs以及express，感觉很好，模板引擎我决定这个项目使用jade，因为很好玩。\n\nos：如果你也是刚刚学习nodejs，建议先做一下官方自带的入门教程learnyounode，一共13题，很经典。如果需要中文教程，在安装好教程后，请运行learnyounode help查看帮助文档，选择自己喜欢的教程语言。\n","source":"_posts/nodejs+express.md","raw":"---\ntitle: nodejs+express\ntags: [nodejs]\ndate: 2016/02/02\n---\n\n准备用nodejs开发一个blog，没想有后台，只是想学习一下nodejs，而且我还有服务器。\n\n不知道这个项目能开发多久，希望不会半途而废。\n\n用自己零碎的时间，开发完整的项目。\n\n### 一、nodejs的安装\n\n去官网看一下<a href=\"http://nodejs.org\" target=\"_blank\">http://nodejs.org</a>\n\n### 二、npm的安装\n\n下载最新版本的nodejs自带npm\n\n### 三、express的安装\n\nnpm install express\n\n### 四、blog项目的建立\n\n服务器新建一个blog文件夹，之后初始化express blog项目\n\n```\n#mkdir blog\n#express blog\n#cd blog\n#npm install\n```\n\n由于默认安装的express是4版本的，4版本应用的jade模板，这个模板引擎其实很不错，但是，对于前端人员来说，需要将html代码转化为jade所规范的写法，增加了页面生成时间。如果熟悉了jade引擎，开发起来要比html快很多，因为可以少写很多字符。\n\n所以，需要安装ejs模板引擎，可以很快捷的使用html格式的文件。\n\n安装方法，可以npm直接安装，我所使用的方法是修改express中的package.json文件，增加\"ejs\":\"~1.0\"，之后\n\n```\n#npm install\n```\n\n### 五、增速开发\n\n由于node命令不会识别文件是否修改而且重启，所以，需要使用supervison工具，安装方式\n\n```\n#sudo npm -g install supervison\n```\n\n由于此工具要修改一些超权限的目录，所以，需要加上管理员权限安装此工具。\n\n安装成功后\n\n```\n#supervison app.js\n```\n\n会监视项目中的文件是否被修改，如有修改，自动重启node\n\n暂时只遇到以上问题，刚刚开始学习nodejs以及express，感觉很好，模板引擎我决定这个项目使用jade，因为很好玩。\n\nos：如果你也是刚刚学习nodejs，建议先做一下官方自带的入门教程learnyounode，一共13题，很经典。如果需要中文教程，在安装好教程后，请运行learnyounode help查看帮助文档，选择自己喜欢的教程语言。\n","slug":"nodejs+express","published":1,"updated":"2016-08-17T06:22:19.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpk6002t68ddcmxr78sd","content":"<p>准备用nodejs开发一个blog，没想有后台，只是想学习一下nodejs，而且我还有服务器。</p>\n<p>不知道这个项目能开发多久，希望不会半途而废。</p>\n<p>用自己零碎的时间，开发完整的项目。</p>\n<h3 id=\"一、nodejs的安装\"><a href=\"#一、nodejs的安装\" class=\"headerlink\" title=\"一、nodejs的安装\"></a>一、nodejs的安装</h3><p>去官网看一下<a href=\"http://nodejs.org\" target=\"_blank\">http://nodejs.org</a></p>\n<h3 id=\"二、npm的安装\"><a href=\"#二、npm的安装\" class=\"headerlink\" title=\"二、npm的安装\"></a>二、npm的安装</h3><p>下载最新版本的nodejs自带npm</p>\n<h3 id=\"三、express的安装\"><a href=\"#三、express的安装\" class=\"headerlink\" title=\"三、express的安装\"></a>三、express的安装</h3><p>npm install express</p>\n<h3 id=\"四、blog项目的建立\"><a href=\"#四、blog项目的建立\" class=\"headerlink\" title=\"四、blog项目的建立\"></a>四、blog项目的建立</h3><p>服务器新建一个blog文件夹，之后初始化express blog项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#mkdir blog</div><div class=\"line\">#express blog</div><div class=\"line\">#cd blog</div><div class=\"line\">#npm install</div></pre></td></tr></table></figure>\n<p>由于默认安装的express是4版本的，4版本应用的jade模板，这个模板引擎其实很不错，但是，对于前端人员来说，需要将html代码转化为jade所规范的写法，增加了页面生成时间。如果熟悉了jade引擎，开发起来要比html快很多，因为可以少写很多字符。</p>\n<p>所以，需要安装ejs模板引擎，可以很快捷的使用html格式的文件。</p>\n<p>安装方法，可以npm直接安装，我所使用的方法是修改express中的package.json文件，增加”ejs”:”~1.0”，之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#npm install</div></pre></td></tr></table></figure>\n<h3 id=\"五、增速开发\"><a href=\"#五、增速开发\" class=\"headerlink\" title=\"五、增速开发\"></a>五、增速开发</h3><p>由于node命令不会识别文件是否修改而且重启，所以，需要使用supervison工具，安装方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#sudo npm -g install supervison</div></pre></td></tr></table></figure>\n<p>由于此工具要修改一些超权限的目录，所以，需要加上管理员权限安装此工具。</p>\n<p>安装成功后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#supervison app.js</div></pre></td></tr></table></figure>\n<p>会监视项目中的文件是否被修改，如有修改，自动重启node</p>\n<p>暂时只遇到以上问题，刚刚开始学习nodejs以及express，感觉很好，模板引擎我决定这个项目使用jade，因为很好玩。</p>\n<p>os：如果你也是刚刚学习nodejs，建议先做一下官方自带的入门教程learnyounode，一共13题，很经典。如果需要中文教程，在安装好教程后，请运行learnyounode help查看帮助文档，选择自己喜欢的教程语言。</p>\n","excerpt":"","more":"<p>准备用nodejs开发一个blog，没想有后台，只是想学习一下nodejs，而且我还有服务器。</p>\n<p>不知道这个项目能开发多久，希望不会半途而废。</p>\n<p>用自己零碎的时间，开发完整的项目。</p>\n<h3 id=\"一、nodejs的安装\"><a href=\"#一、nodejs的安装\" class=\"headerlink\" title=\"一、nodejs的安装\"></a>一、nodejs的安装</h3><p>去官网看一下<a href=\"http://nodejs.org\" target=\"_blank\">http://nodejs.org</a></p>\n<h3 id=\"二、npm的安装\"><a href=\"#二、npm的安装\" class=\"headerlink\" title=\"二、npm的安装\"></a>二、npm的安装</h3><p>下载最新版本的nodejs自带npm</p>\n<h3 id=\"三、express的安装\"><a href=\"#三、express的安装\" class=\"headerlink\" title=\"三、express的安装\"></a>三、express的安装</h3><p>npm install express</p>\n<h3 id=\"四、blog项目的建立\"><a href=\"#四、blog项目的建立\" class=\"headerlink\" title=\"四、blog项目的建立\"></a>四、blog项目的建立</h3><p>服务器新建一个blog文件夹，之后初始化express blog项目</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#mkdir blog</div><div class=\"line\">#express blog</div><div class=\"line\">#cd blog</div><div class=\"line\">#npm install</div></pre></td></tr></table></figure>\n<p>由于默认安装的express是4版本的，4版本应用的jade模板，这个模板引擎其实很不错，但是，对于前端人员来说，需要将html代码转化为jade所规范的写法，增加了页面生成时间。如果熟悉了jade引擎，开发起来要比html快很多，因为可以少写很多字符。</p>\n<p>所以，需要安装ejs模板引擎，可以很快捷的使用html格式的文件。</p>\n<p>安装方法，可以npm直接安装，我所使用的方法是修改express中的package.json文件，增加”ejs”:”~1.0”，之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#npm install</div></pre></td></tr></table></figure>\n<h3 id=\"五、增速开发\"><a href=\"#五、增速开发\" class=\"headerlink\" title=\"五、增速开发\"></a>五、增速开发</h3><p>由于node命令不会识别文件是否修改而且重启，所以，需要使用supervison工具，安装方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#sudo npm -g install supervison</div></pre></td></tr></table></figure>\n<p>由于此工具要修改一些超权限的目录，所以，需要加上管理员权限安装此工具。</p>\n<p>安装成功后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#supervison app.js</div></pre></td></tr></table></figure>\n<p>会监视项目中的文件是否被修改，如有修改，自动重启node</p>\n<p>暂时只遇到以上问题，刚刚开始学习nodejs以及express，感觉很好，模板引擎我决定这个项目使用jade，因为很好玩。</p>\n<p>os：如果你也是刚刚学习nodejs，建议先做一下官方自带的入门教程learnyounode，一共13题，很经典。如果需要中文教程，在安装好教程后，请运行learnyounode help查看帮助文档，选择自己喜欢的教程语言。</p>\n"},{"title":"prop和attr的区别","date":"2015-05-26T16:00:00.000Z","_content":"\n.prop()方法应该被用来处理boolean attributes/properties以及在html(比如：window.location)中不存在的properties。其他所有的attributes(在html中你看到的那些)可以而且应该继续使用.attr()方法来进行操作。\n\n文章来源：[http://blog.sina.com.cn/s/blog_655388ed01017cnc.html](http://blog.sina.com.cn/s/blog_655388ed01017cnc.html)\n","source":"_posts/prop和attr的区别.md","raw":"---\ntitle: prop和attr的区别\ntags: [javascript,jquery]\ndate: 2015/05/27\n---\n\n.prop()方法应该被用来处理boolean attributes/properties以及在html(比如：window.location)中不存在的properties。其他所有的attributes(在html中你看到的那些)可以而且应该继续使用.attr()方法来进行操作。\n\n文章来源：[http://blog.sina.com.cn/s/blog_655388ed01017cnc.html](http://blog.sina.com.cn/s/blog_655388ed01017cnc.html)\n","slug":"prop和attr的区别","published":1,"updated":"2016-08-17T06:22:19.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpk8002v68ddlz6oyuhy","content":"<p>.prop()方法应该被用来处理boolean attributes/properties以及在html(比如：window.location)中不存在的properties。其他所有的attributes(在html中你看到的那些)可以而且应该继续使用.attr()方法来进行操作。</p>\n<p>文章来源：<a href=\"http://blog.sina.com.cn/s/blog_655388ed01017cnc.html\" target=\"_blank\" rel=\"external\">http://blog.sina.com.cn/s/blog_655388ed01017cnc.html</a></p>\n","excerpt":"","more":"<p>.prop()方法应该被用来处理boolean attributes/properties以及在html(比如：window.location)中不存在的properties。其他所有的attributes(在html中你看到的那些)可以而且应该继续使用.attr()方法来进行操作。</p>\n<p>文章来源：<a href=\"http://blog.sina.com.cn/s/blog_655388ed01017cnc.html\">http://blog.sina.com.cn/s/blog_655388ed01017cnc.html</a></p>\n"},{"title":"viewport详解","date":"2015-04-10T16:00:00.000Z","_content":"\n### 前言\n\n这次想聊聊移动开发相关的事。是的，你没有看错，一句话就可以开始你的移动前端开发。\n\n你心里一定在想，什么话这么酷，能够瞬间带入到移动前端开发的世界。\n\n但其实它一点也不新奇，不复杂。\n\n### viewport简介\n\n没错，就是viewport特性，一个移动专属的Meta值，用于定义视口的各种行为。\n\n该特性最先由Apple引入，用于解决移动端的页面展示问题，后续被越来越多的厂商跟进。\n\n举个简单的例子来讲为什么会需要它：\n\n我们知道用户大规模使用手机等移动设备来进行网页浏览器，其实得益于智能手持设备的兴起，也就是近几年的事。（还记得不久前的几年，满大街都还是诺基亚的天下么？）\n\n这时有一个很现实的问题摆在了厂商面前，用户并不能很好地通过手机等设备访问网页，因为屏幕太小。\n\n### layout viewport\n\nApple也发现了这个问题，并且适时的出现，它提出了一个方案用来解决这个问题。在iOS Safari中定义了一个viewport meta标签，用来创建一个虚拟的布局视口（layout viewport），而这个视口的分辨率接近于PC显示器，Apple将其定义为980px（其他厂商各有不同①）。\n\n这就很好的解决了早期的页面在手机上显示的问题，由于两者之间的宽度趋近，CSS只需要像在PC上那样渲染页面就行，原有的页面结构不会被破坏。\n\n> ①的描述大致如下，数值不一定持续准确，厂商可能更改，但这个绝对值其实并非特别重要：\n> iOS, Android基本都是: 980px\n> BlackBerry: 1024px\n\n### visual viewport\n\n有了layout viewport，我们还需要一个视口用来承载它，这个视口可以简单的认为是手持设备物理屏幕的可视区域，我们称之为（视觉视口）visual viewport。这是一个比较直观的概念，因为你能看得见你的手机屏幕。\n\n对于visual viewport，开发者一般只需要知道它的存在和概念就行，因为无法对它进行任何设置或者修改。很明显，visual viewport的尺寸不会是一个固定的值，甚至每款设备都可能不同。大致列几种常见设备的visual viewport尺寸：\n\n+ iPhone4~iPhone5S: 320*480px\n+ iPhone6~iPhone6S: 375*627px\n+ iPhone6 Plus~iPhone6S Plus: 414*736px\n\n以iPhone4S为例，会在其320px②的visual viewport上，创建一个宽980px的layout viewport，于是用户可以在visual viewport中拖动或者缩放网页，来获得良好的浏览效果；布局视口用来配合CSS渲染布局，当我们定义一个容器的宽度为100%时，这个容器的实际宽度是980px而不是320px，通过这种方式大部分网页就能以缩放的形式正常显示在手机屏幕上了。\n\n> ②的描述大致如下：\n> 早期移动前端开发工程师常能见到宽640px的设计稿，原因就是UI工程师以物理屏幕宽度为320px的iPhone4-iPhone5S作为参照设计；\n> 当然，现在你还可能会见到750px和1242px尺寸的设计稿，原因当然是iPhone6的出现\n> 当然，为了更好的适配移动端或者只为移动端设计的应用，单有布局视口和视觉视口还是不够的。\n\n### ideal viewport\n\n我们还需要一个视口，它类似于布局视口，但宽度和视觉视口相同，这就是完美视口（ideal viewport）。\n\n有了完美视口，用户不用缩放和拖动网页就能够很好的进行网页浏览。而完美视口也是通过viewport meta的某种设置来达到。\n\n说了这么一大堆的东西，貌似都和viewport有关联，那么viewport到底怎么搞，请继续往下。\n\n### viewport特性\n\n通常情况下，viewport有以下6种设置。当然厂商可能会增加一些特定的设置，比如iOS Safari7.1增加了一种在网页加载时隐藏地址栏与导航栏的设置：minimal-ui，不过随后又将之移除了。\n\n| Name                    | Value            | Description                      |\n| :---------------------- | :--------------- | :------------------------------- |\n| width                   | 正整数或device-width | 定义视口的宽度，单位为像素                    |\n| height正整数或device-height | 定义视口的高度，单位为像素    |                                  |\n| initial-scale           | [0.0-10.0]       | 定义初始缩放值                          |\n| minimum-scale           | [0.0-10.0]       | 定义缩小最小比例，它必须小于或等于maximum-scale设置 |\n| maximum-scale           | [0.0-10.0]       | 定义放大最大比例，它必须大于或等于minimum-scale设置 |\n| user-scalable           | yes/no           | 定义是否允许用户手动缩放页面，默认值yes            |\n\n**width**\n\nwidth被用来定义layout viewport的宽度，如果不指定该属性（或者移除viewport meta标签），则layout viewport宽度为厂商默认值。如：iPhone为980px；\n\n举个例子：\n\n```\n<meta name=\"viewport\" content=\"width=device-width\" />\n```\n\n此时的layout viewport将成为ideal viewport，因为layout viewport宽度与设备视觉视口宽度一致了。\n\n除了width之外，还有一个属性定义也能实现ideal viewport，那就是initial-scale。\n\n**height**\n\n与width类似，但实际上却不常用，因为没有太多的use case。\n\n**initial-scale**\n\n如果想页面默认以某个比例放大或者缩小然后呈现给用户，那么可以通过定义initial-scale来完成。\n\ninitial-scale用于指定页面的初始缩放比例，假定你这样定义：\n\n```\n<meta name=\"viewport\" content=\"initial-scale=2\" />\n```\n\n那么用户将会看到2倍大小的页面内容。\n\n在说width的时候，我们说到initial-scale也能实现ideal viewport，是的，你只需要这样做，也可以得到完美视口：\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1\" />\n```\n\n**maximum-scale**\n\n在移动端，你可能会考虑用户浏览不便，然后给予用户放大页面的权利，但同时又希望是在一定范围内的放大，这时就可以使用maximum-scale来进行约束。\n\nmaximum-scale用于指定用户能够放大的比例。\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=5\" />\n```\n\n假设页面的默认缩放值initial-scale是1，那么用户最终能够将页面放大到这个初始页面大小的5倍。\n\n**minimum-scale**\n\n类似maximum-scale的描述，不过minimum-scale是用来指定页面缩小比例的。\n\n通常情况下，为了有更好地体验，不会定义该属性的值比1更小，因为那样页面将变得难以阅读。\n\n**user-scalable**\n\n如果你不想页面被放大或者缩小，通过定义user-scalable来约束用户是否可以通过手势对页面进行缩放即可。\n\n该属性的默认值为yes，即可被缩放（如果使用默认值，该属性可以不定义）；当然，如果你的应用不打算让用户拥有缩放权限，可以将该值设置为no。\n\n使用方法如下：\n\n```\n<meta name=\"viewport\" content=\"user-scalable=no\" />\n```\n\n### 结语\n\n正如开篇所说，这既不高深也不新奇，它而仅仅是一点观念转变。\n\n当你掌握了viewport，那么意味着你已经大致了解了移动平台与PC平台的不同，你可以更专注而细致的去解决某些平台差异问题。\n\n转载：[http://web.jobbole.com](http://web.jobbole.com/85854/)\n","source":"_posts/viewport详解.md","raw":"---\ntitle: viewport详解\ntags: [css]\ndate: 2015/04/11\n---\n\n### 前言\n\n这次想聊聊移动开发相关的事。是的，你没有看错，一句话就可以开始你的移动前端开发。\n\n你心里一定在想，什么话这么酷，能够瞬间带入到移动前端开发的世界。\n\n但其实它一点也不新奇，不复杂。\n\n### viewport简介\n\n没错，就是viewport特性，一个移动专属的Meta值，用于定义视口的各种行为。\n\n该特性最先由Apple引入，用于解决移动端的页面展示问题，后续被越来越多的厂商跟进。\n\n举个简单的例子来讲为什么会需要它：\n\n我们知道用户大规模使用手机等移动设备来进行网页浏览器，其实得益于智能手持设备的兴起，也就是近几年的事。（还记得不久前的几年，满大街都还是诺基亚的天下么？）\n\n这时有一个很现实的问题摆在了厂商面前，用户并不能很好地通过手机等设备访问网页，因为屏幕太小。\n\n### layout viewport\n\nApple也发现了这个问题，并且适时的出现，它提出了一个方案用来解决这个问题。在iOS Safari中定义了一个viewport meta标签，用来创建一个虚拟的布局视口（layout viewport），而这个视口的分辨率接近于PC显示器，Apple将其定义为980px（其他厂商各有不同①）。\n\n这就很好的解决了早期的页面在手机上显示的问题，由于两者之间的宽度趋近，CSS只需要像在PC上那样渲染页面就行，原有的页面结构不会被破坏。\n\n> ①的描述大致如下，数值不一定持续准确，厂商可能更改，但这个绝对值其实并非特别重要：\n> iOS, Android基本都是: 980px\n> BlackBerry: 1024px\n\n### visual viewport\n\n有了layout viewport，我们还需要一个视口用来承载它，这个视口可以简单的认为是手持设备物理屏幕的可视区域，我们称之为（视觉视口）visual viewport。这是一个比较直观的概念，因为你能看得见你的手机屏幕。\n\n对于visual viewport，开发者一般只需要知道它的存在和概念就行，因为无法对它进行任何设置或者修改。很明显，visual viewport的尺寸不会是一个固定的值，甚至每款设备都可能不同。大致列几种常见设备的visual viewport尺寸：\n\n+ iPhone4~iPhone5S: 320*480px\n+ iPhone6~iPhone6S: 375*627px\n+ iPhone6 Plus~iPhone6S Plus: 414*736px\n\n以iPhone4S为例，会在其320px②的visual viewport上，创建一个宽980px的layout viewport，于是用户可以在visual viewport中拖动或者缩放网页，来获得良好的浏览效果；布局视口用来配合CSS渲染布局，当我们定义一个容器的宽度为100%时，这个容器的实际宽度是980px而不是320px，通过这种方式大部分网页就能以缩放的形式正常显示在手机屏幕上了。\n\n> ②的描述大致如下：\n> 早期移动前端开发工程师常能见到宽640px的设计稿，原因就是UI工程师以物理屏幕宽度为320px的iPhone4-iPhone5S作为参照设计；\n> 当然，现在你还可能会见到750px和1242px尺寸的设计稿，原因当然是iPhone6的出现\n> 当然，为了更好的适配移动端或者只为移动端设计的应用，单有布局视口和视觉视口还是不够的。\n\n### ideal viewport\n\n我们还需要一个视口，它类似于布局视口，但宽度和视觉视口相同，这就是完美视口（ideal viewport）。\n\n有了完美视口，用户不用缩放和拖动网页就能够很好的进行网页浏览。而完美视口也是通过viewport meta的某种设置来达到。\n\n说了这么一大堆的东西，貌似都和viewport有关联，那么viewport到底怎么搞，请继续往下。\n\n### viewport特性\n\n通常情况下，viewport有以下6种设置。当然厂商可能会增加一些特定的设置，比如iOS Safari7.1增加了一种在网页加载时隐藏地址栏与导航栏的设置：minimal-ui，不过随后又将之移除了。\n\n| Name                    | Value            | Description                      |\n| :---------------------- | :--------------- | :------------------------------- |\n| width                   | 正整数或device-width | 定义视口的宽度，单位为像素                    |\n| height正整数或device-height | 定义视口的高度，单位为像素    |                                  |\n| initial-scale           | [0.0-10.0]       | 定义初始缩放值                          |\n| minimum-scale           | [0.0-10.0]       | 定义缩小最小比例，它必须小于或等于maximum-scale设置 |\n| maximum-scale           | [0.0-10.0]       | 定义放大最大比例，它必须大于或等于minimum-scale设置 |\n| user-scalable           | yes/no           | 定义是否允许用户手动缩放页面，默认值yes            |\n\n**width**\n\nwidth被用来定义layout viewport的宽度，如果不指定该属性（或者移除viewport meta标签），则layout viewport宽度为厂商默认值。如：iPhone为980px；\n\n举个例子：\n\n```\n<meta name=\"viewport\" content=\"width=device-width\" />\n```\n\n此时的layout viewport将成为ideal viewport，因为layout viewport宽度与设备视觉视口宽度一致了。\n\n除了width之外，还有一个属性定义也能实现ideal viewport，那就是initial-scale。\n\n**height**\n\n与width类似，但实际上却不常用，因为没有太多的use case。\n\n**initial-scale**\n\n如果想页面默认以某个比例放大或者缩小然后呈现给用户，那么可以通过定义initial-scale来完成。\n\ninitial-scale用于指定页面的初始缩放比例，假定你这样定义：\n\n```\n<meta name=\"viewport\" content=\"initial-scale=2\" />\n```\n\n那么用户将会看到2倍大小的页面内容。\n\n在说width的时候，我们说到initial-scale也能实现ideal viewport，是的，你只需要这样做，也可以得到完美视口：\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1\" />\n```\n\n**maximum-scale**\n\n在移动端，你可能会考虑用户浏览不便，然后给予用户放大页面的权利，但同时又希望是在一定范围内的放大，这时就可以使用maximum-scale来进行约束。\n\nmaximum-scale用于指定用户能够放大的比例。\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=5\" />\n```\n\n假设页面的默认缩放值initial-scale是1，那么用户最终能够将页面放大到这个初始页面大小的5倍。\n\n**minimum-scale**\n\n类似maximum-scale的描述，不过minimum-scale是用来指定页面缩小比例的。\n\n通常情况下，为了有更好地体验，不会定义该属性的值比1更小，因为那样页面将变得难以阅读。\n\n**user-scalable**\n\n如果你不想页面被放大或者缩小，通过定义user-scalable来约束用户是否可以通过手势对页面进行缩放即可。\n\n该属性的默认值为yes，即可被缩放（如果使用默认值，该属性可以不定义）；当然，如果你的应用不打算让用户拥有缩放权限，可以将该值设置为no。\n\n使用方法如下：\n\n```\n<meta name=\"viewport\" content=\"user-scalable=no\" />\n```\n\n### 结语\n\n正如开篇所说，这既不高深也不新奇，它而仅仅是一点观念转变。\n\n当你掌握了viewport，那么意味着你已经大致了解了移动平台与PC平台的不同，你可以更专注而细致的去解决某些平台差异问题。\n\n转载：[http://web.jobbole.com](http://web.jobbole.com/85854/)\n","slug":"viewport详解","published":1,"updated":"2016-08-17T06:22:19.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkc002y68ddekaw57gg","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这次想聊聊移动开发相关的事。是的，你没有看错，一句话就可以开始你的移动前端开发。</p>\n<p>你心里一定在想，什么话这么酷，能够瞬间带入到移动前端开发的世界。</p>\n<p>但其实它一点也不新奇，不复杂。</p>\n<h3 id=\"viewport简介\"><a href=\"#viewport简介\" class=\"headerlink\" title=\"viewport简介\"></a>viewport简介</h3><p>没错，就是viewport特性，一个移动专属的Meta值，用于定义视口的各种行为。</p>\n<p>该特性最先由Apple引入，用于解决移动端的页面展示问题，后续被越来越多的厂商跟进。</p>\n<p>举个简单的例子来讲为什么会需要它：</p>\n<p>我们知道用户大规模使用手机等移动设备来进行网页浏览器，其实得益于智能手持设备的兴起，也就是近几年的事。（还记得不久前的几年，满大街都还是诺基亚的天下么？）</p>\n<p>这时有一个很现实的问题摆在了厂商面前，用户并不能很好地通过手机等设备访问网页，因为屏幕太小。</p>\n<h3 id=\"layout-viewport\"><a href=\"#layout-viewport\" class=\"headerlink\" title=\"layout viewport\"></a>layout viewport</h3><p>Apple也发现了这个问题，并且适时的出现，它提出了一个方案用来解决这个问题。在iOS Safari中定义了一个viewport meta标签，用来创建一个虚拟的布局视口（layout viewport），而这个视口的分辨率接近于PC显示器，Apple将其定义为980px（其他厂商各有不同①）。</p>\n<p>这就很好的解决了早期的页面在手机上显示的问题，由于两者之间的宽度趋近，CSS只需要像在PC上那样渲染页面就行，原有的页面结构不会被破坏。</p>\n<blockquote>\n<p>①的描述大致如下，数值不一定持续准确，厂商可能更改，但这个绝对值其实并非特别重要：<br>iOS, Android基本都是: 980px<br>BlackBerry: 1024px</p>\n</blockquote>\n<h3 id=\"visual-viewport\"><a href=\"#visual-viewport\" class=\"headerlink\" title=\"visual viewport\"></a>visual viewport</h3><p>有了layout viewport，我们还需要一个视口用来承载它，这个视口可以简单的认为是手持设备物理屏幕的可视区域，我们称之为（视觉视口）visual viewport。这是一个比较直观的概念，因为你能看得见你的手机屏幕。</p>\n<p>对于visual viewport，开发者一般只需要知道它的存在和概念就行，因为无法对它进行任何设置或者修改。很明显，visual viewport的尺寸不会是一个固定的值，甚至每款设备都可能不同。大致列几种常见设备的visual viewport尺寸：</p>\n<ul>\n<li>iPhone4~iPhone5S: 320*480px</li>\n<li>iPhone6~iPhone6S: 375*627px</li>\n<li>iPhone6 Plus~iPhone6S Plus: 414*736px</li>\n</ul>\n<p>以iPhone4S为例，会在其320px②的visual viewport上，创建一个宽980px的layout viewport，于是用户可以在visual viewport中拖动或者缩放网页，来获得良好的浏览效果；布局视口用来配合CSS渲染布局，当我们定义一个容器的宽度为100%时，这个容器的实际宽度是980px而不是320px，通过这种方式大部分网页就能以缩放的形式正常显示在手机屏幕上了。</p>\n<blockquote>\n<p>②的描述大致如下：<br>早期移动前端开发工程师常能见到宽640px的设计稿，原因就是UI工程师以物理屏幕宽度为320px的iPhone4-iPhone5S作为参照设计；<br>当然，现在你还可能会见到750px和1242px尺寸的设计稿，原因当然是iPhone6的出现<br>当然，为了更好的适配移动端或者只为移动端设计的应用，单有布局视口和视觉视口还是不够的。</p>\n</blockquote>\n<h3 id=\"ideal-viewport\"><a href=\"#ideal-viewport\" class=\"headerlink\" title=\"ideal viewport\"></a>ideal viewport</h3><p>我们还需要一个视口，它类似于布局视口，但宽度和视觉视口相同，这就是完美视口（ideal viewport）。</p>\n<p>有了完美视口，用户不用缩放和拖动网页就能够很好的进行网页浏览。而完美视口也是通过viewport meta的某种设置来达到。</p>\n<p>说了这么一大堆的东西，貌似都和viewport有关联，那么viewport到底怎么搞，请继续往下。</p>\n<h3 id=\"viewport特性\"><a href=\"#viewport特性\" class=\"headerlink\" title=\"viewport特性\"></a>viewport特性</h3><p>通常情况下，viewport有以下6种设置。当然厂商可能会增加一些特定的设置，比如iOS Safari7.1增加了一种在网页加载时隐藏地址栏与导航栏的设置：minimal-ui，不过随后又将之移除了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Name</th>\n<th style=\"text-align:left\">Value</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">width</td>\n<td style=\"text-align:left\">正整数或device-width</td>\n<td style=\"text-align:left\">定义视口的宽度，单位为像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">height正整数或device-height</td>\n<td style=\"text-align:left\">定义视口的高度，单位为像素</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">initial-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义初始缩放值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">minimum-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义缩小最小比例，它必须小于或等于maximum-scale设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">maximum-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义放大最大比例，它必须大于或等于minimum-scale设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user-scalable</td>\n<td style=\"text-align:left\">yes/no</td>\n<td style=\"text-align:left\">定义是否允许用户手动缩放页面，默认值yes</td>\n</tr>\n</tbody>\n</table>\n<p><strong>width</strong></p>\n<p>width被用来定义layout viewport的宽度，如果不指定该属性（或者移除viewport meta标签），则layout viewport宽度为厂商默认值。如：iPhone为980px；</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>此时的layout viewport将成为ideal viewport，因为layout viewport宽度与设备视觉视口宽度一致了。</p>\n<p>除了width之外，还有一个属性定义也能实现ideal viewport，那就是initial-scale。</p>\n<p><strong>height</strong></p>\n<p>与width类似，但实际上却不常用，因为没有太多的use case。</p>\n<p><strong>initial-scale</strong></p>\n<p>如果想页面默认以某个比例放大或者缩小然后呈现给用户，那么可以通过定义initial-scale来完成。</p>\n<p>initial-scale用于指定页面的初始缩放比例，假定你这样定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=2&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>那么用户将会看到2倍大小的页面内容。</p>\n<p>在说width的时候，我们说到initial-scale也能实现ideal viewport，是的，你只需要这样做，也可以得到完美视口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>maximum-scale</strong></p>\n<p>在移动端，你可能会考虑用户浏览不便，然后给予用户放大页面的权利，但同时又希望是在一定范围内的放大，这时就可以使用maximum-scale来进行约束。</p>\n<p>maximum-scale用于指定用户能够放大的比例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=5&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>假设页面的默认缩放值initial-scale是1，那么用户最终能够将页面放大到这个初始页面大小的5倍。</p>\n<p><strong>minimum-scale</strong></p>\n<p>类似maximum-scale的描述，不过minimum-scale是用来指定页面缩小比例的。</p>\n<p>通常情况下，为了有更好地体验，不会定义该属性的值比1更小，因为那样页面将变得难以阅读。</p>\n<p><strong>user-scalable</strong></p>\n<p>如果你不想页面被放大或者缩小，通过定义user-scalable来约束用户是否可以通过手势对页面进行缩放即可。</p>\n<p>该属性的默认值为yes，即可被缩放（如果使用默认值，该属性可以不定义）；当然，如果你的应用不打算让用户拥有缩放权限，可以将该值设置为no。</p>\n<p>使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>正如开篇所说，这既不高深也不新奇，它而仅仅是一点观念转变。</p>\n<p>当你掌握了viewport，那么意味着你已经大致了解了移动平台与PC平台的不同，你可以更专注而细致的去解决某些平台差异问题。</p>\n<p>转载：<a href=\"http://web.jobbole.com/85854/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>这次想聊聊移动开发相关的事。是的，你没有看错，一句话就可以开始你的移动前端开发。</p>\n<p>你心里一定在想，什么话这么酷，能够瞬间带入到移动前端开发的世界。</p>\n<p>但其实它一点也不新奇，不复杂。</p>\n<h3 id=\"viewport简介\"><a href=\"#viewport简介\" class=\"headerlink\" title=\"viewport简介\"></a>viewport简介</h3><p>没错，就是viewport特性，一个移动专属的Meta值，用于定义视口的各种行为。</p>\n<p>该特性最先由Apple引入，用于解决移动端的页面展示问题，后续被越来越多的厂商跟进。</p>\n<p>举个简单的例子来讲为什么会需要它：</p>\n<p>我们知道用户大规模使用手机等移动设备来进行网页浏览器，其实得益于智能手持设备的兴起，也就是近几年的事。（还记得不久前的几年，满大街都还是诺基亚的天下么？）</p>\n<p>这时有一个很现实的问题摆在了厂商面前，用户并不能很好地通过手机等设备访问网页，因为屏幕太小。</p>\n<h3 id=\"layout-viewport\"><a href=\"#layout-viewport\" class=\"headerlink\" title=\"layout viewport\"></a>layout viewport</h3><p>Apple也发现了这个问题，并且适时的出现，它提出了一个方案用来解决这个问题。在iOS Safari中定义了一个viewport meta标签，用来创建一个虚拟的布局视口（layout viewport），而这个视口的分辨率接近于PC显示器，Apple将其定义为980px（其他厂商各有不同①）。</p>\n<p>这就很好的解决了早期的页面在手机上显示的问题，由于两者之间的宽度趋近，CSS只需要像在PC上那样渲染页面就行，原有的页面结构不会被破坏。</p>\n<blockquote>\n<p>①的描述大致如下，数值不一定持续准确，厂商可能更改，但这个绝对值其实并非特别重要：<br>iOS, Android基本都是: 980px<br>BlackBerry: 1024px</p>\n</blockquote>\n<h3 id=\"visual-viewport\"><a href=\"#visual-viewport\" class=\"headerlink\" title=\"visual viewport\"></a>visual viewport</h3><p>有了layout viewport，我们还需要一个视口用来承载它，这个视口可以简单的认为是手持设备物理屏幕的可视区域，我们称之为（视觉视口）visual viewport。这是一个比较直观的概念，因为你能看得见你的手机屏幕。</p>\n<p>对于visual viewport，开发者一般只需要知道它的存在和概念就行，因为无法对它进行任何设置或者修改。很明显，visual viewport的尺寸不会是一个固定的值，甚至每款设备都可能不同。大致列几种常见设备的visual viewport尺寸：</p>\n<ul>\n<li>iPhone4~iPhone5S: 320*480px</li>\n<li>iPhone6~iPhone6S: 375*627px</li>\n<li>iPhone6 Plus~iPhone6S Plus: 414*736px</li>\n</ul>\n<p>以iPhone4S为例，会在其320px②的visual viewport上，创建一个宽980px的layout viewport，于是用户可以在visual viewport中拖动或者缩放网页，来获得良好的浏览效果；布局视口用来配合CSS渲染布局，当我们定义一个容器的宽度为100%时，这个容器的实际宽度是980px而不是320px，通过这种方式大部分网页就能以缩放的形式正常显示在手机屏幕上了。</p>\n<blockquote>\n<p>②的描述大致如下：<br>早期移动前端开发工程师常能见到宽640px的设计稿，原因就是UI工程师以物理屏幕宽度为320px的iPhone4-iPhone5S作为参照设计；<br>当然，现在你还可能会见到750px和1242px尺寸的设计稿，原因当然是iPhone6的出现<br>当然，为了更好的适配移动端或者只为移动端设计的应用，单有布局视口和视觉视口还是不够的。</p>\n</blockquote>\n<h3 id=\"ideal-viewport\"><a href=\"#ideal-viewport\" class=\"headerlink\" title=\"ideal viewport\"></a>ideal viewport</h3><p>我们还需要一个视口，它类似于布局视口，但宽度和视觉视口相同，这就是完美视口（ideal viewport）。</p>\n<p>有了完美视口，用户不用缩放和拖动网页就能够很好的进行网页浏览。而完美视口也是通过viewport meta的某种设置来达到。</p>\n<p>说了这么一大堆的东西，貌似都和viewport有关联，那么viewport到底怎么搞，请继续往下。</p>\n<h3 id=\"viewport特性\"><a href=\"#viewport特性\" class=\"headerlink\" title=\"viewport特性\"></a>viewport特性</h3><p>通常情况下，viewport有以下6种设置。当然厂商可能会增加一些特定的设置，比如iOS Safari7.1增加了一种在网页加载时隐藏地址栏与导航栏的设置：minimal-ui，不过随后又将之移除了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Name</th>\n<th style=\"text-align:left\">Value</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">width</td>\n<td style=\"text-align:left\">正整数或device-width</td>\n<td style=\"text-align:left\">定义视口的宽度，单位为像素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">height正整数或device-height</td>\n<td style=\"text-align:left\">定义视口的高度，单位为像素</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">initial-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义初始缩放值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">minimum-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义缩小最小比例，它必须小于或等于maximum-scale设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">maximum-scale</td>\n<td style=\"text-align:left\">[0.0-10.0]</td>\n<td style=\"text-align:left\">定义放大最大比例，它必须大于或等于minimum-scale设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user-scalable</td>\n<td style=\"text-align:left\">yes/no</td>\n<td style=\"text-align:left\">定义是否允许用户手动缩放页面，默认值yes</td>\n</tr>\n</tbody>\n</table>\n<p><strong>width</strong></p>\n<p>width被用来定义layout viewport的宽度，如果不指定该属性（或者移除viewport meta标签），则layout viewport宽度为厂商默认值。如：iPhone为980px；</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>此时的layout viewport将成为ideal viewport，因为layout viewport宽度与设备视觉视口宽度一致了。</p>\n<p>除了width之外，还有一个属性定义也能实现ideal viewport，那就是initial-scale。</p>\n<p><strong>height</strong></p>\n<p>与width类似，但实际上却不常用，因为没有太多的use case。</p>\n<p><strong>initial-scale</strong></p>\n<p>如果想页面默认以某个比例放大或者缩小然后呈现给用户，那么可以通过定义initial-scale来完成。</p>\n<p>initial-scale用于指定页面的初始缩放比例，假定你这样定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=2&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>那么用户将会看到2倍大小的页面内容。</p>\n<p>在说width的时候，我们说到initial-scale也能实现ideal viewport，是的，你只需要这样做，也可以得到完美视口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>maximum-scale</strong></p>\n<p>在移动端，你可能会考虑用户浏览不便，然后给予用户放大页面的权利，但同时又希望是在一定范围内的放大，这时就可以使用maximum-scale来进行约束。</p>\n<p>maximum-scale用于指定用户能够放大的比例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=5&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>假设页面的默认缩放值initial-scale是1，那么用户最终能够将页面放大到这个初始页面大小的5倍。</p>\n<p><strong>minimum-scale</strong></p>\n<p>类似maximum-scale的描述，不过minimum-scale是用来指定页面缩小比例的。</p>\n<p>通常情况下，为了有更好地体验，不会定义该属性的值比1更小，因为那样页面将变得难以阅读。</p>\n<p><strong>user-scalable</strong></p>\n<p>如果你不想页面被放大或者缩小，通过定义user-scalable来约束用户是否可以通过手势对页面进行缩放即可。</p>\n<p>该属性的默认值为yes，即可被缩放（如果使用默认值，该属性可以不定义）；当然，如果你的应用不打算让用户拥有缩放权限，可以将该值设置为no。</p>\n<p>使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>正如开篇所说，这既不高深也不新奇，它而仅仅是一点观念转变。</p>\n<p>当你掌握了viewport，那么意味着你已经大致了解了移动平台与PC平台的不同，你可以更专注而细致的去解决某些平台差异问题。</p>\n<p>转载：<a href=\"http://web.jobbole.com/85854/\">http://web.jobbole.com</a></p>\n"},{"title":"webpack入门指南","date":"2015-04-04T16:00:00.000Z","_content":"\n### 什么是 webpack ?\n\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n\n![](http://images0.cnblogs.com/blog2015/561179/201507/161453372048661.jpg)\n\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。\n\n你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 [React-Bootstrap](https://github.com/react-bootstrap/react-bootstrap) 和 [Redux](https://github.com/gaearon/redux)。\n\nwebpack的官网是 [http://webpack.github.io/](http://webpack.github.io/) ，文档地址是 [http://webpack.github.io/docs/](http://webpack.github.io/docs/) ，想对其进行更详细了解的可以点进去瞧一瞧。\n\n### webpack 的优势\n\n其优势主要可以归类为如下几个：\n\n1. webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。\n2. 能被模块化的不仅仅是 JS 了。\n3. 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。\n4. 扩展性强，插件机制完善，特别是支持 React 热插拔（见 [react-hot-loader](https://github.com/gaearon/react-hot-loader) ）的功能让人眼前一亮。\n\n我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：\n\n```javascript\ndefine(['package/lib'], function(lib){\n \n    function foo(){\n        lib.log('hello world!');\n    } \n \n    return {\n        foo: foo\n    };\n});\n```\n\n另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：\n\n```javascript\ndefine(function (require, exports, module){\n    var someModule = require(\"someModule\");\n    var anotherModule = require(\"anotherModule\");    \n\n    someModule.doTehAwesome();\n    anotherModule.doMoarAwesome();\n\n    exports.asplode = function (){\n        someModule.doTehAwesome();\n        anotherModule.doMoarAwesome();\n    };\n});\n```\n\n然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：\n\n```javascript\n    var someModule = require(\"someModule\");\n    var anotherModule = require(\"anotherModule\");    \n\n    someModule.doTehAwesome();\n    anotherModule.doMoarAwesome();\n\n    exports.asplode = function (){\n        someModule.doTehAwesome();\n        anotherModule.doMoarAwesome();\n    };\n```\n\n这样撸码自然更简单，跟回调神马的说 byebye~\n\n不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。\n\n### 一. 安装\n\n我们常规直接使用 npm 的形式来安装：\n\n`$ npm install webpack -g`\n\n当然如果常规项目还是把依赖写入 package.json 包去更人性化：\n\n`$ npm init`\n\n`$ npm install webpack --save-dev`\n\n### 二. 配置\n\n每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。\n\n我们看看下方的示例：\n\n```javascript\nvar webpack = require('webpack');\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n    //插件项\n    plugins: [commonsPlugin],\n    //页面入口文件配置\n    entry: {\n        index : './src/js/page/index.js'\n    },\n    //入口文件输出配置\n    output: {\n        path: 'dist/js/page',\n        filename: '[name].js'\n    },\n    module: {\n        //加载器配置\n        loaders: [\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    },\n    //其它解决方案配置\n    resolve: {\n        root: 'E:/github/flux-example/src', //绝对路径\n        extensions: ['', '.js', '.json', '.scss'],\n        alias: {\n            AppStore : 'js/stores/AppStores.js',\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n};\n```\n\n⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。\n\n⑵ entry 是页面入口文件配置，output 是对应输出项配置*（即入口文件最终要生成什么名字的文件、存放到哪里）*，其语法大致为：\n\n```javascript\n{\n    entry: {\n        page1: \"./page1\",\n        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出\n        page2: [\"./entry1\", \"./entry2\"]\n    },\n    output: {\n        path: \"dist/js/page\",\n        filename: \"[name].bundle.js\"\n    }\n}\n```\n\n该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。\n\n⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：\n\n```javascript\n    module: {\n        //加载器配置\n        loaders: [\n            //.css 文件使用 style-loader 和 css-loader 来处理\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            //.js 文件使用 jsx-loader 来编译处理\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    }\n```\n\n如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。\n\n注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。\n\n拿最后一个 [url-loader](https://github.com/webpack/url-loader) 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：\n\n`npm install url-loader -save-dev`\n\n配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式*（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）*。\n\n你可以[点这里](http://webpack.github.io/docs/list-of-loaders.html)查阅全部的 loader 列表。\n\n⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：\n\n```javascript\n    resolve: {\n        //查找module的话从这里开始查找\n        root: 'E:/github/flux-example/src', //绝对路径\n        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n        extensions: ['', '.js', '.json', '.scss'],\n        //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n        alias: {\n            AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n```\n\n关于 webpack.config.js 更详尽的配置可以参考[这里](http://webpack.github.io/docs/configuration.html)。\n\n### 运行 webpack\n\nwebpack 的执行也很简单，直接执行\n\n`$ webpack --display-error-details`\n\n即可，后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。\n\n其他主要的参数有：\n\n```shell\n$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\n\n$ webpack --watch   //监听变动并自动打包\n\n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n\n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n其中的 *-p* 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb*（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）*。\n\n### 其他\n\n至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。\n\n**一. shimming**\n\n在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 [exports-loader](https://github.com/webpack/exports-loader) 来帮忙：\n\n```javascript\n{ test: require.resolve(\"./src/js/tool/swipe.js\"),  loader: \"exports?swipe\"}\n```\n\n之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：\n\n```javascript\nrequire('./tool/swipe.js');\nswipe(); \n```\n\n**二. 自定义公共模块提取**\n\n在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。\n\n但有时候我们希望能更加个性化一些，我们可以这样配置：\n\n```javascript\nvar CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");\nmodule.exports = {\n    entry: {\n        p1: \"./page1\",\n        p2: \"./page2\",\n        p3: \"./page3\",\n        ap1: \"./admin/page1\",\n        ap2: \"./admin/page2\"\n    },\n    output: {\n        filename: \"[name].js\"\n    },\n    plugins: [\n        new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]),\n        new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"])\n    ]\n};\n// <script>s required:\n// page1.html: commons.js, p1.js\n// page2.html: commons.js, p2.js\n// page3.html: p3.js\n// admin-page1.html: commons.js, admin-commons.js, ap1.js\n// admin-page2.html: commons.js, admin-commons.js, ap2.js\n```\n\n**三. 独立打包样式文件**\n\n有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 [extract-text-webpack-plugin](https://github.com/webpack/extract-text-webpack-plugin) 来帮忙：\n\n```javascript\n    var webpack = require('webpack');\n    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n    var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\n    module.exports = {\n        plugins: [commonsPlugin, new ExtractTextPlugin(\"[name].css\")],\n        entry: {\n        //...省略其它配置\n```\n\n最终 webpack 执行后会乖乖地把样式文件提取出来：\n\n![](http://images0.cnblogs.com/blog2015/561179/201507/161159531266643.png)\n\n**四. 使用CDN/远程文件**\n\n有时候我们希望某些模块走CDN并以`<script>`的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。\n\n这时候我们可以在配置文件里使用 externals 属性来帮忙：\n\n```javascript\n{\n    externals: {\n        // require(\"jquery\") 是引用自外部模块的\n        // 对应全局变量 jQuery\n        \"jquery\": \"jQuery\"\n    }\n}\n```\n\n需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。\n\n我们倒也可以使用 [script.js](https://github.com/ded/script.js) 在脚本中来加载我们的模块：\n\n```javascript\nvar $script = require(\"scriptjs\");\n$script(\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\", function() {\n  $('body').html('It works!')\n});\n```\n\n**五. 与 grunt/gulp 配合**\n\n以 gulp 为示例，我们可以这样混搭：\n\n```javascript\ngulp.task(\"webpack\", function(callback) {\n    // run webpack\n    webpack({\n        // configuration\n    }, function(err, stats) {\n        if(err) throw new gutil.PluginError(\"webpack\", err);\n        gutil.log(\"[webpack]\", stats.toString({\n            // output options\n        }));\n        callback();\n    });\n});\n```\n\n当然我们只需要把配置写到 webpack({ ... }) 中去即可，无须再写 webpack.config.js 了。\n\n更多参照信息请参阅：[grunt配置](http://webpack.github.io/docs/usage-with-grunt.html) / [gulp配置](http://webpack.github.io/docs/usage-with-gulp.html) 。\n\n**六. React 相关**\n\n⑴ 推荐使用 *npm install react* 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。\n\n⑵ [react-hot-loader](https://github.com/gaearon/react-hot-loader) 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 [webpack-dev-server](http://webpack.github.io/docs/webpack-dev-server.html) 使用更佳！\n\n \n\n基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考下述的文章来入门：\n\n[webpack入门指谜](http://segmentfault.com/a/1190000002551952)\n\n[webpack-howto](https://github.com/petehunt/webpack-howto)\n\n共勉~\n\n","source":"_posts/webpack入门指南.md","raw":"---\ntitle: webpack入门指南\ntags: [javascript]\ndate: 2015/04/05\n---\n\n### 什么是 webpack ?\n\nwebpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。\n\n![](http://images0.cnblogs.com/blog2015/561179/201507/161453372048661.jpg)\n\n我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。\n\n你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 [React-Bootstrap](https://github.com/react-bootstrap/react-bootstrap) 和 [Redux](https://github.com/gaearon/redux)。\n\nwebpack的官网是 [http://webpack.github.io/](http://webpack.github.io/) ，文档地址是 [http://webpack.github.io/docs/](http://webpack.github.io/docs/) ，想对其进行更详细了解的可以点进去瞧一瞧。\n\n### webpack 的优势\n\n其优势主要可以归类为如下几个：\n\n1. webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。\n2. 能被模块化的不仅仅是 JS 了。\n3. 开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。\n4. 扩展性强，插件机制完善，特别是支持 React 热插拔（见 [react-hot-loader](https://github.com/gaearon/react-hot-loader) ）的功能让人眼前一亮。\n\n我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：\n\n```javascript\ndefine(['package/lib'], function(lib){\n \n    function foo(){\n        lib.log('hello world!');\n    } \n \n    return {\n        foo: foo\n    };\n});\n```\n\n另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：\n\n```javascript\ndefine(function (require, exports, module){\n    var someModule = require(\"someModule\");\n    var anotherModule = require(\"anotherModule\");    \n\n    someModule.doTehAwesome();\n    anotherModule.doMoarAwesome();\n\n    exports.asplode = function (){\n        someModule.doTehAwesome();\n        anotherModule.doMoarAwesome();\n    };\n});\n```\n\n然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：\n\n```javascript\n    var someModule = require(\"someModule\");\n    var anotherModule = require(\"anotherModule\");    \n\n    someModule.doTehAwesome();\n    anotherModule.doMoarAwesome();\n\n    exports.asplode = function (){\n        someModule.doTehAwesome();\n        anotherModule.doMoarAwesome();\n    };\n```\n\n这样撸码自然更简单，跟回调神马的说 byebye~\n\n不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。\n\n### 一. 安装\n\n我们常规直接使用 npm 的形式来安装：\n\n`$ npm install webpack -g`\n\n当然如果常规项目还是把依赖写入 package.json 包去更人性化：\n\n`$ npm init`\n\n`$ npm install webpack --save-dev`\n\n### 二. 配置\n\n每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。\n\n我们看看下方的示例：\n\n```javascript\nvar webpack = require('webpack');\nvar commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n\nmodule.exports = {\n    //插件项\n    plugins: [commonsPlugin],\n    //页面入口文件配置\n    entry: {\n        index : './src/js/page/index.js'\n    },\n    //入口文件输出配置\n    output: {\n        path: 'dist/js/page',\n        filename: '[name].js'\n    },\n    module: {\n        //加载器配置\n        loaders: [\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    },\n    //其它解决方案配置\n    resolve: {\n        root: 'E:/github/flux-example/src', //绝对路径\n        extensions: ['', '.js', '.json', '.scss'],\n        alias: {\n            AppStore : 'js/stores/AppStores.js',\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n};\n```\n\n⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。\n\n⑵ entry 是页面入口文件配置，output 是对应输出项配置*（即入口文件最终要生成什么名字的文件、存放到哪里）*，其语法大致为：\n\n```javascript\n{\n    entry: {\n        page1: \"./page1\",\n        //支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出\n        page2: [\"./entry1\", \"./entry2\"]\n    },\n    output: {\n        path: \"dist/js/page\",\n        filename: \"[name].bundle.js\"\n    }\n}\n```\n\n该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。\n\n⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：\n\n```javascript\n    module: {\n        //加载器配置\n        loaders: [\n            //.css 文件使用 style-loader 和 css-loader 来处理\n            { test: /\\.css$/, loader: 'style-loader!css-loader' },\n            //.js 文件使用 jsx-loader 来编译处理\n            { test: /\\.js$/, loader: 'jsx-loader?harmony' },\n            //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理\n            { test: /\\.scss$/, loader: 'style!css!sass?sourceMap'},\n            //图片文件使用 url-loader 来处理，小于8kb的直接转为base64\n            { test: /\\.(png|jpg)$/, loader: 'url-loader?limit=8192'}\n        ]\n    }\n```\n\n如上，\"-loader\"其实是可以省略不写的，多个loader之间用“!”连接起来。\n\n注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。\n\n拿最后一个 [url-loader](https://github.com/webpack/url-loader) 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：\n\n`npm install url-loader -save-dev`\n\n配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式*（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）*。\n\n你可以[点这里](http://webpack.github.io/docs/list-of-loaders.html)查阅全部的 loader 列表。\n\n⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：\n\n```javascript\n    resolve: {\n        //查找module的话从这里开始查找\n        root: 'E:/github/flux-example/src', //绝对路径\n        //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名\n        extensions: ['', '.js', '.json', '.scss'],\n        //模块别名定义，方便后续直接引用别名，无须多写长长的地址\n        alias: {\n            AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可\n            ActionType : 'js/actions/ActionType.js',\n            AppAction : 'js/actions/AppAction.js'\n        }\n    }\n```\n\n关于 webpack.config.js 更详尽的配置可以参考[这里](http://webpack.github.io/docs/configuration.html)。\n\n### 运行 webpack\n\nwebpack 的执行也很简单，直接执行\n\n`$ webpack --display-error-details`\n\n即可，后面的参数“--display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。\n\n其他主要的参数有：\n\n```shell\n$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包\n\n$ webpack --watch   //监听变动并自动打包\n\n$ webpack -p    //压缩混淆脚本，这个非常非常重要！\n\n$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了\n```\n\n其中的 *-p* 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb*（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）*。\n\n### 其他\n\n至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。\n\n**一. shimming**\n\n在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 [exports-loader](https://github.com/webpack/exports-loader) 来帮忙：\n\n```javascript\n{ test: require.resolve(\"./src/js/tool/swipe.js\"),  loader: \"exports?swipe\"}\n```\n\n之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：\n\n```javascript\nrequire('./tool/swipe.js');\nswipe(); \n```\n\n**二. 自定义公共模块提取**\n\n在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。\n\n但有时候我们希望能更加个性化一些，我们可以这样配置：\n\n```javascript\nvar CommonsChunkPlugin = require(\"webpack/lib/optimize/CommonsChunkPlugin\");\nmodule.exports = {\n    entry: {\n        p1: \"./page1\",\n        p2: \"./page2\",\n        p3: \"./page3\",\n        ap1: \"./admin/page1\",\n        ap2: \"./admin/page2\"\n    },\n    output: {\n        filename: \"[name].js\"\n    },\n    plugins: [\n        new CommonsChunkPlugin(\"admin-commons.js\", [\"ap1\", \"ap2\"]),\n        new CommonsChunkPlugin(\"commons.js\", [\"p1\", \"p2\", \"admin-commons.js\"])\n    ]\n};\n// <script>s required:\n// page1.html: commons.js, p1.js\n// page2.html: commons.js, p2.js\n// page3.html: p3.js\n// admin-page1.html: commons.js, admin-commons.js, ap1.js\n// admin-page2.html: commons.js, admin-commons.js, ap2.js\n```\n\n**三. 独立打包样式文件**\n\n有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 [extract-text-webpack-plugin](https://github.com/webpack/extract-text-webpack-plugin) 来帮忙：\n\n```javascript\n    var webpack = require('webpack');\n    var commonsPlugin = new webpack.optimize.CommonsChunkPlugin('common.js');\n    var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\n    module.exports = {\n        plugins: [commonsPlugin, new ExtractTextPlugin(\"[name].css\")],\n        entry: {\n        //...省略其它配置\n```\n\n最终 webpack 执行后会乖乖地把样式文件提取出来：\n\n![](http://images0.cnblogs.com/blog2015/561179/201507/161159531266643.png)\n\n**四. 使用CDN/远程文件**\n\n有时候我们希望某些模块走CDN并以`<script>`的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。\n\n这时候我们可以在配置文件里使用 externals 属性来帮忙：\n\n```javascript\n{\n    externals: {\n        // require(\"jquery\") 是引用自外部模块的\n        // 对应全局变量 jQuery\n        \"jquery\": \"jQuery\"\n    }\n}\n```\n\n需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。\n\n我们倒也可以使用 [script.js](https://github.com/ded/script.js) 在脚本中来加载我们的模块：\n\n```javascript\nvar $script = require(\"scriptjs\");\n$script(\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\", function() {\n  $('body').html('It works!')\n});\n```\n\n**五. 与 grunt/gulp 配合**\n\n以 gulp 为示例，我们可以这样混搭：\n\n```javascript\ngulp.task(\"webpack\", function(callback) {\n    // run webpack\n    webpack({\n        // configuration\n    }, function(err, stats) {\n        if(err) throw new gutil.PluginError(\"webpack\", err);\n        gutil.log(\"[webpack]\", stats.toString({\n            // output options\n        }));\n        callback();\n    });\n});\n```\n\n当然我们只需要把配置写到 webpack({ ... }) 中去即可，无须再写 webpack.config.js 了。\n\n更多参照信息请参阅：[grunt配置](http://webpack.github.io/docs/usage-with-grunt.html) / [gulp配置](http://webpack.github.io/docs/usage-with-gulp.html) 。\n\n**六. React 相关**\n\n⑴ 推荐使用 *npm install react* 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。\n\n⑵ [react-hot-loader](https://github.com/gaearon/react-hot-loader) 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 [webpack-dev-server](http://webpack.github.io/docs/webpack-dev-server.html) 使用更佳！\n\n \n\n基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考下述的文章来入门：\n\n[webpack入门指谜](http://segmentfault.com/a/1190000002551952)\n\n[webpack-howto](https://github.com/petehunt/webpack-howto)\n\n共勉~\n\n","slug":"webpack入门指南","published":1,"updated":"2016-08-17T06:22:19.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkf003068ddlo237l0k","content":"<h3 id=\"什么是-webpack\"><a href=\"#什么是-webpack\" class=\"headerlink\" title=\"什么是 webpack ?\"></a>什么是 webpack ?</h3><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/561179/201507/161453372048661.jpg\" alt=\"\"></p>\n<p>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。</p>\n<p>你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 <a href=\"https://github.com/react-bootstrap/react-bootstrap\" target=\"_blank\" rel=\"external\">React-Bootstrap</a> 和 <a href=\"https://github.com/gaearon/redux\" target=\"_blank\" rel=\"external\">Redux</a>。</p>\n<p>webpack的官网是 <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">http://webpack.github.io/</a> ，文档地址是 <a href=\"http://webpack.github.io/docs/\" target=\"_blank\" rel=\"external\">http://webpack.github.io/docs/</a> ，想对其进行更详细了解的可以点进去瞧一瞧。</p>\n<h3 id=\"webpack-的优势\"><a href=\"#webpack-的优势\" class=\"headerlink\" title=\"webpack 的优势\"></a>webpack 的优势</h3><p>其优势主要可以归类为如下几个：</p>\n<ol>\n<li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li>\n<li>能被模块化的不仅仅是 JS 了。</li>\n<li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li>\n<li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 <a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"external\">react-hot-loader</a> ）的功能让人眼前一亮。</li>\n</ol>\n<p>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'package/lib'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lib</span>)</span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        lib.log(<span class=\"string\">'hello world!'</span>);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo: foo</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require, exports, module</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> someModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"someModule\"</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> anotherModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"anotherModule\"</span>);    </div><div class=\"line\"></div><div class=\"line\">    someModule.doTehAwesome();</div><div class=\"line\">    anotherModule.doMoarAwesome();</div><div class=\"line\"></div><div class=\"line\">    exports.asplode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        someModule.doTehAwesome();</div><div class=\"line\">        anotherModule.doMoarAwesome();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"someModule\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> anotherModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"anotherModule\"</span>);    </div><div class=\"line\"></div><div class=\"line\">someModule.doTehAwesome();</div><div class=\"line\">anotherModule.doMoarAwesome();</div><div class=\"line\"></div><div class=\"line\">exports.asplode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    someModule.doTehAwesome();</div><div class=\"line\">    anotherModule.doMoarAwesome();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样撸码自然更简单，跟回调神马的说 byebye~</p>\n<p>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p>\n<h3 id=\"一-安装\"><a href=\"#一-安装\" class=\"headerlink\" title=\"一. 安装\"></a>一. 安装</h3><p>我们常规直接使用 npm 的形式来安装：</p>\n<p><code>$ npm install webpack -g</code></p>\n<p>当然如果常规项目还是把依赖写入 package.json 包去更人性化：</p>\n<p><code>$ npm init</code></p>\n<p><code>$ npm install webpack --save-dev</code></p>\n<h3 id=\"二-配置\"><a href=\"#二-配置\" class=\"headerlink\" title=\"二. 配置\"></a>二. 配置</h3><p>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。</p>\n<p>我们看看下方的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"comment\">//插件项</span></div><div class=\"line\">    plugins: [commonsPlugin],</div><div class=\"line\">    <span class=\"comment\">//页面入口文件配置</span></div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        index : <span class=\"string\">'./src/js/page/index.js'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//入口文件输出配置</span></div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: <span class=\"string\">'dist/js/page'</span>,</div><div class=\"line\">        filename: <span class=\"string\">'[name].js'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">        <span class=\"comment\">//加载器配置</span></div><div class=\"line\">        loaders: [</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.css$/</span>, loader: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.scss$/</span>, loader: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.(png|jpg)$/</span>, loader: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//其它解决方案配置</span></div><div class=\"line\">    resolve: &#123;</div><div class=\"line\">        root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></div><div class=\"line\">        extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">        alias: &#123;</div><div class=\"line\">            AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,</div><div class=\"line\">            ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</div><div class=\"line\">            AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。</p>\n<p>⑵ entry 是页面入口文件配置，output 是对应输出项配置<em>（即入口文件最终要生成什么名字的文件、存放到哪里）</em>，其语法大致为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        page1: <span class=\"string\">\"./page1\"</span>,</div><div class=\"line\">        <span class=\"comment\">//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span></div><div class=\"line\">        page2: [<span class=\"string\">\"./entry1\"</span>, <span class=\"string\">\"./entry2\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: <span class=\"string\">\"dist/js/page\"</span>,</div><div class=\"line\">        filename: <span class=\"string\">\"[name].bundle.js\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。</p>\n<p>⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">//加载器配置</span></div><div class=\"line\">    loaders: [</div><div class=\"line\">        <span class=\"comment\">//.css 文件使用 style-loader 和 css-loader 来处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.css$/</span>, loader: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</div><div class=\"line\">        <span class=\"comment\">//.js 文件使用 jsx-loader 来编译处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</div><div class=\"line\">        <span class=\"comment\">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.scss$/</span>, loader: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</div><div class=\"line\">        <span class=\"comment\">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.(png|jpg)$/</span>, loader: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。</p>\n<p>注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</p>\n<p>拿最后一个 <a href=\"https://github.com/webpack/url-loader\" target=\"_blank\" rel=\"external\">url-loader</a> 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：</p>\n<p><code>npm install url-loader -save-dev</code></p>\n<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式<em>（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）</em>。</p>\n<p>你可以<a href=\"http://webpack.github.io/docs/list-of-loaders.html\" target=\"_blank\" rel=\"external\">点这里</a>查阅全部的 loader 列表。</p>\n<p>⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">    <span class=\"comment\">//查找module的话从这里开始查找</span></div><div class=\"line\">    root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></div><div class=\"line\">    <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></div><div class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">    <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></div><div class=\"line\">    alias: &#123;</div><div class=\"line\">        AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></div><div class=\"line\">        ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</div><div class=\"line\">        AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于 webpack.config.js 更详尽的配置可以参考<a href=\"http://webpack.github.io/docs/configuration.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h3 id=\"运行-webpack\"><a href=\"#运行-webpack\" class=\"headerlink\" title=\"运行 webpack\"></a>运行 webpack</h3><p>webpack 的执行也很简单，直接执行</p>\n<p><code>$ webpack --display-error-details</code></p>\n<p>即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。</p>\n<p>其他主要的参数有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</div><div class=\"line\"></div><div class=\"line\">$ webpack --watch   //监听变动并自动打包</div><div class=\"line\"></div><div class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</div><div class=\"line\"></div><div class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</div></pre></td></tr></table></figure>\n<p>其中的 <em>-p</em> 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb<em>（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）</em>。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。</p>\n<p><strong>一. shimming</strong></p>\n<p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 <a href=\"https://github.com/webpack/exports-loader\" target=\"_blank\" rel=\"external\">exports-loader</a> 来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; test: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">\"./src/js/tool/swipe.js\"</span>),  loader: <span class=\"string\">\"exports?swipe\"</span>&#125;</div></pre></td></tr></table></figure>\n<p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./tool/swipe.js'</span>);</div><div class=\"line\">swipe();</div></pre></td></tr></table></figure>\n<p><strong>二. 自定义公共模块提取</strong></p>\n<p>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。</p>\n<p>但有时候我们希望能更加个性化一些，我们可以这样配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CommonsChunkPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack/lib/optimize/CommonsChunkPlugin\"</span>);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        p1: <span class=\"string\">\"./page1\"</span>,</div><div class=\"line\">        p2: <span class=\"string\">\"./page2\"</span>,</div><div class=\"line\">        p3: <span class=\"string\">\"./page3\"</span>,</div><div class=\"line\">        ap1: <span class=\"string\">\"./admin/page1\"</span>,</div><div class=\"line\">        ap2: <span class=\"string\">\"./admin/page2\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        filename: <span class=\"string\">\"[name].js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    plugins: [</div><div class=\"line\">        <span class=\"keyword\">new</span> CommonsChunkPlugin(<span class=\"string\">\"admin-commons.js\"</span>, [<span class=\"string\">\"ap1\"</span>, <span class=\"string\">\"ap2\"</span>]),</div><div class=\"line\">        <span class=\"keyword\">new</span> CommonsChunkPlugin(<span class=\"string\">\"commons.js\"</span>, [<span class=\"string\">\"p1\"</span>, <span class=\"string\">\"p2\"</span>, <span class=\"string\">\"admin-commons.js\"</span>])</div><div class=\"line\">    ]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// &lt;script&gt;s required:</span></div><div class=\"line\"><span class=\"comment\">// page1.html: commons.js, p1.js</span></div><div class=\"line\"><span class=\"comment\">// page2.html: commons.js, p2.js</span></div><div class=\"line\"><span class=\"comment\">// page3.html: p3.js</span></div><div class=\"line\"><span class=\"comment\">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span></div><div class=\"line\"><span class=\"comment\">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></div></pre></td></tr></table></figure>\n<p><strong>三. 独立打包样式文件</strong></p>\n<p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 <a href=\"https://github.com/webpack/extract-text-webpack-plugin\" target=\"_blank\" rel=\"external\">extract-text-webpack-plugin</a> 来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    plugins: [commonsPlugin, <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"[name].css\"</span>)],</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">    <span class=\"comment\">//...省略其它配置</span></div></pre></td></tr></table></figure>\n<p>最终 webpack 执行后会乖乖地把样式文件提取出来：</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/561179/201507/161159531266643.png\" alt=\"\"></p>\n<p><strong>四. 使用CDN/远程文件</strong></p>\n<p>有时候我们希望某些模块走CDN并以<code>&lt;script&gt;</code>的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。</p>\n<p>这时候我们可以在配置文件里使用 externals 属性来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    externals: &#123;</div><div class=\"line\">        <span class=\"comment\">// require(\"jquery\") 是引用自外部模块的</span></div><div class=\"line\">        <span class=\"comment\">// 对应全局变量 jQuery</span></div><div class=\"line\">        <span class=\"string\">\"jquery\"</span>: <span class=\"string\">\"jQuery\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。</p>\n<p>我们倒也可以使用 <a href=\"https://github.com/ded/script.js\" target=\"_blank\" rel=\"external\">script.js</a> 在脚本中来加载我们的模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $script = <span class=\"built_in\">require</span>(<span class=\"string\">\"scriptjs\"</span>);</div><div class=\"line\">$script(<span class=\"string\">\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  $(<span class=\"string\">'body'</span>).html(<span class=\"string\">'It works!'</span>)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>五. 与 grunt/gulp 配合</strong></p>\n<p>以 gulp 为示例，我们可以这样混搭：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">\"webpack\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// run webpack</span></div><div class=\"line\">    webpack(&#123;</div><div class=\"line\">        <span class=\"comment\">// configuration</span></div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(err) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> gutil.PluginError(<span class=\"string\">\"webpack\"</span>, err);</div><div class=\"line\">        gutil.log(<span class=\"string\">\"[webpack]\"</span>, stats.toString(&#123;</div><div class=\"line\">            <span class=\"comment\">// output options</span></div><div class=\"line\">        &#125;));</div><div class=\"line\">        callback();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。</p>\n<p>更多参照信息请参阅：<a href=\"http://webpack.github.io/docs/usage-with-grunt.html\" target=\"_blank\" rel=\"external\">grunt配置</a> / <a href=\"http://webpack.github.io/docs/usage-with-gulp.html\" target=\"_blank\" rel=\"external\">gulp配置</a> 。</p>\n<p><strong>六. React 相关</strong></p>\n<p>⑴ 推荐使用 <em>npm install react</em> 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。</p>\n<p>⑵ <a href=\"https://github.com/gaearon/react-hot-loader\" target=\"_blank\" rel=\"external\">react-hot-loader</a> 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\" target=\"_blank\" rel=\"external\">webpack-dev-server</a> 使用更佳！</p>\n<p>基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考下述的文章来入门：</p>\n<p><a href=\"http://segmentfault.com/a/1190000002551952\" target=\"_blank\" rel=\"external\">webpack入门指谜</a></p>\n<p><a href=\"https://github.com/petehunt/webpack-howto\" target=\"_blank\" rel=\"external\">webpack-howto</a></p>\n<p>共勉~</p>\n","excerpt":"","more":"<h3 id=\"什么是-webpack\"><a href=\"#什么是-webpack\" class=\"headerlink\" title=\"什么是 webpack ?\"></a>什么是 webpack ?</h3><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/561179/201507/161453372048661.jpg\" alt=\"\"></p>\n<p>我们可以直接使用 require(XXX) 的形式来引入各模块，即使它们可能需要经过编译（比如JSX和sass），但我们无须在上面花费太多心思，因为 webpack 有着各种健全的加载器（loader）在默默处理这些事情，这块我们后续会提到。</p>\n<p>你可以不打算将其用在你的项目上，但没有理由不去掌握它，因为以近期 Github 上各大主流的（React相关）项目来说，它们仓库上所展示的示例已经是基于 webpack 来开发的，比如 <a href=\"https://github.com/react-bootstrap/react-bootstrap\">React-Bootstrap</a> 和 <a href=\"https://github.com/gaearon/redux\">Redux</a>。</p>\n<p>webpack的官网是 <a href=\"http://webpack.github.io/\">http://webpack.github.io/</a> ，文档地址是 <a href=\"http://webpack.github.io/docs/\">http://webpack.github.io/docs/</a> ，想对其进行更详细了解的可以点进去瞧一瞧。</p>\n<h3 id=\"webpack-的优势\"><a href=\"#webpack-的优势\" class=\"headerlink\" title=\"webpack 的优势\"></a>webpack 的优势</h3><p>其优势主要可以归类为如下几个：</p>\n<ol>\n<li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</li>\n<li>能被模块化的不仅仅是 JS 了。</li>\n<li>开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。</li>\n<li>扩展性强，插件机制完善，特别是支持 React 热插拔（见 <a href=\"https://github.com/gaearon/react-hot-loader\">react-hot-loader</a> ）的功能让人眼前一亮。</li>\n</ol>\n<p>我们谈谈第一点。以 AMD/CMD 模式来说，鉴于模块是异步加载的，所以我们常规需要使用 define 函数来帮我们搞回调：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">define([<span class=\"string\">'package/lib'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lib</span>)</span>&#123;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        lib.log(<span class=\"string\">'hello world!'</span>);</div><div class=\"line\">    &#125; </div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        foo: foo</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>另外为了可以兼容 commonJS 的写法，我们也可以将 define 这么写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">require, exports, module</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> someModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"someModule\"</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> anotherModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"anotherModule\"</span>);    </div><div class=\"line\"></div><div class=\"line\">    someModule.doTehAwesome();</div><div class=\"line\">    anotherModule.doMoarAwesome();</div><div class=\"line\"></div><div class=\"line\">    exports.asplode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        someModule.doTehAwesome();</div><div class=\"line\">        anotherModule.doMoarAwesome();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>然而对 webpack 来说，我们可以直接在上面书写 commonJS 形式的语法，无须任何 define （毕竟最终模块都打包在一起，webpack 也会最终自动加上自己的加载器）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"someModule\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> anotherModule = <span class=\"built_in\">require</span>(<span class=\"string\">\"anotherModule\"</span>);    </div><div class=\"line\"></div><div class=\"line\">someModule.doTehAwesome();</div><div class=\"line\">anotherModule.doMoarAwesome();</div><div class=\"line\"></div><div class=\"line\">exports.asplode = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    someModule.doTehAwesome();</div><div class=\"line\">    anotherModule.doMoarAwesome();</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这样撸码自然更简单，跟回调神马的说 byebye~</p>\n<p>不过即使你保留了之前 define 的写法也是可以滴，毕竟 webpack 的兼容性相当出色，方便你旧项目的模块直接迁移过来。</p>\n<h3 id=\"一-安装\"><a href=\"#一-安装\" class=\"headerlink\" title=\"一. 安装\"></a>一. 安装</h3><p>我们常规直接使用 npm 的形式来安装：</p>\n<p><code>$ npm install webpack -g</code></p>\n<p>当然如果常规项目还是把依赖写入 package.json 包去更人性化：</p>\n<p><code>$ npm init</code></p>\n<p><code>$ npm install webpack --save-dev</code></p>\n<h3 id=\"二-配置\"><a href=\"#二-配置\" class=\"headerlink\" title=\"二. 配置\"></a>二. 配置</h3><p>每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。</p>\n<p>我们看看下方的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"comment\">//插件项</span></div><div class=\"line\">    plugins: [commonsPlugin],</div><div class=\"line\">    <span class=\"comment\">//页面入口文件配置</span></div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        index : <span class=\"string\">'./src/js/page/index.js'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//入口文件输出配置</span></div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: <span class=\"string\">'dist/js/page'</span>,</div><div class=\"line\">        filename: <span class=\"string\">'[name].js'</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">        <span class=\"comment\">//加载器配置</span></div><div class=\"line\">        loaders: [</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.css$/</span>, loader: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.scss$/</span>, loader: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</div><div class=\"line\">            &#123; test: <span class=\"regexp\">/\\.(png|jpg)$/</span>, loader: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"comment\">//其它解决方案配置</span></div><div class=\"line\">    resolve: &#123;</div><div class=\"line\">        root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></div><div class=\"line\">        extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">        alias: &#123;</div><div class=\"line\">            AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,</div><div class=\"line\">            ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</div><div class=\"line\">            AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>⑴ plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin 的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。</p>\n<p>⑵ entry 是页面入口文件配置，output 是对应输出项配置<em>（即入口文件最终要生成什么名字的文件、存放到哪里）</em>，其语法大致为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        page1: <span class=\"string\">\"./page1\"</span>,</div><div class=\"line\">        <span class=\"comment\">//支持数组形式，将加载数组中的所有模块，但以最后一个模块作为输出</span></div><div class=\"line\">        page2: [<span class=\"string\">\"./entry1\"</span>, <span class=\"string\">\"./entry2\"</span>]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: <span class=\"string\">\"dist/js/page\"</span>,</div><div class=\"line\">        filename: <span class=\"string\">\"[name].bundle.js\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该段代码最终会生成一个 page1.bundle.js 和 page2.bundle.js，并存放到 ./dist/js/page 文件夹下。</p>\n<p>⑶ module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">//加载器配置</span></div><div class=\"line\">    loaders: [</div><div class=\"line\">        <span class=\"comment\">//.css 文件使用 style-loader 和 css-loader 来处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.css$/</span>, loader: <span class=\"string\">'style-loader!css-loader'</span> &#125;,</div><div class=\"line\">        <span class=\"comment\">//.js 文件使用 jsx-loader 来编译处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.js$/</span>, loader: <span class=\"string\">'jsx-loader?harmony'</span> &#125;,</div><div class=\"line\">        <span class=\"comment\">//.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.scss$/</span>, loader: <span class=\"string\">'style!css!sass?sourceMap'</span>&#125;,</div><div class=\"line\">        <span class=\"comment\">//图片文件使用 url-loader 来处理，小于8kb的直接转为base64</span></div><div class=\"line\">        &#123; test: <span class=\"regexp\">/\\.(png|jpg)$/</span>, loader: <span class=\"string\">'url-loader?limit=8192'</span>&#125;</div><div class=\"line\">    ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如上，”-loader”其实是可以省略不写的，多个loader之间用“!”连接起来。</p>\n<p>注意所有的加载器都需要通过 npm 来加载，并建议查阅它们对应的 readme 来看看如何使用。</p>\n<p>拿最后一个 <a href=\"https://github.com/webpack/url-loader\">url-loader</a> 来说，它会将样式中引用到的图片转为模块来处理，使用该加载器需要先进行安装：</p>\n<p><code>npm install url-loader -save-dev</code></p>\n<p>配置信息的参数“?limit=8192”表示将所有小于8kb的图片都转为base64形式<em>（其实应该说超过8kb的才使用 url-loader 来映射到文件，否则转为data url形式）</em>。</p>\n<p>你可以<a href=\"http://webpack.github.io/docs/list-of-loaders.html\">点这里</a>查阅全部的 loader 列表。</p>\n<p>⑷ 最后是 resolve 配置，这块很好理解，直接写注释了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">    <span class=\"comment\">//查找module的话从这里开始查找</span></div><div class=\"line\">    root: <span class=\"string\">'E:/github/flux-example/src'</span>, <span class=\"comment\">//绝对路径</span></div><div class=\"line\">    <span class=\"comment\">//自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</span></div><div class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.json'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">    <span class=\"comment\">//模块别名定义，方便后续直接引用别名，无须多写长长的地址</span></div><div class=\"line\">    alias: &#123;</div><div class=\"line\">        AppStore : <span class=\"string\">'js/stores/AppStores.js'</span>,<span class=\"comment\">//后续直接 require('AppStore') 即可</span></div><div class=\"line\">        ActionType : <span class=\"string\">'js/actions/ActionType.js'</span>,</div><div class=\"line\">        AppAction : <span class=\"string\">'js/actions/AppAction.js'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于 webpack.config.js 更详尽的配置可以参考<a href=\"http://webpack.github.io/docs/configuration.html\">这里</a>。</p>\n<h3 id=\"运行-webpack\"><a href=\"#运行-webpack\" class=\"headerlink\" title=\"运行 webpack\"></a>运行 webpack</h3><p>webpack 的执行也很简单，直接执行</p>\n<p><code>$ webpack --display-error-details</code></p>\n<p>即可，后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。</p>\n<p>其他主要的参数有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ webpack --config XXX.js   //使用另一份配置文件（比如webpack.config2.js）来打包</div><div class=\"line\"></div><div class=\"line\">$ webpack --watch   //监听变动并自动打包</div><div class=\"line\"></div><div class=\"line\">$ webpack -p    //压缩混淆脚本，这个非常非常重要！</div><div class=\"line\"></div><div class=\"line\">$ webpack -d    //生成map映射文件，告知哪些模块被最终打包到哪里了</div></pre></td></tr></table></figure>\n<p>其中的 <em>-p</em> 是很重要的参数，曾经一个未压缩的 700kb 的文件，压缩后直接降到 180kb<em>（主要是样式这块一句就独占一行脚本，导致未压缩脚本变得很大）</em>。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>至此我们已经基本上手了 webpack 的使用，下面是补充一些有用的技巧。</p>\n<p><strong>一. shimming</strong></p>\n<p>在 AMD/CMD 中，我们需要对不符合规范的模块（比如一些直接返回全局变量的插件）进行 shim 处理，这时候我们需要使用 <a href=\"https://github.com/webpack/exports-loader\">exports-loader</a> 来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123; test: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">\"./src/js/tool/swipe.js\"</span>),  loader: <span class=\"string\">\"exports?swipe\"</span>&#125;</div></pre></td></tr></table></figure>\n<p>之后在脚本中需要引用该模块的时候，这么简单地来使用就可以了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./tool/swipe.js'</span>);</div><div class=\"line\">swipe();</div></pre></td></tr></table></figure>\n<p><strong>二. 自定义公共模块提取</strong></p>\n<p>在文章开始我们使用了 CommonsChunkPlugin 插件来提取多个页面之间的公共模块，并将该模块打包为 common.js 。</p>\n<p>但有时候我们希望能更加个性化一些，我们可以这样配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CommonsChunkPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack/lib/optimize/CommonsChunkPlugin\"</span>);</div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        p1: <span class=\"string\">\"./page1\"</span>,</div><div class=\"line\">        p2: <span class=\"string\">\"./page2\"</span>,</div><div class=\"line\">        p3: <span class=\"string\">\"./page3\"</span>,</div><div class=\"line\">        ap1: <span class=\"string\">\"./admin/page1\"</span>,</div><div class=\"line\">        ap2: <span class=\"string\">\"./admin/page2\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        filename: <span class=\"string\">\"[name].js\"</span></div><div class=\"line\">    &#125;,</div><div class=\"line\">    plugins: [</div><div class=\"line\">        <span class=\"keyword\">new</span> CommonsChunkPlugin(<span class=\"string\">\"admin-commons.js\"</span>, [<span class=\"string\">\"ap1\"</span>, <span class=\"string\">\"ap2\"</span>]),</div><div class=\"line\">        <span class=\"keyword\">new</span> CommonsChunkPlugin(<span class=\"string\">\"commons.js\"</span>, [<span class=\"string\">\"p1\"</span>, <span class=\"string\">\"p2\"</span>, <span class=\"string\">\"admin-commons.js\"</span>])</div><div class=\"line\">    ]</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"comment\">// &lt;script&gt;s required:</span></div><div class=\"line\"><span class=\"comment\">// page1.html: commons.js, p1.js</span></div><div class=\"line\"><span class=\"comment\">// page2.html: commons.js, p2.js</span></div><div class=\"line\"><span class=\"comment\">// page3.html: p3.js</span></div><div class=\"line\"><span class=\"comment\">// admin-page1.html: commons.js, admin-commons.js, ap1.js</span></div><div class=\"line\"><span class=\"comment\">// admin-page2.html: commons.js, admin-commons.js, ap2.js</span></div></pre></td></tr></table></figure>\n<p><strong>三. 独立打包样式文件</strong></p>\n<p>有时候可能希望项目的样式能不要被打包到脚本中，而是独立出来作为.css，然后在页面中以<link>标签引入。这时候我们需要 <a href=\"https://github.com/webpack/extract-text-webpack-plugin\">extract-text-webpack-plugin</a> 来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> commonsPlugin = <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(<span class=\"string\">'common.js'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">\"extract-text-webpack-plugin\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    plugins: [commonsPlugin, <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"[name].css\"</span>)],</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">    <span class=\"comment\">//...省略其它配置</span></div></pre></td></tr></table></figure>\n<p>最终 webpack 执行后会乖乖地把样式文件提取出来：</p>\n<p><img src=\"http://images0.cnblogs.com/blog2015/561179/201507/161159531266643.png\" alt=\"\"></p>\n<p><strong>四. 使用CDN/远程文件</strong></p>\n<p>有时候我们希望某些模块走CDN并以<code>&lt;script&gt;</code>的形式挂载到页面上来加载，但又希望能在 webpack 的模块中使用上。</p>\n<p>这时候我们可以在配置文件里使用 externals 属性来帮忙：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    externals: &#123;</div><div class=\"line\">        <span class=\"comment\">// require(\"jquery\") 是引用自外部模块的</span></div><div class=\"line\">        <span class=\"comment\">// 对应全局变量 jQuery</span></div><div class=\"line\">        <span class=\"string\">\"jquery\"</span>: <span class=\"string\">\"jQuery\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要留意的是，得确保 CDN 文件必须在 webpack 打包文件引入之前先引入。</p>\n<p>我们倒也可以使用 <a href=\"https://github.com/ded/script.js\">script.js</a> 在脚本中来加载我们的模块：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $script = <span class=\"built_in\">require</span>(<span class=\"string\">\"scriptjs\"</span>);</div><div class=\"line\">$script(<span class=\"string\">\"//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  $(<span class=\"string\">'body'</span>).html(<span class=\"string\">'It works!'</span>)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p><strong>五. 与 grunt/gulp 配合</strong></p>\n<p>以 gulp 为示例，我们可以这样混搭：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">gulp.task(<span class=\"string\">\"webpack\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// run webpack</span></div><div class=\"line\">    webpack(&#123;</div><div class=\"line\">        <span class=\"comment\">// configuration</span></div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(err) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> gutil.PluginError(<span class=\"string\">\"webpack\"</span>, err);</div><div class=\"line\">        gutil.log(<span class=\"string\">\"[webpack]\"</span>, stats.toString(&#123;</div><div class=\"line\">            <span class=\"comment\">// output options</span></div><div class=\"line\">        &#125;));</div><div class=\"line\">        callback();</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>当然我们只需要把配置写到 webpack({ … }) 中去即可，无须再写 webpack.config.js 了。</p>\n<p>更多参照信息请参阅：<a href=\"http://webpack.github.io/docs/usage-with-grunt.html\">grunt配置</a> / <a href=\"http://webpack.github.io/docs/usage-with-gulp.html\">gulp配置</a> 。</p>\n<p><strong>六. React 相关</strong></p>\n<p>⑴ 推荐使用 <em>npm install react</em> 的形式来安装并引用 React 模块，而不是直接使用编译后的 react.js，这样最终编译出来的 React 部分的脚本会减少 10-20 kb左右的大小。</p>\n<p>⑵ <a href=\"https://github.com/gaearon/react-hot-loader\">react-hot-loader</a> 是一款非常好用的 React 热插拔的加载插件，通过它可以实现修改-运行同步的效果，配合 <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">webpack-dev-server</a> 使用更佳！</p>\n<p>基于 webpack 的入门指引就到这里，希望本文能对你有所帮助，你也可以参考下述的文章来入门：</p>\n<p><a href=\"http://segmentfault.com/a/1190000002551952\">webpack入门指谜</a></p>\n<p><a href=\"https://github.com/petehunt/webpack-howto\">webpack-howto</a></p>\n<p>共勉~</p>\n"},{"title":"【Angularjs文档翻译及实例】DOM事件","date":"2015-04-19T16:00:00.000Z","_content":"\n把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。\n\n> 约定：\n> 此文中ngXxx表示ng-xxx属性名。\n\n### ngBlur\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-blur=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数     | 类型         | 详情                              |      |\n| :----- | :--------- | :------------------------------ | ---- |\n| ngBlur | expression | 表达式将在失去焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngFocus\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-focus=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                            |      |\n| :------ | :--------- | :---------------------------- | ---- |\n| ngFocus | expression | 表达在获得焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngChange\n\n**用法**\n\n```\n<input\n  ng-change=\"expression\">\n...\n</input>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                 |      |\n| :------- | :--------- | :----------------- | ---- |\n| ngChange | expression | 表达式将在input控件被改变时触发 |      |\n\n### ngChecked\n\n**用法**\n\n```\n<INPUT\n  ng-checked=\"expression\">\n...\n</INPUT>\n```\n\n**参数**\n\n| 参数        | 类型         | 详情                          |      |\n| :-------- | :--------- | :-------------------------- | ---- |\n| ngChecked | expression | 如果表达式为真，那么就会在元素上设置checked属性 |      |\n\n### ngClick\n\n**用法**\n\n```\n<ANY\n  ng-click=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                             |      |\n| :------ | :--------- | :----------------------------- | ---- |\n| ngClick | expression | 当被点击的时候触发表达式（事件对象与$event一样可获得） |      |\n\n\n\n\n### ngKeydown/ngKeypress/ngKeyup\n\n**用法**\n\n```\n<ANY\n  ng-keydown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keypress=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keyup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                                       |      |\n| :--------- | :--------- | :--------------------------------------- | ---- |\n| ngKeydown  | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeypress | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeyup    | expression | 表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n\n### ngMousedown/ngMouseup\n\n**用法**\n\n```\n<ANY\n  ng-mousedown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数          | 类型         | 详情                             |      |\n| :---------- | :--------- | :----------------------------- | ---- |\n| ngMousedown | expression | 表达式在鼠标按下时被触发（事件对象与$event一样可获得） |      |\n| ngMouseup   | expression | 表达式在鼠标释放时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseenter/ngMousemove\n\n**用法**\n\n```\n<ANY\n  ng-mouseenter=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mousemove=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                                 |      |\n| :----------- | :--------- | :--------------------------------- | ---- |\n| ngMouseenter | expression | 表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）   |      |\n| ngMousemove  | expression | 表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseover/ngMouseleave\n\n**用法**\n\n```\n<ANY\n  ng-mouseover=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseleave=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                               |      |\n| :----------- | :--------- | :------------------------------- | ---- |\n| ngMouseover  | expression | 表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得） |      |\n| ngMouseleave | expression | 表达式在鼠标离开时被触发（事件对象与$event一样可获得）   |      |\n\n### ngSelected\n\n**用法**\n\n```\n<OPTION\n  ng-selected=\"expression\">\n...\n</OPTION>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                         |      |\n| :--------- | :--------- | :------------------------- | ---- |\n| ngSelected | expression | 表达式为真时，selected属性将被设置在元素上。 |      |\n\n### ngSubmit\n\n**用法**\n\n```\n<form\n  ng-submit=\"expression\">\n...\n</form>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                             |      |\n| :------- | :--------- | :----------------------------- | ---- |\n| ngSubmit | expression | 提交表单时，表达式被触发（事件对象与$event一样可获得） |      |\n\n\n### 综合实例\n\n**html代码**\n\n```\n<div ng-app=\"myapp\">\n    <form name=\"form\" ng-controller=\"formCtrl\">\n        <p>\n            <input type=\"text\" ng-model=\"blur\" ng-blur=\"blur='be blured'\" ng-focus=\"blur='got focus,click other place'\" placeholder=\"click me\" />\n        </p>\n        <p>\n            <span ng-model=\"mouseEvent\" ng-mouseenter=\"mouseEvent='mouseenter'\" ng-mouseleave=\"mouseEvent='mouseleave'\" ng-bind=\"mouseEvent\" ng-init=\"mouseEvent='touch me'\">touch me</span>\n        </p>\n        <p>\n            <input type=\"text\" ng-model=\"change\" ng-change=\"changeEvent()\" placeholder=\"change me\" />\n        </p>\n        <p>\n            msg1:{{changeStatus}},content:{{change}}\n        </p>\n        <p>\n            <input type=\"button\" ng-click=\"btnClickChangeCheckboxEvent()\" value=\"change status of checkbox->\" />\n            <input type=\"checkbox\" ng-model=\"checkbox\" ng-checked=\"isStatus\" />\n        </p>\n        <p>\n            <input type=\"checkbox\" ng-model=\"option\" />change status of select\n            <select>\n                <option>A</option>\n                <option ng-selected=\"option\">B</option>\n            </select>\n        </p>\n    </form>\n</div>\n```\n\n**js代码**\n\n```\nangular.module('myapp', [])\n    .controller('formCtrl', function($scope) {\n        $scope.change = 'change me';\n        $scope.changeStatus = 'no change';\n        $scope.isStatus = false;\n        $scope.option = false;\n\n        $scope.changeEvent = function() {\n            $scope.changeStatus = 'be changed';\n        }\n\n        $scope.btnClickChangeCheckboxEvent = function() {\n            $scope.isStatus = !$scope.isStatus;\n        }\n    });\n```\n\nDEMO地址：[https://jsfiddle.net/Lionney/vLkoz9d3/](https://jsfiddle.net/Lionney/vLkoz9d3/)\n\n如有问题，请指正。\n","source":"_posts/【Angularjs文档翻译及实例】DOM事件.md","raw":"---\ntitle: 【Angularjs文档翻译及实例】DOM事件\ntags: [javascript,angularjs]\ndate: 2015/04/20\n---\n\n把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。\n\n> 约定：\n> 此文中ngXxx表示ng-xxx属性名。\n\n### ngBlur\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-blur=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数     | 类型         | 详情                              |      |\n| :----- | :--------- | :------------------------------ | ---- |\n| ngBlur | expression | 表达式将在失去焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngFocus\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-focus=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                            |      |\n| :------ | :--------- | :---------------------------- | ---- |\n| ngFocus | expression | 表达在获得焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngChange\n\n**用法**\n\n```\n<input\n  ng-change=\"expression\">\n...\n</input>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                 |      |\n| :------- | :--------- | :----------------- | ---- |\n| ngChange | expression | 表达式将在input控件被改变时触发 |      |\n\n### ngChecked\n\n**用法**\n\n```\n<INPUT\n  ng-checked=\"expression\">\n...\n</INPUT>\n```\n\n**参数**\n\n| 参数        | 类型         | 详情                          |      |\n| :-------- | :--------- | :-------------------------- | ---- |\n| ngChecked | expression | 如果表达式为真，那么就会在元素上设置checked属性 |      |\n\n### ngClick\n\n**用法**\n\n```\n<ANY\n  ng-click=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                             |      |\n| :------ | :--------- | :----------------------------- | ---- |\n| ngClick | expression | 当被点击的时候触发表达式（事件对象与$event一样可获得） |      |\n\n\n\n\n### ngKeydown/ngKeypress/ngKeyup\n\n**用法**\n\n```\n<ANY\n  ng-keydown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keypress=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keyup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                                       |      |\n| :--------- | :--------- | :--------------------------------------- | ---- |\n| ngKeydown  | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeypress | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeyup    | expression | 表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n\n### ngMousedown/ngMouseup\n\n**用法**\n\n```\n<ANY\n  ng-mousedown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数          | 类型         | 详情                             |      |\n| :---------- | :--------- | :----------------------------- | ---- |\n| ngMousedown | expression | 表达式在鼠标按下时被触发（事件对象与$event一样可获得） |      |\n| ngMouseup   | expression | 表达式在鼠标释放时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseenter/ngMousemove\n\n**用法**\n\n```\n<ANY\n  ng-mouseenter=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mousemove=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                                 |      |\n| :----------- | :--------- | :--------------------------------- | ---- |\n| ngMouseenter | expression | 表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）   |      |\n| ngMousemove  | expression | 表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseover/ngMouseleave\n\n**用法**\n\n```\n<ANY\n  ng-mouseover=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseleave=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                               |      |\n| :----------- | :--------- | :------------------------------- | ---- |\n| ngMouseover  | expression | 表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得） |      |\n| ngMouseleave | expression | 表达式在鼠标离开时被触发（事件对象与$event一样可获得）   |      |\n\n### ngSelected\n\n**用法**\n\n```\n<OPTION\n  ng-selected=\"expression\">\n...\n</OPTION>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                         |      |\n| :--------- | :--------- | :------------------------- | ---- |\n| ngSelected | expression | 表达式为真时，selected属性将被设置在元素上。 |      |\n\n### ngSubmit\n\n**用法**\n\n```\n<form\n  ng-submit=\"expression\">\n...\n</form>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                             |      |\n| :------- | :--------- | :----------------------------- | ---- |\n| ngSubmit | expression | 提交表单时，表达式被触发（事件对象与$event一样可获得） |      |\n\n\n### 综合实例\n\n**html代码**\n\n```\n<div ng-app=\"myapp\">\n    <form name=\"form\" ng-controller=\"formCtrl\">\n        <p>\n            <input type=\"text\" ng-model=\"blur\" ng-blur=\"blur='be blured'\" ng-focus=\"blur='got focus,click other place'\" placeholder=\"click me\" />\n        </p>\n        <p>\n            <span ng-model=\"mouseEvent\" ng-mouseenter=\"mouseEvent='mouseenter'\" ng-mouseleave=\"mouseEvent='mouseleave'\" ng-bind=\"mouseEvent\" ng-init=\"mouseEvent='touch me'\">touch me</span>\n        </p>\n        <p>\n            <input type=\"text\" ng-model=\"change\" ng-change=\"changeEvent()\" placeholder=\"change me\" />\n        </p>\n        <p>\n            msg1:{{changeStatus}},content:{{change}}\n        </p>\n        <p>\n            <input type=\"button\" ng-click=\"btnClickChangeCheckboxEvent()\" value=\"change status of checkbox->\" />\n            <input type=\"checkbox\" ng-model=\"checkbox\" ng-checked=\"isStatus\" />\n        </p>\n        <p>\n            <input type=\"checkbox\" ng-model=\"option\" />change status of select\n            <select>\n                <option>A</option>\n                <option ng-selected=\"option\">B</option>\n            </select>\n        </p>\n    </form>\n</div>\n```\n\n**js代码**\n\n```\nangular.module('myapp', [])\n    .controller('formCtrl', function($scope) {\n        $scope.change = 'change me';\n        $scope.changeStatus = 'no change';\n        $scope.isStatus = false;\n        $scope.option = false;\n\n        $scope.changeEvent = function() {\n            $scope.changeStatus = 'be changed';\n        }\n\n        $scope.btnClickChangeCheckboxEvent = function() {\n            $scope.isStatus = !$scope.isStatus;\n        }\n    });\n```\n\nDEMO地址：[https://jsfiddle.net/Lionney/vLkoz9d3/](https://jsfiddle.net/Lionney/vLkoz9d3/)\n\n如有问题，请指正。\n","slug":"【Angularjs文档翻译及实例】DOM事件","published":1,"updated":"2016-08-17T06:22:19.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkh003368dd2msnu7cy","content":"<p>把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。</p>\n<blockquote>\n<p>约定：<br>此文中ngXxx表示ng-xxx属性名。</p>\n</blockquote>\n<h3 id=\"ngBlur\"><a href=\"#ngBlur\" class=\"headerlink\" title=\"ngBlur\"></a>ngBlur</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;window, input, select, textarea, a</div><div class=\"line\">  ng-blur=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/window, input, select, textarea, a&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngBlur</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在失去焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngFocus\"><a href=\"#ngFocus\" class=\"headerlink\" title=\"ngFocus\"></a>ngFocus</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;window, input, select, textarea, a</div><div class=\"line\">  ng-focus=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/window, input, select, textarea, a&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngFocus</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达在获得焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChange\"><a href=\"#ngChange\" class=\"headerlink\" title=\"ngChange\"></a>ngChange</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;input</div><div class=\"line\">  ng-change=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/input&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChange</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在input控件被改变时触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChecked\"><a href=\"#ngChecked\" class=\"headerlink\" title=\"ngChecked\"></a>ngChecked</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;INPUT</div><div class=\"line\">  ng-checked=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/INPUT&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChecked</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">如果表达式为真，那么就会在元素上设置checked属性</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngClick\"><a href=\"#ngClick\" class=\"headerlink\" title=\"ngClick\"></a>ngClick</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-click=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngClick</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">当被点击的时候触发表达式（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngKeydown-ngKeypress-ngKeyup\"><a href=\"#ngKeydown-ngKeypress-ngKeyup\" class=\"headerlink\" title=\"ngKeydown/ngKeypress/ngKeyup\"></a>ngKeydown/ngKeypress/ngKeyup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keydown=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keypress=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keyup=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngKeydown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeypress</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeyup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMousedown-ngMouseup\"><a href=\"#ngMousedown-ngMouseup\" class=\"headerlink\" title=\"ngMousedown/ngMouseup\"></a>ngMousedown/ngMouseup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mousedown=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseup=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMousedown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标按下时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标释放时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseenter-ngMousemove\"><a href=\"#ngMouseenter-ngMousemove\" class=\"headerlink\" title=\"ngMouseenter/ngMousemove\"></a>ngMouseenter/ngMousemove</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseenter=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mousemove=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseenter</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMousemove</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseover-ngMouseleave\"><a href=\"#ngMouseover-ngMouseleave\" class=\"headerlink\" title=\"ngMouseover/ngMouseleave\"></a>ngMouseover/ngMouseleave</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseover=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseleave=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseover</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseleave</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标离开时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSelected\"><a href=\"#ngSelected\" class=\"headerlink\" title=\"ngSelected\"></a>ngSelected</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;OPTION</div><div class=\"line\">  ng-selected=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/OPTION&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSelected</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式为真时，selected属性将被设置在元素上。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSubmit\"><a href=\"#ngSubmit\" class=\"headerlink\" title=\"ngSubmit\"></a>ngSubmit</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;form</div><div class=\"line\">  ng-submit=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSubmit</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">提交表单时，表达式被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"综合实例\"><a href=\"#综合实例\" class=\"headerlink\" title=\"综合实例\"></a>综合实例</h3><p><strong>html代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;myapp&quot;&gt;</div><div class=\"line\">    &lt;form name=&quot;form&quot; ng-controller=&quot;formCtrl&quot;&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;blur&quot; ng-blur=&quot;blur=&apos;be blured&apos;&quot; ng-focus=&quot;blur=&apos;got focus,click other place&apos;&quot; placeholder=&quot;click me&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;span ng-model=&quot;mouseEvent&quot; ng-mouseenter=&quot;mouseEvent=&apos;mouseenter&apos;&quot; ng-mouseleave=&quot;mouseEvent=&apos;mouseleave&apos;&quot; ng-bind=&quot;mouseEvent&quot; ng-init=&quot;mouseEvent=&apos;touch me&apos;&quot;&gt;touch me&lt;/span&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;change&quot; ng-change=&quot;changeEvent()&quot; placeholder=&quot;change me&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            msg1:&#123;&#123;changeStatus&#125;&#125;,content:&#123;&#123;change&#125;&#125;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;button&quot; ng-click=&quot;btnClickChangeCheckboxEvent()&quot; value=&quot;change status of checkbox-&gt;&quot; /&gt;</div><div class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;checkbox&quot; ng-checked=&quot;isStatus&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;option&quot; /&gt;change status of select</div><div class=\"line\">            &lt;select&gt;</div><div class=\"line\">                &lt;option&gt;A&lt;/option&gt;</div><div class=\"line\">                &lt;option ng-selected=&quot;option&quot;&gt;B&lt;/option&gt;</div><div class=\"line\">            &lt;/select&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">    &lt;/form&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p><strong>js代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myapp&apos;, [])</div><div class=\"line\">    .controller(&apos;formCtrl&apos;, function($scope) &#123;</div><div class=\"line\">        $scope.change = &apos;change me&apos;;</div><div class=\"line\">        $scope.changeStatus = &apos;no change&apos;;</div><div class=\"line\">        $scope.isStatus = false;</div><div class=\"line\">        $scope.option = false;</div><div class=\"line\"></div><div class=\"line\">        $scope.changeEvent = function() &#123;</div><div class=\"line\">            $scope.changeStatus = &apos;be changed&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        $scope.btnClickChangeCheckboxEvent = function() &#123;</div><div class=\"line\">            $scope.isStatus = !$scope.isStatus;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>DEMO地址：<a href=\"https://jsfiddle.net/Lionney/vLkoz9d3/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/Lionney/vLkoz9d3/</a></p>\n<p>如有问题，请指正。</p>\n","excerpt":"","more":"<p>把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。</p>\n<blockquote>\n<p>约定：<br>此文中ngXxx表示ng-xxx属性名。</p>\n</blockquote>\n<h3 id=\"ngBlur\"><a href=\"#ngBlur\" class=\"headerlink\" title=\"ngBlur\"></a>ngBlur</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;window, input, select, textarea, a</div><div class=\"line\">  ng-blur=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/window, input, select, textarea, a&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngBlur</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在失去焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngFocus\"><a href=\"#ngFocus\" class=\"headerlink\" title=\"ngFocus\"></a>ngFocus</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;window, input, select, textarea, a</div><div class=\"line\">  ng-focus=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/window, input, select, textarea, a&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngFocus</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达在获得焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChange\"><a href=\"#ngChange\" class=\"headerlink\" title=\"ngChange\"></a>ngChange</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;input</div><div class=\"line\">  ng-change=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/input&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChange</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在input控件被改变时触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChecked\"><a href=\"#ngChecked\" class=\"headerlink\" title=\"ngChecked\"></a>ngChecked</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;INPUT</div><div class=\"line\">  ng-checked=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/INPUT&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChecked</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">如果表达式为真，那么就会在元素上设置checked属性</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngClick\"><a href=\"#ngClick\" class=\"headerlink\" title=\"ngClick\"></a>ngClick</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-click=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngClick</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">当被点击的时候触发表达式（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngKeydown-ngKeypress-ngKeyup\"><a href=\"#ngKeydown-ngKeypress-ngKeyup\" class=\"headerlink\" title=\"ngKeydown/ngKeypress/ngKeyup\"></a>ngKeydown/ngKeypress/ngKeyup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keydown=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keypress=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-keyup=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngKeydown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeypress</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeyup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMousedown-ngMouseup\"><a href=\"#ngMousedown-ngMouseup\" class=\"headerlink\" title=\"ngMousedown/ngMouseup\"></a>ngMousedown/ngMouseup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mousedown=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseup=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMousedown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标按下时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标释放时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseenter-ngMousemove\"><a href=\"#ngMouseenter-ngMousemove\" class=\"headerlink\" title=\"ngMouseenter/ngMousemove\"></a>ngMouseenter/ngMousemove</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseenter=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mousemove=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseenter</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMousemove</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseover-ngMouseleave\"><a href=\"#ngMouseover-ngMouseleave\" class=\"headerlink\" title=\"ngMouseover/ngMouseleave\"></a>ngMouseover/ngMouseleave</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseover=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div><div class=\"line\">&lt;ANY</div><div class=\"line\">  ng-mouseleave=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/ANY&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseover</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseleave</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标离开时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSelected\"><a href=\"#ngSelected\" class=\"headerlink\" title=\"ngSelected\"></a>ngSelected</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;OPTION</div><div class=\"line\">  ng-selected=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/OPTION&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSelected</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式为真时，selected属性将被设置在元素上。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSubmit\"><a href=\"#ngSubmit\" class=\"headerlink\" title=\"ngSubmit\"></a>ngSubmit</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;form</div><div class=\"line\">  ng-submit=&quot;expression&quot;&gt;</div><div class=\"line\">...</div><div class=\"line\">&lt;/form&gt;</div></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSubmit</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">提交表单时，表达式被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"综合实例\"><a href=\"#综合实例\" class=\"headerlink\" title=\"综合实例\"></a>综合实例</h3><p><strong>html代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;div ng-app=&quot;myapp&quot;&gt;</div><div class=\"line\">    &lt;form name=&quot;form&quot; ng-controller=&quot;formCtrl&quot;&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;blur&quot; ng-blur=&quot;blur=&apos;be blured&apos;&quot; ng-focus=&quot;blur=&apos;got focus,click other place&apos;&quot; placeholder=&quot;click me&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;span ng-model=&quot;mouseEvent&quot; ng-mouseenter=&quot;mouseEvent=&apos;mouseenter&apos;&quot; ng-mouseleave=&quot;mouseEvent=&apos;mouseleave&apos;&quot; ng-bind=&quot;mouseEvent&quot; ng-init=&quot;mouseEvent=&apos;touch me&apos;&quot;&gt;touch me&lt;/span&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;change&quot; ng-change=&quot;changeEvent()&quot; placeholder=&quot;change me&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            msg1:&#123;&#123;changeStatus&#125;&#125;,content:&#123;&#123;change&#125;&#125;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;button&quot; ng-click=&quot;btnClickChangeCheckboxEvent()&quot; value=&quot;change status of checkbox-&gt;&quot; /&gt;</div><div class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;checkbox&quot; ng-checked=&quot;isStatus&quot; /&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">        &lt;p&gt;</div><div class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;option&quot; /&gt;change status of select</div><div class=\"line\">            &lt;select&gt;</div><div class=\"line\">                &lt;option&gt;A&lt;/option&gt;</div><div class=\"line\">                &lt;option ng-selected=&quot;option&quot;&gt;B&lt;/option&gt;</div><div class=\"line\">            &lt;/select&gt;</div><div class=\"line\">        &lt;/p&gt;</div><div class=\"line\">    &lt;/form&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p><strong>js代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">angular.module(&apos;myapp&apos;, [])</div><div class=\"line\">    .controller(&apos;formCtrl&apos;, function($scope) &#123;</div><div class=\"line\">        $scope.change = &apos;change me&apos;;</div><div class=\"line\">        $scope.changeStatus = &apos;no change&apos;;</div><div class=\"line\">        $scope.isStatus = false;</div><div class=\"line\">        $scope.option = false;</div><div class=\"line\"></div><div class=\"line\">        $scope.changeEvent = function() &#123;</div><div class=\"line\">            $scope.changeStatus = &apos;be changed&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        $scope.btnClickChangeCheckboxEvent = function() &#123;</div><div class=\"line\">            $scope.isStatus = !$scope.isStatus;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>DEMO地址：<a href=\"https://jsfiddle.net/Lionney/vLkoz9d3/\">https://jsfiddle.net/Lionney/vLkoz9d3/</a></p>\n<p>如有问题，请指正。</p>\n"},{"title":"了解Javascript传值机制","date":"2015-02-12T16:00:00.000Z","_content":"\n理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。\n\n### 实例 1\n\n```\nvar me = {                  // 1\n    'partOf' : 'A Team'\n}; \n\nfunction myTeam(me) {       // 2\n\n    me = {                  // 3\n        'belongsTo' : 'A Group'\n    }; \n}   \n\nmyTeam(me);     \nconsole.log(me);            // 4  : {'partOf' : 'A Team'}\n```\n\n在上面的实例里myTeam被调用的时候，JavaScript 传递me对象的引用值，因为它是一个对象。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如me, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。\n当我们在#3定义了一个新的对象，我们完全改变了myTeam函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#4输出去了。\n\n### 实例 2\n\n```\nvar me = {                  // 1\n    'partOf' : 'A Team'\n}; \n\nfunction myGroup(me) {      // 2\n    me.partOf = 'A Group';  // 3\n} \n\nmyGroup(me);\nconsole.log(me);            // 4  : {'partOf' : 'A Group'}\n```\n\n当myGroup调用时，我们将对象me传给函数。但是与实例1的情况不同，我们没有指派me变量到任何新对象，有效的说明了myGroup函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#7的输出结果。\n所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，如果是对象的话，JavaScript将引用按值传递。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为call-by-sharing。\n\n[转载自js-by-examples](https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md)\n","source":"_posts/了解Javascript传值机制.md","raw":"---\ntitle: 了解Javascript传值机制\ntags: [javascript]\ndate: 2015/02/13\n---\n\n理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。\n\n### 实例 1\n\n```\nvar me = {                  // 1\n    'partOf' : 'A Team'\n}; \n\nfunction myTeam(me) {       // 2\n\n    me = {                  // 3\n        'belongsTo' : 'A Group'\n    }; \n}   \n\nmyTeam(me);     \nconsole.log(me);            // 4  : {'partOf' : 'A Team'}\n```\n\n在上面的实例里myTeam被调用的时候，JavaScript 传递me对象的引用值，因为它是一个对象。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如me, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。\n当我们在#3定义了一个新的对象，我们完全改变了myTeam函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#4输出去了。\n\n### 实例 2\n\n```\nvar me = {                  // 1\n    'partOf' : 'A Team'\n}; \n\nfunction myGroup(me) {      // 2\n    me.partOf = 'A Group';  // 3\n} \n\nmyGroup(me);\nconsole.log(me);            // 4  : {'partOf' : 'A Group'}\n```\n\n当myGroup调用时，我们将对象me传给函数。但是与实例1的情况不同，我们没有指派me变量到任何新对象，有效的说明了myGroup函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#7的输出结果。\n所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，如果是对象的话，JavaScript将引用按值传递。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为call-by-sharing。\n\n[转载自js-by-examples](https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md)\n","slug":"了解Javascript传值机制","published":1,"updated":"2016-08-17T06:22:19.864Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkj003568dd2tlzlksn","content":"<p>理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。</p>\n<h3 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例 1\"></a>实例 1</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var me = &#123;                  // 1</div><div class=\"line\">    &apos;partOf&apos; : &apos;A Team&apos;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">function myTeam(me) &#123;       // 2</div><div class=\"line\"></div><div class=\"line\">    me = &#123;                  // 3</div><div class=\"line\">        &apos;belongsTo&apos; : &apos;A Group&apos;</div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125;   </div><div class=\"line\"></div><div class=\"line\">myTeam(me);     </div><div class=\"line\">console.log(me);            // 4  : &#123;&apos;partOf&apos; : &apos;A Team&apos;&#125;</div></pre></td></tr></table></figure>\n<p>在上面的实例里myTeam被调用的时候，JavaScript 传递me对象的引用值，因为它是一个对象。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如me, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。<br>当我们在#3定义了一个新的对象，我们完全改变了myTeam函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#4输出去了。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例 2\"></a>实例 2</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var me = &#123;                  // 1</div><div class=\"line\">    &apos;partOf&apos; : &apos;A Team&apos;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">function myGroup(me) &#123;      // 2</div><div class=\"line\">    me.partOf = &apos;A Group&apos;;  // 3</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">myGroup(me);</div><div class=\"line\">console.log(me);            // 4  : &#123;&apos;partOf&apos; : &apos;A Group&apos;&#125;</div></pre></td></tr></table></figure>\n<p>当myGroup调用时，我们将对象me传给函数。但是与实例1的情况不同，我们没有指派me变量到任何新对象，有效的说明了myGroup函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#7的输出结果。<br>所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，如果是对象的话，JavaScript将引用按值传递。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为call-by-sharing。</p>\n<p><a href=\"https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md\" target=\"_blank\" rel=\"external\">转载自js-by-examples</a></p>\n","excerpt":"","more":"<p>理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。</p>\n<h3 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例 1\"></a>实例 1</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var me = &#123;                  // 1</div><div class=\"line\">    &apos;partOf&apos; : &apos;A Team&apos;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">function myTeam(me) &#123;       // 2</div><div class=\"line\"></div><div class=\"line\">    me = &#123;                  // 3</div><div class=\"line\">        &apos;belongsTo&apos; : &apos;A Group&apos;</div><div class=\"line\">    &#125;; </div><div class=\"line\">&#125;   </div><div class=\"line\"></div><div class=\"line\">myTeam(me);     </div><div class=\"line\">console.log(me);            // 4  : &#123;&apos;partOf&apos; : &apos;A Team&apos;&#125;</div></pre></td></tr></table></figure>\n<p>在上面的实例里myTeam被调用的时候，JavaScript 传递me对象的引用值，因为它是一个对象。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如me, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。<br>当我们在#3定义了一个新的对象，我们完全改变了myTeam函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#4输出去了。</p>\n<h3 id=\"实例-2\"><a href=\"#实例-2\" class=\"headerlink\" title=\"实例 2\"></a>实例 2</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var me = &#123;                  // 1</div><div class=\"line\">    &apos;partOf&apos; : &apos;A Team&apos;</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">function myGroup(me) &#123;      // 2</div><div class=\"line\">    me.partOf = &apos;A Group&apos;;  // 3</div><div class=\"line\">&#125; </div><div class=\"line\"></div><div class=\"line\">myGroup(me);</div><div class=\"line\">console.log(me);            // 4  : &#123;&apos;partOf&apos; : &apos;A Group&apos;&#125;</div></pre></td></tr></table></figure>\n<p>当myGroup调用时，我们将对象me传给函数。但是与实例1的情况不同，我们没有指派me变量到任何新对象，有效的说明了myGroup函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#7的输出结果。<br>所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，如果是对象的话，JavaScript将引用按值传递。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为call-by-sharing。</p>\n<p><a href=\"https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md\">转载自js-by-examples</a></p>\n"},{"title":"人人必知的10个jQuery小技巧","date":"2015-02-06T16:00:00.000Z","_content":"\n收集的10个jQuery小技巧/代码片段，可以帮你快速开发。\n\n### 1.返回顶部按钮\n\n你可以利用animate和scrollTop来实现返回顶部的动画，而不需要使用其他插件。\n\n```\n// Back to top\n$('a.top').click(function () {\n  $(document.body).animate({scrollTop: 0}, 800);\n  return false;\n});\n\n<!-- Create an anchor tag -->\n<a class=\"top\" href=\"#\">Back to top</a>\n\n```\n\n改变scrollTop的值可以调整返回距离顶部的距离，而animate的第二个参数是执行返回动作需要的时间(单位：毫秒)。\n\n### 2. 预加载图片\n\n如果你的页面中使用了很多不可见的图片（如：hover显示），你可能需要预加载它们：\n\n```\n$.preloadImages = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    $('<img>').attr('src', arguments[i]);\n  }\n};\n```\n\n```$.preloadImages('img/hover1.png', 'img/hover2.png');```\n\n### 3. 检查图片是否加载完成\n\n有时候你需要确保图片完成加载完成以便执行后面的操作：\n\n```\n$('img').load(function () {\n  console.log('image load successful');\n});\n```\n\n你可以把img替换为其他的ID或者class来检查指定图片是否加载完成。\n\n### 4. 自动修改破损图像\n\n如果你碰巧在你的网站上发现了破碎的图像链接，你可以用一个不易被替换的图像来代替它们。添加这个简单的代码可以节省很多麻烦：\n\n```\n$('img').on('error', function () {\n  $(this).prop('src', 'img/broken.png');\n});\n```\n\n即使你的网站没有破碎的图像链接，添加这段代码也没有任何害处。\n\n### 5. 鼠标悬停(hover)切换class属性\n\n假如当用户鼠标悬停在一个可点击的元素上时，你希望改变其效果，下面这段代码可以在其悬停在元素上时添加class属性，当用户鼠标离开时，则自动取消该class属性：\n\n```\n$('.btn').hover(function () {\n  $(this).addClass('hover');\n  }, function () {\n    $(this).removeClass('hover');\n  });\n```\n\n你只需要添加必要的CSS代码即可。如果你想要更简洁的代码，可以使用toggleClass 方法：\n\n```\n$('.btn').hover(function () { \n  $(this).toggleClass('hover'); \n});\n```\n\n注：直接使用CSS实现该效果可能是更好的解决方案，但你仍然有必要知道该方法。\n\n### 6. 禁用 input 字段\n\n有时你可能需要禁用表单的submit按钮或者某个input字段，直到用户执行了某些操作（例如，检查“已阅读条款”复选框）。可以添加disabled属性，直到你想启用它时：\n\n```\n$('input[type=\"submit\"]').prop('disabled', true);\n```\n\n你要做的就是执行removeAttr方法，并把要移除的属性作为参数传入：\n\n```\n$('input[type=\"submit\"]').removeAttr('disabled');\n```\n\n### 7. 阻止链接加载\n\n有时你不希望链接到某个页面或者重新加载它，你可能希望它来做一些其他事情或者触发一些其他脚本，你可以这么做：\n\n```\n$('a.no-link').click(function (e) {\n  e.preventDefault();\n});\n```\n\n### 8. 切换fade/slide\n\nfade和slide是我们在jQuery中经常使用的动画效果，它们可以使元素显示效果更好。但是如果你希望元素显示时使用第一种效果，而消失时使用第二种效果，则可以这么做：\n\n```\n// Fade\n$('.btn').click(function () {\n  $('.element').fadeToggle('slow');\n});\n// Toggle\n$('.btn').click(function () {\n  $('.element').slideToggle('slow');\n});\n```\n\n### 9. 简单的手风琴效果\n\n这是一个实现手风琴效果快速简单的方法：\n\n```\n// Close all panels\n$('#accordion').find('.content').hide();\n// Accordion\n$('#accordion').find('.accordion-header').click(function () {\n  var next = $(this).next();\n  next.slideToggle('fast');\n  $('.content').not(next).slideUp('fast');\n  return false;\n});\n```\n\n### 10. 让两个DIV高度相同\n\n有时你需要让两个div度相同，而不管它们里面的内容多少。可以使用下面的代码片段：\n\n```\nvar $columns = $('.column');\nvar height = 0;\n$columns.each(function () {\n  if ($(this).height() > height) {\n    height = $(this).height();\n  }\n});\n$columns.height(height);\n```\n\n这段代码会循环一组元素，并设置它们的高度为元素中的最大高。","source":"_posts/人人必知的10个jQuery小技巧.md","raw":"---\ntitle: 人人必知的10个jQuery小技巧\ntags: [javascript,jquery]\ndate: 2015/02/07\n---\n\n收集的10个jQuery小技巧/代码片段，可以帮你快速开发。\n\n### 1.返回顶部按钮\n\n你可以利用animate和scrollTop来实现返回顶部的动画，而不需要使用其他插件。\n\n```\n// Back to top\n$('a.top').click(function () {\n  $(document.body).animate({scrollTop: 0}, 800);\n  return false;\n});\n\n<!-- Create an anchor tag -->\n<a class=\"top\" href=\"#\">Back to top</a>\n\n```\n\n改变scrollTop的值可以调整返回距离顶部的距离，而animate的第二个参数是执行返回动作需要的时间(单位：毫秒)。\n\n### 2. 预加载图片\n\n如果你的页面中使用了很多不可见的图片（如：hover显示），你可能需要预加载它们：\n\n```\n$.preloadImages = function () {\n  for (var i = 0; i < arguments.length; i++) {\n    $('<img>').attr('src', arguments[i]);\n  }\n};\n```\n\n```$.preloadImages('img/hover1.png', 'img/hover2.png');```\n\n### 3. 检查图片是否加载完成\n\n有时候你需要确保图片完成加载完成以便执行后面的操作：\n\n```\n$('img').load(function () {\n  console.log('image load successful');\n});\n```\n\n你可以把img替换为其他的ID或者class来检查指定图片是否加载完成。\n\n### 4. 自动修改破损图像\n\n如果你碰巧在你的网站上发现了破碎的图像链接，你可以用一个不易被替换的图像来代替它们。添加这个简单的代码可以节省很多麻烦：\n\n```\n$('img').on('error', function () {\n  $(this).prop('src', 'img/broken.png');\n});\n```\n\n即使你的网站没有破碎的图像链接，添加这段代码也没有任何害处。\n\n### 5. 鼠标悬停(hover)切换class属性\n\n假如当用户鼠标悬停在一个可点击的元素上时，你希望改变其效果，下面这段代码可以在其悬停在元素上时添加class属性，当用户鼠标离开时，则自动取消该class属性：\n\n```\n$('.btn').hover(function () {\n  $(this).addClass('hover');\n  }, function () {\n    $(this).removeClass('hover');\n  });\n```\n\n你只需要添加必要的CSS代码即可。如果你想要更简洁的代码，可以使用toggleClass 方法：\n\n```\n$('.btn').hover(function () { \n  $(this).toggleClass('hover'); \n});\n```\n\n注：直接使用CSS实现该效果可能是更好的解决方案，但你仍然有必要知道该方法。\n\n### 6. 禁用 input 字段\n\n有时你可能需要禁用表单的submit按钮或者某个input字段，直到用户执行了某些操作（例如，检查“已阅读条款”复选框）。可以添加disabled属性，直到你想启用它时：\n\n```\n$('input[type=\"submit\"]').prop('disabled', true);\n```\n\n你要做的就是执行removeAttr方法，并把要移除的属性作为参数传入：\n\n```\n$('input[type=\"submit\"]').removeAttr('disabled');\n```\n\n### 7. 阻止链接加载\n\n有时你不希望链接到某个页面或者重新加载它，你可能希望它来做一些其他事情或者触发一些其他脚本，你可以这么做：\n\n```\n$('a.no-link').click(function (e) {\n  e.preventDefault();\n});\n```\n\n### 8. 切换fade/slide\n\nfade和slide是我们在jQuery中经常使用的动画效果，它们可以使元素显示效果更好。但是如果你希望元素显示时使用第一种效果，而消失时使用第二种效果，则可以这么做：\n\n```\n// Fade\n$('.btn').click(function () {\n  $('.element').fadeToggle('slow');\n});\n// Toggle\n$('.btn').click(function () {\n  $('.element').slideToggle('slow');\n});\n```\n\n### 9. 简单的手风琴效果\n\n这是一个实现手风琴效果快速简单的方法：\n\n```\n// Close all panels\n$('#accordion').find('.content').hide();\n// Accordion\n$('#accordion').find('.accordion-header').click(function () {\n  var next = $(this).next();\n  next.slideToggle('fast');\n  $('.content').not(next).slideUp('fast');\n  return false;\n});\n```\n\n### 10. 让两个DIV高度相同\n\n有时你需要让两个div度相同，而不管它们里面的内容多少。可以使用下面的代码片段：\n\n```\nvar $columns = $('.column');\nvar height = 0;\n$columns.each(function () {\n  if ($(this).height() > height) {\n    height = $(this).height();\n  }\n});\n$columns.height(height);\n```\n\n这段代码会循环一组元素，并设置它们的高度为元素中的最大高。","slug":"人人必知的10个jQuery小技巧","published":1,"updated":"2016-08-17T06:22:19.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkl003868dd9ys4avyv","content":"<p>收集的10个jQuery小技巧/代码片段，可以帮你快速开发。</p>\n<h3 id=\"1-返回顶部按钮\"><a href=\"#1-返回顶部按钮\" class=\"headerlink\" title=\"1.返回顶部按钮\"></a>1.返回顶部按钮</h3><p>你可以利用animate和scrollTop来实现返回顶部的动画，而不需要使用其他插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Back to top</div><div class=\"line\">$(&apos;a.top&apos;).click(function () &#123;</div><div class=\"line\">  $(document.body).animate(&#123;scrollTop: 0&#125;, 800);</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">&lt;!-- Create an anchor tag --&gt;</div><div class=\"line\">&lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>改变scrollTop的值可以调整返回距离顶部的距离，而animate的第二个参数是执行返回动作需要的时间(单位：毫秒)。</p>\n<h3 id=\"2-预加载图片\"><a href=\"#2-预加载图片\" class=\"headerlink\" title=\"2. 预加载图片\"></a>2. 预加载图片</h3><p>如果你的页面中使用了很多不可见的图片（如：hover显示），你可能需要预加载它们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$.preloadImages = function () &#123;</div><div class=\"line\">  for (var i = 0; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>'img/hover2.png');```</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 3. 检查图片是否加载完成</div><div class=\"line\"></div><div class=\"line\">有时候你需要确保图片完成加载完成以便执行后面的操作：</div></pre></td></tr></table></figure>\n<p>$(‘img’).load(function () {<br>  console.log(‘image load successful’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你可以把img替换为其他的ID或者class来检查指定图片是否加载完成。</div><div class=\"line\"></div><div class=\"line\">### 4. 自动修改破损图像</div><div class=\"line\"></div><div class=\"line\">如果你碰巧在你的网站上发现了破碎的图像链接，你可以用一个不易被替换的图像来代替它们。添加这个简单的代码可以节省很多麻烦：</div></pre></td></tr></table></figure></p>\n<p>$(‘img’).on(‘error’, function () {<br>  $(this).prop(‘src’, ‘img/broken.png’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">即使你的网站没有破碎的图像链接，添加这段代码也没有任何害处。</div><div class=\"line\"></div><div class=\"line\">### 5. 鼠标悬停(hover)切换class属性</div><div class=\"line\"></div><div class=\"line\">假如当用户鼠标悬停在一个可点击的元素上时，你希望改变其效果，下面这段代码可以在其悬停在元素上时添加class属性，当用户鼠标离开时，则自动取消该class属性：</div></pre></td></tr></table></figure></p>\n<p>$(‘.btn’).hover(function () {<br>  $(this).addClass(‘hover’);<br>  }, function () {<br>    $(this).removeClass(‘hover’);<br>  });<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你只需要添加必要的CSS代码即可。如果你想要更简洁的代码，可以使用toggleClass 方法：</div></pre></td></tr></table></figure></p>\n<p>$(‘.btn’).hover(function () {<br>  $(this).toggleClass(‘hover’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：直接使用CSS实现该效果可能是更好的解决方案，但你仍然有必要知道该方法。</div><div class=\"line\"></div><div class=\"line\">### 6. 禁用 input 字段</div><div class=\"line\"></div><div class=\"line\">有时你可能需要禁用表单的submit按钮或者某个input字段，直到用户执行了某些操作（例如，检查“已阅读条款”复选框）。可以添加disabled属性，直到你想启用它时：</div></pre></td></tr></table></figure></p>\n<p>$(‘input[type=”submit”]’).prop(‘disabled’, true);<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你要做的就是执行removeAttr方法，并把要移除的属性作为参数传入：</div></pre></td></tr></table></figure></p>\n<p>$(‘input[type=”submit”]’).removeAttr(‘disabled’);<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 7. 阻止链接加载</div><div class=\"line\"></div><div class=\"line\">有时你不希望链接到某个页面或者重新加载它，你可能希望它来做一些其他事情或者触发一些其他脚本，你可以这么做：</div></pre></td></tr></table></figure></p>\n<p>$(‘a.no-link’).click(function (e) {<br>  e.preventDefault();<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 8. 切换fade/slide</div><div class=\"line\"></div><div class=\"line\">fade和slide是我们在jQuery中经常使用的动画效果，它们可以使元素显示效果更好。但是如果你希望元素显示时使用第一种效果，而消失时使用第二种效果，则可以这么做：</div></pre></td></tr></table></figure></p>\n<p>// Fade<br>$(‘.btn’).click(function () {<br>  $(‘.element’).fadeToggle(‘slow’);<br>});<br>// Toggle<br>$(‘.btn’).click(function () {<br>  $(‘.element’).slideToggle(‘slow’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 9. 简单的手风琴效果</div><div class=\"line\"></div><div class=\"line\">这是一个实现手风琴效果快速简单的方法：</div></pre></td></tr></table></figure></p>\n<p>// Close all panels<br>$(‘#accordion’).find(‘.content’).hide();<br>// Accordion<br>$(‘#accordion’).find(‘.accordion-header’).click(function () {<br>  var next = $(this).next();<br>  next.slideToggle(‘fast’);<br>  $(‘.content’).not(next).slideUp(‘fast’);<br>  return false;<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 10. 让两个DIV高度相同</div><div class=\"line\"></div><div class=\"line\">有时你需要让两个div度相同，而不管它们里面的内容多少。可以使用下面的代码片段：</div></pre></td></tr></table></figure></p>\n<p>var $columns = $(‘.column’);<br>var height = 0;<br>$columns.each(function () {<br>  if ($(this).height() &gt; height) {<br>    height = $(this).height();<br>  }<br>});<br>$columns.height(height);<br>```</p>\n<p>这段代码会循环一组元素，并设置它们的高度为元素中的最大高。</p>\n","excerpt":"","more":"<p>收集的10个jQuery小技巧/代码片段，可以帮你快速开发。</p>\n<h3 id=\"1-返回顶部按钮\"><a href=\"#1-返回顶部按钮\" class=\"headerlink\" title=\"1.返回顶部按钮\"></a>1.返回顶部按钮</h3><p>你可以利用animate和scrollTop来实现返回顶部的动画，而不需要使用其他插件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Back to top</div><div class=\"line\">$(&apos;a.top&apos;).click(function () &#123;</div><div class=\"line\">  $(document.body).animate(&#123;scrollTop: 0&#125;, 800);</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">&lt;!-- Create an anchor tag --&gt;</div><div class=\"line\">&lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>改变scrollTop的值可以调整返回距离顶部的距离，而animate的第二个参数是执行返回动作需要的时间(单位：毫秒)。</p>\n<h3 id=\"2-预加载图片\"><a href=\"#2-预加载图片\" class=\"headerlink\" title=\"2. 预加载图片\"></a>2. 预加载图片</h3><p>如果你的页面中使用了很多不可见的图片（如：hover显示），你可能需要预加载它们：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$.preloadImages = function () &#123;</div><div class=\"line\">  for (var i = 0; i &lt; arguments.length; i++) &#123;</div><div class=\"line\">    $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>'img/hover2.png');```</span></figcaption><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 3. 检查图片是否加载完成</div><div class=\"line\"></div><div class=\"line\">有时候你需要确保图片完成加载完成以便执行后面的操作：</div></pre></td></tr></table></figure>\n<p>$(‘img’).load(function () {<br>  console.log(‘image load successful’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你可以把img替换为其他的ID或者class来检查指定图片是否加载完成。</div><div class=\"line\"></div><div class=\"line\">### 4. 自动修改破损图像</div><div class=\"line\"></div><div class=\"line\">如果你碰巧在你的网站上发现了破碎的图像链接，你可以用一个不易被替换的图像来代替它们。添加这个简单的代码可以节省很多麻烦：</div></pre></td></tr></table></figure></p>\n<p>$(‘img’).on(‘error’, function () {<br>  $(this).prop(‘src’, ‘img/broken.png’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">即使你的网站没有破碎的图像链接，添加这段代码也没有任何害处。</div><div class=\"line\"></div><div class=\"line\">### 5. 鼠标悬停(hover)切换class属性</div><div class=\"line\"></div><div class=\"line\">假如当用户鼠标悬停在一个可点击的元素上时，你希望改变其效果，下面这段代码可以在其悬停在元素上时添加class属性，当用户鼠标离开时，则自动取消该class属性：</div></pre></td></tr></table></figure></p>\n<p>$(‘.btn’).hover(function () {<br>  $(this).addClass(‘hover’);<br>  }, function () {<br>    $(this).removeClass(‘hover’);<br>  });<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你只需要添加必要的CSS代码即可。如果你想要更简洁的代码，可以使用toggleClass 方法：</div></pre></td></tr></table></figure></p>\n<p>$(‘.btn’).hover(function () {<br>  $(this).toggleClass(‘hover’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">注：直接使用CSS实现该效果可能是更好的解决方案，但你仍然有必要知道该方法。</div><div class=\"line\"></div><div class=\"line\">### 6. 禁用 input 字段</div><div class=\"line\"></div><div class=\"line\">有时你可能需要禁用表单的submit按钮或者某个input字段，直到用户执行了某些操作（例如，检查“已阅读条款”复选框）。可以添加disabled属性，直到你想启用它时：</div></pre></td></tr></table></figure></p>\n<p>$(‘input[type=”submit”]’).prop(‘disabled’, true);<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">你要做的就是执行removeAttr方法，并把要移除的属性作为参数传入：</div></pre></td></tr></table></figure></p>\n<p>$(‘input[type=”submit”]’).removeAttr(‘disabled’);<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 7. 阻止链接加载</div><div class=\"line\"></div><div class=\"line\">有时你不希望链接到某个页面或者重新加载它，你可能希望它来做一些其他事情或者触发一些其他脚本，你可以这么做：</div></pre></td></tr></table></figure></p>\n<p>$(‘a.no-link’).click(function (e) {<br>  e.preventDefault();<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 8. 切换fade/slide</div><div class=\"line\"></div><div class=\"line\">fade和slide是我们在jQuery中经常使用的动画效果，它们可以使元素显示效果更好。但是如果你希望元素显示时使用第一种效果，而消失时使用第二种效果，则可以这么做：</div></pre></td></tr></table></figure></p>\n<p>// Fade<br>$(‘.btn’).click(function () {<br>  $(‘.element’).fadeToggle(‘slow’);<br>});<br>// Toggle<br>$(‘.btn’).click(function () {<br>  $(‘.element’).slideToggle(‘slow’);<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 9. 简单的手风琴效果</div><div class=\"line\"></div><div class=\"line\">这是一个实现手风琴效果快速简单的方法：</div></pre></td></tr></table></figure></p>\n<p>// Close all panels<br>$(‘#accordion’).find(‘.content’).hide();<br>// Accordion<br>$(‘#accordion’).find(‘.accordion-header’).click(function () {<br>  var next = $(this).next();<br>  next.slideToggle(‘fast’);<br>  $(‘.content’).not(next).slideUp(‘fast’);<br>  return false;<br>});<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">### 10. 让两个DIV高度相同</div><div class=\"line\"></div><div class=\"line\">有时你需要让两个div度相同，而不管它们里面的内容多少。可以使用下面的代码片段：</div></pre></td></tr></table></figure></p>\n<p>var $columns = $(‘.column’);<br>var height = 0;<br>$columns.each(function () {<br>  if ($(this).height() &gt; height) {<br>    height = $(this).height();<br>  }<br>});<br>$columns.height(height);<br>```</p>\n<p>这段代码会循环一组元素，并设置它们的高度为元素中的最大高。</p>\n"},{"title":"从本质认识JavaScript的原型继承和类继承","date":"2016-03-30T16:00:00.000Z","_content":"\nJavaScript发展到今天，和其他语言不一样的一个特点是，有各种各样的“继承方式”，或者稍微准确一点的说法，叫做有各种各样的基于prototype的模拟类继承实现方式。\n\n在ES6之前，JavaScript没有类继承的概念，因此使用者为了代码复用的目的，只能参考其他语言的“继承”，然后用prototype来模拟出对应的实现，于是有了各种继承方式，比如《JavaScript高级程序设计》上说的 原型链，借用构造函数，组合继承，原型式继承，寄生式继承，寄生组合式继承 等等\n\n那么多继承方式，让第一次接触这一块的小伙伴们内心有点崩溃。然而，之所以有那么多继承方式，其实还是因为“模拟”二字，因为我们在说继承的时候不是在研究prototype本身，而是在用prototype和JS特性来模拟别的语言的类继承。\n\n我们现在抛开这些种类繁多的继承方式，来看一下prototype的本质和我们为什么要模拟类继承。\n\n### 原型继承\n\n“原型” 这个词本身源自心理学，指神话、宗教、梦境、幻想、文学中不断重复出现的意象，它源自民族记忆和原始经验的集体潜意识。\n\n所以，原型是一种抽象，代表事物表象之下的联系，用简单的话来说，就是原型描述事物与事物之间的相似性.\n\n想象一个小孩子如何认知这个世界：\n\n当小孩子没见过老虎的时候，大人可能会教他，老虎啊，就像是一只大猫。如果这个孩子碰巧常常和邻居家的猫咪玩耍，那么她不用去动物园见到真实的老虎，就能想象出老虎大概是长什么样子。\n\n这个故事有个更简单的表达，叫做“照猫画虎”。如果我们用JavaScript的原型来描述它，就是：\n\n```\nfunction Tiger(){\n    //...\n}\n\nTiger.prototype = new Cat(); //老虎的原型是一只猫\n```\n\n很显然，“照猫画虎”（或者反过来“照虎画猫”，也可以，取决孩子于先认识老虎还是先认识猫）是一种认知模式，它让人类儿童不需要在脑海里重新完全构建一只老虎的全部信息，而可以通过她熟悉的猫咪的“复用”得到老虎的大部分信息，接下来她只需要去到动物园，去观察老虎和猫咪的不同部分，就可以正确认知什么是老虎了。这段话用JavaScript可以描述如下：\n\n```\nfunction Cat(){\n\n}\n//小猫喵喵叫\nCat.prototype.say = function(){    \n  return \"喵\";\n}\n//小猫会爬树\nCat.prototype.climb = function(){\n  return \"我会爬树\";\n}\n\nfunction Tiger(){\n\n}\nTiger.prototype = new Cat();\n\n//老虎的叫声和小猫不同，但老虎也会爬树\nTiger.prototype.say = function(){\n  return \"嗷\";\n}\n```\n\n所以，原型可以通过描述两个事物之间的相似关系来复用代码，我们可以把这种复用代码的模式称为原型继承。\n\n### 类继承\n\n几年之后，当时的小孩子长大了，随着她的知识结构不断丰富，她认识世界的方式也发生了一些变化，她学会了太多的动物，有喵喵叫的猫，百兽之王狮子，优雅的丛林之王老虎，还有豺狼、大象等等。\n\n这时候，单纯的相似性的认知方式已经很少被使用在如此丰富的知识内容里，更加严谨的认知方式——分类，开始被更频繁使用。\n\n这时候当年的小孩会说，猫和狗都是动物，如果她碰巧学习的是专业的生物学，她可能还会说猫和狗都是脊索门哺乳纲，于是，相似性被“类”这一种更高程度的抽象表达取代，我们用JavaScript来描述：\n\n```\nclass Animal{\n    eat(){}\n    say(){}\n    climb(){}\n    ...\n}\nclass Cat extends Animal{\n    say(){return \"喵\"}\n}\nclass Dog extends Animal{\n    say(){return \"汪\"}\n}\n```\n\n### 原型继承和类继承\n\n所以，原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。\n\n原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”）\n\n原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。\n\n既然原型本质上是一种认知模式可以用来复用代码，那我们为什么还要模拟“类继承”呢？在这里面我们就得看看原型继承有什么问题。\n\n### 原型继承的问题\n\n由于我们刚才前面举例的猫和老虎的构造器没有参数，因此大家很可能没发现问题，现在我们试验一个有参数构造器的原型继承：\n\n```\nfunction Vector2D(x, y){\n  this.x = x;\n  this.y = y;\n}\nVector2D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n\nfunction Vector3D(x, y, z){\n  Vector2D.call(this, x, y);\n  this.z = z;\n}\nVector3D.prototype = new Vector2D();\n\nVector3D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n}\n\nvar p = new Vector3D(1, 2, 3);\nconsole.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);\n```\n\n上面这段代码里面我们看到我们用 Vector2D 的实例作为 Vector3D 的原型，在 Vector3D 的构造器里面我们还可以调用 Vector2D 的构造器来初始化 x、y。\n\n但是，如果认真研究上面的代码，会发现一个小问题，在中间描述原型继承的时候：\n\n```\nVector3D.prototype = new Vector2D();\n```\n\n我们其实无参数地调用了一次 Vector2D 的构造器！\n\n这一次调用是不必要的，而且，因为我们的 Vector2D 的构造器足够简单并且没有副作用，所以我们这次无谓的调用除了稍稍消耗了性能之外，并不会带来太严重的问题。\n\n但在实际项目中，我们有些组件的构造器比较复杂，或者操作DOM，那么这种情况下无谓多调用一次构造器，显然是有可能造成严重问题的。\n\n于是，我们得想办法克服这一次多余的构造器调用，而显然，我们发现我们可以不必要这一次多余的调用：\n\n```\nfunction createObjWithoutConstructor(Class){\n    function T(){};\n    T.prototype = Class.prototype;\n    return new T();    \n}\n```\n\n上面的代码中，我们通过创建一个空的构造器T，引用父类Class的prototype，然后返回new T( )，来巧妙地避开Class构造器的执行。这样，我们确实可以绕开父类构造器的调用，并将它的调用时机延迟到子类实例化的时候（本来也应该这样才合理）。\n\n```\nfunction Vector2D(x, y){\n  this.x = x;\n  this.y = y;\n}\nVector2D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n\nfunction Vector3D(x, y, z){\n  Vector2D.call(this, x, y);\n  this.z = z;\n}\nVector3D.prototype = createObjWithoutConstructor(Vector2D);\n\nVector3D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n}\n\nvar p = new Vector3D(1, 2, 3);\nconsole.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);\n```\n\n这样，我们解决了父类构造器延迟构造的问题之后，原型继承就比较适用了，并且这样简单处理之后，使用起来还不会影响 instanceof 返回值的正确性，这是与其他模拟方式相比最大的好处。\n\n### 模拟类继承\n\n最后，我们利用这个原理还可以实现比较完美的类继承：\n\n```\n(function(global){\"use strict\"\n\n  Function.prototype.extend = function(props){\n    var Super = this; //父类构造函数\n\n    //父类原型\n    var TmpCls = function(){\n\n    }\n    TmpCls.prototype = Super.prototype;\n\n    var superProto = new TmpCls();\n\n    //父类构造器wrapper\n    var _super = function(){\n      return Super.apply(this, arguments);\n    }\n\n    var Cls = function(){\n      if(props.constructor){\n        //执行构造函数\n        props.constructor.apply(this, arguments);\n      }\n      //绑定 this._super 的方法\n      for(var i in Super.prototype){\n        _super[i] = Super.prototype[i].bind(this);\n      }\n    }\n    Cls.prototype = superProto;\n    Cls.prototype._super = _super;\n\n    //复制属性\n    for(var i in props){\n      if(i !== \"constructor\"){\n        Cls.prototype[i] = props[i];\n      }\n    }  \n\n    return Cls;\n  }\n\n  function Animal(name){\n    this.name = name;\n  }\n\n  Animal.prototype.sayName = function(){\n    console.log(\"My name is \"+this.name);\n  }\n\n  var Programmer = Animal.extend({\n    constructor: function(name){\n      this._super(name);\n    },\n    sayName: function(){\n      this._super.sayName(name);\n    },\n    program: function(){\n      console.log(\"I\\\"m coding...\");\n    }\n  });\n  //测试我们的类\n  var animal = new Animal(\"dummy\"),\n      akira = new Programmer(\"akira\");\n  animal.sayName();//输出 ‘My name is dummy’\n  akira.sayName();//输出 ‘My name is akira’\n  akira.program();//输出 ‘I\"m coding...’\n\n})(this);\n```\n\n可以比较一下ES6的类继承：\n\n```\n(function(global){\"use strict\"\n\n  //类的定义\n  class Animal {\n    //ES6中新型构造器\n      constructor(name) {\n          this.name = name;\n      }\n      //实例方法\n      sayName() {\n          console.log(\"My name is \"+this.name);\n      }\n  }\n\n  //类的继承\n  class Programmer extends Animal {\n      constructor(name) {\n        //直接调用父类构造器进行初始化\n          super(name);\n      }\n      sayName(){\n          super.sayName();\n      }\n      program() {\n          console.log(\"I\\\"m coding...\");\n      }\n  }\n  //测试我们的类\n  var animal = new Animal(\"dummy\"),\n      akira = new Programmer(\"akira\");\n  animal.sayName();//输出 ‘My name is dummy’\n  akira.sayName();//输出 ‘My name is akira’\n  akira.program();//输出 ‘I\"m coding...’\n\n})(this);\n```\n\n### 总结\n\n原型继承和类继承是两种不同的认知模式，原型继承在对象不是很多的简单应用模型里比类继承更加灵活方便。然而JavaScript的原型继承在语法上有一个构造器额外调用的问题，我们只要通过 createObjWithoutConstructor 来延迟构造器的调用，就能解决这个问题。\n\n[http://blog.h5jun.com](http://blog.h5jun.com/post/inherits.html)","source":"_posts/从本质认识JavaScript的原型继承和类继承.md","raw":"---\ntitle: 从本质认识JavaScript的原型继承和类继承\ntags: [javascript,es6]\ndate: 2016/03/31\n---\n\nJavaScript发展到今天，和其他语言不一样的一个特点是，有各种各样的“继承方式”，或者稍微准确一点的说法，叫做有各种各样的基于prototype的模拟类继承实现方式。\n\n在ES6之前，JavaScript没有类继承的概念，因此使用者为了代码复用的目的，只能参考其他语言的“继承”，然后用prototype来模拟出对应的实现，于是有了各种继承方式，比如《JavaScript高级程序设计》上说的 原型链，借用构造函数，组合继承，原型式继承，寄生式继承，寄生组合式继承 等等\n\n那么多继承方式，让第一次接触这一块的小伙伴们内心有点崩溃。然而，之所以有那么多继承方式，其实还是因为“模拟”二字，因为我们在说继承的时候不是在研究prototype本身，而是在用prototype和JS特性来模拟别的语言的类继承。\n\n我们现在抛开这些种类繁多的继承方式，来看一下prototype的本质和我们为什么要模拟类继承。\n\n### 原型继承\n\n“原型” 这个词本身源自心理学，指神话、宗教、梦境、幻想、文学中不断重复出现的意象，它源自民族记忆和原始经验的集体潜意识。\n\n所以，原型是一种抽象，代表事物表象之下的联系，用简单的话来说，就是原型描述事物与事物之间的相似性.\n\n想象一个小孩子如何认知这个世界：\n\n当小孩子没见过老虎的时候，大人可能会教他，老虎啊，就像是一只大猫。如果这个孩子碰巧常常和邻居家的猫咪玩耍，那么她不用去动物园见到真实的老虎，就能想象出老虎大概是长什么样子。\n\n这个故事有个更简单的表达，叫做“照猫画虎”。如果我们用JavaScript的原型来描述它，就是：\n\n```\nfunction Tiger(){\n    //...\n}\n\nTiger.prototype = new Cat(); //老虎的原型是一只猫\n```\n\n很显然，“照猫画虎”（或者反过来“照虎画猫”，也可以，取决孩子于先认识老虎还是先认识猫）是一种认知模式，它让人类儿童不需要在脑海里重新完全构建一只老虎的全部信息，而可以通过她熟悉的猫咪的“复用”得到老虎的大部分信息，接下来她只需要去到动物园，去观察老虎和猫咪的不同部分，就可以正确认知什么是老虎了。这段话用JavaScript可以描述如下：\n\n```\nfunction Cat(){\n\n}\n//小猫喵喵叫\nCat.prototype.say = function(){    \n  return \"喵\";\n}\n//小猫会爬树\nCat.prototype.climb = function(){\n  return \"我会爬树\";\n}\n\nfunction Tiger(){\n\n}\nTiger.prototype = new Cat();\n\n//老虎的叫声和小猫不同，但老虎也会爬树\nTiger.prototype.say = function(){\n  return \"嗷\";\n}\n```\n\n所以，原型可以通过描述两个事物之间的相似关系来复用代码，我们可以把这种复用代码的模式称为原型继承。\n\n### 类继承\n\n几年之后，当时的小孩子长大了，随着她的知识结构不断丰富，她认识世界的方式也发生了一些变化，她学会了太多的动物，有喵喵叫的猫，百兽之王狮子，优雅的丛林之王老虎，还有豺狼、大象等等。\n\n这时候，单纯的相似性的认知方式已经很少被使用在如此丰富的知识内容里，更加严谨的认知方式——分类，开始被更频繁使用。\n\n这时候当年的小孩会说，猫和狗都是动物，如果她碰巧学习的是专业的生物学，她可能还会说猫和狗都是脊索门哺乳纲，于是，相似性被“类”这一种更高程度的抽象表达取代，我们用JavaScript来描述：\n\n```\nclass Animal{\n    eat(){}\n    say(){}\n    climb(){}\n    ...\n}\nclass Cat extends Animal{\n    say(){return \"喵\"}\n}\nclass Dog extends Animal{\n    say(){return \"汪\"}\n}\n```\n\n### 原型继承和类继承\n\n所以，原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。\n\n原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”）\n\n原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。\n\n既然原型本质上是一种认知模式可以用来复用代码，那我们为什么还要模拟“类继承”呢？在这里面我们就得看看原型继承有什么问题。\n\n### 原型继承的问题\n\n由于我们刚才前面举例的猫和老虎的构造器没有参数，因此大家很可能没发现问题，现在我们试验一个有参数构造器的原型继承：\n\n```\nfunction Vector2D(x, y){\n  this.x = x;\n  this.y = y;\n}\nVector2D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n\nfunction Vector3D(x, y, z){\n  Vector2D.call(this, x, y);\n  this.z = z;\n}\nVector3D.prototype = new Vector2D();\n\nVector3D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n}\n\nvar p = new Vector3D(1, 2, 3);\nconsole.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);\n```\n\n上面这段代码里面我们看到我们用 Vector2D 的实例作为 Vector3D 的原型，在 Vector3D 的构造器里面我们还可以调用 Vector2D 的构造器来初始化 x、y。\n\n但是，如果认真研究上面的代码，会发现一个小问题，在中间描述原型继承的时候：\n\n```\nVector3D.prototype = new Vector2D();\n```\n\n我们其实无参数地调用了一次 Vector2D 的构造器！\n\n这一次调用是不必要的，而且，因为我们的 Vector2D 的构造器足够简单并且没有副作用，所以我们这次无谓的调用除了稍稍消耗了性能之外，并不会带来太严重的问题。\n\n但在实际项目中，我们有些组件的构造器比较复杂，或者操作DOM，那么这种情况下无谓多调用一次构造器，显然是有可能造成严重问题的。\n\n于是，我们得想办法克服这一次多余的构造器调用，而显然，我们发现我们可以不必要这一次多余的调用：\n\n```\nfunction createObjWithoutConstructor(Class){\n    function T(){};\n    T.prototype = Class.prototype;\n    return new T();    \n}\n```\n\n上面的代码中，我们通过创建一个空的构造器T，引用父类Class的prototype，然后返回new T( )，来巧妙地避开Class构造器的执行。这样，我们确实可以绕开父类构造器的调用，并将它的调用时机延迟到子类实例化的时候（本来也应该这样才合理）。\n\n```\nfunction Vector2D(x, y){\n  this.x = x;\n  this.y = y;\n}\nVector2D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n}\n\nfunction Vector3D(x, y, z){\n  Vector2D.call(this, x, y);\n  this.z = z;\n}\nVector3D.prototype = createObjWithoutConstructor(Vector2D);\n\nVector3D.prototype.length = function(){\n  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n}\n\nvar p = new Vector3D(1, 2, 3);\nconsole.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);\n```\n\n这样，我们解决了父类构造器延迟构造的问题之后，原型继承就比较适用了，并且这样简单处理之后，使用起来还不会影响 instanceof 返回值的正确性，这是与其他模拟方式相比最大的好处。\n\n### 模拟类继承\n\n最后，我们利用这个原理还可以实现比较完美的类继承：\n\n```\n(function(global){\"use strict\"\n\n  Function.prototype.extend = function(props){\n    var Super = this; //父类构造函数\n\n    //父类原型\n    var TmpCls = function(){\n\n    }\n    TmpCls.prototype = Super.prototype;\n\n    var superProto = new TmpCls();\n\n    //父类构造器wrapper\n    var _super = function(){\n      return Super.apply(this, arguments);\n    }\n\n    var Cls = function(){\n      if(props.constructor){\n        //执行构造函数\n        props.constructor.apply(this, arguments);\n      }\n      //绑定 this._super 的方法\n      for(var i in Super.prototype){\n        _super[i] = Super.prototype[i].bind(this);\n      }\n    }\n    Cls.prototype = superProto;\n    Cls.prototype._super = _super;\n\n    //复制属性\n    for(var i in props){\n      if(i !== \"constructor\"){\n        Cls.prototype[i] = props[i];\n      }\n    }  \n\n    return Cls;\n  }\n\n  function Animal(name){\n    this.name = name;\n  }\n\n  Animal.prototype.sayName = function(){\n    console.log(\"My name is \"+this.name);\n  }\n\n  var Programmer = Animal.extend({\n    constructor: function(name){\n      this._super(name);\n    },\n    sayName: function(){\n      this._super.sayName(name);\n    },\n    program: function(){\n      console.log(\"I\\\"m coding...\");\n    }\n  });\n  //测试我们的类\n  var animal = new Animal(\"dummy\"),\n      akira = new Programmer(\"akira\");\n  animal.sayName();//输出 ‘My name is dummy’\n  akira.sayName();//输出 ‘My name is akira’\n  akira.program();//输出 ‘I\"m coding...’\n\n})(this);\n```\n\n可以比较一下ES6的类继承：\n\n```\n(function(global){\"use strict\"\n\n  //类的定义\n  class Animal {\n    //ES6中新型构造器\n      constructor(name) {\n          this.name = name;\n      }\n      //实例方法\n      sayName() {\n          console.log(\"My name is \"+this.name);\n      }\n  }\n\n  //类的继承\n  class Programmer extends Animal {\n      constructor(name) {\n        //直接调用父类构造器进行初始化\n          super(name);\n      }\n      sayName(){\n          super.sayName();\n      }\n      program() {\n          console.log(\"I\\\"m coding...\");\n      }\n  }\n  //测试我们的类\n  var animal = new Animal(\"dummy\"),\n      akira = new Programmer(\"akira\");\n  animal.sayName();//输出 ‘My name is dummy’\n  akira.sayName();//输出 ‘My name is akira’\n  akira.program();//输出 ‘I\"m coding...’\n\n})(this);\n```\n\n### 总结\n\n原型继承和类继承是两种不同的认知模式，原型继承在对象不是很多的简单应用模型里比类继承更加灵活方便。然而JavaScript的原型继承在语法上有一个构造器额外调用的问题，我们只要通过 createObjWithoutConstructor 来延迟构造器的调用，就能解决这个问题。\n\n[http://blog.h5jun.com](http://blog.h5jun.com/post/inherits.html)","slug":"从本质认识JavaScript的原型继承和类继承","published":1,"updated":"2016-08-23T07:24:46.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkn003a68ddbf4jlrxo","content":"<p>JavaScript发展到今天，和其他语言不一样的一个特点是，有各种各样的“继承方式”，或者稍微准确一点的说法，叫做有各种各样的基于prototype的模拟类继承实现方式。</p>\n<p>在ES6之前，JavaScript没有类继承的概念，因此使用者为了代码复用的目的，只能参考其他语言的“继承”，然后用prototype来模拟出对应的实现，于是有了各种继承方式，比如《JavaScript高级程序设计》上说的 原型链，借用构造函数，组合继承，原型式继承，寄生式继承，寄生组合式继承 等等</p>\n<p>那么多继承方式，让第一次接触这一块的小伙伴们内心有点崩溃。然而，之所以有那么多继承方式，其实还是因为“模拟”二字，因为我们在说继承的时候不是在研究prototype本身，而是在用prototype和JS特性来模拟别的语言的类继承。</p>\n<p>我们现在抛开这些种类繁多的继承方式，来看一下prototype的本质和我们为什么要模拟类继承。</p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><p>“原型” 这个词本身源自心理学，指神话、宗教、梦境、幻想、文学中不断重复出现的意象，它源自民族记忆和原始经验的集体潜意识。</p>\n<p>所以，原型是一种抽象，代表事物表象之下的联系，用简单的话来说，就是原型描述事物与事物之间的相似性.</p>\n<p>想象一个小孩子如何认知这个世界：</p>\n<p>当小孩子没见过老虎的时候，大人可能会教他，老虎啊，就像是一只大猫。如果这个孩子碰巧常常和邻居家的猫咪玩耍，那么她不用去动物园见到真实的老虎，就能想象出老虎大概是长什么样子。</p>\n<p>这个故事有个更简单的表达，叫做“照猫画虎”。如果我们用JavaScript的原型来描述它，就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Tiger()&#123;</div><div class=\"line\">    //...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Tiger.prototype = new Cat(); //老虎的原型是一只猫</div></pre></td></tr></table></figure>\n<p>很显然，“照猫画虎”（或者反过来“照虎画猫”，也可以，取决孩子于先认识老虎还是先认识猫）是一种认知模式，它让人类儿童不需要在脑海里重新完全构建一只老虎的全部信息，而可以通过她熟悉的猫咪的“复用”得到老虎的大部分信息，接下来她只需要去到动物园，去观察老虎和猫咪的不同部分，就可以正确认知什么是老虎了。这段话用JavaScript可以描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Cat()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//小猫喵喵叫</div><div class=\"line\">Cat.prototype.say = function()&#123;    </div><div class=\"line\">  return &quot;喵&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">//小猫会爬树</div><div class=\"line\">Cat.prototype.climb = function()&#123;</div><div class=\"line\">  return &quot;我会爬树&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Tiger()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">Tiger.prototype = new Cat();</div><div class=\"line\"></div><div class=\"line\">//老虎的叫声和小猫不同，但老虎也会爬树</div><div class=\"line\">Tiger.prototype.say = function()&#123;</div><div class=\"line\">  return &quot;嗷&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，原型可以通过描述两个事物之间的相似关系来复用代码，我们可以把这种复用代码的模式称为原型继承。</p>\n<h3 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h3><p>几年之后，当时的小孩子长大了，随着她的知识结构不断丰富，她认识世界的方式也发生了一些变化，她学会了太多的动物，有喵喵叫的猫，百兽之王狮子，优雅的丛林之王老虎，还有豺狼、大象等等。</p>\n<p>这时候，单纯的相似性的认知方式已经很少被使用在如此丰富的知识内容里，更加严谨的认知方式——分类，开始被更频繁使用。</p>\n<p>这时候当年的小孩会说，猫和狗都是动物，如果她碰巧学习的是专业的生物学，她可能还会说猫和狗都是脊索门哺乳纲，于是，相似性被“类”这一种更高程度的抽象表达取代，我们用JavaScript来描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">class Animal&#123;</div><div class=\"line\">    eat()&#123;&#125;</div><div class=\"line\">    say()&#123;&#125;</div><div class=\"line\">    climb()&#123;&#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\">class Cat extends Animal&#123;</div><div class=\"line\">    say()&#123;return &quot;喵&quot;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Dog extends Animal&#123;</div><div class=\"line\">    say()&#123;return &quot;汪&quot;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"原型继承和类继承\"><a href=\"#原型继承和类继承\" class=\"headerlink\" title=\"原型继承和类继承\"></a>原型继承和类继承</h3><p>所以，原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。</p>\n<p>原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”）</p>\n<p>原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。</p>\n<p>既然原型本质上是一种认知模式可以用来复用代码，那我们为什么还要模拟“类继承”呢？在这里面我们就得看看原型继承有什么问题。</p>\n<h3 id=\"原型继承的问题\"><a href=\"#原型继承的问题\" class=\"headerlink\" title=\"原型继承的问题\"></a>原型继承的问题</h3><p>由于我们刚才前面举例的猫和老虎的构造器没有参数，因此大家很可能没发现问题，现在我们试验一个有参数构造器的原型继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Vector2D(x, y)&#123;</div><div class=\"line\">  this.x = x;</div><div class=\"line\">  this.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector2D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Vector3D(x, y, z)&#123;</div><div class=\"line\">  Vector2D.call(this, x, y);</div><div class=\"line\">  this.z = z;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector3D.prototype = new Vector2D();</div><div class=\"line\"></div><div class=\"line\">Vector3D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Vector3D(1, 2, 3);</div><div class=\"line\">console.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);</div></pre></td></tr></table></figure>\n<p>上面这段代码里面我们看到我们用 Vector2D 的实例作为 Vector3D 的原型，在 Vector3D 的构造器里面我们还可以调用 Vector2D 的构造器来初始化 x、y。</p>\n<p>但是，如果认真研究上面的代码，会发现一个小问题，在中间描述原型继承的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vector3D.prototype = new Vector2D();</div></pre></td></tr></table></figure>\n<p>我们其实无参数地调用了一次 Vector2D 的构造器！</p>\n<p>这一次调用是不必要的，而且，因为我们的 Vector2D 的构造器足够简单并且没有副作用，所以我们这次无谓的调用除了稍稍消耗了性能之外，并不会带来太严重的问题。</p>\n<p>但在实际项目中，我们有些组件的构造器比较复杂，或者操作DOM，那么这种情况下无谓多调用一次构造器，显然是有可能造成严重问题的。</p>\n<p>于是，我们得想办法克服这一次多余的构造器调用，而显然，我们发现我们可以不必要这一次多余的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function createObjWithoutConstructor(Class)&#123;</div><div class=\"line\">    function T()&#123;&#125;;</div><div class=\"line\">    T.prototype = Class.prototype;</div><div class=\"line\">    return new T();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中，我们通过创建一个空的构造器T，引用父类Class的prototype，然后返回new T( )，来巧妙地避开Class构造器的执行。这样，我们确实可以绕开父类构造器的调用，并将它的调用时机延迟到子类实例化的时候（本来也应该这样才合理）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Vector2D(x, y)&#123;</div><div class=\"line\">  this.x = x;</div><div class=\"line\">  this.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector2D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Vector3D(x, y, z)&#123;</div><div class=\"line\">  Vector2D.call(this, x, y);</div><div class=\"line\">  this.z = z;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector3D.prototype = createObjWithoutConstructor(Vector2D);</div><div class=\"line\"></div><div class=\"line\">Vector3D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Vector3D(1, 2, 3);</div><div class=\"line\">console.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);</div></pre></td></tr></table></figure>\n<p>这样，我们解决了父类构造器延迟构造的问题之后，原型继承就比较适用了，并且这样简单处理之后，使用起来还不会影响 instanceof 返回值的正确性，这是与其他模拟方式相比最大的好处。</p>\n<h3 id=\"模拟类继承\"><a href=\"#模拟类继承\" class=\"headerlink\" title=\"模拟类继承\"></a>模拟类继承</h3><p>最后，我们利用这个原理还可以实现比较完美的类继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function(global)&#123;&quot;use strict&quot;</div><div class=\"line\"></div><div class=\"line\">  Function.prototype.extend = function(props)&#123;</div><div class=\"line\">    var Super = this; //父类构造函数</div><div class=\"line\"></div><div class=\"line\">    //父类原型</div><div class=\"line\">    var TmpCls = function()&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    TmpCls.prototype = Super.prototype;</div><div class=\"line\"></div><div class=\"line\">    var superProto = new TmpCls();</div><div class=\"line\"></div><div class=\"line\">    //父类构造器wrapper</div><div class=\"line\">    var _super = function()&#123;</div><div class=\"line\">      return Super.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var Cls = function()&#123;</div><div class=\"line\">      if(props.constructor)&#123;</div><div class=\"line\">        //执行构造函数</div><div class=\"line\">        props.constructor.apply(this, arguments);</div><div class=\"line\">      &#125;</div><div class=\"line\">      //绑定 this._super 的方法</div><div class=\"line\">      for(var i in Super.prototype)&#123;</div><div class=\"line\">        _super[i] = Super.prototype[i].bind(this);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Cls.prototype = superProto;</div><div class=\"line\">    Cls.prototype._super = _super;</div><div class=\"line\"></div><div class=\"line\">    //复制属性</div><div class=\"line\">    for(var i in props)&#123;</div><div class=\"line\">      if(i !== &quot;constructor&quot;)&#123;</div><div class=\"line\">        Cls.prototype[i] = props[i];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    return Cls;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  function Animal(name)&#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  Animal.prototype.sayName = function()&#123;</div><div class=\"line\">    console.log(&quot;My name is &quot;+this.name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var Programmer = Animal.extend(&#123;</div><div class=\"line\">    constructor: function(name)&#123;</div><div class=\"line\">      this._super(name);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    sayName: function()&#123;</div><div class=\"line\">      this._super.sayName(name);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    program: function()&#123;</div><div class=\"line\">      console.log(&quot;I\\&quot;m coding...&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">  //测试我们的类</div><div class=\"line\">  var animal = new Animal(&quot;dummy&quot;),</div><div class=\"line\">      akira = new Programmer(&quot;akira&quot;);</div><div class=\"line\">  animal.sayName();//输出 ‘My name is dummy’</div><div class=\"line\">  akira.sayName();//输出 ‘My name is akira’</div><div class=\"line\">  akira.program();//输出 ‘I&quot;m coding...’</div><div class=\"line\"></div><div class=\"line\">&#125;)(this);</div></pre></td></tr></table></figure>\n<p>可以比较一下ES6的类继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function(global)&#123;&quot;use strict&quot;</div><div class=\"line\"></div><div class=\"line\">  //类的定义</div><div class=\"line\">  class Animal &#123;</div><div class=\"line\">    //ES6中新型构造器</div><div class=\"line\">      constructor(name) &#123;</div><div class=\"line\">          this.name = name;</div><div class=\"line\">      &#125;</div><div class=\"line\">      //实例方法</div><div class=\"line\">      sayName() &#123;</div><div class=\"line\">          console.log(&quot;My name is &quot;+this.name);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  //类的继承</div><div class=\"line\">  class Programmer extends Animal &#123;</div><div class=\"line\">      constructor(name) &#123;</div><div class=\"line\">        //直接调用父类构造器进行初始化</div><div class=\"line\">          super(name);</div><div class=\"line\">      &#125;</div><div class=\"line\">      sayName()&#123;</div><div class=\"line\">          super.sayName();</div><div class=\"line\">      &#125;</div><div class=\"line\">      program() &#123;</div><div class=\"line\">          console.log(&quot;I\\&quot;m coding...&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //测试我们的类</div><div class=\"line\">  var animal = new Animal(&quot;dummy&quot;),</div><div class=\"line\">      akira = new Programmer(&quot;akira&quot;);</div><div class=\"line\">  animal.sayName();//输出 ‘My name is dummy’</div><div class=\"line\">  akira.sayName();//输出 ‘My name is akira’</div><div class=\"line\">  akira.program();//输出 ‘I&quot;m coding...’</div><div class=\"line\"></div><div class=\"line\">&#125;)(this);</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>原型继承和类继承是两种不同的认知模式，原型继承在对象不是很多的简单应用模型里比类继承更加灵活方便。然而JavaScript的原型继承在语法上有一个构造器额外调用的问题，我们只要通过 createObjWithoutConstructor 来延迟构造器的调用，就能解决这个问题。</p>\n<p><a href=\"http://blog.h5jun.com/post/inherits.html\" target=\"_blank\" rel=\"external\">http://blog.h5jun.com</a></p>\n","excerpt":"","more":"<p>JavaScript发展到今天，和其他语言不一样的一个特点是，有各种各样的“继承方式”，或者稍微准确一点的说法，叫做有各种各样的基于prototype的模拟类继承实现方式。</p>\n<p>在ES6之前，JavaScript没有类继承的概念，因此使用者为了代码复用的目的，只能参考其他语言的“继承”，然后用prototype来模拟出对应的实现，于是有了各种继承方式，比如《JavaScript高级程序设计》上说的 原型链，借用构造函数，组合继承，原型式继承，寄生式继承，寄生组合式继承 等等</p>\n<p>那么多继承方式，让第一次接触这一块的小伙伴们内心有点崩溃。然而，之所以有那么多继承方式，其实还是因为“模拟”二字，因为我们在说继承的时候不是在研究prototype本身，而是在用prototype和JS特性来模拟别的语言的类继承。</p>\n<p>我们现在抛开这些种类繁多的继承方式，来看一下prototype的本质和我们为什么要模拟类继承。</p>\n<h3 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h3><p>“原型” 这个词本身源自心理学，指神话、宗教、梦境、幻想、文学中不断重复出现的意象，它源自民族记忆和原始经验的集体潜意识。</p>\n<p>所以，原型是一种抽象，代表事物表象之下的联系，用简单的话来说，就是原型描述事物与事物之间的相似性.</p>\n<p>想象一个小孩子如何认知这个世界：</p>\n<p>当小孩子没见过老虎的时候，大人可能会教他，老虎啊，就像是一只大猫。如果这个孩子碰巧常常和邻居家的猫咪玩耍，那么她不用去动物园见到真实的老虎，就能想象出老虎大概是长什么样子。</p>\n<p>这个故事有个更简单的表达，叫做“照猫画虎”。如果我们用JavaScript的原型来描述它，就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Tiger()&#123;</div><div class=\"line\">    //...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Tiger.prototype = new Cat(); //老虎的原型是一只猫</div></pre></td></tr></table></figure>\n<p>很显然，“照猫画虎”（或者反过来“照虎画猫”，也可以，取决孩子于先认识老虎还是先认识猫）是一种认知模式，它让人类儿童不需要在脑海里重新完全构建一只老虎的全部信息，而可以通过她熟悉的猫咪的“复用”得到老虎的大部分信息，接下来她只需要去到动物园，去观察老虎和猫咪的不同部分，就可以正确认知什么是老虎了。这段话用JavaScript可以描述如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Cat()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">//小猫喵喵叫</div><div class=\"line\">Cat.prototype.say = function()&#123;    </div><div class=\"line\">  return &quot;喵&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\">//小猫会爬树</div><div class=\"line\">Cat.prototype.climb = function()&#123;</div><div class=\"line\">  return &quot;我会爬树&quot;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Tiger()&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">Tiger.prototype = new Cat();</div><div class=\"line\"></div><div class=\"line\">//老虎的叫声和小猫不同，但老虎也会爬树</div><div class=\"line\">Tiger.prototype.say = function()&#123;</div><div class=\"line\">  return &quot;嗷&quot;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>所以，原型可以通过描述两个事物之间的相似关系来复用代码，我们可以把这种复用代码的模式称为原型继承。</p>\n<h3 id=\"类继承\"><a href=\"#类继承\" class=\"headerlink\" title=\"类继承\"></a>类继承</h3><p>几年之后，当时的小孩子长大了，随着她的知识结构不断丰富，她认识世界的方式也发生了一些变化，她学会了太多的动物，有喵喵叫的猫，百兽之王狮子，优雅的丛林之王老虎，还有豺狼、大象等等。</p>\n<p>这时候，单纯的相似性的认知方式已经很少被使用在如此丰富的知识内容里，更加严谨的认知方式——分类，开始被更频繁使用。</p>\n<p>这时候当年的小孩会说，猫和狗都是动物，如果她碰巧学习的是专业的生物学，她可能还会说猫和狗都是脊索门哺乳纲，于是，相似性被“类”这一种更高程度的抽象表达取代，我们用JavaScript来描述：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">class Animal&#123;</div><div class=\"line\">    eat()&#123;&#125;</div><div class=\"line\">    say()&#123;&#125;</div><div class=\"line\">    climb()&#123;&#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\">class Cat extends Animal&#123;</div><div class=\"line\">    say()&#123;return &quot;喵&quot;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Dog extends Animal&#123;</div><div class=\"line\">    say()&#123;return &quot;汪&quot;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"原型继承和类继承\"><a href=\"#原型继承和类继承\" class=\"headerlink\" title=\"原型继承和类继承\"></a>原型继承和类继承</h3><p>所以，原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。</p>\n<p>原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”）</p>\n<p>原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。</p>\n<p>既然原型本质上是一种认知模式可以用来复用代码，那我们为什么还要模拟“类继承”呢？在这里面我们就得看看原型继承有什么问题。</p>\n<h3 id=\"原型继承的问题\"><a href=\"#原型继承的问题\" class=\"headerlink\" title=\"原型继承的问题\"></a>原型继承的问题</h3><p>由于我们刚才前面举例的猫和老虎的构造器没有参数，因此大家很可能没发现问题，现在我们试验一个有参数构造器的原型继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Vector2D(x, y)&#123;</div><div class=\"line\">  this.x = x;</div><div class=\"line\">  this.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector2D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Vector3D(x, y, z)&#123;</div><div class=\"line\">  Vector2D.call(this, x, y);</div><div class=\"line\">  this.z = z;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector3D.prototype = new Vector2D();</div><div class=\"line\"></div><div class=\"line\">Vector3D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Vector3D(1, 2, 3);</div><div class=\"line\">console.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);</div></pre></td></tr></table></figure>\n<p>上面这段代码里面我们看到我们用 Vector2D 的实例作为 Vector3D 的原型，在 Vector3D 的构造器里面我们还可以调用 Vector2D 的构造器来初始化 x、y。</p>\n<p>但是，如果认真研究上面的代码，会发现一个小问题，在中间描述原型继承的时候：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Vector3D.prototype = new Vector2D();</div></pre></td></tr></table></figure>\n<p>我们其实无参数地调用了一次 Vector2D 的构造器！</p>\n<p>这一次调用是不必要的，而且，因为我们的 Vector2D 的构造器足够简单并且没有副作用，所以我们这次无谓的调用除了稍稍消耗了性能之外，并不会带来太严重的问题。</p>\n<p>但在实际项目中，我们有些组件的构造器比较复杂，或者操作DOM，那么这种情况下无谓多调用一次构造器，显然是有可能造成严重问题的。</p>\n<p>于是，我们得想办法克服这一次多余的构造器调用，而显然，我们发现我们可以不必要这一次多余的调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function createObjWithoutConstructor(Class)&#123;</div><div class=\"line\">    function T()&#123;&#125;;</div><div class=\"line\">    T.prototype = Class.prototype;</div><div class=\"line\">    return new T();    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码中，我们通过创建一个空的构造器T，引用父类Class的prototype，然后返回new T( )，来巧妙地避开Class构造器的执行。这样，我们确实可以绕开父类构造器的调用，并将它的调用时机延迟到子类实例化的时候（本来也应该这样才合理）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Vector2D(x, y)&#123;</div><div class=\"line\">  this.x = x;</div><div class=\"line\">  this.y = y;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector2D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Vector3D(x, y, z)&#123;</div><div class=\"line\">  Vector2D.call(this, x, y);</div><div class=\"line\">  this.z = z;</div><div class=\"line\">&#125;</div><div class=\"line\">Vector3D.prototype = createObjWithoutConstructor(Vector2D);</div><div class=\"line\"></div><div class=\"line\">Vector3D.prototype.length = function()&#123;</div><div class=\"line\">  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var p = new Vector3D(1, 2, 3);</div><div class=\"line\">console.log(p.x, p.y, p.z, p.length(), p instanceof Vector2D);</div></pre></td></tr></table></figure>\n<p>这样，我们解决了父类构造器延迟构造的问题之后，原型继承就比较适用了，并且这样简单处理之后，使用起来还不会影响 instanceof 返回值的正确性，这是与其他模拟方式相比最大的好处。</p>\n<h3 id=\"模拟类继承\"><a href=\"#模拟类继承\" class=\"headerlink\" title=\"模拟类继承\"></a>模拟类继承</h3><p>最后，我们利用这个原理还可以实现比较完美的类继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function(global)&#123;&quot;use strict&quot;</div><div class=\"line\"></div><div class=\"line\">  Function.prototype.extend = function(props)&#123;</div><div class=\"line\">    var Super = this; //父类构造函数</div><div class=\"line\"></div><div class=\"line\">    //父类原型</div><div class=\"line\">    var TmpCls = function()&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">    TmpCls.prototype = Super.prototype;</div><div class=\"line\"></div><div class=\"line\">    var superProto = new TmpCls();</div><div class=\"line\"></div><div class=\"line\">    //父类构造器wrapper</div><div class=\"line\">    var _super = function()&#123;</div><div class=\"line\">      return Super.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var Cls = function()&#123;</div><div class=\"line\">      if(props.constructor)&#123;</div><div class=\"line\">        //执行构造函数</div><div class=\"line\">        props.constructor.apply(this, arguments);</div><div class=\"line\">      &#125;</div><div class=\"line\">      //绑定 this._super 的方法</div><div class=\"line\">      for(var i in Super.prototype)&#123;</div><div class=\"line\">        _super[i] = Super.prototype[i].bind(this);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Cls.prototype = superProto;</div><div class=\"line\">    Cls.prototype._super = _super;</div><div class=\"line\"></div><div class=\"line\">    //复制属性</div><div class=\"line\">    for(var i in props)&#123;</div><div class=\"line\">      if(i !== &quot;constructor&quot;)&#123;</div><div class=\"line\">        Cls.prototype[i] = props[i];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;  </div><div class=\"line\"></div><div class=\"line\">    return Cls;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  function Animal(name)&#123;</div><div class=\"line\">    this.name = name;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  Animal.prototype.sayName = function()&#123;</div><div class=\"line\">    console.log(&quot;My name is &quot;+this.name);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  var Programmer = Animal.extend(&#123;</div><div class=\"line\">    constructor: function(name)&#123;</div><div class=\"line\">      this._super(name);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    sayName: function()&#123;</div><div class=\"line\">      this._super.sayName(name);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    program: function()&#123;</div><div class=\"line\">      console.log(&quot;I\\&quot;m coding...&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;);</div><div class=\"line\">  //测试我们的类</div><div class=\"line\">  var animal = new Animal(&quot;dummy&quot;),</div><div class=\"line\">      akira = new Programmer(&quot;akira&quot;);</div><div class=\"line\">  animal.sayName();//输出 ‘My name is dummy’</div><div class=\"line\">  akira.sayName();//输出 ‘My name is akira’</div><div class=\"line\">  akira.program();//输出 ‘I&quot;m coding...’</div><div class=\"line\"></div><div class=\"line\">&#125;)(this);</div></pre></td></tr></table></figure>\n<p>可以比较一下ES6的类继承：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">(function(global)&#123;&quot;use strict&quot;</div><div class=\"line\"></div><div class=\"line\">  //类的定义</div><div class=\"line\">  class Animal &#123;</div><div class=\"line\">    //ES6中新型构造器</div><div class=\"line\">      constructor(name) &#123;</div><div class=\"line\">          this.name = name;</div><div class=\"line\">      &#125;</div><div class=\"line\">      //实例方法</div><div class=\"line\">      sayName() &#123;</div><div class=\"line\">          console.log(&quot;My name is &quot;+this.name);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  //类的继承</div><div class=\"line\">  class Programmer extends Animal &#123;</div><div class=\"line\">      constructor(name) &#123;</div><div class=\"line\">        //直接调用父类构造器进行初始化</div><div class=\"line\">          super(name);</div><div class=\"line\">      &#125;</div><div class=\"line\">      sayName()&#123;</div><div class=\"line\">          super.sayName();</div><div class=\"line\">      &#125;</div><div class=\"line\">      program() &#123;</div><div class=\"line\">          console.log(&quot;I\\&quot;m coding...&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //测试我们的类</div><div class=\"line\">  var animal = new Animal(&quot;dummy&quot;),</div><div class=\"line\">      akira = new Programmer(&quot;akira&quot;);</div><div class=\"line\">  animal.sayName();//输出 ‘My name is dummy’</div><div class=\"line\">  akira.sayName();//输出 ‘My name is akira’</div><div class=\"line\">  akira.program();//输出 ‘I&quot;m coding...’</div><div class=\"line\"></div><div class=\"line\">&#125;)(this);</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>原型继承和类继承是两种不同的认知模式，原型继承在对象不是很多的简单应用模型里比类继承更加灵活方便。然而JavaScript的原型继承在语法上有一个构造器额外调用的问题，我们只要通过 createObjWithoutConstructor 来延迟构造器的调用，就能解决这个问题。</p>\n<p><a href=\"http://blog.h5jun.com/post/inherits.html\">http://blog.h5jun.com</a></p>\n"},{"title":"使用Flexbox的六个理由","date":"2015-02-01T16:00:00.000Z","_content":"\n### 所有主流浏览器均支持\n\n我还没有使用Flexbox的主要原因是我认为缺乏浏览器的支持。但事实上，Flexbox以95.89％的比率在全球浏览器得到了很好的支持。如果你不考虑IE 10及以下的版本，Microsoft表示现在可以这样认为，这个数字甚至可以更高。\n\n![2016030901](/resource/2016030901.png)\n\n### 不必担心语法\n\n虽然所有浏览器的最新版本均支持Flexbox目前的语法，那老版本的支持如何呢？因为语法的改变已经半年多了，在书写方面存在一些不一致的地方。为了支持所有浏览器目前最后的两个版本，我们将不得不使用不同供应商前缀，每条规则至少书写4个不同的版本。\n\n关于这个问题，我的解决方案是只需使用autoprefixer。跟踪最好使用哪个供应商前缀，不应该占用我们的时间和精力，所以我们应该将其设置为自动化。\n\n使用 autoprefixer，我们可以指定我们想要支持的浏览器版本，然后他就会自动添加相应的供应商前缀。\n\n```\n/* Write this */\n.flex-container {\n  display: flex;\n}\n\n/* Compiles to this (with autoprefixer set to support last 2 versions of all browsers) */\n.flex-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n```\n\n### 简单的开始\n\n诚然，学习所有flexbox 相关的知识并不是那么简单。它有12个新属性，其中每个大约有 4个潜在值。当然你可以一点一点的去理解掌握。\n\n**但是你并不需要去了解所有的属性。**因为在很多情况下，我发现自己只需要使用 3 个属性-\n\n+ display：将元素设置为内联或者块flexbox容器元素\n+ justify-content： 控制 flex 容器内项的水平对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)\n+ align-items: 控制 flex 容器内项的垂直对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)\n\n使用这些仅适用于 flex 容器的属性，我们可以产生大量不同的布局。如果你想要了解更多相关知识，还有丰富的资源/属性列表/帮助你学习的例子\n\n+ [Flexbox中文教程](http://www.w3cplus.com/blog/tags/157.html)\n+ [Flexbox Playground](http://codepen.io/enxaneta/full/adLPwv/)：一个在线文档，你可以验证每个属性-值对的作用\n+ [Flexbox 完全指南(CSS 技巧)](https://css-tricks.com/snippets/css/a-guide-to-flexbox/): 所有 flexbox 概述\n+ [Flexbox Froggy](http://flexboxfroggy.com/): 学习 CSS flexbox 的游戏\n+ [Flexbugs](https://github.com/philipwalton/flexbugs): flexbox 问题的列表以及解决他们跨浏览器问题的方法\n+ [Flexibility](https://github.com/10up/flexibility):支持旧版浏览器的一个polyfill\n\n### 元素居中\n\n除了 flexbox 良好的浏览器支持，我们还可以很轻松的实现元素在水平垂直居中问题。\n\n仅仅需要3个声明，我们就可以实现子元素完全居中:\n\n```\n.flex-container {\n  display: flex;\n  justify-content: center; /* horizontal centering */\n  align-items: center; /* vertical centering */\n\n  border: 2px dashed #000;\n}\n```\n\n![2016030902](/resource/2016030902.png)\n\n### 更容易地操作内联元素\n\n关于内联项定位问题就是臭名昭著的额外的4个像素的外边距。虽然存在解决这个问题的方法，如浮动元素，但随时就会出现新的问题。\n\n使用Flexbox，我们就可以毫不费力地处理内联元素。我们可以实现元素的**两端对齐**对齐：\n\n```\n.flex-container { display: flex; }\n.flex-item { width: 20%; }\n```\n\n![2016030903](/resource/2016030903.png)\n\n我们可以实现项与项之间的**均匀分布**\n\n```\n.flex-container {\n  display: flex;\n  justify-content: space-around;\n}\n```\n![2016030904](/resource/2016030904.png)\n\n我们甚至可以在不处理:first-child或:last-child的情况下，实现列表项的均匀分布：\n\n```\n.flex-container {\n  display: flex;\n  justify-content: space-between;\n}\n```\n\n![2016030905](/resource/2016030905.png)\n\n### 简化了复杂性\n\n究其Flexbox的创建原因，首先可能是因为这个原因，让我们实现在尽可能少的声明中创建复杂的布局。\n\n在前面的例子中，我仅仅通过设置flex容器样式来实现。然而，我们可以通过设置 flex 项来实现更加精细的样式调节。例如，定价表的通用布局:\n\n![2016030906](/resource/2016030906.png)\n\n这里有三个 div，中间div的宽度是两边的两倍。为了使用flexbox实现这种布局，我们可以这样书写。\n\n```\n.flex-container {\n  display: flex;\n  align-items: center;\n}\n\n.flex-items:not(:nth-child(2)) {\n  flex-grow: 1;\n  height: 300px;\n}\n\n.flex-items:nth-child(2) {\n  flex-grow: 2;\n  height: 350px;\n}\n```\n\n关于Felxbox，我的意识已经很晚了，但是我仍然相信还有许多人的思想没有改变。您已经使用 flexbox 了吗?如果没有，您是不是已经被信服，要试一试呢?\n\n[原文链接](http://www.w3cplus.com/css3/6-reasons-to-start-using-flexbox.html)\n","source":"_posts/使用Flexbox的六个理由.md","raw":"---\ntitle: 使用Flexbox的六个理由\ntags: [html,css]\ndate: 2015/02/02\n---\n\n### 所有主流浏览器均支持\n\n我还没有使用Flexbox的主要原因是我认为缺乏浏览器的支持。但事实上，Flexbox以95.89％的比率在全球浏览器得到了很好的支持。如果你不考虑IE 10及以下的版本，Microsoft表示现在可以这样认为，这个数字甚至可以更高。\n\n![2016030901](/resource/2016030901.png)\n\n### 不必担心语法\n\n虽然所有浏览器的最新版本均支持Flexbox目前的语法，那老版本的支持如何呢？因为语法的改变已经半年多了，在书写方面存在一些不一致的地方。为了支持所有浏览器目前最后的两个版本，我们将不得不使用不同供应商前缀，每条规则至少书写4个不同的版本。\n\n关于这个问题，我的解决方案是只需使用autoprefixer。跟踪最好使用哪个供应商前缀，不应该占用我们的时间和精力，所以我们应该将其设置为自动化。\n\n使用 autoprefixer，我们可以指定我们想要支持的浏览器版本，然后他就会自动添加相应的供应商前缀。\n\n```\n/* Write this */\n.flex-container {\n  display: flex;\n}\n\n/* Compiles to this (with autoprefixer set to support last 2 versions of all browsers) */\n.flex-container {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n```\n\n### 简单的开始\n\n诚然，学习所有flexbox 相关的知识并不是那么简单。它有12个新属性，其中每个大约有 4个潜在值。当然你可以一点一点的去理解掌握。\n\n**但是你并不需要去了解所有的属性。**因为在很多情况下，我发现自己只需要使用 3 个属性-\n\n+ display：将元素设置为内联或者块flexbox容器元素\n+ justify-content： 控制 flex 容器内项的水平对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)\n+ align-items: 控制 flex 容器内项的垂直对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)\n\n使用这些仅适用于 flex 容器的属性，我们可以产生大量不同的布局。如果你想要了解更多相关知识，还有丰富的资源/属性列表/帮助你学习的例子\n\n+ [Flexbox中文教程](http://www.w3cplus.com/blog/tags/157.html)\n+ [Flexbox Playground](http://codepen.io/enxaneta/full/adLPwv/)：一个在线文档，你可以验证每个属性-值对的作用\n+ [Flexbox 完全指南(CSS 技巧)](https://css-tricks.com/snippets/css/a-guide-to-flexbox/): 所有 flexbox 概述\n+ [Flexbox Froggy](http://flexboxfroggy.com/): 学习 CSS flexbox 的游戏\n+ [Flexbugs](https://github.com/philipwalton/flexbugs): flexbox 问题的列表以及解决他们跨浏览器问题的方法\n+ [Flexibility](https://github.com/10up/flexibility):支持旧版浏览器的一个polyfill\n\n### 元素居中\n\n除了 flexbox 良好的浏览器支持，我们还可以很轻松的实现元素在水平垂直居中问题。\n\n仅仅需要3个声明，我们就可以实现子元素完全居中:\n\n```\n.flex-container {\n  display: flex;\n  justify-content: center; /* horizontal centering */\n  align-items: center; /* vertical centering */\n\n  border: 2px dashed #000;\n}\n```\n\n![2016030902](/resource/2016030902.png)\n\n### 更容易地操作内联元素\n\n关于内联项定位问题就是臭名昭著的额外的4个像素的外边距。虽然存在解决这个问题的方法，如浮动元素，但随时就会出现新的问题。\n\n使用Flexbox，我们就可以毫不费力地处理内联元素。我们可以实现元素的**两端对齐**对齐：\n\n```\n.flex-container { display: flex; }\n.flex-item { width: 20%; }\n```\n\n![2016030903](/resource/2016030903.png)\n\n我们可以实现项与项之间的**均匀分布**\n\n```\n.flex-container {\n  display: flex;\n  justify-content: space-around;\n}\n```\n![2016030904](/resource/2016030904.png)\n\n我们甚至可以在不处理:first-child或:last-child的情况下，实现列表项的均匀分布：\n\n```\n.flex-container {\n  display: flex;\n  justify-content: space-between;\n}\n```\n\n![2016030905](/resource/2016030905.png)\n\n### 简化了复杂性\n\n究其Flexbox的创建原因，首先可能是因为这个原因，让我们实现在尽可能少的声明中创建复杂的布局。\n\n在前面的例子中，我仅仅通过设置flex容器样式来实现。然而，我们可以通过设置 flex 项来实现更加精细的样式调节。例如，定价表的通用布局:\n\n![2016030906](/resource/2016030906.png)\n\n这里有三个 div，中间div的宽度是两边的两倍。为了使用flexbox实现这种布局，我们可以这样书写。\n\n```\n.flex-container {\n  display: flex;\n  align-items: center;\n}\n\n.flex-items:not(:nth-child(2)) {\n  flex-grow: 1;\n  height: 300px;\n}\n\n.flex-items:nth-child(2) {\n  flex-grow: 2;\n  height: 350px;\n}\n```\n\n关于Felxbox，我的意识已经很晚了，但是我仍然相信还有许多人的思想没有改变。您已经使用 flexbox 了吗?如果没有，您是不是已经被信服，要试一试呢?\n\n[原文链接](http://www.w3cplus.com/css3/6-reasons-to-start-using-flexbox.html)\n","slug":"使用Flexbox的六个理由","published":1,"updated":"2016-08-17T06:22:19.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkr003d68ddvcp3i4dr","content":"<h3 id=\"所有主流浏览器均支持\"><a href=\"#所有主流浏览器均支持\" class=\"headerlink\" title=\"所有主流浏览器均支持\"></a>所有主流浏览器均支持</h3><p>我还没有使用Flexbox的主要原因是我认为缺乏浏览器的支持。但事实上，Flexbox以95.89％的比率在全球浏览器得到了很好的支持。如果你不考虑IE 10及以下的版本，Microsoft表示现在可以这样认为，这个数字甚至可以更高。</p>\n<p><img src=\"/resource/2016030901.png\" alt=\"2016030901\"></p>\n<h3 id=\"不必担心语法\"><a href=\"#不必担心语法\" class=\"headerlink\" title=\"不必担心语法\"></a>不必担心语法</h3><p>虽然所有浏览器的最新版本均支持Flexbox目前的语法，那老版本的支持如何呢？因为语法的改变已经半年多了，在书写方面存在一些不一致的地方。为了支持所有浏览器目前最后的两个版本，我们将不得不使用不同供应商前缀，每条规则至少书写4个不同的版本。</p>\n<p>关于这个问题，我的解决方案是只需使用autoprefixer。跟踪最好使用哪个供应商前缀，不应该占用我们的时间和精力，所以我们应该将其设置为自动化。</p>\n<p>使用 autoprefixer，我们可以指定我们想要支持的浏览器版本，然后他就会自动添加相应的供应商前缀。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/* Write this */</div><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* Compiles to this (with autoprefixer set to support last 2 versions of all browsers) */</div><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: -webkit-box;</div><div class=\"line\">  display: -webkit-flex;</div><div class=\"line\">  display: -ms-flexbox;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"简单的开始\"><a href=\"#简单的开始\" class=\"headerlink\" title=\"简单的开始\"></a>简单的开始</h3><p>诚然，学习所有flexbox 相关的知识并不是那么简单。它有12个新属性，其中每个大约有 4个潜在值。当然你可以一点一点的去理解掌握。</p>\n<p><strong>但是你并不需要去了解所有的属性。</strong>因为在很多情况下，我发现自己只需要使用 3 个属性-</p>\n<ul>\n<li>display：将元素设置为内联或者块flexbox容器元素</li>\n<li>justify-content： 控制 flex 容器内项的水平对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)</li>\n<li>align-items: 控制 flex 容器内项的垂直对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)</li>\n</ul>\n<p>使用这些仅适用于 flex 容器的属性，我们可以产生大量不同的布局。如果你想要了解更多相关知识，还有丰富的资源/属性列表/帮助你学习的例子</p>\n<ul>\n<li><a href=\"http://www.w3cplus.com/blog/tags/157.html\" target=\"_blank\" rel=\"external\">Flexbox中文教程</a></li>\n<li><a href=\"http://codepen.io/enxaneta/full/adLPwv/\" target=\"_blank\" rel=\"external\">Flexbox Playground</a>：一个在线文档，你可以验证每个属性-值对的作用</li>\n<li><a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\" target=\"_blank\" rel=\"external\">Flexbox 完全指南(CSS 技巧)</a>: 所有 flexbox 概述</li>\n<li><a href=\"http://flexboxfroggy.com/\" target=\"_blank\" rel=\"external\">Flexbox Froggy</a>: 学习 CSS flexbox 的游戏</li>\n<li><a href=\"https://github.com/philipwalton/flexbugs\" target=\"_blank\" rel=\"external\">Flexbugs</a>: flexbox 问题的列表以及解决他们跨浏览器问题的方法</li>\n<li><a href=\"https://github.com/10up/flexibility\" target=\"_blank\" rel=\"external\">Flexibility</a>:支持旧版浏览器的一个polyfill</li>\n</ul>\n<h3 id=\"元素居中\"><a href=\"#元素居中\" class=\"headerlink\" title=\"元素居中\"></a>元素居中</h3><p>除了 flexbox 良好的浏览器支持，我们还可以很轻松的实现元素在水平垂直居中问题。</p>\n<p>仅仅需要3个声明，我们就可以实现子元素完全居中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: center; /* horizontal centering */</div><div class=\"line\">  align-items: center; /* vertical centering */</div><div class=\"line\"></div><div class=\"line\">  border: 2px dashed #000;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030902.png\" alt=\"2016030902\"></p>\n<h3 id=\"更容易地操作内联元素\"><a href=\"#更容易地操作内联元素\" class=\"headerlink\" title=\"更容易地操作内联元素\"></a>更容易地操作内联元素</h3><p>关于内联项定位问题就是臭名昭著的额外的4个像素的外边距。虽然存在解决这个问题的方法，如浮动元素，但随时就会出现新的问题。</p>\n<p>使用Flexbox，我们就可以毫不费力地处理内联元素。我们可以实现元素的<strong>两端对齐</strong>对齐：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123; display: flex; &#125;</div><div class=\"line\">.flex-item &#123; width: 20%; &#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030903.png\" alt=\"2016030903\"></p>\n<p>我们可以实现项与项之间的<strong>均匀分布</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030904.png\" alt=\"2016030904\"></p>\n<p>我们甚至可以在不处理:first-child或:last-child的情况下，实现列表项的均匀分布：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: space-between;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030905.png\" alt=\"2016030905\"></p>\n<h3 id=\"简化了复杂性\"><a href=\"#简化了复杂性\" class=\"headerlink\" title=\"简化了复杂性\"></a>简化了复杂性</h3><p>究其Flexbox的创建原因，首先可能是因为这个原因，让我们实现在尽可能少的声明中创建复杂的布局。</p>\n<p>在前面的例子中，我仅仅通过设置flex容器样式来实现。然而，我们可以通过设置 flex 项来实现更加精细的样式调节。例如，定价表的通用布局:</p>\n<p><img src=\"/resource/2016030906.png\" alt=\"2016030906\"></p>\n<p>这里有三个 div，中间div的宽度是两边的两倍。为了使用flexbox实现这种布局，我们可以这样书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  align-items: center;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.flex-items:not(:nth-child(2)) &#123;</div><div class=\"line\">  flex-grow: 1;</div><div class=\"line\">  height: 300px;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.flex-items:nth-child(2) &#123;</div><div class=\"line\">  flex-grow: 2;</div><div class=\"line\">  height: 350px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Felxbox，我的意识已经很晚了，但是我仍然相信还有许多人的思想没有改变。您已经使用 flexbox 了吗?如果没有，您是不是已经被信服，要试一试呢?</p>\n<p><a href=\"http://www.w3cplus.com/css3/6-reasons-to-start-using-flexbox.html\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n","excerpt":"","more":"<h3 id=\"所有主流浏览器均支持\"><a href=\"#所有主流浏览器均支持\" class=\"headerlink\" title=\"所有主流浏览器均支持\"></a>所有主流浏览器均支持</h3><p>我还没有使用Flexbox的主要原因是我认为缺乏浏览器的支持。但事实上，Flexbox以95.89％的比率在全球浏览器得到了很好的支持。如果你不考虑IE 10及以下的版本，Microsoft表示现在可以这样认为，这个数字甚至可以更高。</p>\n<p><img src=\"/resource/2016030901.png\" alt=\"2016030901\"></p>\n<h3 id=\"不必担心语法\"><a href=\"#不必担心语法\" class=\"headerlink\" title=\"不必担心语法\"></a>不必担心语法</h3><p>虽然所有浏览器的最新版本均支持Flexbox目前的语法，那老版本的支持如何呢？因为语法的改变已经半年多了，在书写方面存在一些不一致的地方。为了支持所有浏览器目前最后的两个版本，我们将不得不使用不同供应商前缀，每条规则至少书写4个不同的版本。</p>\n<p>关于这个问题，我的解决方案是只需使用autoprefixer。跟踪最好使用哪个供应商前缀，不应该占用我们的时间和精力，所以我们应该将其设置为自动化。</p>\n<p>使用 autoprefixer，我们可以指定我们想要支持的浏览器版本，然后他就会自动添加相应的供应商前缀。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/* Write this */</div><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/* Compiles to this (with autoprefixer set to support last 2 versions of all browsers) */</div><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: -webkit-box;</div><div class=\"line\">  display: -webkit-flex;</div><div class=\"line\">  display: -ms-flexbox;</div><div class=\"line\">  display: flex;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"简单的开始\"><a href=\"#简单的开始\" class=\"headerlink\" title=\"简单的开始\"></a>简单的开始</h3><p>诚然，学习所有flexbox 相关的知识并不是那么简单。它有12个新属性，其中每个大约有 4个潜在值。当然你可以一点一点的去理解掌握。</p>\n<p><strong>但是你并不需要去了解所有的属性。</strong>因为在很多情况下，我发现自己只需要使用 3 个属性-</p>\n<ul>\n<li>display：将元素设置为内联或者块flexbox容器元素</li>\n<li>justify-content： 控制 flex 容器内项的水平对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)</li>\n<li>align-items: 控制 flex 容器内项的垂直对齐方式 (如果 flex 的默认属性为 row 或 row-reverse)</li>\n</ul>\n<p>使用这些仅适用于 flex 容器的属性，我们可以产生大量不同的布局。如果你想要了解更多相关知识，还有丰富的资源/属性列表/帮助你学习的例子</p>\n<ul>\n<li><a href=\"http://www.w3cplus.com/blog/tags/157.html\">Flexbox中文教程</a></li>\n<li><a href=\"http://codepen.io/enxaneta/full/adLPwv/\">Flexbox Playground</a>：一个在线文档，你可以验证每个属性-值对的作用</li>\n<li><a href=\"https://css-tricks.com/snippets/css/a-guide-to-flexbox/\">Flexbox 完全指南(CSS 技巧)</a>: 所有 flexbox 概述</li>\n<li><a href=\"http://flexboxfroggy.com/\">Flexbox Froggy</a>: 学习 CSS flexbox 的游戏</li>\n<li><a href=\"https://github.com/philipwalton/flexbugs\">Flexbugs</a>: flexbox 问题的列表以及解决他们跨浏览器问题的方法</li>\n<li><a href=\"https://github.com/10up/flexibility\">Flexibility</a>:支持旧版浏览器的一个polyfill</li>\n</ul>\n<h3 id=\"元素居中\"><a href=\"#元素居中\" class=\"headerlink\" title=\"元素居中\"></a>元素居中</h3><p>除了 flexbox 良好的浏览器支持，我们还可以很轻松的实现元素在水平垂直居中问题。</p>\n<p>仅仅需要3个声明，我们就可以实现子元素完全居中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: center; /* horizontal centering */</div><div class=\"line\">  align-items: center; /* vertical centering */</div><div class=\"line\"></div><div class=\"line\">  border: 2px dashed #000;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030902.png\" alt=\"2016030902\"></p>\n<h3 id=\"更容易地操作内联元素\"><a href=\"#更容易地操作内联元素\" class=\"headerlink\" title=\"更容易地操作内联元素\"></a>更容易地操作内联元素</h3><p>关于内联项定位问题就是臭名昭著的额外的4个像素的外边距。虽然存在解决这个问题的方法，如浮动元素，但随时就会出现新的问题。</p>\n<p>使用Flexbox，我们就可以毫不费力地处理内联元素。我们可以实现元素的<strong>两端对齐</strong>对齐：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123; display: flex; &#125;</div><div class=\"line\">.flex-item &#123; width: 20%; &#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030903.png\" alt=\"2016030903\"></p>\n<p>我们可以实现项与项之间的<strong>均匀分布</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: space-around;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030904.png\" alt=\"2016030904\"></p>\n<p>我们甚至可以在不处理:first-child或:last-child的情况下，实现列表项的均匀分布：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  justify-content: space-between;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><img src=\"/resource/2016030905.png\" alt=\"2016030905\"></p>\n<h3 id=\"简化了复杂性\"><a href=\"#简化了复杂性\" class=\"headerlink\" title=\"简化了复杂性\"></a>简化了复杂性</h3><p>究其Flexbox的创建原因，首先可能是因为这个原因，让我们实现在尽可能少的声明中创建复杂的布局。</p>\n<p>在前面的例子中，我仅仅通过设置flex容器样式来实现。然而，我们可以通过设置 flex 项来实现更加精细的样式调节。例如，定价表的通用布局:</p>\n<p><img src=\"/resource/2016030906.png\" alt=\"2016030906\"></p>\n<p>这里有三个 div，中间div的宽度是两边的两倍。为了使用flexbox实现这种布局，我们可以这样书写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.flex-container &#123;</div><div class=\"line\">  display: flex;</div><div class=\"line\">  align-items: center;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.flex-items:not(:nth-child(2)) &#123;</div><div class=\"line\">  flex-grow: 1;</div><div class=\"line\">  height: 300px;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.flex-items:nth-child(2) &#123;</div><div class=\"line\">  flex-grow: 2;</div><div class=\"line\">  height: 350px;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>关于Felxbox，我的意识已经很晚了，但是我仍然相信还有许多人的思想没有改变。您已经使用 flexbox 了吗?如果没有，您是不是已经被信服，要试一试呢?</p>\n<p><a href=\"http://www.w3cplus.com/css3/6-reasons-to-start-using-flexbox.html\">原文链接</a></p>\n"},{"title":"使用Git时，怎么忽略不想上传的文件","date":"2015-08-24T16:00:00.000Z","_content":"\n在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用git add . 将所有文件纳入git库中，那么会出现频繁的改动和push，这样会引起开发上的不便。\n\nGit可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。\n\ngit中提供两种过滤机制，一种是全局过滤机制，即对所有的git都适用；另一种是针对某个项目使用的过滤规则。个人倾向于第二种。\n\n以我的一个项目为例，该项目用.net开发，.config文件、包括生成的bin/Debug, bin/Release文件等，我希望不加入git管理。\n\n在代码目录下建立.gitignore文件：vim .gitignore ,内容如下：\n\n#过滤数据库文件、sln解决方案文件、配置文件  \n*.mdb  \n*.ldb  \n*.sln  \n*.config  \n  \n  \n#过滤文件夹Debug,Release,obj  \nDebug/  \nRelease/  \nobj/  \n然后调用git add. ，执行 git commit即可。\n\n问题：.gitignore只适用于尚未添加到git库的文件。如果已经添加了，则需用git rm移除后再重新commit。\n","source":"_posts/使用Git时，怎么忽略不想上传的文件.md","raw":"---\ntitle: 使用Git时，怎么忽略不想上传的文件\ntags: [git]\ndate: 2015/08/25\n---\n\n在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用git add . 将所有文件纳入git库中，那么会出现频繁的改动和push，这样会引起开发上的不便。\n\nGit可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。\n\ngit中提供两种过滤机制，一种是全局过滤机制，即对所有的git都适用；另一种是针对某个项目使用的过滤规则。个人倾向于第二种。\n\n以我的一个项目为例，该项目用.net开发，.config文件、包括生成的bin/Debug, bin/Release文件等，我希望不加入git管理。\n\n在代码目录下建立.gitignore文件：vim .gitignore ,内容如下：\n\n#过滤数据库文件、sln解决方案文件、配置文件  \n*.mdb  \n*.ldb  \n*.sln  \n*.config  \n  \n  \n#过滤文件夹Debug,Release,obj  \nDebug/  \nRelease/  \nobj/  \n然后调用git add. ，执行 git commit即可。\n\n问题：.gitignore只适用于尚未添加到git库的文件。如果已经添加了，则需用git rm移除后再重新commit。\n","slug":"使用Git时，怎么忽略不想上传的文件","published":1,"updated":"2016-08-17T06:22:19.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkw003f68ddiyr2h1kn","content":"<p>在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用git add . 将所有文件纳入git库中，那么会出现频繁的改动和push，这样会引起开发上的不便。</p>\n<p>Git可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。</p>\n<p>git中提供两种过滤机制，一种是全局过滤机制，即对所有的git都适用；另一种是针对某个项目使用的过滤规则。个人倾向于第二种。</p>\n<p>以我的一个项目为例，该项目用.net开发，.config文件、包括生成的bin/Debug, bin/Release文件等，我希望不加入git管理。</p>\n<p>在代码目录下建立.gitignore文件：vim .gitignore ,内容如下：</p>\n<p>#过滤数据库文件、sln解决方案文件、配置文件<br><em>.mdb  \n</em>.ldb<br><em>.sln  \n</em>.config  </p>\n<p>#过滤文件夹Debug,Release,obj<br>Debug/<br>Release/<br>obj/<br>然后调用git add. ，执行 git commit即可。</p>\n<p>问题：.gitignore只适用于尚未添加到git库的文件。如果已经添加了，则需用git rm移除后再重新commit。</p>\n","excerpt":"","more":"<p>在进行协作开发代码管理的过程中，常常会遇到某些临时文件、配置文件、或者生成文件等，这些文件由于不同的开发端会不一样，如果使用git add . 将所有文件纳入git库中，那么会出现频繁的改动和push，这样会引起开发上的不便。</p>\n<p>Git可以很方便的帮助我们解决这个问题，那就是建立项目文件过滤规则。</p>\n<p>git中提供两种过滤机制，一种是全局过滤机制，即对所有的git都适用；另一种是针对某个项目使用的过滤规则。个人倾向于第二种。</p>\n<p>以我的一个项目为例，该项目用.net开发，.config文件、包括生成的bin/Debug, bin/Release文件等，我希望不加入git管理。</p>\n<p>在代码目录下建立.gitignore文件：vim .gitignore ,内容如下：</p>\n<p>#过滤数据库文件、sln解决方案文件、配置文件<br><em>.mdb  \n</em>.ldb<br><em>.sln  \n</em>.config  </p>\n<p>#过滤文件夹Debug,Release,obj<br>Debug/<br>Release/<br>obj/<br>然后调用git add. ，执行 git commit即可。</p>\n<p>问题：.gitignore只适用于尚未添加到git库的文件。如果已经添加了，则需用git rm移除后再重新commit。</p>\n"},{"title":"使用JSON.Stringify","date":"2015-01-31T16:00:00.000Z","_content":"\n加入有一个对象具有参数\"prop1\", \"prop2\", \"prop3\"。 我们可以通过传递 附加参数 给 JSON.stringify 来选择性将参数生成字符串，像这样：\n\n```\nvar obj = {\n    'prop1': 'value1',\n    'prop2': 'value2',\n    'prop3': 'value3'\n};\n\nvar selectedProperties = ['prop1', 'prop2'];\n\nvar str = JSON.stringify(obj, selectedProperties);\n\n// str\n// {\"prop1\":\"value1\",\"prop2\":\"value2\"}\n```\n\n\"str\" 降至包含选择的参数。\n除了传递数组，我们也可以传递函数。\n\n```\nfunction selectedProperties(key, val) {\n    // the first val will be the entire object, key is empty string\n    if (!key) {\n        return val;\n    }\n\n    if (key === 'prop1' || key === 'prop2') {\n        return val;\n    }\n\n    return;\n}\n```\n\n最后一个参数，可以修改生成字符串的方式。\n\n```\nvar str = JSON.stringify(obj, selectedProperties, '\\t\\t');\n\n/* str output with double tabs in every line.\n{\n        \"prop1\": \"value1\",\n        \"prop2\": \"value2\"\n}\n*/\n```\n\n[转载自github:loverajoel/jstips](https://github.com/loverajoel/jstips/blob/gh-pages/_posts/en/2016-02-09-using-json-stringify.md);\n","source":"_posts/使用JSON.Stringify.md","raw":"---\ntitle: 使用JSON.Stringify\ntags: [javascript,json]\ndate: 2015/02/01\n---\n\n加入有一个对象具有参数\"prop1\", \"prop2\", \"prop3\"。 我们可以通过传递 附加参数 给 JSON.stringify 来选择性将参数生成字符串，像这样：\n\n```\nvar obj = {\n    'prop1': 'value1',\n    'prop2': 'value2',\n    'prop3': 'value3'\n};\n\nvar selectedProperties = ['prop1', 'prop2'];\n\nvar str = JSON.stringify(obj, selectedProperties);\n\n// str\n// {\"prop1\":\"value1\",\"prop2\":\"value2\"}\n```\n\n\"str\" 降至包含选择的参数。\n除了传递数组，我们也可以传递函数。\n\n```\nfunction selectedProperties(key, val) {\n    // the first val will be the entire object, key is empty string\n    if (!key) {\n        return val;\n    }\n\n    if (key === 'prop1' || key === 'prop2') {\n        return val;\n    }\n\n    return;\n}\n```\n\n最后一个参数，可以修改生成字符串的方式。\n\n```\nvar str = JSON.stringify(obj, selectedProperties, '\\t\\t');\n\n/* str output with double tabs in every line.\n{\n        \"prop1\": \"value1\",\n        \"prop2\": \"value2\"\n}\n*/\n```\n\n[转载自github:loverajoel/jstips](https://github.com/loverajoel/jstips/blob/gh-pages/_posts/en/2016-02-09-using-json-stringify.md);\n","slug":"使用JSON.Stringify","published":1,"updated":"2016-08-17T06:22:19.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpkx003i68ddwwwkevd1","content":"<p>加入有一个对象具有参数”prop1”, “prop2”, “prop3”。 我们可以通过传递 附加参数 给 JSON.stringify 来选择性将参数生成字符串，像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var obj = &#123;</div><div class=\"line\">    &apos;prop1&apos;: &apos;value1&apos;,</div><div class=\"line\">    &apos;prop2&apos;: &apos;value2&apos;,</div><div class=\"line\">    &apos;prop3&apos;: &apos;value3&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];</div><div class=\"line\"></div><div class=\"line\">var str = JSON.stringify(obj, selectedProperties);</div><div class=\"line\"></div><div class=\"line\">// str</div><div class=\"line\">// &#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;</div></pre></td></tr></table></figure>\n<p>“str” 降至包含选择的参数。<br>除了传递数组，我们也可以传递函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function selectedProperties(key, val) &#123;</div><div class=\"line\">    // the first val will be the entire object, key is empty string</div><div class=\"line\">    if (!key) &#123;</div><div class=\"line\">        return val;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (key === &apos;prop1&apos; || key === &apos;prop2&apos;) &#123;</div><div class=\"line\">        return val;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个参数，可以修改生成字符串的方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var str = JSON.stringify(obj, selectedProperties, &apos;\\t\\t&apos;);</div><div class=\"line\"></div><div class=\"line\">/* str output with double tabs in every line.</div><div class=\"line\">&#123;</div><div class=\"line\">        &quot;prop1&quot;: &quot;value1&quot;,</div><div class=\"line\">        &quot;prop2&quot;: &quot;value2&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/loverajoel/jstips/blob/gh-pages/_posts/en/2016-02-09-using-json-stringify.md\" target=\"_blank\" rel=\"external\">转载自github:loverajoel/jstips</a>;</p>\n","excerpt":"","more":"<p>加入有一个对象具有参数”prop1”, “prop2”, “prop3”。 我们可以通过传递 附加参数 给 JSON.stringify 来选择性将参数生成字符串，像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var obj = &#123;</div><div class=\"line\">    &apos;prop1&apos;: &apos;value1&apos;,</div><div class=\"line\">    &apos;prop2&apos;: &apos;value2&apos;,</div><div class=\"line\">    &apos;prop3&apos;: &apos;value3&apos;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var selectedProperties = [&apos;prop1&apos;, &apos;prop2&apos;];</div><div class=\"line\"></div><div class=\"line\">var str = JSON.stringify(obj, selectedProperties);</div><div class=\"line\"></div><div class=\"line\">// str</div><div class=\"line\">// &#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;</div></pre></td></tr></table></figure>\n<p>“str” 降至包含选择的参数。<br>除了传递数组，我们也可以传递函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function selectedProperties(key, val) &#123;</div><div class=\"line\">    // the first val will be the entire object, key is empty string</div><div class=\"line\">    if (!key) &#123;</div><div class=\"line\">        return val;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (key === &apos;prop1&apos; || key === &apos;prop2&apos;) &#123;</div><div class=\"line\">        return val;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个参数，可以修改生成字符串的方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var str = JSON.stringify(obj, selectedProperties, &apos;\\t\\t&apos;);</div><div class=\"line\"></div><div class=\"line\">/* str output with double tabs in every line.</div><div class=\"line\">&#123;</div><div class=\"line\">        &quot;prop1&quot;: &quot;value1&quot;,</div><div class=\"line\">        &quot;prop2&quot;: &quot;value2&quot;</div><div class=\"line\">&#125;</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/loverajoel/jstips/blob/gh-pages/_posts/en/2016-02-09-using-json-stringify.md\">转载自github:loverajoel/jstips</a>;</p>\n"},{"title":"使用QUnit进行JavaScript单元测试","date":"2015-01-30T16:00:00.000Z","_content":"\n### 简介\n\nQUnit是一个强大的JavaScript单元测试框架。他可用于jQuery，jQuery UI和jQuery Mobile项目，以及任何使用JavaScript代码编写的项目的测试。\n\n### 运行环境\n\n+ 任何Html和JavaScript编辑器（Visual Studio 2013）\n+ 从QUnit官方下载reference js和css文件\n\n### 加入QUnit到单元测试\n\n添加QUnit.js和QUnit.css到你要测试的HTML页面中。\n\n```\n<script src=\"//code.jquery.com/qunit/qunit-1.22.0.js\"></script>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.22.0.css\">\n```\n\n### 创建需要进行单元测试的JavaScript类\n\n将要进行单元测试的代码放到一个单独的js文件中（Calculations.js）：\n\n```\n// Create Calculation class.\nvar Calculation = function () { };\n\n// Add Addition to method to the Calculation class.\nCalculation.prototype.Add = function (a, b) {\n    return a + b;\n};\n\n// Add Subtraction method to the Calculation class.\nCalculation.prototype.Substraction = function (a, b) {\n    return a - b;\n};\n\n// Add Multiplication method to the Calculation class.\nCalculation.prototype.Multiplication = function (a, b) {\n    return a * b;\n};\n\n// Add Division method to the Calculation class.\nCalculation.prototype.Division = function (a, b) {\n    return a / b;\n};\n```\n\n### 为上面的方法创建一个单元测试用例\n\n下面的代码就是上面JavaScript方法的单元测试用例，我们同样将它放到单独的一个js文件中（UnitTest.js）：\n\n```\n// Instantiate Calculation class.\nvar c = new Calculation();\n// Unit test for addition.\nQUnit.test(\"Addition Test\", function (assert) {   \n    assert.ok(c.Add(2, 3) == \"5\", \"Passed!\");\n});\n\n// Unit test for subtraction.\nQUnit.test(\"Substraction Test\", function (assert) {\n    assert.ok(c.Substraction(3, 2) == \"1\", \"Passed!\");\n});\n\n// Unit test for division.\nQUnit.test(\"Division Test\", function (assert) {\n    assert.ok(c.Division(5, 5) == \"1\", \"Passed!\");\n});\n\n// Unit test for multiplication.\nQUnit.test(\"Multiplication Test\", function (assert) {\n    assert.ok(c.Multiplication(5, 5) == \"25\", \"Passed!\");\n});\n```\n\n###  在HTML代码中引用所有的js和css文件\n\n在HTML代码中分别创建一个id为qunit、qunit-fixture的div标记。\n\n```\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.22.0.css\">\n<script src=\"~/Scripts/Calculations.js\"></script>\n<div id=\"qunit\"></div>\n<div id=\"qunit-fixture\"></div>\n<script src=\"//code.jquery.com/qunit/qunit-1.22.0.js\"></script>\n<script src=\"~/Scripts/UnitTest.js\"></script>\n```\n\n[http://www.codeceo.com/article/qunit-javascript-unit-test.html](http://www.codeceo.com/article/qunit-javascript-unit-test.html)\n","source":"_posts/使用QUnit进行JavaScript单元测试.md","raw":"---\ntitle: 使用QUnit进行JavaScript单元测试\ntags: [javascript,jquery,qunit]\ndate: 2015/01/31\n---\n\n### 简介\n\nQUnit是一个强大的JavaScript单元测试框架。他可用于jQuery，jQuery UI和jQuery Mobile项目，以及任何使用JavaScript代码编写的项目的测试。\n\n### 运行环境\n\n+ 任何Html和JavaScript编辑器（Visual Studio 2013）\n+ 从QUnit官方下载reference js和css文件\n\n### 加入QUnit到单元测试\n\n添加QUnit.js和QUnit.css到你要测试的HTML页面中。\n\n```\n<script src=\"//code.jquery.com/qunit/qunit-1.22.0.js\"></script>\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.22.0.css\">\n```\n\n### 创建需要进行单元测试的JavaScript类\n\n将要进行单元测试的代码放到一个单独的js文件中（Calculations.js）：\n\n```\n// Create Calculation class.\nvar Calculation = function () { };\n\n// Add Addition to method to the Calculation class.\nCalculation.prototype.Add = function (a, b) {\n    return a + b;\n};\n\n// Add Subtraction method to the Calculation class.\nCalculation.prototype.Substraction = function (a, b) {\n    return a - b;\n};\n\n// Add Multiplication method to the Calculation class.\nCalculation.prototype.Multiplication = function (a, b) {\n    return a * b;\n};\n\n// Add Division method to the Calculation class.\nCalculation.prototype.Division = function (a, b) {\n    return a / b;\n};\n```\n\n### 为上面的方法创建一个单元测试用例\n\n下面的代码就是上面JavaScript方法的单元测试用例，我们同样将它放到单独的一个js文件中（UnitTest.js）：\n\n```\n// Instantiate Calculation class.\nvar c = new Calculation();\n// Unit test for addition.\nQUnit.test(\"Addition Test\", function (assert) {   \n    assert.ok(c.Add(2, 3) == \"5\", \"Passed!\");\n});\n\n// Unit test for subtraction.\nQUnit.test(\"Substraction Test\", function (assert) {\n    assert.ok(c.Substraction(3, 2) == \"1\", \"Passed!\");\n});\n\n// Unit test for division.\nQUnit.test(\"Division Test\", function (assert) {\n    assert.ok(c.Division(5, 5) == \"1\", \"Passed!\");\n});\n\n// Unit test for multiplication.\nQUnit.test(\"Multiplication Test\", function (assert) {\n    assert.ok(c.Multiplication(5, 5) == \"25\", \"Passed!\");\n});\n```\n\n###  在HTML代码中引用所有的js和css文件\n\n在HTML代码中分别创建一个id为qunit、qunit-fixture的div标记。\n\n```\n<link rel=\"stylesheet\" href=\"https://code.jquery.com/qunit/qunit-1.22.0.css\">\n<script src=\"~/Scripts/Calculations.js\"></script>\n<div id=\"qunit\"></div>\n<div id=\"qunit-fixture\"></div>\n<script src=\"//code.jquery.com/qunit/qunit-1.22.0.js\"></script>\n<script src=\"~/Scripts/UnitTest.js\"></script>\n```\n\n[http://www.codeceo.com/article/qunit-javascript-unit-test.html](http://www.codeceo.com/article/qunit-javascript-unit-test.html)\n","slug":"使用QUnit进行JavaScript单元测试","published":1,"updated":"2016-08-17T06:22:19.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpl0003k68ddl516eyqo","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>QUnit是一个强大的JavaScript单元测试框架。他可用于jQuery，jQuery UI和jQuery Mobile项目，以及任何使用JavaScript代码编写的项目的测试。</p>\n<h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><ul>\n<li>任何Html和JavaScript编辑器（Visual Studio 2013）</li>\n<li>从QUnit官方下载reference js和css文件</li>\n</ul>\n<h3 id=\"加入QUnit到单元测试\"><a href=\"#加入QUnit到单元测试\" class=\"headerlink\" title=\"加入QUnit到单元测试\"></a>加入QUnit到单元测试</h3><p>添加QUnit.js和QUnit.css到你要测试的HTML页面中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;//code.jquery.com/qunit/qunit-1.22.0.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://code.jquery.com/qunit/qunit-1.22.0.css&quot;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"创建需要进行单元测试的JavaScript类\"><a href=\"#创建需要进行单元测试的JavaScript类\" class=\"headerlink\" title=\"创建需要进行单元测试的JavaScript类\"></a>创建需要进行单元测试的JavaScript类</h3><p>将要进行单元测试的代码放到一个单独的js文件中（Calculations.js）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Create Calculation class.</div><div class=\"line\">var Calculation = function () &#123; &#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Addition to method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Add = function (a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Subtraction method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Substraction = function (a, b) &#123;</div><div class=\"line\">    return a - b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Multiplication method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Multiplication = function (a, b) &#123;</div><div class=\"line\">    return a * b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Division method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Division = function (a, b) &#123;</div><div class=\"line\">    return a / b;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"为上面的方法创建一个单元测试用例\"><a href=\"#为上面的方法创建一个单元测试用例\" class=\"headerlink\" title=\"为上面的方法创建一个单元测试用例\"></a>为上面的方法创建一个单元测试用例</h3><p>下面的代码就是上面JavaScript方法的单元测试用例，我们同样将它放到单独的一个js文件中（UnitTest.js）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Instantiate Calculation class.</div><div class=\"line\">var c = new Calculation();</div><div class=\"line\">// Unit test for addition.</div><div class=\"line\">QUnit.test(&quot;Addition Test&quot;, function (assert) &#123;   </div><div class=\"line\">    assert.ok(c.Add(2, 3) == &quot;5&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for subtraction.</div><div class=\"line\">QUnit.test(&quot;Substraction Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Substraction(3, 2) == &quot;1&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for division.</div><div class=\"line\">QUnit.test(&quot;Division Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Division(5, 5) == &quot;1&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for multiplication.</div><div class=\"line\">QUnit.test(&quot;Multiplication Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Multiplication(5, 5) == &quot;25&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"在HTML代码中引用所有的js和css文件\"><a href=\"#在HTML代码中引用所有的js和css文件\" class=\"headerlink\" title=\"在HTML代码中引用所有的js和css文件\"></a>在HTML代码中引用所有的js和css文件</h3><p>在HTML代码中分别创建一个id为qunit、qunit-fixture的div标记。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://code.jquery.com/qunit/qunit-1.22.0.css&quot;&gt;</div><div class=\"line\">&lt;script src=&quot;~/Scripts/Calculations.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;script src=&quot;//code.jquery.com/qunit/qunit-1.22.0.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;~/Scripts/UnitTest.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.codeceo.com/article/qunit-javascript-unit-test.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/qunit-javascript-unit-test.html</a></p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>QUnit是一个强大的JavaScript单元测试框架。他可用于jQuery，jQuery UI和jQuery Mobile项目，以及任何使用JavaScript代码编写的项目的测试。</p>\n<h3 id=\"运行环境\"><a href=\"#运行环境\" class=\"headerlink\" title=\"运行环境\"></a>运行环境</h3><ul>\n<li>任何Html和JavaScript编辑器（Visual Studio 2013）</li>\n<li>从QUnit官方下载reference js和css文件</li>\n</ul>\n<h3 id=\"加入QUnit到单元测试\"><a href=\"#加入QUnit到单元测试\" class=\"headerlink\" title=\"加入QUnit到单元测试\"></a>加入QUnit到单元测试</h3><p>添加QUnit.js和QUnit.css到你要测试的HTML页面中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;//code.jquery.com/qunit/qunit-1.22.0.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://code.jquery.com/qunit/qunit-1.22.0.css&quot;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"创建需要进行单元测试的JavaScript类\"><a href=\"#创建需要进行单元测试的JavaScript类\" class=\"headerlink\" title=\"创建需要进行单元测试的JavaScript类\"></a>创建需要进行单元测试的JavaScript类</h3><p>将要进行单元测试的代码放到一个单独的js文件中（Calculations.js）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Create Calculation class.</div><div class=\"line\">var Calculation = function () &#123; &#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Addition to method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Add = function (a, b) &#123;</div><div class=\"line\">    return a + b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Subtraction method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Substraction = function (a, b) &#123;</div><div class=\"line\">    return a - b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Multiplication method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Multiplication = function (a, b) &#123;</div><div class=\"line\">    return a * b;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// Add Division method to the Calculation class.</div><div class=\"line\">Calculation.prototype.Division = function (a, b) &#123;</div><div class=\"line\">    return a / b;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"为上面的方法创建一个单元测试用例\"><a href=\"#为上面的方法创建一个单元测试用例\" class=\"headerlink\" title=\"为上面的方法创建一个单元测试用例\"></a>为上面的方法创建一个单元测试用例</h3><p>下面的代码就是上面JavaScript方法的单元测试用例，我们同样将它放到单独的一个js文件中（UnitTest.js）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Instantiate Calculation class.</div><div class=\"line\">var c = new Calculation();</div><div class=\"line\">// Unit test for addition.</div><div class=\"line\">QUnit.test(&quot;Addition Test&quot;, function (assert) &#123;   </div><div class=\"line\">    assert.ok(c.Add(2, 3) == &quot;5&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for subtraction.</div><div class=\"line\">QUnit.test(&quot;Substraction Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Substraction(3, 2) == &quot;1&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for division.</div><div class=\"line\">QUnit.test(&quot;Division Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Division(5, 5) == &quot;1&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">// Unit test for multiplication.</div><div class=\"line\">QUnit.test(&quot;Multiplication Test&quot;, function (assert) &#123;</div><div class=\"line\">    assert.ok(c.Multiplication(5, 5) == &quot;25&quot;, &quot;Passed!&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"在HTML代码中引用所有的js和css文件\"><a href=\"#在HTML代码中引用所有的js和css文件\" class=\"headerlink\" title=\"在HTML代码中引用所有的js和css文件\"></a>在HTML代码中引用所有的js和css文件</h3><p>在HTML代码中分别创建一个id为qunit、qunit-fixture的div标记。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://code.jquery.com/qunit/qunit-1.22.0.css&quot;&gt;</div><div class=\"line\">&lt;script src=&quot;~/Scripts/Calculations.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;div id=&quot;qunit&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;qunit-fixture&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;script src=&quot;//code.jquery.com/qunit/qunit-1.22.0.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;~/Scripts/UnitTest.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://www.codeceo.com/article/qunit-javascript-unit-test.html\">http://www.codeceo.com/article/qunit-javascript-unit-test.html</a></p>\n"},{"title":"使用git pull文件时和本地文件冲突怎么办？","date":"2016-06-06T16:00:00.000Z","_content":"\n同事在使用`git pull`代码时，经常会碰到有冲突的情况，提示如下信息：\n\n>error: Your local changes to 'c/environ.c' would be overwritten by merge.  Aborting.\n>Please, commit your changes or stash them before you can merge.\n\n这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。\n\n处理的方式非常简单，主要是使用`git stash`命令进行处理，分成以下几个步骤进行处理。\n\n**1、先将本地修改存储起来**\n\n```\n$ git stash\n```\n\n这样本地的所有修改就都被暂时存储起来 。是用`git stash list`可以看到保存的信息：\n\n>stash@{0}:WIP on master: a80c24d\n\n其中stash@{0}就是刚才保存的标记。\n\n**2、pull内容**\n\n暂存了本地修改之后，就可以pull了。\n\n```\n$ git pull\n```\n\n**3、还原暂存的内容**\n\n```\n$ git stash pop stash@{0}\n```\n\n系统提示如下类似的信息：\n\n>Auto-merging c/environ.c\n>CONFLICT (content): Merge conflict in c/environ.c\n\n意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。\n\n**4、解决文件中冲突的的部分**\n\n打开冲突的文件，其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。\n解决完成之后，就可以正常的提交了。\n","source":"_posts/使用git pull文件时和本地文件冲突怎么办？.md","raw":"---\ntitle: 使用git pull文件时和本地文件冲突怎么办？\ntags: [git]\ndate: 2016/06/07\n---\n\n同事在使用`git pull`代码时，经常会碰到有冲突的情况，提示如下信息：\n\n>error: Your local changes to 'c/environ.c' would be overwritten by merge.  Aborting.\n>Please, commit your changes or stash them before you can merge.\n\n这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。\n\n处理的方式非常简单，主要是使用`git stash`命令进行处理，分成以下几个步骤进行处理。\n\n**1、先将本地修改存储起来**\n\n```\n$ git stash\n```\n\n这样本地的所有修改就都被暂时存储起来 。是用`git stash list`可以看到保存的信息：\n\n>stash@{0}:WIP on master: a80c24d\n\n其中stash@{0}就是刚才保存的标记。\n\n**2、pull内容**\n\n暂存了本地修改之后，就可以pull了。\n\n```\n$ git pull\n```\n\n**3、还原暂存的内容**\n\n```\n$ git stash pop stash@{0}\n```\n\n系统提示如下类似的信息：\n\n>Auto-merging c/environ.c\n>CONFLICT (content): Merge conflict in c/environ.c\n\n意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。\n\n**4、解决文件中冲突的的部分**\n\n打开冲突的文件，其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。\n解决完成之后，就可以正常的提交了。\n","slug":"使用git pull文件时和本地文件冲突怎么办？","published":1,"updated":"2016-08-17T06:22:19.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpl1003m68ddu56t3j3u","content":"<p>同事在使用<code>git pull</code>代码时，经常会碰到有冲突的情况，提示如下信息：</p>\n<blockquote>\n<p>error: Your local changes to ‘c/environ.c’ would be overwritten by merge.  Aborting.<br>Please, commit your changes or stash them before you can merge.</p>\n</blockquote>\n<p>这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。</p>\n<p>处理的方式非常简单，主要是使用<code>git stash</code>命令进行处理，分成以下几个步骤进行处理。</p>\n<p><strong>1、先将本地修改存储起来</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git stash</div></pre></td></tr></table></figure>\n<p>这样本地的所有修改就都被暂时存储起来 。是用<code>git stash list</code>可以看到保存的信息：</p>\n<blockquote>\n<p>stash@{0}:WIP on master: a80c24d</p>\n</blockquote>\n<p>其中stash@{0}就是刚才保存的标记。</p>\n<p><strong>2、pull内容</strong></p>\n<p>暂存了本地修改之后，就可以pull了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git pull</div></pre></td></tr></table></figure>\n<p><strong>3、还原暂存的内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git stash pop stash@&#123;0&#125;</div></pre></td></tr></table></figure>\n<p>系统提示如下类似的信息：</p>\n<blockquote>\n<p>Auto-merging c/environ.c<br>CONFLICT (content): Merge conflict in c/environ.c</p>\n</blockquote>\n<p>意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。</p>\n<p><strong>4、解决文件中冲突的的部分</strong></p>\n<p>打开冲突的文件，其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。<br>解决完成之后，就可以正常的提交了。</p>\n","excerpt":"","more":"<p>同事在使用<code>git pull</code>代码时，经常会碰到有冲突的情况，提示如下信息：</p>\n<blockquote>\n<p>error: Your local changes to ‘c/environ.c’ would be overwritten by merge.  Aborting.<br>Please, commit your changes or stash them before you can merge.</p>\n</blockquote>\n<p>这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。</p>\n<p>处理的方式非常简单，主要是使用<code>git stash</code>命令进行处理，分成以下几个步骤进行处理。</p>\n<p><strong>1、先将本地修改存储起来</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git stash</div></pre></td></tr></table></figure>\n<p>这样本地的所有修改就都被暂时存储起来 。是用<code>git stash list</code>可以看到保存的信息：</p>\n<blockquote>\n<p>stash@{0}:WIP on master: a80c24d</p>\n</blockquote>\n<p>其中stash@{0}就是刚才保存的标记。</p>\n<p><strong>2、pull内容</strong></p>\n<p>暂存了本地修改之后，就可以pull了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git pull</div></pre></td></tr></table></figure>\n<p><strong>3、还原暂存的内容</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git stash pop stash@&#123;0&#125;</div></pre></td></tr></table></figure>\n<p>系统提示如下类似的信息：</p>\n<blockquote>\n<p>Auto-merging c/environ.c<br>CONFLICT (content): Merge conflict in c/environ.c</p>\n</blockquote>\n<p>意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。</p>\n<p><strong>4、解决文件中冲突的的部分</strong></p>\n<p>打开冲突的文件，其中Updated upstream 和=====之间的内容就是pull下来的内容，====和stashed changes之间的内容就是本地修改的内容。碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。<br>解决完成之后，就可以正常的提交了。</p>\n"},{"title":"使用ajax和history.pushState无刷新改变页面URL","date":"2015-02-03T16:00:00.000Z","_content":"\n如果你使用chrome或者firefox等浏览器访问本博客、github.com、plus.google.com等网站时，细心的你会发现页面之间的点击是通过ajax异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器前进和后退。\n\n是什么有这么强大的功能呢？\n\n### 表现\n\nHTML5里引用了新的API，history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的。\n\n### 与传统的AJAX的区别\n\n传统的ajax有如下的问题：\n\n1、可以无刷新改变页面内容，但无法改变页面URL\n\n2、为了更好的可访问性，内容发生改变后，通常改变URL的hash\n\n3、hash的方式不能很好的处理浏览器的前进、后退等问题\n\n4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变\n\n5、但这种方式对搜索引擎很不友好\n\n6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。\n\n为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState\n\n可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。\n\npushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。\n\n### 如何使用\n\n```\nvar state = {\n    title: title,\n    url: options.url,\n    otherkey: othervalue\n};\nwindow.history.pushState(state, document.title, url);\n```\n\nstate对象除了要title和url之外，你也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。\n\nreplaceState和pushState是相似的，这里就不多介绍了。\n\n### 如何响应浏览器的前进、后退操作\n\nwindow对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。\n\n```\nwindow.addEventListener('popstate', function(e){\n  if (history.state){\n    var state = e.state;\n    //do something(state.url, state.title);\n  }\n}, false);\n```\n\n这样就可以结合ajax和pushState完美的进行无刷新浏览了。\n\n### 一些限制\n\n1、传递的URL必须是同域下的，无法跨域\n\n2、state对象虽然可以存储很多自定义的属性，但对于不可序列化的对象则不能存储，如：DOM对象。\n\n### 对应后端的一些处理\n\n这种模式下除了当前使用ajax可以无刷新浏览外，还要保证直接请求改变的URL后也可以正常浏览，所以后端要对这些处理下。\n\n1、对使用pushState的ajax发送一个特殊的头，如： setRequestHeader('PJAX', 'true')。\n\n2、后端获取到有PJAX=true的header时，将页面中通用的部分都不输出。比如：PHP可以通过下面的判断\n\n```\nfunction is_pjax(){\n    return array_key_exists('HTTP_X_PJAX', $_SERVER) && $_SERVER['HTTP_X_PJAX'] === 'true';\n}\n```\n\n虽然接口上只有pushState、replaceState、onpopstate，但在使用的时候需要做很多的处理。\n\n针对这个已经写好了一个基于jquery的插件，接下来的文章会详细介绍如何使用pjax(ajax+pushState)进行无刷新改变URL浏览。\n\n@update - 2012.03.06\n\n已经将ajax+history.pushState封装成pjax, 项目地址： [https://github.com/welefen/pjax](https://github.com/welefen/pjax)， 目前支持jquery, qwrap, kissy 3个版本\n\n文章源：[http://www.welefen.com/use-ajax-and-pushstate.html](http://www.welefen.com/use-ajax-and-pushstate.html)\n","source":"_posts/使用ajax和history.pushState无刷新改变页面URL.md","raw":"---\ntitle: 使用ajax和history.pushState无刷新改变页面URL\ntags: [javascript,ajax]\ndate: 2015/02/04\n---\n\n如果你使用chrome或者firefox等浏览器访问本博客、github.com、plus.google.com等网站时，细心的你会发现页面之间的点击是通过ajax异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器前进和后退。\n\n是什么有这么强大的功能呢？\n\n### 表现\n\nHTML5里引用了新的API，history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的。\n\n### 与传统的AJAX的区别\n\n传统的ajax有如下的问题：\n\n1、可以无刷新改变页面内容，但无法改变页面URL\n\n2、为了更好的可访问性，内容发生改变后，通常改变URL的hash\n\n3、hash的方式不能很好的处理浏览器的前进、后退等问题\n\n4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变\n\n5、但这种方式对搜索引擎很不友好\n\n6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。\n\n为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState\n\n可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。\n\npushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。\n\n### 如何使用\n\n```\nvar state = {\n    title: title,\n    url: options.url,\n    otherkey: othervalue\n};\nwindow.history.pushState(state, document.title, url);\n```\n\nstate对象除了要title和url之外，你也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。\n\nreplaceState和pushState是相似的，这里就不多介绍了。\n\n### 如何响应浏览器的前进、后退操作\n\nwindow对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。\n\n```\nwindow.addEventListener('popstate', function(e){\n  if (history.state){\n    var state = e.state;\n    //do something(state.url, state.title);\n  }\n}, false);\n```\n\n这样就可以结合ajax和pushState完美的进行无刷新浏览了。\n\n### 一些限制\n\n1、传递的URL必须是同域下的，无法跨域\n\n2、state对象虽然可以存储很多自定义的属性，但对于不可序列化的对象则不能存储，如：DOM对象。\n\n### 对应后端的一些处理\n\n这种模式下除了当前使用ajax可以无刷新浏览外，还要保证直接请求改变的URL后也可以正常浏览，所以后端要对这些处理下。\n\n1、对使用pushState的ajax发送一个特殊的头，如： setRequestHeader('PJAX', 'true')。\n\n2、后端获取到有PJAX=true的header时，将页面中通用的部分都不输出。比如：PHP可以通过下面的判断\n\n```\nfunction is_pjax(){\n    return array_key_exists('HTTP_X_PJAX', $_SERVER) && $_SERVER['HTTP_X_PJAX'] === 'true';\n}\n```\n\n虽然接口上只有pushState、replaceState、onpopstate，但在使用的时候需要做很多的处理。\n\n针对这个已经写好了一个基于jquery的插件，接下来的文章会详细介绍如何使用pjax(ajax+pushState)进行无刷新改变URL浏览。\n\n@update - 2012.03.06\n\n已经将ajax+history.pushState封装成pjax, 项目地址： [https://github.com/welefen/pjax](https://github.com/welefen/pjax)， 目前支持jquery, qwrap, kissy 3个版本\n\n文章源：[http://www.welefen.com/use-ajax-and-pushstate.html](http://www.welefen.com/use-ajax-and-pushstate.html)\n","slug":"使用ajax和history.pushState无刷新改变页面URL","published":1,"updated":"2016-08-17T06:22:19.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpl6003p68dds0qkmeez","content":"<p>如果你使用chrome或者firefox等浏览器访问本博客、github.com、plus.google.com等网站时，细心的你会发现页面之间的点击是通过ajax异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器前进和后退。</p>\n<p>是什么有这么强大的功能呢？</p>\n<h3 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h3><p>HTML5里引用了新的API，history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的。</p>\n<h3 id=\"与传统的AJAX的区别\"><a href=\"#与传统的AJAX的区别\" class=\"headerlink\" title=\"与传统的AJAX的区别\"></a>与传统的AJAX的区别</h3><p>传统的ajax有如下的问题：</p>\n<p>1、可以无刷新改变页面内容，但无法改变页面URL</p>\n<p>2、为了更好的可访问性，内容发生改变后，通常改变URL的hash</p>\n<p>3、hash的方式不能很好的处理浏览器的前进、后退等问题</p>\n<p>4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变</p>\n<p>5、但这种方式对搜索引擎很不友好</p>\n<p>6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。</p>\n<p>为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState</p>\n<p>可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。</p>\n<p>pushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。</p>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var state = &#123;</div><div class=\"line\">    title: title,</div><div class=\"line\">    url: options.url,</div><div class=\"line\">    otherkey: othervalue</div><div class=\"line\">&#125;;</div><div class=\"line\">window.history.pushState(state, document.title, url);</div></pre></td></tr></table></figure>\n<p>state对象除了要title和url之外，你也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。</p>\n<p>replaceState和pushState是相似的，这里就不多介绍了。</p>\n<h3 id=\"如何响应浏览器的前进、后退操作\"><a href=\"#如何响应浏览器的前进、后退操作\" class=\"headerlink\" title=\"如何响应浏览器的前进、后退操作\"></a>如何响应浏览器的前进、后退操作</h3><p>window对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">window.addEventListener(&apos;popstate&apos;, function(e)&#123;</div><div class=\"line\">  if (history.state)&#123;</div><div class=\"line\">    var state = e.state;</div><div class=\"line\">    //do something(state.url, state.title);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, false);</div></pre></td></tr></table></figure>\n<p>这样就可以结合ajax和pushState完美的进行无刷新浏览了。</p>\n<h3 id=\"一些限制\"><a href=\"#一些限制\" class=\"headerlink\" title=\"一些限制\"></a>一些限制</h3><p>1、传递的URL必须是同域下的，无法跨域</p>\n<p>2、state对象虽然可以存储很多自定义的属性，但对于不可序列化的对象则不能存储，如：DOM对象。</p>\n<h3 id=\"对应后端的一些处理\"><a href=\"#对应后端的一些处理\" class=\"headerlink\" title=\"对应后端的一些处理\"></a>对应后端的一些处理</h3><p>这种模式下除了当前使用ajax可以无刷新浏览外，还要保证直接请求改变的URL后也可以正常浏览，所以后端要对这些处理下。</p>\n<p>1、对使用pushState的ajax发送一个特殊的头，如： setRequestHeader(‘PJAX’, ‘true’)。</p>\n<p>2、后端获取到有PJAX=true的header时，将页面中通用的部分都不输出。比如：PHP可以通过下面的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function is_pjax()&#123;</div><div class=\"line\">    return array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER) &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然接口上只有pushState、replaceState、onpopstate，但在使用的时候需要做很多的处理。</p>\n<p>针对这个已经写好了一个基于jquery的插件，接下来的文章会详细介绍如何使用pjax(ajax+pushState)进行无刷新改变URL浏览。</p>\n<p>@update - 2012.03.06</p>\n<p>已经将ajax+history.pushState封装成pjax, 项目地址： <a href=\"https://github.com/welefen/pjax\" target=\"_blank\" rel=\"external\">https://github.com/welefen/pjax</a>， 目前支持jquery, qwrap, kissy 3个版本</p>\n<p>文章源：<a href=\"http://www.welefen.com/use-ajax-and-pushstate.html\" target=\"_blank\" rel=\"external\">http://www.welefen.com/use-ajax-and-pushstate.html</a></p>\n","excerpt":"","more":"<p>如果你使用chrome或者firefox等浏览器访问本博客、github.com、plus.google.com等网站时，细心的你会发现页面之间的点击是通过ajax异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器前进和后退。</p>\n<p>是什么有这么强大的功能呢？</p>\n<h3 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h3><p>HTML5里引用了新的API，history.pushState和history.replaceState，就是通过这个接口做到无刷新改变页面URL的。</p>\n<h3 id=\"与传统的AJAX的区别\"><a href=\"#与传统的AJAX的区别\" class=\"headerlink\" title=\"与传统的AJAX的区别\"></a>与传统的AJAX的区别</h3><p>传统的ajax有如下的问题：</p>\n<p>1、可以无刷新改变页面内容，但无法改变页面URL</p>\n<p>2、为了更好的可访问性，内容发生改变后，通常改变URL的hash</p>\n<p>3、hash的方式不能很好的处理浏览器的前进、后退等问题</p>\n<p>4、进而浏览器引入了onhashchange的接口，不支持的浏览器只能定时去判断hash是否改变</p>\n<p>5、但这种方式对搜索引擎很不友好</p>\n<p>6、twitter和google约定了使用#!xxx（即hash第一个字符为!），搜索引擎进行支持。</p>\n<p>为了解决传统ajax带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState</p>\n<p>可以通过pushState和replaceState接口操作浏览器历史，并且改变当前页面的URL。</p>\n<p>pushState是将指定的URL添加到浏览器历史里，replaceState是将指定的URL替换当前的URL。</p>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var state = &#123;</div><div class=\"line\">    title: title,</div><div class=\"line\">    url: options.url,</div><div class=\"line\">    otherkey: othervalue</div><div class=\"line\">&#125;;</div><div class=\"line\">window.history.pushState(state, document.title, url);</div></pre></td></tr></table></figure>\n<p>state对象除了要title和url之外，你也可以添加其他的数据，比如：还想将一些发送ajax的配置给保存起来。</p>\n<p>replaceState和pushState是相似的，这里就不多介绍了。</p>\n<h3 id=\"如何响应浏览器的前进、后退操作\"><a href=\"#如何响应浏览器的前进、后退操作\" class=\"headerlink\" title=\"如何响应浏览器的前进、后退操作\"></a>如何响应浏览器的前进、后退操作</h3><p>window对象上提供了onpopstate事件，上面传递的state对象会成为event的子对象，这样就可以拿到存储的title和URL了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">window.addEventListener(&apos;popstate&apos;, function(e)&#123;</div><div class=\"line\">  if (history.state)&#123;</div><div class=\"line\">    var state = e.state;</div><div class=\"line\">    //do something(state.url, state.title);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;, false);</div></pre></td></tr></table></figure>\n<p>这样就可以结合ajax和pushState完美的进行无刷新浏览了。</p>\n<h3 id=\"一些限制\"><a href=\"#一些限制\" class=\"headerlink\" title=\"一些限制\"></a>一些限制</h3><p>1、传递的URL必须是同域下的，无法跨域</p>\n<p>2、state对象虽然可以存储很多自定义的属性，但对于不可序列化的对象则不能存储，如：DOM对象。</p>\n<h3 id=\"对应后端的一些处理\"><a href=\"#对应后端的一些处理\" class=\"headerlink\" title=\"对应后端的一些处理\"></a>对应后端的一些处理</h3><p>这种模式下除了当前使用ajax可以无刷新浏览外，还要保证直接请求改变的URL后也可以正常浏览，所以后端要对这些处理下。</p>\n<p>1、对使用pushState的ajax发送一个特殊的头，如： setRequestHeader(‘PJAX’, ‘true’)。</p>\n<p>2、后端获取到有PJAX=true的header时，将页面中通用的部分都不输出。比如：PHP可以通过下面的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function is_pjax()&#123;</div><div class=\"line\">    return array_key_exists(&apos;HTTP_X_PJAX&apos;, $_SERVER) &amp;&amp; $_SERVER[&apos;HTTP_X_PJAX&apos;] === &apos;true&apos;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然接口上只有pushState、replaceState、onpopstate，但在使用的时候需要做很多的处理。</p>\n<p>针对这个已经写好了一个基于jquery的插件，接下来的文章会详细介绍如何使用pjax(ajax+pushState)进行无刷新改变URL浏览。</p>\n<p>@update - 2012.03.06</p>\n<p>已经将ajax+history.pushState封装成pjax, 项目地址： <a href=\"https://github.com/welefen/pjax\">https://github.com/welefen/pjax</a>， 目前支持jquery, qwrap, kissy 3个版本</p>\n<p>文章源：<a href=\"http://www.welefen.com/use-ajax-and-pushstate.html\">http://www.welefen.com/use-ajax-and-pushstate.html</a></p>\n"},{"title":"使用nginx搭建https服务器","date":"2016-06-13T16:00:00.000Z","_content":"\n最近在研究nginx，整好遇到一个需求就是希望服务器与客户端之间传输内容是加密的，防止中间监听泄露信息，但是去证书服务商那边申请证书又不合算，因为访问服务器的都是内部人士，所以自己给自己颁发证书，忽略掉浏览器的不信任警报即可。下面是颁发证书和配置过程。\n\n首先确保机器上安装了openssl和openssl-devel\n\n```bash\n#yum install openssl\n#yum install openssl-devel\n```\n\n然后就是自己颁发证书给自己\n\n```bash\n#cd /usr/local/nginx/conf\n#openssl genrsa -des3 -out server.key 1024\n#openssl req -new -key server.key -out server.csr\n#openssl rsa -in server.key -out server_nopwd.key\n#openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt\n```\n\n至此证书已经生成完毕，下面就是配置nginx\n\n```\nserver {\n    listen 443;\n    ssl on;\n    ssl_certificate  /usr/local/nginx/conf/server.crt;\n    ssl_certificate_key  /usr/local/nginx/conf/server_nopwd.key;\n}\n```\n\n然后重启nginx即可。\n\nps： 如果出现\n\n```\n[emerg] 10464#0: unknown directive \"ssl\" in /usr/local/nginx-0.6.32/conf/nginx.conf:74\n```\n\n则说明没有将ssl模块编译进nginx，在configure的时候加上“--with-http_ssl_module”即可^^\n\n至此已经完成了https服务器搭建，但如何让浏览器信任自己颁发的证书呢？\n\n今天终于研究捣鼓出来了，只要将之前生成的server.crt文件导入到系统的证书管理器就行了，具体方法：\n\n控制面板 -> Internet选项 -> 内容 -> 发行者 -> 受信任的根证书颁发机构 -> 导入 -》选择server.crt","source":"_posts/使用nginx搭建https服务器.md","raw":"---\ntitle: 使用nginx搭建https服务器\ntags: [linux,ngnix,ssl]\ndate: 2016/06/14\n---\n\n最近在研究nginx，整好遇到一个需求就是希望服务器与客户端之间传输内容是加密的，防止中间监听泄露信息，但是去证书服务商那边申请证书又不合算，因为访问服务器的都是内部人士，所以自己给自己颁发证书，忽略掉浏览器的不信任警报即可。下面是颁发证书和配置过程。\n\n首先确保机器上安装了openssl和openssl-devel\n\n```bash\n#yum install openssl\n#yum install openssl-devel\n```\n\n然后就是自己颁发证书给自己\n\n```bash\n#cd /usr/local/nginx/conf\n#openssl genrsa -des3 -out server.key 1024\n#openssl req -new -key server.key -out server.csr\n#openssl rsa -in server.key -out server_nopwd.key\n#openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt\n```\n\n至此证书已经生成完毕，下面就是配置nginx\n\n```\nserver {\n    listen 443;\n    ssl on;\n    ssl_certificate  /usr/local/nginx/conf/server.crt;\n    ssl_certificate_key  /usr/local/nginx/conf/server_nopwd.key;\n}\n```\n\n然后重启nginx即可。\n\nps： 如果出现\n\n```\n[emerg] 10464#0: unknown directive \"ssl\" in /usr/local/nginx-0.6.32/conf/nginx.conf:74\n```\n\n则说明没有将ssl模块编译进nginx，在configure的时候加上“--with-http_ssl_module”即可^^\n\n至此已经完成了https服务器搭建，但如何让浏览器信任自己颁发的证书呢？\n\n今天终于研究捣鼓出来了，只要将之前生成的server.crt文件导入到系统的证书管理器就行了，具体方法：\n\n控制面板 -> Internet选项 -> 内容 -> 发行者 -> 受信任的根证书颁发机构 -> 导入 -》选择server.crt","slug":"使用nginx搭建https服务器","published":1,"updated":"2016-08-17T06:22:19.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpl7003r68ddksf2usmh","content":"<p>最近在研究nginx，整好遇到一个需求就是希望服务器与客户端之间传输内容是加密的，防止中间监听泄露信息，但是去证书服务商那边申请证书又不合算，因为访问服务器的都是内部人士，所以自己给自己颁发证书，忽略掉浏览器的不信任警报即可。下面是颁发证书和配置过程。</p>\n<p>首先确保机器上安装了openssl和openssl-devel</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#yum install openssl</span></div><div class=\"line\"><span class=\"comment\">#yum install openssl-devel</span></div></pre></td></tr></table></figure>\n<p>然后就是自己颁发证书给自己</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#cd /usr/local/nginx/conf</span></div><div class=\"line\"><span class=\"comment\">#openssl genrsa -des3 -out server.key 1024</span></div><div class=\"line\"><span class=\"comment\">#openssl req -new -key server.key -out server.csr</span></div><div class=\"line\"><span class=\"comment\">#openssl rsa -in server.key -out server_nopwd.key</span></div><div class=\"line\"><span class=\"comment\">#openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt</span></div></pre></td></tr></table></figure>\n<p>至此证书已经生成完毕，下面就是配置nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 443;</div><div class=\"line\">    ssl on;</div><div class=\"line\">    ssl_certificate  /usr/local/nginx/conf/server.crt;</div><div class=\"line\">    ssl_certificate_key  /usr/local/nginx/conf/server_nopwd.key;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后重启nginx即可。</p>\n<p>ps： 如果出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[emerg] 10464#0: unknown directive &quot;ssl&quot; in /usr/local/nginx-0.6.32/conf/nginx.conf:74</div></pre></td></tr></table></figure>\n<p>则说明没有将ssl模块编译进nginx，在configure的时候加上“–with-http_ssl_module”即可^^</p>\n<p>至此已经完成了https服务器搭建，但如何让浏览器信任自己颁发的证书呢？</p>\n<p>今天终于研究捣鼓出来了，只要将之前生成的server.crt文件导入到系统的证书管理器就行了，具体方法：</p>\n<p>控制面板 -&gt; Internet选项 -&gt; 内容 -&gt; 发行者 -&gt; 受信任的根证书颁发机构 -&gt; 导入 -》选择server.crt</p>\n","excerpt":"","more":"<p>最近在研究nginx，整好遇到一个需求就是希望服务器与客户端之间传输内容是加密的，防止中间监听泄露信息，但是去证书服务商那边申请证书又不合算，因为访问服务器的都是内部人士，所以自己给自己颁发证书，忽略掉浏览器的不信任警报即可。下面是颁发证书和配置过程。</p>\n<p>首先确保机器上安装了openssl和openssl-devel</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#yum install openssl</span></div><div class=\"line\"><span class=\"comment\">#yum install openssl-devel</span></div></pre></td></tr></table></figure>\n<p>然后就是自己颁发证书给自己</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#cd /usr/local/nginx/conf</span></div><div class=\"line\"><span class=\"comment\">#openssl genrsa -des3 -out server.key 1024</span></div><div class=\"line\"><span class=\"comment\">#openssl req -new -key server.key -out server.csr</span></div><div class=\"line\"><span class=\"comment\">#openssl rsa -in server.key -out server_nopwd.key</span></div><div class=\"line\"><span class=\"comment\">#openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt</span></div></pre></td></tr></table></figure>\n<p>至此证书已经生成完毕，下面就是配置nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 443;</div><div class=\"line\">    ssl on;</div><div class=\"line\">    ssl_certificate  /usr/local/nginx/conf/server.crt;</div><div class=\"line\">    ssl_certificate_key  /usr/local/nginx/conf/server_nopwd.key;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后重启nginx即可。</p>\n<p>ps： 如果出现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[emerg] 10464#0: unknown directive &quot;ssl&quot; in /usr/local/nginx-0.6.32/conf/nginx.conf:74</div></pre></td></tr></table></figure>\n<p>则说明没有将ssl模块编译进nginx，在configure的时候加上“–with-http_ssl_module”即可^^</p>\n<p>至此已经完成了https服务器搭建，但如何让浏览器信任自己颁发的证书呢？</p>\n<p>今天终于研究捣鼓出来了，只要将之前生成的server.crt文件导入到系统的证书管理器就行了，具体方法：</p>\n<p>控制面板 -&gt; Internet选项 -&gt; 内容 -&gt; 发行者 -&gt; 受信任的根证书颁发机构 -&gt; 导入 -》选择server.crt</p>\n"},{"title":"俞敏洪：我和马云就差了8个字","date":"2015-12-24T16:00:00.000Z","_content":"\n\n\n马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。\n\n但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。\n\n有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。\n\n阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。\n\n请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。\n\n人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！\n\n有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。\n\n为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？\n\n我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。\n\n因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。\n\n人生就像心电图，一帆风顺，你就挂了！\n\n心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。\n\n有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。\n\n人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。\n\n人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。\n\n我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。\n\n刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。\n\n有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。\n\n随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。\n\n世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？\n","source":"_posts/俞敏洪：我和马云就差了8个字.md","raw":"---\ntitle: 俞敏洪：我和马云就差了8个字\ntags: [其它]\ndate: 2015/12/25\n---\n\n\n\n马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。\n\n但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。\n\n有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。\n\n阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。\n\n请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。\n\n人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！\n\n有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。\n\n为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？\n\n我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。\n\n因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。\n\n人生就像心电图，一帆风顺，你就挂了！\n\n心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。\n\n有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。\n\n人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。\n\n人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。\n\n我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。\n\n刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。\n\n有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。\n\n随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。\n\n世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？\n","slug":"俞敏洪：我和马云就差了8个字","published":1,"updated":"2016-08-17T06:22:19.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cplb003u68ddw06c9zyo","content":"<p>马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。</p>\n<p>但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。</p>\n<p>有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。</p>\n<p>阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。</p>\n<p>请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。</p>\n<p>人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！</p>\n<p>有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。</p>\n<p>为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？</p>\n<p>我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。</p>\n<p>因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。</p>\n<p>人生就像心电图，一帆风顺，你就挂了！</p>\n<p>心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。</p>\n<p>有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。</p>\n<p>人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。</p>\n<p>人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。</p>\n<p>我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。</p>\n<p>刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。</p>\n<p>有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。</p>\n<p>随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。</p>\n<p>世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？</p>\n","excerpt":"","more":"<p>马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。</p>\n<p>但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。</p>\n<p>有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。</p>\n<p>阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。</p>\n<p>请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。</p>\n<p>人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！</p>\n<p>有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。</p>\n<p>为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？</p>\n<p>我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。</p>\n<p>因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。</p>\n<p>人生就像心电图，一帆风顺，你就挂了！</p>\n<p>心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。</p>\n<p>有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。</p>\n<p>人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。</p>\n<p>人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。</p>\n<p>我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。</p>\n<p>刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。</p>\n<p>有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。</p>\n<p>随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。</p>\n<p>世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？</p>\n"},{"title":"修改ubuntu DNS的步骤","date":"2016-05-31T16:00:00.000Z","_content":"\n有时候连接上VPN服务器后,还是打不开某些网站，这时候需要对DNS进行更改，一般是修改成为谷歌提供的免费DNS:8.8.8.8 8.8.4.4，在windows下更改比较简单，今天教大家如何修改ubuntu的DNS域名解析服务器。\n\n### 修改DNS步骤\n\n1. 要更改ubuntu DNS必须编辑文件 - “/etc/resolv.conf”,打开“终端应用程序”-“附件” - “终端”,在终端里输入下面的命令:\n\n```\nsudo nano /etc/resolv.conf\n```\n\n如果不是管理员,会要求输入密码。\n\n如果不是root用户，需要输入密码确认身份\n\n1. 打开文档后，找到现有的DNS记录，使用“#”注释掉，然后添加新的DNS记录：\n\n按照该格式\n```\nnameserver x.x.x.x\n```\n\n使用谷歌的DNS 8.8.8.8 8.8.4.4\n\n```\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n```\n\n1. 有一些文件会自动修改DNS服务器，我们把这些文件进行锁定。使用如下的代码进行锁定操作：\n\n```\nsudo chattr +i /etc/resolv.conf\n```\n\n锁定那些自动修改DNS的文件\n\n如果需要解锁，使用如下的代码：\n\n```\nsudo chattr -i /etc/resolv.conf\n```\n\n至此，教程完成！\n\n### 附录：什么是DNS？\n\n域名解析系统（DNS）是一种建立在一个分布式数据库，计算机，服务器或任何连接到互联网或私有网络资源的分层命名系统。DNS对人类有意义的域名转换成相关的数字标识符网络设备，这些设备的全球定位和解决的目的。\n\n例如google.com DNS记录看起来像google.com。\n\n1 IN A 74.125.232.20 google.com的。\n1 IN A 74.125.232.16 google.com的。\n1 IN A 74.125.232.17 google.com的。\n1 IN A 74.125.232.18 google.com的。\n1 IN A 74.125.232.19 google.com的。\n\n### 更改DNS的建议\n\n如果你使用VPN和不希望被追踪，有些网站可以使用DNS记录来确定您的位置。因此，让我们改变我们的DNS谷歌公共DNS。然而，你可以使用你的VPN服务商的DNS或任何其他DNS服务器。","source":"_posts/修改ubuntu DNS的步骤.md","raw":"---\ntitle: 修改ubuntu DNS的步骤\ntags: [linux,ubuntu]\ndate: 2016/06/01\n---\n\n有时候连接上VPN服务器后,还是打不开某些网站，这时候需要对DNS进行更改，一般是修改成为谷歌提供的免费DNS:8.8.8.8 8.8.4.4，在windows下更改比较简单，今天教大家如何修改ubuntu的DNS域名解析服务器。\n\n### 修改DNS步骤\n\n1. 要更改ubuntu DNS必须编辑文件 - “/etc/resolv.conf”,打开“终端应用程序”-“附件” - “终端”,在终端里输入下面的命令:\n\n```\nsudo nano /etc/resolv.conf\n```\n\n如果不是管理员,会要求输入密码。\n\n如果不是root用户，需要输入密码确认身份\n\n1. 打开文档后，找到现有的DNS记录，使用“#”注释掉，然后添加新的DNS记录：\n\n按照该格式\n```\nnameserver x.x.x.x\n```\n\n使用谷歌的DNS 8.8.8.8 8.8.4.4\n\n```\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n```\n\n1. 有一些文件会自动修改DNS服务器，我们把这些文件进行锁定。使用如下的代码进行锁定操作：\n\n```\nsudo chattr +i /etc/resolv.conf\n```\n\n锁定那些自动修改DNS的文件\n\n如果需要解锁，使用如下的代码：\n\n```\nsudo chattr -i /etc/resolv.conf\n```\n\n至此，教程完成！\n\n### 附录：什么是DNS？\n\n域名解析系统（DNS）是一种建立在一个分布式数据库，计算机，服务器或任何连接到互联网或私有网络资源的分层命名系统。DNS对人类有意义的域名转换成相关的数字标识符网络设备，这些设备的全球定位和解决的目的。\n\n例如google.com DNS记录看起来像google.com。\n\n1 IN A 74.125.232.20 google.com的。\n1 IN A 74.125.232.16 google.com的。\n1 IN A 74.125.232.17 google.com的。\n1 IN A 74.125.232.18 google.com的。\n1 IN A 74.125.232.19 google.com的。\n\n### 更改DNS的建议\n\n如果你使用VPN和不希望被追踪，有些网站可以使用DNS记录来确定您的位置。因此，让我们改变我们的DNS谷歌公共DNS。然而，你可以使用你的VPN服务商的DNS或任何其他DNS服务器。","slug":"修改ubuntu DNS的步骤","published":1,"updated":"2016-08-17T06:22:19.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cple003w68ddmq48pz5f","content":"<p>有时候连接上VPN服务器后,还是打不开某些网站，这时候需要对DNS进行更改，一般是修改成为谷歌提供的免费DNS:8.8.8.8 8.8.4.4，在windows下更改比较简单，今天教大家如何修改ubuntu的DNS域名解析服务器。</p>\n<h3 id=\"修改DNS步骤\"><a href=\"#修改DNS步骤\" class=\"headerlink\" title=\"修改DNS步骤\"></a>修改DNS步骤</h3><ol>\n<li>要更改ubuntu DNS必须编辑文件 - “/etc/resolv.conf”,打开“终端应用程序”-“附件” - “终端”,在终端里输入下面的命令:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo nano /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>如果不是管理员,会要求输入密码。</p>\n<p>如果不是root用户，需要输入密码确认身份</p>\n<ol>\n<li>打开文档后，找到现有的DNS记录，使用“#”注释掉，然后添加新的DNS记录：</li>\n</ol>\n<p>按照该格式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">nameserver x.x.x.x</div></pre></td></tr></table></figure></p>\n<p>使用谷歌的DNS 8.8.8.8 8.8.4.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">nameserver 8.8.8.8</div><div class=\"line\">nameserver 8.8.4.4</div></pre></td></tr></table></figure>\n<ol>\n<li>有一些文件会自动修改DNS服务器，我们把这些文件进行锁定。使用如下的代码进行锁定操作：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo chattr +i /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>锁定那些自动修改DNS的文件</p>\n<p>如果需要解锁，使用如下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo chattr -i /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>至此，教程完成！</p>\n<h3 id=\"附录：什么是DNS？\"><a href=\"#附录：什么是DNS？\" class=\"headerlink\" title=\"附录：什么是DNS？\"></a>附录：什么是DNS？</h3><p>域名解析系统（DNS）是一种建立在一个分布式数据库，计算机，服务器或任何连接到互联网或私有网络资源的分层命名系统。DNS对人类有意义的域名转换成相关的数字标识符网络设备，这些设备的全球定位和解决的目的。</p>\n<p>例如google.com DNS记录看起来像google.com。</p>\n<p>1 IN A 74.125.232.20 google.com的。<br>1 IN A 74.125.232.16 google.com的。<br>1 IN A 74.125.232.17 google.com的。<br>1 IN A 74.125.232.18 google.com的。<br>1 IN A 74.125.232.19 google.com的。</p>\n<h3 id=\"更改DNS的建议\"><a href=\"#更改DNS的建议\" class=\"headerlink\" title=\"更改DNS的建议\"></a>更改DNS的建议</h3><p>如果你使用VPN和不希望被追踪，有些网站可以使用DNS记录来确定您的位置。因此，让我们改变我们的DNS谷歌公共DNS。然而，你可以使用你的VPN服务商的DNS或任何其他DNS服务器。</p>\n","excerpt":"","more":"<p>有时候连接上VPN服务器后,还是打不开某些网站，这时候需要对DNS进行更改，一般是修改成为谷歌提供的免费DNS:8.8.8.8 8.8.4.4，在windows下更改比较简单，今天教大家如何修改ubuntu的DNS域名解析服务器。</p>\n<h3 id=\"修改DNS步骤\"><a href=\"#修改DNS步骤\" class=\"headerlink\" title=\"修改DNS步骤\"></a>修改DNS步骤</h3><ol>\n<li>要更改ubuntu DNS必须编辑文件 - “/etc/resolv.conf”,打开“终端应用程序”-“附件” - “终端”,在终端里输入下面的命令:</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo nano /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>如果不是管理员,会要求输入密码。</p>\n<p>如果不是root用户，需要输入密码确认身份</p>\n<ol>\n<li>打开文档后，找到现有的DNS记录，使用“#”注释掉，然后添加新的DNS记录：</li>\n</ol>\n<p>按照该格式<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">nameserver x.x.x.x</div></pre></td></tr></table></figure></p>\n<p>使用谷歌的DNS 8.8.8.8 8.8.4.4</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">nameserver 8.8.8.8</div><div class=\"line\">nameserver 8.8.4.4</div></pre></td></tr></table></figure>\n<ol>\n<li>有一些文件会自动修改DNS服务器，我们把这些文件进行锁定。使用如下的代码进行锁定操作：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo chattr +i /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>锁定那些自动修改DNS的文件</p>\n<p>如果需要解锁，使用如下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo chattr -i /etc/resolv.conf</div></pre></td></tr></table></figure>\n<p>至此，教程完成！</p>\n<h3 id=\"附录：什么是DNS？\"><a href=\"#附录：什么是DNS？\" class=\"headerlink\" title=\"附录：什么是DNS？\"></a>附录：什么是DNS？</h3><p>域名解析系统（DNS）是一种建立在一个分布式数据库，计算机，服务器或任何连接到互联网或私有网络资源的分层命名系统。DNS对人类有意义的域名转换成相关的数字标识符网络设备，这些设备的全球定位和解决的目的。</p>\n<p>例如google.com DNS记录看起来像google.com。</p>\n<p>1 IN A 74.125.232.20 google.com的。<br>1 IN A 74.125.232.16 google.com的。<br>1 IN A 74.125.232.17 google.com的。<br>1 IN A 74.125.232.18 google.com的。<br>1 IN A 74.125.232.19 google.com的。</p>\n<h3 id=\"更改DNS的建议\"><a href=\"#更改DNS的建议\" class=\"headerlink\" title=\"更改DNS的建议\"></a>更改DNS的建议</h3><p>如果你使用VPN和不希望被追踪，有些网站可以使用DNS记录来确定您的位置。因此，让我们改变我们的DNS谷歌公共DNS。然而，你可以使用你的VPN服务商的DNS或任何其他DNS服务器。</p>\n"},{"title":"减少HTTP请求（大型网站优化技术）","date":"2015-07-12T16:00:00.000Z","_content":"\n在网站开发过程中，对于页面的加载效率一般都想尽办法求快。那么，怎么让才能更快呢？减少页面请求是一个优化页面加载速度很好的方法。这一篇博文将讲解“将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片”。\n\n***一、为何选择将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片的方法减少HTTP请求数？***\n\n为什么我会讲解 “将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片” 这一种方式来减少HTTP请求，进而优化页面呢？这里呢，是涉及到移动端的图标使用。上一篇博文所讲的方法能否使用于手机端的网页呢？\n\n但是，它会出现一个问题：背景图+css显示图标时，图标本身无法缩放，比如背景图中64px*64px的图标，显示到界面时必须设置icon的大小也是64*64。在PC网页中这通常不会有什么问题，但在移动端设备上就完全行不通。同样是4英寸的手机屏幕，其分辨率有可能是320*400，也可能是640*800，甚至也可能是1920*1080。这样64px*64px的图标在不同的设备上看起来的大小就会差别非常明显。\n\n幸运的是，手机上的浏览器基本对此做了优化，会把设备模拟成更低的分辨率。比如在1136*640的IPHONE 5中获取$(window).width(),取出来的是320而不是640，这样一个宽度为160px的图片占用的是屏幕宽度的一半，而不是1/4。手机设备这样处理是为了解决兼容性问题。除了网页，包括手机上app的界面，在retina屏幕上和非retina屏幕上的大小是完全一样的，都是因为对分辨率做了处理。\n\n但是，移动设备这样的处理方式并不能完全解决问题，因为机器的假设性猜测在很多时候是不合适的，尤其是在android设备中。为了更好地控制元素显示的大小，解决的办法就是用pt代替ps，px是对应屏幕的分辨率，而pt是针对人眼睛实际感觉的大小，无论在何种分辨率的设备上，72pt固定是1英寸。\n\nHTML的img标签元素的src属性不只是可以指定url，也可以指定图片的二进制数据流。然后通过img元素的自动缩放功能，指定img的大小，就可以实现在不同分辨率的设备上显示一致的图标大小。\n\n***二、使用Base64编码减少页面请求数***\n\n当我们的一个页面中要传入很多图片时，特别是一些小图标，十几K、几K，甚至是字节级别大小的小图标，这些小图标都会增加HTTP请求，假如多了，就会给服务器带来很大的压力。比如要下载一些一两K大的小图标，其实请求时带上的额外信息有可能比图标的大小还要大。所以，在请求越多时，在网络传输的数据自然就越多了，传输的数据自然也就变慢了。而这里，我们采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入，这样就减少了HTTP请求。当然了，它有一个小缺点，就是使当前页面的大小变大了（对于优化来说，其实这个可以忽略，影响不大）。看一下下图，小图标大小为2.4k，等待响应时间是14ms，而接受数据，也就是下载时间约为0ms；可想而知，在有大量小图标下载的时候，这样的方式去优化能大大提高网站的性能（在jquery mobile和天猫的手机站上面都有用到此技术）。\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求1.jpg)\n\n***三、开发思路***\n\n将小图标放在以icon_开头的文件夹里（以区分不用生成base64的图片的文件夹）—>用程序去遍历文件夹图片 —>将每张图片的base64编码放在一个js对象里—>在HTML页面的img标签里 使用属性 icon-data = ‘图标名(不带后缀)’来显示图片 —> JS文件写一个函数对icon-data属性进行转换，转换成src属性，然后值就通过icon-data的属性值获得图标名，然后进行相应的替换得到相应图标的base64编码 —> 显示图片\n\n四、代码实现\n\n```\n<?php\n    $pathinfo = pathinfo($_SERVER['SCRIPT_FILENAME']);\n    define('ROOT', $pathinfo['dirname']);\n\n    function generateIcon_mobile() {\n        $imgRoot = ROOT.\"/img/mobile\";\n        $iterator = new DirectoryIterator($imgRoot);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue; \n            $filename = $file->getFilename();\n\n            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理\n            if ($file->isDir() && 0 === strncasecmp('icon_', $filename, 5)) {\n                generateIconMobileCallback(\"$imgRoot/$filename\", ROOT.\"/js/mobile\");\n            }\n        }\n\n    }\n\n    function generateIconMobileCallback($iconDir, $styleSaveDir) {\n        //保存成js的文件名\n        $saveName = array_pop(explode('/', $iconDir));\n        //JS文件保存路径\n        $styleSavePath = $styleSaveDir.'/'.$saveName.'.js';\n\n        //将当前目录下的所有文件及MD5组成一个识别字符串\n        $fileMap = array();\n        $iterator = new DirectoryIterator($iconDir);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue;\n            $fileName = $file->getFilename();\n            if ($file->isDir()) {\n                generateIconMobileCallback($iconDir.'/'.$fileName, $styleSaveDir.'/'.$fileName);\n            } else {\n                $fileMap[$fileName] = md5_file($file->getRealPath());\n            }\n        }\n        ksort($fileMap);\n        $fileMapStr = json_encode($fileMap);\n\n        //确保目录可写\n        ensure_writable_dir($styleSaveDir);\n\n        //js文件句柄\n        $wirteHandle = fopen($styleSavePath, 'w');\n        //当前小图标文件夹的相对路径\n        $iconSaveRelative = substr($iconDir, strlen(ROOT));\n        //写入，初始化保存数据的对象\n        fwrite($wirteHandle, \"/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == 'undefined') \\$iconData={};\");\n        foreach ($fileMap as $fileName => $md5) {\n            //当前图片的绝对路径\n            $fullPathName = \"$iconDir/$fileName\";\n            //取得路径信息\n            $pathInfo = pathinfo($fullPathName);\n            //取得文件名（没有后缀）\n            $fileNameNoExt = $pathInfo['filename'];\n            //取得图片信息\n            $imageSize = getimagesize($fullPathName);\n\n            //取得文件的后缀\n            switch ($imageSize[2]) {\n                case IMAGETYPE_GIF:\n                    $imageType = 'gif';\n                    break;\n                case IMAGETYPE_JPEG:\n                    $imageType = 'jpg';\n                    break;\n                case IMAGETYPE_PNG:\n                    $imageType = 'png';\n                    break;\n\n                default:\n                    $imageType = 'jpg';\n                    break;\n            }\n\n            //取得图片资源\n            $readHandle = fopen($fullPathName, 'r');\n            //将图片转成二进制并生成Base64编码\n            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));\n            //关闭资源\n            fclose($readHandle);\n            //将Base64编码写入js文件中\n            fwrite($wirteHandle, \"\\n\\$iconData.$fileNameNoExt=\\\"data:image/$imageType;base64,$base64\\\";\");\n        }\n        //最后换个行\n        fwrite($wirteHandle, \"\\n\");\n        //关闭资源\n        fclose($wirteHandle); \n\n        //处理成功的图标文件夹给予提示\n        echo '<p>'.$iconSaveRelative. ' saved</p>';  \n    }\n\n    /**\n    * 确保文件夹存在并可写\n    *\n    * @param string $dir\n    */\n    function ensure_writable_dir($dir) {\n        if(!file_exists($dir)) {\n            mkdir($dir, 0766, true);\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n        }\n        else if(!is_writable($dir)) {\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n            if(!@is_writable($dir)) {\n                throw new BusinessLogicException(\"目录不可写\", $dir);\n            }\n        }\n    }\n    generateIcon_mobile();\n?>\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<br>\n<br>\n<br>\n\n<div>我们直接引入所生成的js文件，测试一下是否成功</div>\n<br>\n<div>直接在img标签里加入 icon-data = '图标文件名'  例如  <\\img icon-data=\"tryit\">,查看效果</div>\n<br>\n<br>\n<br>\n    <img icon-data=\"tryit\">\n    <script src=\"js/mobile/icon_pink.js\"></script>\n    <script src=\"js/mobile/jquery.all.min.js\"></script>\n    <script src=\"js/mobile/attrHandle.js\"></script>\n</body>\n</html>\n\n<?php\n    $pathinfo = pathinfo($_SERVER['SCRIPT_FILENAME']);\n    define('ROOT', $pathinfo['dirname']);\n \n    function generateIcon_mobile() {\n        $imgRoot = ROOT.\"/img/mobile\";\n        $iterator = new DirectoryIterator($imgRoot);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue; \n            $filename = $file->getFilename();\n \n            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理\n            if ($file->isDir() && 0 === strncasecmp('icon_', $filename, 5)) {\n                generateIconMobileCallback(\"$imgRoot/$filename\", ROOT.\"/js/mobile\");\n            }\n        }\n \n    }\n \n    function generateIconMobileCallback($iconDir, $styleSaveDir) {\n        //保存成js的文件名\n        $saveName = array_pop(explode('/', $iconDir));\n        //JS文件保存路径\n        $styleSavePath = $styleSaveDir.'/'.$saveName.'.js';\n \n        //将当前目录下的所有文件及MD5组成一个识别字符串\n        $fileMap = array();\n        $iterator = new DirectoryIterator($iconDir);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue;\n            $fileName = $file->getFilename();\n            if ($file->isDir()) {\n                generateIconMobileCallback($iconDir.'/'.$fileName, $styleSaveDir.'/'.$fileName);\n            } else {\n                $fileMap[$fileName] = md5_file($file->getRealPath());\n            }\n        }\n        ksort($fileMap);\n        $fileMapStr = json_encode($fileMap);\n \n        //确保目录可写\n        ensure_writable_dir($styleSaveDir);\n \n        //js文件句柄\n        $wirteHandle = fopen($styleSavePath, 'w');\n        //当前小图标文件夹的相对路径\n        $iconSaveRelative = substr($iconDir, strlen(ROOT));\n        //写入，初始化保存数据的对象\n        fwrite($wirteHandle, \"/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == 'undefined') \\$iconData={};\");\n        foreach ($fileMap as $fileName => $md5) {\n            //当前图片的绝对路径\n            $fullPathName = \"$iconDir/$fileName\";\n            //取得路径信息\n            $pathInfo = pathinfo($fullPathName);\n            //取得文件名（没有后缀）\n            $fileNameNoExt = $pathInfo['filename'];\n            //取得图片信息\n            $imageSize = getimagesize($fullPathName);\n \n            //取得文件的后缀\n            switch ($imageSize[2]) {\n                case IMAGETYPE_GIF:\n                    $imageType = 'gif';\n                    break;\n                case IMAGETYPE_JPEG:\n                    $imageType = 'jpg';\n                    break;\n                case IMAGETYPE_PNG:\n                    $imageType = 'png';\n                    break;\n \n                default:\n                    $imageType = 'jpg';\n                    break;\n            }\n \n            //取得图片资源\n            $readHandle = fopen($fullPathName, 'r');\n            //将图片转成二进制并生成Base64编码\n            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));\n            //关闭资源\n            fclose($readHandle);\n            //将Base64编码写入js文件中\n            fwrite($wirteHandle, \"\\n\\$iconData.$fileNameNoExt=\\\"data:image/$imageType;base64,$base64\\\";\");\n        }\n        //最后换个行\n        fwrite($wirteHandle, \"\\n\");\n        //关闭资源\n        fclose($wirteHandle); \n \n        //处理成功的图标文件夹给予提示\n        echo '<p>'.$iconSaveRelative. ' saved</p>';  \n    }\n \n    /**\n    * 确保文件夹存在并可写\n    *\n    * @param string $dir\n    */\n    function ensure_writable_dir($dir) {\n        if(!file_exists($dir)) {\n            mkdir($dir, 0766, true);\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n        }\n        else if(!is_writable($dir)) {\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n            if(!@is_writable($dir)) {\n                throw new BusinessLogicException(\"目录不可写\", $dir);\n            }\n        }\n    }\n    generateIcon_mobile();\n?>\n \n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<br>\n<br>\n<br>\n \n<div>我们直接引入所生成的js文件，测试一下是否成功</div>\n<br>\n<div>直接在img标签里加入 icon-data = '图标文件名'  例如  <\\img icon-data=\"tryit\">,查看效果</div>\n<br>\n<br>\n<br>\n    <img icon-data=\"tryit\">\n    <script src=\"js/mobile/icon_pink.js\"></script>\n    <script src=\"js/mobile/jquery.all.min.js\"></script>\n    <script src=\"js/mobile/attrHandle.js\"></script>\n</body>\n</html>\n```\n\n然后这里附上属性转换的JS代码\n\n```\n$(function(){\n    setIconData();\n});\n\nfunction setIconData() {\n    if (typeof($iconData != 'undefined')) {\n        $('img[icon-data]').each(function() {\n            var self = $(this);\n            var name = self.attr('icon-data');\n            if (typeof($iconData[name]) != 'undefined') {\n                self.attr('src', $iconData[name]);\n                self.removeAttr('icon-data');\n            }\n        });\n    }\n}\n\n$(function(){\n    setIconData();\n});\n \nfunction setIconData() {\n    if (typeof($iconData != 'undefined')) {\n        $('img[icon-data]').each(function() {\n            var self = $(this);\n            var name = self.attr('icon-data');\n            if (typeof($iconData[name]) != 'undefined') {\n                self.attr('src', $iconData[name]);\n                self.removeAttr('icon-data');\n            }\n        });\n    }\n}\n```\n\n***五、实现效果***\n\n这是页面输入效果，小图标正常显示出来了\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求2.jpg)\n\n这里我们自动生成的JS文件是这样子的格式：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求3.jpg)\n\n页面调用的代码：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求4.jpg)\n\nJS对img的icon-data属性转换处理的代码：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求5.jpg)\n\n我们对比下用base64编码和不用base64时所花费的时间：\n\n先看不用的速度\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求6.jpg)\n\n再看我们用了base64编码的速度　　　\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求7.jpg)\n\n假如一个页面有很多小图标，那么这种方式对网站的性能优化会有大大的提升。如今此种优化方案是用在我现在的项目中移动端，而上一篇博文讲解的生成背景图的优化方案用在我们项目中的PC端。优化效果是很明显的！当然了，base64编码这种方法也可以用在PC端，我们的项目为啥将它用在手机端，本博文开头部分也有对其做解释。这里测试我就直接在PC端测试，手机端测试也是一个样的。\n\n这里我补充一点：\n\n（1）所生成的base64的js文件是在开发中就生成的了，而不是在用户访问时才去生成，我把HTML代码和PHP代码写在一个文件里是方便，在真实项目中是分开的；\n\n（2）使用此种优化技术有它的优点，当然也会有它的缺点，只有适合自己项目的优化技术才是好技术；\n\n（3）此中优化技术建议使用在手机端（可以解决背景图优化方式所不能解决的问题），而PC端的则用合并小图标生成背景图的方式（看此文：[http://www.cnblogs.com/it-cen/p/4618954.html](http://www.cnblogs.com/it-cen/p/4618954.html)）；\n\n（4）此种优化技术一般用于小图标（十几K以下），也就是HTTP响应时间远远大于下载时间的时候，用此方法优化会看到明显的效果；\n\n（5）当然可以配合其他优化技术一起使用，效果更明显，比如缓存等。\n\n\n这一次就分享那么多给大家，代码我都贴上了，而且很多都标上了注释，方便大家理解。\n\n如果此博文中有哪里讲得让人难以理解，欢迎留言交流，若有讲解错的地方欢迎指出。\n\n如果您觉得您能在此博文学到了新知识，请为我顶一个，如文章中有解释错的地方，欢迎指出。\n\n互相学习，共同进步！\n","source":"_posts/减少HTTP请求（大型网站优化技术）.md","raw":"---\ntitle: 减少HTTP请求（大型网站优化技术）\ntags: [html,php]\ndate: 2015/07/13\n---\n\n在网站开发过程中，对于页面的加载效率一般都想尽办法求快。那么，怎么让才能更快呢？减少页面请求是一个优化页面加载速度很好的方法。这一篇博文将讲解“将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片”。\n\n***一、为何选择将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片的方法减少HTTP请求数？***\n\n为什么我会讲解 “将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片” 这一种方式来减少HTTP请求，进而优化页面呢？这里呢，是涉及到移动端的图标使用。上一篇博文所讲的方法能否使用于手机端的网页呢？\n\n但是，它会出现一个问题：背景图+css显示图标时，图标本身无法缩放，比如背景图中64px*64px的图标，显示到界面时必须设置icon的大小也是64*64。在PC网页中这通常不会有什么问题，但在移动端设备上就完全行不通。同样是4英寸的手机屏幕，其分辨率有可能是320*400，也可能是640*800，甚至也可能是1920*1080。这样64px*64px的图标在不同的设备上看起来的大小就会差别非常明显。\n\n幸运的是，手机上的浏览器基本对此做了优化，会把设备模拟成更低的分辨率。比如在1136*640的IPHONE 5中获取$(window).width(),取出来的是320而不是640，这样一个宽度为160px的图片占用的是屏幕宽度的一半，而不是1/4。手机设备这样处理是为了解决兼容性问题。除了网页，包括手机上app的界面，在retina屏幕上和非retina屏幕上的大小是完全一样的，都是因为对分辨率做了处理。\n\n但是，移动设备这样的处理方式并不能完全解决问题，因为机器的假设性猜测在很多时候是不合适的，尤其是在android设备中。为了更好地控制元素显示的大小，解决的办法就是用pt代替ps，px是对应屏幕的分辨率，而pt是针对人眼睛实际感觉的大小，无论在何种分辨率的设备上，72pt固定是1英寸。\n\nHTML的img标签元素的src属性不只是可以指定url，也可以指定图片的二进制数据流。然后通过img元素的自动缩放功能，指定img的大小，就可以实现在不同分辨率的设备上显示一致的图标大小。\n\n***二、使用Base64编码减少页面请求数***\n\n当我们的一个页面中要传入很多图片时，特别是一些小图标，十几K、几K，甚至是字节级别大小的小图标，这些小图标都会增加HTTP请求，假如多了，就会给服务器带来很大的压力。比如要下载一些一两K大的小图标，其实请求时带上的额外信息有可能比图标的大小还要大。所以，在请求越多时，在网络传输的数据自然就越多了，传输的数据自然也就变慢了。而这里，我们采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入，这样就减少了HTTP请求。当然了，它有一个小缺点，就是使当前页面的大小变大了（对于优化来说，其实这个可以忽略，影响不大）。看一下下图，小图标大小为2.4k，等待响应时间是14ms，而接受数据，也就是下载时间约为0ms；可想而知，在有大量小图标下载的时候，这样的方式去优化能大大提高网站的性能（在jquery mobile和天猫的手机站上面都有用到此技术）。\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求1.jpg)\n\n***三、开发思路***\n\n将小图标放在以icon_开头的文件夹里（以区分不用生成base64的图片的文件夹）—>用程序去遍历文件夹图片 —>将每张图片的base64编码放在一个js对象里—>在HTML页面的img标签里 使用属性 icon-data = ‘图标名(不带后缀)’来显示图片 —> JS文件写一个函数对icon-data属性进行转换，转换成src属性，然后值就通过icon-data的属性值获得图标名，然后进行相应的替换得到相应图标的base64编码 —> 显示图片\n\n四、代码实现\n\n```\n<?php\n    $pathinfo = pathinfo($_SERVER['SCRIPT_FILENAME']);\n    define('ROOT', $pathinfo['dirname']);\n\n    function generateIcon_mobile() {\n        $imgRoot = ROOT.\"/img/mobile\";\n        $iterator = new DirectoryIterator($imgRoot);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue; \n            $filename = $file->getFilename();\n\n            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理\n            if ($file->isDir() && 0 === strncasecmp('icon_', $filename, 5)) {\n                generateIconMobileCallback(\"$imgRoot/$filename\", ROOT.\"/js/mobile\");\n            }\n        }\n\n    }\n\n    function generateIconMobileCallback($iconDir, $styleSaveDir) {\n        //保存成js的文件名\n        $saveName = array_pop(explode('/', $iconDir));\n        //JS文件保存路径\n        $styleSavePath = $styleSaveDir.'/'.$saveName.'.js';\n\n        //将当前目录下的所有文件及MD5组成一个识别字符串\n        $fileMap = array();\n        $iterator = new DirectoryIterator($iconDir);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue;\n            $fileName = $file->getFilename();\n            if ($file->isDir()) {\n                generateIconMobileCallback($iconDir.'/'.$fileName, $styleSaveDir.'/'.$fileName);\n            } else {\n                $fileMap[$fileName] = md5_file($file->getRealPath());\n            }\n        }\n        ksort($fileMap);\n        $fileMapStr = json_encode($fileMap);\n\n        //确保目录可写\n        ensure_writable_dir($styleSaveDir);\n\n        //js文件句柄\n        $wirteHandle = fopen($styleSavePath, 'w');\n        //当前小图标文件夹的相对路径\n        $iconSaveRelative = substr($iconDir, strlen(ROOT));\n        //写入，初始化保存数据的对象\n        fwrite($wirteHandle, \"/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == 'undefined') \\$iconData={};\");\n        foreach ($fileMap as $fileName => $md5) {\n            //当前图片的绝对路径\n            $fullPathName = \"$iconDir/$fileName\";\n            //取得路径信息\n            $pathInfo = pathinfo($fullPathName);\n            //取得文件名（没有后缀）\n            $fileNameNoExt = $pathInfo['filename'];\n            //取得图片信息\n            $imageSize = getimagesize($fullPathName);\n\n            //取得文件的后缀\n            switch ($imageSize[2]) {\n                case IMAGETYPE_GIF:\n                    $imageType = 'gif';\n                    break;\n                case IMAGETYPE_JPEG:\n                    $imageType = 'jpg';\n                    break;\n                case IMAGETYPE_PNG:\n                    $imageType = 'png';\n                    break;\n\n                default:\n                    $imageType = 'jpg';\n                    break;\n            }\n\n            //取得图片资源\n            $readHandle = fopen($fullPathName, 'r');\n            //将图片转成二进制并生成Base64编码\n            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));\n            //关闭资源\n            fclose($readHandle);\n            //将Base64编码写入js文件中\n            fwrite($wirteHandle, \"\\n\\$iconData.$fileNameNoExt=\\\"data:image/$imageType;base64,$base64\\\";\");\n        }\n        //最后换个行\n        fwrite($wirteHandle, \"\\n\");\n        //关闭资源\n        fclose($wirteHandle); \n\n        //处理成功的图标文件夹给予提示\n        echo '<p>'.$iconSaveRelative. ' saved</p>';  \n    }\n\n    /**\n    * 确保文件夹存在并可写\n    *\n    * @param string $dir\n    */\n    function ensure_writable_dir($dir) {\n        if(!file_exists($dir)) {\n            mkdir($dir, 0766, true);\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n        }\n        else if(!is_writable($dir)) {\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n            if(!@is_writable($dir)) {\n                throw new BusinessLogicException(\"目录不可写\", $dir);\n            }\n        }\n    }\n    generateIcon_mobile();\n?>\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<br>\n<br>\n<br>\n\n<div>我们直接引入所生成的js文件，测试一下是否成功</div>\n<br>\n<div>直接在img标签里加入 icon-data = '图标文件名'  例如  <\\img icon-data=\"tryit\">,查看效果</div>\n<br>\n<br>\n<br>\n    <img icon-data=\"tryit\">\n    <script src=\"js/mobile/icon_pink.js\"></script>\n    <script src=\"js/mobile/jquery.all.min.js\"></script>\n    <script src=\"js/mobile/attrHandle.js\"></script>\n</body>\n</html>\n\n<?php\n    $pathinfo = pathinfo($_SERVER['SCRIPT_FILENAME']);\n    define('ROOT', $pathinfo['dirname']);\n \n    function generateIcon_mobile() {\n        $imgRoot = ROOT.\"/img/mobile\";\n        $iterator = new DirectoryIterator($imgRoot);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue; \n            $filename = $file->getFilename();\n \n            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理\n            if ($file->isDir() && 0 === strncasecmp('icon_', $filename, 5)) {\n                generateIconMobileCallback(\"$imgRoot/$filename\", ROOT.\"/js/mobile\");\n            }\n        }\n \n    }\n \n    function generateIconMobileCallback($iconDir, $styleSaveDir) {\n        //保存成js的文件名\n        $saveName = array_pop(explode('/', $iconDir));\n        //JS文件保存路径\n        $styleSavePath = $styleSaveDir.'/'.$saveName.'.js';\n \n        //将当前目录下的所有文件及MD5组成一个识别字符串\n        $fileMap = array();\n        $iterator = new DirectoryIterator($iconDir);\n        foreach ($iterator as $file) {\n            if ($file->isDot()) continue;\n            $fileName = $file->getFilename();\n            if ($file->isDir()) {\n                generateIconMobileCallback($iconDir.'/'.$fileName, $styleSaveDir.'/'.$fileName);\n            } else {\n                $fileMap[$fileName] = md5_file($file->getRealPath());\n            }\n        }\n        ksort($fileMap);\n        $fileMapStr = json_encode($fileMap);\n \n        //确保目录可写\n        ensure_writable_dir($styleSaveDir);\n \n        //js文件句柄\n        $wirteHandle = fopen($styleSavePath, 'w');\n        //当前小图标文件夹的相对路径\n        $iconSaveRelative = substr($iconDir, strlen(ROOT));\n        //写入，初始化保存数据的对象\n        fwrite($wirteHandle, \"/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == 'undefined') \\$iconData={};\");\n        foreach ($fileMap as $fileName => $md5) {\n            //当前图片的绝对路径\n            $fullPathName = \"$iconDir/$fileName\";\n            //取得路径信息\n            $pathInfo = pathinfo($fullPathName);\n            //取得文件名（没有后缀）\n            $fileNameNoExt = $pathInfo['filename'];\n            //取得图片信息\n            $imageSize = getimagesize($fullPathName);\n \n            //取得文件的后缀\n            switch ($imageSize[2]) {\n                case IMAGETYPE_GIF:\n                    $imageType = 'gif';\n                    break;\n                case IMAGETYPE_JPEG:\n                    $imageType = 'jpg';\n                    break;\n                case IMAGETYPE_PNG:\n                    $imageType = 'png';\n                    break;\n \n                default:\n                    $imageType = 'jpg';\n                    break;\n            }\n \n            //取得图片资源\n            $readHandle = fopen($fullPathName, 'r');\n            //将图片转成二进制并生成Base64编码\n            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));\n            //关闭资源\n            fclose($readHandle);\n            //将Base64编码写入js文件中\n            fwrite($wirteHandle, \"\\n\\$iconData.$fileNameNoExt=\\\"data:image/$imageType;base64,$base64\\\";\");\n        }\n        //最后换个行\n        fwrite($wirteHandle, \"\\n\");\n        //关闭资源\n        fclose($wirteHandle); \n \n        //处理成功的图标文件夹给予提示\n        echo '<p>'.$iconSaveRelative. ' saved</p>';  \n    }\n \n    /**\n    * 确保文件夹存在并可写\n    *\n    * @param string $dir\n    */\n    function ensure_writable_dir($dir) {\n        if(!file_exists($dir)) {\n            mkdir($dir, 0766, true);\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n        }\n        else if(!is_writable($dir)) {\n            @chmod($dir, 0766);\n            @chmod($dir, 0777);\n            if(!@is_writable($dir)) {\n                throw new BusinessLogicException(\"目录不可写\", $dir);\n            }\n        }\n    }\n    generateIcon_mobile();\n?>\n \n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<br>\n<br>\n<br>\n \n<div>我们直接引入所生成的js文件，测试一下是否成功</div>\n<br>\n<div>直接在img标签里加入 icon-data = '图标文件名'  例如  <\\img icon-data=\"tryit\">,查看效果</div>\n<br>\n<br>\n<br>\n    <img icon-data=\"tryit\">\n    <script src=\"js/mobile/icon_pink.js\"></script>\n    <script src=\"js/mobile/jquery.all.min.js\"></script>\n    <script src=\"js/mobile/attrHandle.js\"></script>\n</body>\n</html>\n```\n\n然后这里附上属性转换的JS代码\n\n```\n$(function(){\n    setIconData();\n});\n\nfunction setIconData() {\n    if (typeof($iconData != 'undefined')) {\n        $('img[icon-data]').each(function() {\n            var self = $(this);\n            var name = self.attr('icon-data');\n            if (typeof($iconData[name]) != 'undefined') {\n                self.attr('src', $iconData[name]);\n                self.removeAttr('icon-data');\n            }\n        });\n    }\n}\n\n$(function(){\n    setIconData();\n});\n \nfunction setIconData() {\n    if (typeof($iconData != 'undefined')) {\n        $('img[icon-data]').each(function() {\n            var self = $(this);\n            var name = self.attr('icon-data');\n            if (typeof($iconData[name]) != 'undefined') {\n                self.attr('src', $iconData[name]);\n                self.removeAttr('icon-data');\n            }\n        });\n    }\n}\n```\n\n***五、实现效果***\n\n这是页面输入效果，小图标正常显示出来了\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求2.jpg)\n\n这里我们自动生成的JS文件是这样子的格式：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求3.jpg)\n\n页面调用的代码：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求4.jpg)\n\nJS对img的icon-data属性转换处理的代码：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求5.jpg)\n\n我们对比下用base64编码和不用base64时所花费的时间：\n\n先看不用的速度\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求6.jpg)\n\n再看我们用了base64编码的速度　　　\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求7.jpg)\n\n假如一个页面有很多小图标，那么这种方式对网站的性能优化会有大大的提升。如今此种优化方案是用在我现在的项目中移动端，而上一篇博文讲解的生成背景图的优化方案用在我们项目中的PC端。优化效果是很明显的！当然了，base64编码这种方法也可以用在PC端，我们的项目为啥将它用在手机端，本博文开头部分也有对其做解释。这里测试我就直接在PC端测试，手机端测试也是一个样的。\n\n这里我补充一点：\n\n（1）所生成的base64的js文件是在开发中就生成的了，而不是在用户访问时才去生成，我把HTML代码和PHP代码写在一个文件里是方便，在真实项目中是分开的；\n\n（2）使用此种优化技术有它的优点，当然也会有它的缺点，只有适合自己项目的优化技术才是好技术；\n\n（3）此中优化技术建议使用在手机端（可以解决背景图优化方式所不能解决的问题），而PC端的则用合并小图标生成背景图的方式（看此文：[http://www.cnblogs.com/it-cen/p/4618954.html](http://www.cnblogs.com/it-cen/p/4618954.html)）；\n\n（4）此种优化技术一般用于小图标（十几K以下），也就是HTTP响应时间远远大于下载时间的时候，用此方法优化会看到明显的效果；\n\n（5）当然可以配合其他优化技术一起使用，效果更明显，比如缓存等。\n\n\n这一次就分享那么多给大家，代码我都贴上了，而且很多都标上了注释，方便大家理解。\n\n如果此博文中有哪里讲得让人难以理解，欢迎留言交流，若有讲解错的地方欢迎指出。\n\n如果您觉得您能在此博文学到了新知识，请为我顶一个，如文章中有解释错的地方，欢迎指出。\n\n互相学习，共同进步！\n","slug":"减少HTTP请求（大型网站优化技术）","published":1,"updated":"2016-08-17T06:22:19.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpli003z68dd9s2awcey","content":"<p>在网站开发过程中，对于页面的加载效率一般都想尽办法求快。那么，怎么让才能更快呢？减少页面请求是一个优化页面加载速度很好的方法。这一篇博文将讲解“将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片”。</p>\n<p><strong><em>一、为何选择将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片的方法减少HTTP请求数？</em></strong></p>\n<p>为什么我会讲解 “将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片” 这一种方式来减少HTTP请求，进而优化页面呢？这里呢，是涉及到移动端的图标使用。上一篇博文所讲的方法能否使用于手机端的网页呢？</p>\n<p>但是，它会出现一个问题：背景图+css显示图标时，图标本身无法缩放，比如背景图中64px<em>64px的图标，显示到界面时必须设置icon的大小也是64</em>64。在PC网页中这通常不会有什么问题，但在移动端设备上就完全行不通。同样是4英寸的手机屏幕，其分辨率有可能是320<em>400，也可能是640</em>800，甚至也可能是1920<em>1080。这样64px</em>64px的图标在不同的设备上看起来的大小就会差别非常明显。</p>\n<p>幸运的是，手机上的浏览器基本对此做了优化，会把设备模拟成更低的分辨率。比如在1136*640的IPHONE 5中获取$(window).width(),取出来的是320而不是640，这样一个宽度为160px的图片占用的是屏幕宽度的一半，而不是1/4。手机设备这样处理是为了解决兼容性问题。除了网页，包括手机上app的界面，在retina屏幕上和非retina屏幕上的大小是完全一样的，都是因为对分辨率做了处理。</p>\n<p>但是，移动设备这样的处理方式并不能完全解决问题，因为机器的假设性猜测在很多时候是不合适的，尤其是在android设备中。为了更好地控制元素显示的大小，解决的办法就是用pt代替ps，px是对应屏幕的分辨率，而pt是针对人眼睛实际感觉的大小，无论在何种分辨率的设备上，72pt固定是1英寸。</p>\n<p>HTML的img标签元素的src属性不只是可以指定url，也可以指定图片的二进制数据流。然后通过img元素的自动缩放功能，指定img的大小，就可以实现在不同分辨率的设备上显示一致的图标大小。</p>\n<p><strong><em>二、使用Base64编码减少页面请求数</em></strong></p>\n<p>当我们的一个页面中要传入很多图片时，特别是一些小图标，十几K、几K，甚至是字节级别大小的小图标，这些小图标都会增加HTTP请求，假如多了，就会给服务器带来很大的压力。比如要下载一些一两K大的小图标，其实请求时带上的额外信息有可能比图标的大小还要大。所以，在请求越多时，在网络传输的数据自然就越多了，传输的数据自然也就变慢了。而这里，我们采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入，这样就减少了HTTP请求。当然了，它有一个小缺点，就是使当前页面的大小变大了（对于优化来说，其实这个可以忽略，影响不大）。看一下下图，小图标大小为2.4k，等待响应时间是14ms，而接受数据，也就是下载时间约为0ms；可想而知，在有大量小图标下载的时候，这样的方式去优化能大大提高网站的性能（在jquery mobile和天猫的手机站上面都有用到此技术）。</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求1.jpg\" alt=\"图片\"></p>\n<p><strong><em>三、开发思路</em></strong></p>\n<p>将小图标放在以icon_开头的文件夹里（以区分不用生成base64的图片的文件夹）—&gt;用程序去遍历文件夹图片 —&gt;将每张图片的base64编码放在一个js对象里—&gt;在HTML页面的img标签里 使用属性 icon-data = ‘图标名(不带后缀)’来显示图片 —&gt; JS文件写一个函数对icon-data属性进行转换，转换成src属性，然后值就通过icon-data的属性值获得图标名，然后进行相应的替换得到相应图标的base64编码 —&gt; 显示图片</p>\n<p>四、代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">    $pathinfo = pathinfo($_SERVER[&apos;SCRIPT_FILENAME&apos;]);</div><div class=\"line\">    define(&apos;ROOT&apos;, $pathinfo[&apos;dirname&apos;]);</div><div class=\"line\"></div><div class=\"line\">    function generateIcon_mobile() &#123;</div><div class=\"line\">        $imgRoot = ROOT.&quot;/img/mobile&quot;;</div><div class=\"line\">        $iterator = new DirectoryIterator($imgRoot);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue; </div><div class=\"line\">            $filename = $file-&gt;getFilename();</div><div class=\"line\"></div><div class=\"line\">            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理</div><div class=\"line\">            if ($file-&gt;isDir() &amp;&amp; 0 === strncasecmp(&apos;icon_&apos;, $filename, 5)) &#123;</div><div class=\"line\">                generateIconMobileCallback(&quot;$imgRoot/$filename&quot;, ROOT.&quot;/js/mobile&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function generateIconMobileCallback($iconDir, $styleSaveDir) &#123;</div><div class=\"line\">        //保存成js的文件名</div><div class=\"line\">        $saveName = array_pop(explode(&apos;/&apos;, $iconDir));</div><div class=\"line\">        //JS文件保存路径</div><div class=\"line\">        $styleSavePath = $styleSaveDir.&apos;/&apos;.$saveName.&apos;.js&apos;;</div><div class=\"line\"></div><div class=\"line\">        //将当前目录下的所有文件及MD5组成一个识别字符串</div><div class=\"line\">        $fileMap = array();</div><div class=\"line\">        $iterator = new DirectoryIterator($iconDir);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue;</div><div class=\"line\">            $fileName = $file-&gt;getFilename();</div><div class=\"line\">            if ($file-&gt;isDir()) &#123;</div><div class=\"line\">                generateIconMobileCallback($iconDir.&apos;/&apos;.$fileName, $styleSaveDir.&apos;/&apos;.$fileName);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                $fileMap[$fileName] = md5_file($file-&gt;getRealPath());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ksort($fileMap);</div><div class=\"line\">        $fileMapStr = json_encode($fileMap);</div><div class=\"line\"></div><div class=\"line\">        //确保目录可写</div><div class=\"line\">        ensure_writable_dir($styleSaveDir);</div><div class=\"line\"></div><div class=\"line\">        //js文件句柄</div><div class=\"line\">        $wirteHandle = fopen($styleSavePath, &apos;w&apos;);</div><div class=\"line\">        //当前小图标文件夹的相对路径</div><div class=\"line\">        $iconSaveRelative = substr($iconDir, strlen(ROOT));</div><div class=\"line\">        //写入，初始化保存数据的对象</div><div class=\"line\">        fwrite($wirteHandle, &quot;/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == &apos;undefined&apos;) \\$iconData=&#123;&#125;;&quot;);</div><div class=\"line\">        foreach ($fileMap as $fileName =&gt; $md5) &#123;</div><div class=\"line\">            //当前图片的绝对路径</div><div class=\"line\">            $fullPathName = &quot;$iconDir/$fileName&quot;;</div><div class=\"line\">            //取得路径信息</div><div class=\"line\">            $pathInfo = pathinfo($fullPathName);</div><div class=\"line\">            //取得文件名（没有后缀）</div><div class=\"line\">            $fileNameNoExt = $pathInfo[&apos;filename&apos;];</div><div class=\"line\">            //取得图片信息</div><div class=\"line\">            $imageSize = getimagesize($fullPathName);</div><div class=\"line\"></div><div class=\"line\">            //取得文件的后缀</div><div class=\"line\">            switch ($imageSize[2]) &#123;</div><div class=\"line\">                case IMAGETYPE_GIF:</div><div class=\"line\">                    $imageType = &apos;gif&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_JPEG:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_PNG:</div><div class=\"line\">                    $imageType = &apos;png&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\"></div><div class=\"line\">                default:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            //取得图片资源</div><div class=\"line\">            $readHandle = fopen($fullPathName, &apos;r&apos;);</div><div class=\"line\">            //将图片转成二进制并生成Base64编码</div><div class=\"line\">            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));</div><div class=\"line\">            //关闭资源</div><div class=\"line\">            fclose($readHandle);</div><div class=\"line\">            //将Base64编码写入js文件中</div><div class=\"line\">            fwrite($wirteHandle, &quot;\\n\\$iconData.$fileNameNoExt=\\&quot;data:image/$imageType;base64,$base64\\&quot;;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //最后换个行</div><div class=\"line\">        fwrite($wirteHandle, &quot;\\n&quot;);</div><div class=\"line\">        //关闭资源</div><div class=\"line\">        fclose($wirteHandle); </div><div class=\"line\"></div><div class=\"line\">        //处理成功的图标文件夹给予提示</div><div class=\"line\">        echo &apos;&lt;p&gt;&apos;.$iconSaveRelative. &apos; saved&lt;/p&gt;&apos;;  </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">    * 确保文件夹存在并可写</div><div class=\"line\">    *</div><div class=\"line\">    * @param string $dir</div><div class=\"line\">    */</div><div class=\"line\">    function ensure_writable_dir($dir) &#123;</div><div class=\"line\">        if(!file_exists($dir)) &#123;</div><div class=\"line\">            mkdir($dir, 0766, true);</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if(!is_writable($dir)) &#123;</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">            if(!@is_writable($dir)) &#123;</div><div class=\"line\">                throw new BusinessLogicException(&quot;目录不可写&quot;, $dir);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    generateIcon_mobile();</div><div class=\"line\">?&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;title&gt;&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;我们直接引入所生成的js文件，测试一下是否成功&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div&gt;直接在img标签里加入 icon-data = &apos;图标文件名&apos;  例如  &lt;\\img icon-data=&quot;tryit&quot;&gt;,查看效果&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">    &lt;img icon-data=&quot;tryit&quot;&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/icon_pink.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/jquery.all.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/attrHandle.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;?php</div><div class=\"line\">    $pathinfo = pathinfo($_SERVER[&apos;SCRIPT_FILENAME&apos;]);</div><div class=\"line\">    define(&apos;ROOT&apos;, $pathinfo[&apos;dirname&apos;]);</div><div class=\"line\"> </div><div class=\"line\">    function generateIcon_mobile() &#123;</div><div class=\"line\">        $imgRoot = ROOT.&quot;/img/mobile&quot;;</div><div class=\"line\">        $iterator = new DirectoryIterator($imgRoot);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue; </div><div class=\"line\">            $filename = $file-&gt;getFilename();</div><div class=\"line\"> </div><div class=\"line\">            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理</div><div class=\"line\">            if ($file-&gt;isDir() &amp;&amp; 0 === strncasecmp(&apos;icon_&apos;, $filename, 5)) &#123;</div><div class=\"line\">                generateIconMobileCallback(&quot;$imgRoot/$filename&quot;, ROOT.&quot;/js/mobile&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    function generateIconMobileCallback($iconDir, $styleSaveDir) &#123;</div><div class=\"line\">        //保存成js的文件名</div><div class=\"line\">        $saveName = array_pop(explode(&apos;/&apos;, $iconDir));</div><div class=\"line\">        //JS文件保存路径</div><div class=\"line\">        $styleSavePath = $styleSaveDir.&apos;/&apos;.$saveName.&apos;.js&apos;;</div><div class=\"line\"> </div><div class=\"line\">        //将当前目录下的所有文件及MD5组成一个识别字符串</div><div class=\"line\">        $fileMap = array();</div><div class=\"line\">        $iterator = new DirectoryIterator($iconDir);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue;</div><div class=\"line\">            $fileName = $file-&gt;getFilename();</div><div class=\"line\">            if ($file-&gt;isDir()) &#123;</div><div class=\"line\">                generateIconMobileCallback($iconDir.&apos;/&apos;.$fileName, $styleSaveDir.&apos;/&apos;.$fileName);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                $fileMap[$fileName] = md5_file($file-&gt;getRealPath());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ksort($fileMap);</div><div class=\"line\">        $fileMapStr = json_encode($fileMap);</div><div class=\"line\"> </div><div class=\"line\">        //确保目录可写</div><div class=\"line\">        ensure_writable_dir($styleSaveDir);</div><div class=\"line\"> </div><div class=\"line\">        //js文件句柄</div><div class=\"line\">        $wirteHandle = fopen($styleSavePath, &apos;w&apos;);</div><div class=\"line\">        //当前小图标文件夹的相对路径</div><div class=\"line\">        $iconSaveRelative = substr($iconDir, strlen(ROOT));</div><div class=\"line\">        //写入，初始化保存数据的对象</div><div class=\"line\">        fwrite($wirteHandle, &quot;/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == &apos;undefined&apos;) \\$iconData=&#123;&#125;;&quot;);</div><div class=\"line\">        foreach ($fileMap as $fileName =&gt; $md5) &#123;</div><div class=\"line\">            //当前图片的绝对路径</div><div class=\"line\">            $fullPathName = &quot;$iconDir/$fileName&quot;;</div><div class=\"line\">            //取得路径信息</div><div class=\"line\">            $pathInfo = pathinfo($fullPathName);</div><div class=\"line\">            //取得文件名（没有后缀）</div><div class=\"line\">            $fileNameNoExt = $pathInfo[&apos;filename&apos;];</div><div class=\"line\">            //取得图片信息</div><div class=\"line\">            $imageSize = getimagesize($fullPathName);</div><div class=\"line\"> </div><div class=\"line\">            //取得文件的后缀</div><div class=\"line\">            switch ($imageSize[2]) &#123;</div><div class=\"line\">                case IMAGETYPE_GIF:</div><div class=\"line\">                    $imageType = &apos;gif&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_JPEG:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_PNG:</div><div class=\"line\">                    $imageType = &apos;png&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\"> </div><div class=\"line\">                default:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">            //取得图片资源</div><div class=\"line\">            $readHandle = fopen($fullPathName, &apos;r&apos;);</div><div class=\"line\">            //将图片转成二进制并生成Base64编码</div><div class=\"line\">            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));</div><div class=\"line\">            //关闭资源</div><div class=\"line\">            fclose($readHandle);</div><div class=\"line\">            //将Base64编码写入js文件中</div><div class=\"line\">            fwrite($wirteHandle, &quot;\\n\\$iconData.$fileNameNoExt=\\&quot;data:image/$imageType;base64,$base64\\&quot;;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //最后换个行</div><div class=\"line\">        fwrite($wirteHandle, &quot;\\n&quot;);</div><div class=\"line\">        //关闭资源</div><div class=\"line\">        fclose($wirteHandle); </div><div class=\"line\"> </div><div class=\"line\">        //处理成功的图标文件夹给予提示</div><div class=\"line\">        echo &apos;&lt;p&gt;&apos;.$iconSaveRelative. &apos; saved&lt;/p&gt;&apos;;  </div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    /**</div><div class=\"line\">    * 确保文件夹存在并可写</div><div class=\"line\">    *</div><div class=\"line\">    * @param string $dir</div><div class=\"line\">    */</div><div class=\"line\">    function ensure_writable_dir($dir) &#123;</div><div class=\"line\">        if(!file_exists($dir)) &#123;</div><div class=\"line\">            mkdir($dir, 0766, true);</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if(!is_writable($dir)) &#123;</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">            if(!@is_writable($dir)) &#123;</div><div class=\"line\">                throw new BusinessLogicException(&quot;目录不可写&quot;, $dir);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    generateIcon_mobile();</div><div class=\"line\">?&gt;</div><div class=\"line\"> </div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;title&gt;&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\"> </div><div class=\"line\">&lt;div&gt;我们直接引入所生成的js文件，测试一下是否成功&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div&gt;直接在img标签里加入 icon-data = &apos;图标文件名&apos;  例如  &lt;\\img icon-data=&quot;tryit&quot;&gt;,查看效果&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">    &lt;img icon-data=&quot;tryit&quot;&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/icon_pink.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/jquery.all.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/attrHandle.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>然后这里附上属性转换的JS代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(function()&#123;</div><div class=\"line\">    setIconData();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">function setIconData() &#123;</div><div class=\"line\">    if (typeof($iconData != &apos;undefined&apos;)) &#123;</div><div class=\"line\">        $(&apos;img[icon-data]&apos;).each(function() &#123;</div><div class=\"line\">            var self = $(this);</div><div class=\"line\">            var name = self.attr(&apos;icon-data&apos;);</div><div class=\"line\">            if (typeof($iconData[name]) != &apos;undefined&apos;) &#123;</div><div class=\"line\">                self.attr(&apos;src&apos;, $iconData[name]);</div><div class=\"line\">                self.removeAttr(&apos;icon-data&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(function()&#123;</div><div class=\"line\">    setIconData();</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">function setIconData() &#123;</div><div class=\"line\">    if (typeof($iconData != &apos;undefined&apos;)) &#123;</div><div class=\"line\">        $(&apos;img[icon-data]&apos;).each(function() &#123;</div><div class=\"line\">            var self = $(this);</div><div class=\"line\">            var name = self.attr(&apos;icon-data&apos;);</div><div class=\"line\">            if (typeof($iconData[name]) != &apos;undefined&apos;) &#123;</div><div class=\"line\">                self.attr(&apos;src&apos;, $iconData[name]);</div><div class=\"line\">                self.removeAttr(&apos;icon-data&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong><em>五、实现效果</em></strong></p>\n<p>这是页面输入效果，小图标正常显示出来了</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求2.jpg\" alt=\"图片\"></p>\n<p>这里我们自动生成的JS文件是这样子的格式：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求3.jpg\" alt=\"图片\"></p>\n<p>页面调用的代码：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求4.jpg\" alt=\"图片\"></p>\n<p>JS对img的icon-data属性转换处理的代码：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求5.jpg\" alt=\"图片\"></p>\n<p>我们对比下用base64编码和不用base64时所花费的时间：</p>\n<p>先看不用的速度</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求6.jpg\" alt=\"图片\"></p>\n<p>再看我们用了base64编码的速度　　　</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求7.jpg\" alt=\"图片\"></p>\n<p>假如一个页面有很多小图标，那么这种方式对网站的性能优化会有大大的提升。如今此种优化方案是用在我现在的项目中移动端，而上一篇博文讲解的生成背景图的优化方案用在我们项目中的PC端。优化效果是很明显的！当然了，base64编码这种方法也可以用在PC端，我们的项目为啥将它用在手机端，本博文开头部分也有对其做解释。这里测试我就直接在PC端测试，手机端测试也是一个样的。</p>\n<p>这里我补充一点：</p>\n<p>（1）所生成的base64的js文件是在开发中就生成的了，而不是在用户访问时才去生成，我把HTML代码和PHP代码写在一个文件里是方便，在真实项目中是分开的；</p>\n<p>（2）使用此种优化技术有它的优点，当然也会有它的缺点，只有适合自己项目的优化技术才是好技术；</p>\n<p>（3）此中优化技术建议使用在手机端（可以解决背景图优化方式所不能解决的问题），而PC端的则用合并小图标生成背景图的方式（看此文：<a href=\"http://www.cnblogs.com/it-cen/p/4618954.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/it-cen/p/4618954.html</a>）；</p>\n<p>（4）此种优化技术一般用于小图标（十几K以下），也就是HTTP响应时间远远大于下载时间的时候，用此方法优化会看到明显的效果；</p>\n<p>（5）当然可以配合其他优化技术一起使用，效果更明显，比如缓存等。</p>\n<p>这一次就分享那么多给大家，代码我都贴上了，而且很多都标上了注释，方便大家理解。</p>\n<p>如果此博文中有哪里讲得让人难以理解，欢迎留言交流，若有讲解错的地方欢迎指出。</p>\n<p>如果您觉得您能在此博文学到了新知识，请为我顶一个，如文章中有解释错的地方，欢迎指出。</p>\n<p>互相学习，共同进步！</p>\n","excerpt":"","more":"<p>在网站开发过程中，对于页面的加载效率一般都想尽办法求快。那么，怎么让才能更快呢？减少页面请求是一个优化页面加载速度很好的方法。这一篇博文将讲解“将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片”。</p>\n<p><strong><em>一、为何选择将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片的方法减少HTTP请求数？</em></strong></p>\n<p>为什么我会讲解 “将图片转成二进制并生成Base64编码,可以在网页中通过url查看图片” 这一种方式来减少HTTP请求，进而优化页面呢？这里呢，是涉及到移动端的图标使用。上一篇博文所讲的方法能否使用于手机端的网页呢？</p>\n<p>但是，它会出现一个问题：背景图+css显示图标时，图标本身无法缩放，比如背景图中64px<em>64px的图标，显示到界面时必须设置icon的大小也是64</em>64。在PC网页中这通常不会有什么问题，但在移动端设备上就完全行不通。同样是4英寸的手机屏幕，其分辨率有可能是320<em>400，也可能是640</em>800，甚至也可能是1920<em>1080。这样64px</em>64px的图标在不同的设备上看起来的大小就会差别非常明显。</p>\n<p>幸运的是，手机上的浏览器基本对此做了优化，会把设备模拟成更低的分辨率。比如在1136*640的IPHONE 5中获取$(window).width(),取出来的是320而不是640，这样一个宽度为160px的图片占用的是屏幕宽度的一半，而不是1/4。手机设备这样处理是为了解决兼容性问题。除了网页，包括手机上app的界面，在retina屏幕上和非retina屏幕上的大小是完全一样的，都是因为对分辨率做了处理。</p>\n<p>但是，移动设备这样的处理方式并不能完全解决问题，因为机器的假设性猜测在很多时候是不合适的，尤其是在android设备中。为了更好地控制元素显示的大小，解决的办法就是用pt代替ps，px是对应屏幕的分辨率，而pt是针对人眼睛实际感觉的大小，无论在何种分辨率的设备上，72pt固定是1英寸。</p>\n<p>HTML的img标签元素的src属性不只是可以指定url，也可以指定图片的二进制数据流。然后通过img元素的自动缩放功能，指定img的大小，就可以实现在不同分辨率的设备上显示一致的图标大小。</p>\n<p><strong><em>二、使用Base64编码减少页面请求数</em></strong></p>\n<p>当我们的一个页面中要传入很多图片时，特别是一些小图标，十几K、几K，甚至是字节级别大小的小图标，这些小图标都会增加HTTP请求，假如多了，就会给服务器带来很大的压力。比如要下载一些一两K大的小图标，其实请求时带上的额外信息有可能比图标的大小还要大。所以，在请求越多时，在网络传输的数据自然就越多了，传输的数据自然也就变慢了。而这里，我们采用Base64的编码方式将图片直接嵌入到网页中，而不是从外部载入，这样就减少了HTTP请求。当然了，它有一个小缺点，就是使当前页面的大小变大了（对于优化来说，其实这个可以忽略，影响不大）。看一下下图，小图标大小为2.4k，等待响应时间是14ms，而接受数据，也就是下载时间约为0ms；可想而知，在有大量小图标下载的时候，这样的方式去优化能大大提高网站的性能（在jquery mobile和天猫的手机站上面都有用到此技术）。</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求1.jpg\" alt=\"图片\"></p>\n<p><strong><em>三、开发思路</em></strong></p>\n<p>将小图标放在以icon_开头的文件夹里（以区分不用生成base64的图片的文件夹）—&gt;用程序去遍历文件夹图片 —&gt;将每张图片的base64编码放在一个js对象里—&gt;在HTML页面的img标签里 使用属性 icon-data = ‘图标名(不带后缀)’来显示图片 —&gt; JS文件写一个函数对icon-data属性进行转换，转换成src属性，然后值就通过icon-data的属性值获得图标名，然后进行相应的替换得到相应图标的base64编码 —&gt; 显示图片</p>\n<p>四、代码实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">    $pathinfo = pathinfo($_SERVER[&apos;SCRIPT_FILENAME&apos;]);</div><div class=\"line\">    define(&apos;ROOT&apos;, $pathinfo[&apos;dirname&apos;]);</div><div class=\"line\"></div><div class=\"line\">    function generateIcon_mobile() &#123;</div><div class=\"line\">        $imgRoot = ROOT.&quot;/img/mobile&quot;;</div><div class=\"line\">        $iterator = new DirectoryIterator($imgRoot);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue; </div><div class=\"line\">            $filename = $file-&gt;getFilename();</div><div class=\"line\"></div><div class=\"line\">            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理</div><div class=\"line\">            if ($file-&gt;isDir() &amp;&amp; 0 === strncasecmp(&apos;icon_&apos;, $filename, 5)) &#123;</div><div class=\"line\">                generateIconMobileCallback(&quot;$imgRoot/$filename&quot;, ROOT.&quot;/js/mobile&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function generateIconMobileCallback($iconDir, $styleSaveDir) &#123;</div><div class=\"line\">        //保存成js的文件名</div><div class=\"line\">        $saveName = array_pop(explode(&apos;/&apos;, $iconDir));</div><div class=\"line\">        //JS文件保存路径</div><div class=\"line\">        $styleSavePath = $styleSaveDir.&apos;/&apos;.$saveName.&apos;.js&apos;;</div><div class=\"line\"></div><div class=\"line\">        //将当前目录下的所有文件及MD5组成一个识别字符串</div><div class=\"line\">        $fileMap = array();</div><div class=\"line\">        $iterator = new DirectoryIterator($iconDir);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue;</div><div class=\"line\">            $fileName = $file-&gt;getFilename();</div><div class=\"line\">            if ($file-&gt;isDir()) &#123;</div><div class=\"line\">                generateIconMobileCallback($iconDir.&apos;/&apos;.$fileName, $styleSaveDir.&apos;/&apos;.$fileName);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                $fileMap[$fileName] = md5_file($file-&gt;getRealPath());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ksort($fileMap);</div><div class=\"line\">        $fileMapStr = json_encode($fileMap);</div><div class=\"line\"></div><div class=\"line\">        //确保目录可写</div><div class=\"line\">        ensure_writable_dir($styleSaveDir);</div><div class=\"line\"></div><div class=\"line\">        //js文件句柄</div><div class=\"line\">        $wirteHandle = fopen($styleSavePath, &apos;w&apos;);</div><div class=\"line\">        //当前小图标文件夹的相对路径</div><div class=\"line\">        $iconSaveRelative = substr($iconDir, strlen(ROOT));</div><div class=\"line\">        //写入，初始化保存数据的对象</div><div class=\"line\">        fwrite($wirteHandle, &quot;/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == &apos;undefined&apos;) \\$iconData=&#123;&#125;;&quot;);</div><div class=\"line\">        foreach ($fileMap as $fileName =&gt; $md5) &#123;</div><div class=\"line\">            //当前图片的绝对路径</div><div class=\"line\">            $fullPathName = &quot;$iconDir/$fileName&quot;;</div><div class=\"line\">            //取得路径信息</div><div class=\"line\">            $pathInfo = pathinfo($fullPathName);</div><div class=\"line\">            //取得文件名（没有后缀）</div><div class=\"line\">            $fileNameNoExt = $pathInfo[&apos;filename&apos;];</div><div class=\"line\">            //取得图片信息</div><div class=\"line\">            $imageSize = getimagesize($fullPathName);</div><div class=\"line\"></div><div class=\"line\">            //取得文件的后缀</div><div class=\"line\">            switch ($imageSize[2]) &#123;</div><div class=\"line\">                case IMAGETYPE_GIF:</div><div class=\"line\">                    $imageType = &apos;gif&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_JPEG:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_PNG:</div><div class=\"line\">                    $imageType = &apos;png&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\"></div><div class=\"line\">                default:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            //取得图片资源</div><div class=\"line\">            $readHandle = fopen($fullPathName, &apos;r&apos;);</div><div class=\"line\">            //将图片转成二进制并生成Base64编码</div><div class=\"line\">            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));</div><div class=\"line\">            //关闭资源</div><div class=\"line\">            fclose($readHandle);</div><div class=\"line\">            //将Base64编码写入js文件中</div><div class=\"line\">            fwrite($wirteHandle, &quot;\\n\\$iconData.$fileNameNoExt=\\&quot;data:image/$imageType;base64,$base64\\&quot;;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //最后换个行</div><div class=\"line\">        fwrite($wirteHandle, &quot;\\n&quot;);</div><div class=\"line\">        //关闭资源</div><div class=\"line\">        fclose($wirteHandle); </div><div class=\"line\"></div><div class=\"line\">        //处理成功的图标文件夹给予提示</div><div class=\"line\">        echo &apos;&lt;p&gt;&apos;.$iconSaveRelative. &apos; saved&lt;/p&gt;&apos;;  </div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    /**</div><div class=\"line\">    * 确保文件夹存在并可写</div><div class=\"line\">    *</div><div class=\"line\">    * @param string $dir</div><div class=\"line\">    */</div><div class=\"line\">    function ensure_writable_dir($dir) &#123;</div><div class=\"line\">        if(!file_exists($dir)) &#123;</div><div class=\"line\">            mkdir($dir, 0766, true);</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if(!is_writable($dir)) &#123;</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">            if(!@is_writable($dir)) &#123;</div><div class=\"line\">                throw new BusinessLogicException(&quot;目录不可写&quot;, $dir);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    generateIcon_mobile();</div><div class=\"line\">?&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;title&gt;&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;div&gt;我们直接引入所生成的js文件，测试一下是否成功&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div&gt;直接在img标签里加入 icon-data = &apos;图标文件名&apos;  例如  &lt;\\img icon-data=&quot;tryit&quot;&gt;,查看效果&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">    &lt;img icon-data=&quot;tryit&quot;&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/icon_pink.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/jquery.all.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/attrHandle.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;?php</div><div class=\"line\">    $pathinfo = pathinfo($_SERVER[&apos;SCRIPT_FILENAME&apos;]);</div><div class=\"line\">    define(&apos;ROOT&apos;, $pathinfo[&apos;dirname&apos;]);</div><div class=\"line\"> </div><div class=\"line\">    function generateIcon_mobile() &#123;</div><div class=\"line\">        $imgRoot = ROOT.&quot;/img/mobile&quot;;</div><div class=\"line\">        $iterator = new DirectoryIterator($imgRoot);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue; </div><div class=\"line\">            $filename = $file-&gt;getFilename();</div><div class=\"line\"> </div><div class=\"line\">            //识别出是否以icon_开头的文件夹，如果是，则对此文件夹的图标进行base64编码处理</div><div class=\"line\">            if ($file-&gt;isDir() &amp;&amp; 0 === strncasecmp(&apos;icon_&apos;, $filename, 5)) &#123;</div><div class=\"line\">                generateIconMobileCallback(&quot;$imgRoot/$filename&quot;, ROOT.&quot;/js/mobile&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    function generateIconMobileCallback($iconDir, $styleSaveDir) &#123;</div><div class=\"line\">        //保存成js的文件名</div><div class=\"line\">        $saveName = array_pop(explode(&apos;/&apos;, $iconDir));</div><div class=\"line\">        //JS文件保存路径</div><div class=\"line\">        $styleSavePath = $styleSaveDir.&apos;/&apos;.$saveName.&apos;.js&apos;;</div><div class=\"line\"> </div><div class=\"line\">        //将当前目录下的所有文件及MD5组成一个识别字符串</div><div class=\"line\">        $fileMap = array();</div><div class=\"line\">        $iterator = new DirectoryIterator($iconDir);</div><div class=\"line\">        foreach ($iterator as $file) &#123;</div><div class=\"line\">            if ($file-&gt;isDot()) continue;</div><div class=\"line\">            $fileName = $file-&gt;getFilename();</div><div class=\"line\">            if ($file-&gt;isDir()) &#123;</div><div class=\"line\">                generateIconMobileCallback($iconDir.&apos;/&apos;.$fileName, $styleSaveDir.&apos;/&apos;.$fileName);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                $fileMap[$fileName] = md5_file($file-&gt;getRealPath());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ksort($fileMap);</div><div class=\"line\">        $fileMapStr = json_encode($fileMap);</div><div class=\"line\"> </div><div class=\"line\">        //确保目录可写</div><div class=\"line\">        ensure_writable_dir($styleSaveDir);</div><div class=\"line\"> </div><div class=\"line\">        //js文件句柄</div><div class=\"line\">        $wirteHandle = fopen($styleSavePath, &apos;w&apos;);</div><div class=\"line\">        //当前小图标文件夹的相对路径</div><div class=\"line\">        $iconSaveRelative = substr($iconDir, strlen(ROOT));</div><div class=\"line\">        //写入，初始化保存数据的对象</div><div class=\"line\">        fwrite($wirteHandle, &quot;/** icon in dir: $iconSaveRelative/ */ \\nif(typeof(\\$iconData) == &apos;undefined&apos;) \\$iconData=&#123;&#125;;&quot;);</div><div class=\"line\">        foreach ($fileMap as $fileName =&gt; $md5) &#123;</div><div class=\"line\">            //当前图片的绝对路径</div><div class=\"line\">            $fullPathName = &quot;$iconDir/$fileName&quot;;</div><div class=\"line\">            //取得路径信息</div><div class=\"line\">            $pathInfo = pathinfo($fullPathName);</div><div class=\"line\">            //取得文件名（没有后缀）</div><div class=\"line\">            $fileNameNoExt = $pathInfo[&apos;filename&apos;];</div><div class=\"line\">            //取得图片信息</div><div class=\"line\">            $imageSize = getimagesize($fullPathName);</div><div class=\"line\"> </div><div class=\"line\">            //取得文件的后缀</div><div class=\"line\">            switch ($imageSize[2]) &#123;</div><div class=\"line\">                case IMAGETYPE_GIF:</div><div class=\"line\">                    $imageType = &apos;gif&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_JPEG:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">                case IMAGETYPE_PNG:</div><div class=\"line\">                    $imageType = &apos;png&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\"> </div><div class=\"line\">                default:</div><div class=\"line\">                    $imageType = &apos;jpg&apos;;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\"> </div><div class=\"line\">            //取得图片资源</div><div class=\"line\">            $readHandle = fopen($fullPathName, &apos;r&apos;);</div><div class=\"line\">            //将图片转成二进制并生成Base64编码</div><div class=\"line\">            $base64 = base64_encode(fread($readHandle, filesize($fullPathName)));</div><div class=\"line\">            //关闭资源</div><div class=\"line\">            fclose($readHandle);</div><div class=\"line\">            //将Base64编码写入js文件中</div><div class=\"line\">            fwrite($wirteHandle, &quot;\\n\\$iconData.$fileNameNoExt=\\&quot;data:image/$imageType;base64,$base64\\&quot;;&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        //最后换个行</div><div class=\"line\">        fwrite($wirteHandle, &quot;\\n&quot;);</div><div class=\"line\">        //关闭资源</div><div class=\"line\">        fclose($wirteHandle); </div><div class=\"line\"> </div><div class=\"line\">        //处理成功的图标文件夹给予提示</div><div class=\"line\">        echo &apos;&lt;p&gt;&apos;.$iconSaveRelative. &apos; saved&lt;/p&gt;&apos;;  </div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    /**</div><div class=\"line\">    * 确保文件夹存在并可写</div><div class=\"line\">    *</div><div class=\"line\">    * @param string $dir</div><div class=\"line\">    */</div><div class=\"line\">    function ensure_writable_dir($dir) &#123;</div><div class=\"line\">        if(!file_exists($dir)) &#123;</div><div class=\"line\">            mkdir($dir, 0766, true);</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if(!is_writable($dir)) &#123;</div><div class=\"line\">            @chmod($dir, 0766);</div><div class=\"line\">            @chmod($dir, 0777);</div><div class=\"line\">            if(!@is_writable($dir)) &#123;</div><div class=\"line\">                throw new BusinessLogicException(&quot;目录不可写&quot;, $dir);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    generateIcon_mobile();</div><div class=\"line\">?&gt;</div><div class=\"line\"> </div><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">    &lt;title&gt;&lt;/title&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\"> </div><div class=\"line\">&lt;div&gt;我们直接引入所生成的js文件，测试一下是否成功&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;div&gt;直接在img标签里加入 icon-data = &apos;图标文件名&apos;  例如  &lt;\\img icon-data=&quot;tryit&quot;&gt;,查看效果&lt;/div&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">&lt;br&gt;</div><div class=\"line\">    &lt;img icon-data=&quot;tryit&quot;&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/icon_pink.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/jquery.all.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">    &lt;script src=&quot;js/mobile/attrHandle.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<p>然后这里附上属性转换的JS代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$(function()&#123;</div><div class=\"line\">    setIconData();</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">function setIconData() &#123;</div><div class=\"line\">    if (typeof($iconData != &apos;undefined&apos;)) &#123;</div><div class=\"line\">        $(&apos;img[icon-data]&apos;).each(function() &#123;</div><div class=\"line\">            var self = $(this);</div><div class=\"line\">            var name = self.attr(&apos;icon-data&apos;);</div><div class=\"line\">            if (typeof($iconData[name]) != &apos;undefined&apos;) &#123;</div><div class=\"line\">                self.attr(&apos;src&apos;, $iconData[name]);</div><div class=\"line\">                self.removeAttr(&apos;icon-data&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$(function()&#123;</div><div class=\"line\">    setIconData();</div><div class=\"line\">&#125;);</div><div class=\"line\"> </div><div class=\"line\">function setIconData() &#123;</div><div class=\"line\">    if (typeof($iconData != &apos;undefined&apos;)) &#123;</div><div class=\"line\">        $(&apos;img[icon-data]&apos;).each(function() &#123;</div><div class=\"line\">            var self = $(this);</div><div class=\"line\">            var name = self.attr(&apos;icon-data&apos;);</div><div class=\"line\">            if (typeof($iconData[name]) != &apos;undefined&apos;) &#123;</div><div class=\"line\">                self.attr(&apos;src&apos;, $iconData[name]);</div><div class=\"line\">                self.removeAttr(&apos;icon-data&apos;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong><em>五、实现效果</em></strong></p>\n<p>这是页面输入效果，小图标正常显示出来了</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求2.jpg\" alt=\"图片\"></p>\n<p>这里我们自动生成的JS文件是这样子的格式：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求3.jpg\" alt=\"图片\"></p>\n<p>页面调用的代码：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求4.jpg\" alt=\"图片\"></p>\n<p>JS对img的icon-data属性转换处理的代码：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求5.jpg\" alt=\"图片\"></p>\n<p>我们对比下用base64编码和不用base64时所花费的时间：</p>\n<p>先看不用的速度</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求6.jpg\" alt=\"图片\"></p>\n<p>再看我们用了base64编码的速度　　　</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/减少HTTP请求7.jpg\" alt=\"图片\"></p>\n<p>假如一个页面有很多小图标，那么这种方式对网站的性能优化会有大大的提升。如今此种优化方案是用在我现在的项目中移动端，而上一篇博文讲解的生成背景图的优化方案用在我们项目中的PC端。优化效果是很明显的！当然了，base64编码这种方法也可以用在PC端，我们的项目为啥将它用在手机端，本博文开头部分也有对其做解释。这里测试我就直接在PC端测试，手机端测试也是一个样的。</p>\n<p>这里我补充一点：</p>\n<p>（1）所生成的base64的js文件是在开发中就生成的了，而不是在用户访问时才去生成，我把HTML代码和PHP代码写在一个文件里是方便，在真实项目中是分开的；</p>\n<p>（2）使用此种优化技术有它的优点，当然也会有它的缺点，只有适合自己项目的优化技术才是好技术；</p>\n<p>（3）此中优化技术建议使用在手机端（可以解决背景图优化方式所不能解决的问题），而PC端的则用合并小图标生成背景图的方式（看此文：<a href=\"http://www.cnblogs.com/it-cen/p/4618954.html\">http://www.cnblogs.com/it-cen/p/4618954.html</a>）；</p>\n<p>（4）此种优化技术一般用于小图标（十几K以下），也就是HTTP响应时间远远大于下载时间的时候，用此方法优化会看到明显的效果；</p>\n<p>（5）当然可以配合其他优化技术一起使用，效果更明显，比如缓存等。</p>\n<p>这一次就分享那么多给大家，代码我都贴上了，而且很多都标上了注释，方便大家理解。</p>\n<p>如果此博文中有哪里讲得让人难以理解，欢迎留言交流，若有讲解错的地方欢迎指出。</p>\n<p>如果您觉得您能在此博文学到了新知识，请为我顶一个，如文章中有解释错的地方，欢迎指出。</p>\n<p>互相学习，共同进步！</p>\n"},{"title":"别人家的面试题：统计“1”的个数","date":"2016-05-31T16:00:00.000Z","_content":"\n小胡子哥[@Barret李靖](http://weibo.com/173248656?is_all=1)给我推荐了一个写算法刷题的地方[leetcode.com](https://leetcode.com/)，没有[ACM](http://acm.zju.edu.cn/)那么难，但题目很有趣。而且据说这些题目都来源于一些公司的面试题。好吧，解解别人公司的面试题其实很好玩，既能整理思路锻炼能力，又不用担心漏题 ╮(╯▽╰)╭。\n\n长话短说，让我们来看[一道题](https://leetcode.com/problems/counting-bits/)：\n\n### 统计“1”的个数\n\n给定一个非负整数num，对于任意i，0 ≤ i ≤ num，计算i的值对应的二进制数中“1” 的个数，将这些结果返回为一个数组。\n\n例如：\n\n当num = 5时，返回值为[0,1,1,2,1,2]。\n\n```javascript\n/** \n  * @param {number} num \n  * @return {number[]} \n  * /\nvar countBits = function(num) {\n\t//在此处实现代码\n};\n```\n\n### 解题思路\n\n这道题咋一看还挺简单的，无非是：\n\n- 实现一个方法`countBit`，对任意非负整数n，计算它的二进制数中“1”的个数\n- 循环i从0到num，求`countBit(i)`，将值放在数组中返回。\n\nJavaScript中，计算`countBit`可以取巧：\n\n```javascript\nfunction countBit(n){\n\treturn n.toString(2).replace(/0/g,\"\").length;\n} \n```\n\n上面的代码里，我们直接对n用toString(2)转成二进制表示的字符串，然后去掉其中的0，剩下的就是“1”的个数。\n\n然后，我们写一下完整的程序：\n\n```javascript\nfunction countBit(n){\n\treturn n.toString(2).replace(/0/g,'').length;\n}\nfunction countBits(nums){\n\tvar ret = [];   \n\tfor(var i = 0; i <= nums; i++){\n    \tret.push(countBit(i));\n    }\n\treturn ret;\n} \n```\n\n上面这种写法十分讨巧，好处是`countBit`利用JavaScript语言特性实现得十分简洁，坏处是如果将来要将它改写成其他语言的版本，就有可能懵B了，它不是很通用，而且它的性能还取决于Number.prototype.toString(2)和String.prototype.replace的实现。\n\n所以为了追求更好的写法，我们有必要考虑一下`countBit`的通用实现法。\n\n我们说，求一个整数的二进制表示中“1”的个数，最普通的当然是一个O(logN) 的方法：\n\n```javascript\nfunction countBit(n){\n\tvar ret = 0;\n    while(n > 0){\n    \tret += n & 1;\n        n >>= 1;\n    }\n    return ret;\n}\n```\n\n这么实现也很简洁不是吗？但是这么实现是否最优？建议此处思考10秒钟再往下看。\n\n------\n\n### 更快的countBit\n\n上一个版本的`countBit`的时间复杂度已经是O(logN) 了，难道还可以更快吗？当然是可以的，我们不需要去判断每一位是不是“1”，也能知道n的二进制中有几个“1”。\n\n有一个诀窍，是基于以下一个定律：\n\n- 对于任意 n， n ≥ 1，有如下等式成立：\n\n```javascript\ncountBit(n & (n - 1)) === countBit(n) - 1\n```\n\n这个很容易理解，大家只要想一下，对于任意n，n – 1的二进制数表示正好是n的二进制数的最末一个“1”退位，因此n & n – 1正好将n的最末一位“1”消去，例如：\n\n- **6**的二进制数是110， **5 = 6 – 1**的二进制数是101，`6 & 5`的二进制数是`110 & 101 == 100`\n- **88**的二进制数是1011000，**87 = 88 – 1**的二进制数是 1010111，`88 & 87的二进制数是1011000 & 1010111 == 1010000`\n\n于是，我们有了一个更快的算法：\n\n```javascript\nfunction countBit(n){\n\tvar ret = 0;\n    while(n > 0){\n    \tret++;\n        n &= n - 1;\n    }\n    return ret;\n}\nfunction countBits(nums){\n\tvar ret = [];\n    for(var i = 0; i <= nums; i++){\n    \tret.push(countBit(i));\n    }\n    return ret;\n}\n```\n\n上面的`countBit(88)`只循环3次，而上一版本的`countBit(88)`却需要循环7次。\n\n优化到了这个程度，是不是一切都结束了呢？从算法上来说似乎已经是极致了？真的吗？再给大家 30 秒时间思考一下，然后再往下看。\n\n------\n\n### countBits的时间复杂度\n\n考虑`countBits`， 上面的算法：\n\n- 最初版本的时间复杂度是O(N*M)，M取决于Number.prototype.toString和String.prototype.replace的复杂度。\n- 第二版本的时间复杂度是O(N*logN)\n- 最后版本的时间复杂度是O(N*M)，M是N的二进制数中的“1”的个数，介于1 ~ logN之间。\n\n上面三个版本的`countBits`的时间复杂度都大于O(N)。那么有没有时间复杂度O(N)的算法呢？\n\n实际上，最后版本已经为我们提示了答案，答案就在上面的那个定律里，我把那个等式再写一遍：\n\n```javascript\ncountBit(n & (n - 1)) === countBit(n) - 1\n```\n\n也就是说，如果我们知道了`countBit(n & (n - 1))`，那么我们也就知道了`countBit(n)`！\n\n而我们知道`countBit(0)`的值是 0，于是，我们可以很简单的递推：\n\n```javascript\nfunction countBits(nums){\n\tvar ret = [0];\n    for(var i = 1; i <= nums; i++){\n    \tret.push(ret[i & i - 1] + 1);\n    }\n    return ret;\n}\n```\n\n原来就这么简单，你想到了吗 ╮(╯▽╰)╭\n\n以上就是所有的内容，简单的题目思考起来很有意思吧？程序员就应该追求完美的算法，不是吗？\n\n转载整理自：[http://web.jobbole.com](http://web.jobbole.com/86266/)","source":"_posts/别人家的面试题：统计“1”的个数.md","raw":"---\ntitle: 别人家的面试题：统计“1”的个数\ntags: [javascript]\ndate: 2016/06/01\n---\n\n小胡子哥[@Barret李靖](http://weibo.com/173248656?is_all=1)给我推荐了一个写算法刷题的地方[leetcode.com](https://leetcode.com/)，没有[ACM](http://acm.zju.edu.cn/)那么难，但题目很有趣。而且据说这些题目都来源于一些公司的面试题。好吧，解解别人公司的面试题其实很好玩，既能整理思路锻炼能力，又不用担心漏题 ╮(╯▽╰)╭。\n\n长话短说，让我们来看[一道题](https://leetcode.com/problems/counting-bits/)：\n\n### 统计“1”的个数\n\n给定一个非负整数num，对于任意i，0 ≤ i ≤ num，计算i的值对应的二进制数中“1” 的个数，将这些结果返回为一个数组。\n\n例如：\n\n当num = 5时，返回值为[0,1,1,2,1,2]。\n\n```javascript\n/** \n  * @param {number} num \n  * @return {number[]} \n  * /\nvar countBits = function(num) {\n\t//在此处实现代码\n};\n```\n\n### 解题思路\n\n这道题咋一看还挺简单的，无非是：\n\n- 实现一个方法`countBit`，对任意非负整数n，计算它的二进制数中“1”的个数\n- 循环i从0到num，求`countBit(i)`，将值放在数组中返回。\n\nJavaScript中，计算`countBit`可以取巧：\n\n```javascript\nfunction countBit(n){\n\treturn n.toString(2).replace(/0/g,\"\").length;\n} \n```\n\n上面的代码里，我们直接对n用toString(2)转成二进制表示的字符串，然后去掉其中的0，剩下的就是“1”的个数。\n\n然后，我们写一下完整的程序：\n\n```javascript\nfunction countBit(n){\n\treturn n.toString(2).replace(/0/g,'').length;\n}\nfunction countBits(nums){\n\tvar ret = [];   \n\tfor(var i = 0; i <= nums; i++){\n    \tret.push(countBit(i));\n    }\n\treturn ret;\n} \n```\n\n上面这种写法十分讨巧，好处是`countBit`利用JavaScript语言特性实现得十分简洁，坏处是如果将来要将它改写成其他语言的版本，就有可能懵B了，它不是很通用，而且它的性能还取决于Number.prototype.toString(2)和String.prototype.replace的实现。\n\n所以为了追求更好的写法，我们有必要考虑一下`countBit`的通用实现法。\n\n我们说，求一个整数的二进制表示中“1”的个数，最普通的当然是一个O(logN) 的方法：\n\n```javascript\nfunction countBit(n){\n\tvar ret = 0;\n    while(n > 0){\n    \tret += n & 1;\n        n >>= 1;\n    }\n    return ret;\n}\n```\n\n这么实现也很简洁不是吗？但是这么实现是否最优？建议此处思考10秒钟再往下看。\n\n------\n\n### 更快的countBit\n\n上一个版本的`countBit`的时间复杂度已经是O(logN) 了，难道还可以更快吗？当然是可以的，我们不需要去判断每一位是不是“1”，也能知道n的二进制中有几个“1”。\n\n有一个诀窍，是基于以下一个定律：\n\n- 对于任意 n， n ≥ 1，有如下等式成立：\n\n```javascript\ncountBit(n & (n - 1)) === countBit(n) - 1\n```\n\n这个很容易理解，大家只要想一下，对于任意n，n – 1的二进制数表示正好是n的二进制数的最末一个“1”退位，因此n & n – 1正好将n的最末一位“1”消去，例如：\n\n- **6**的二进制数是110， **5 = 6 – 1**的二进制数是101，`6 & 5`的二进制数是`110 & 101 == 100`\n- **88**的二进制数是1011000，**87 = 88 – 1**的二进制数是 1010111，`88 & 87的二进制数是1011000 & 1010111 == 1010000`\n\n于是，我们有了一个更快的算法：\n\n```javascript\nfunction countBit(n){\n\tvar ret = 0;\n    while(n > 0){\n    \tret++;\n        n &= n - 1;\n    }\n    return ret;\n}\nfunction countBits(nums){\n\tvar ret = [];\n    for(var i = 0; i <= nums; i++){\n    \tret.push(countBit(i));\n    }\n    return ret;\n}\n```\n\n上面的`countBit(88)`只循环3次，而上一版本的`countBit(88)`却需要循环7次。\n\n优化到了这个程度，是不是一切都结束了呢？从算法上来说似乎已经是极致了？真的吗？再给大家 30 秒时间思考一下，然后再往下看。\n\n------\n\n### countBits的时间复杂度\n\n考虑`countBits`， 上面的算法：\n\n- 最初版本的时间复杂度是O(N*M)，M取决于Number.prototype.toString和String.prototype.replace的复杂度。\n- 第二版本的时间复杂度是O(N*logN)\n- 最后版本的时间复杂度是O(N*M)，M是N的二进制数中的“1”的个数，介于1 ~ logN之间。\n\n上面三个版本的`countBits`的时间复杂度都大于O(N)。那么有没有时间复杂度O(N)的算法呢？\n\n实际上，最后版本已经为我们提示了答案，答案就在上面的那个定律里，我把那个等式再写一遍：\n\n```javascript\ncountBit(n & (n - 1)) === countBit(n) - 1\n```\n\n也就是说，如果我们知道了`countBit(n & (n - 1))`，那么我们也就知道了`countBit(n)`！\n\n而我们知道`countBit(0)`的值是 0，于是，我们可以很简单的递推：\n\n```javascript\nfunction countBits(nums){\n\tvar ret = [0];\n    for(var i = 1; i <= nums; i++){\n    \tret.push(ret[i & i - 1] + 1);\n    }\n    return ret;\n}\n```\n\n原来就这么简单，你想到了吗 ╮(╯▽╰)╭\n\n以上就是所有的内容，简单的题目思考起来很有意思吧？程序员就应该追求完美的算法，不是吗？\n\n转载整理自：[http://web.jobbole.com](http://web.jobbole.com/86266/)","slug":"别人家的面试题：统计“1”的个数","published":1,"updated":"2016-08-17T06:22:19.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cplj004168ddineqj9ox","content":"<p>小胡子哥<a href=\"http://weibo.com/173248656?is_all=1\" target=\"_blank\" rel=\"external\">@Barret李靖</a>给我推荐了一个写算法刷题的地方<a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"external\">leetcode.com</a>，没有<a href=\"http://acm.zju.edu.cn/\" target=\"_blank\" rel=\"external\">ACM</a>那么难，但题目很有趣。而且据说这些题目都来源于一些公司的面试题。好吧，解解别人公司的面试题其实很好玩，既能整理思路锻炼能力，又不用担心漏题 ╮(╯▽╰)╭。</p>\n<p>长话短说，让我们来看<a href=\"https://leetcode.com/problems/counting-bits/\" target=\"_blank\" rel=\"external\">一道题</a>：</p>\n<h3 id=\"统计“1”的个数\"><a href=\"#统计“1”的个数\" class=\"headerlink\" title=\"统计“1”的个数\"></a>统计“1”的个数</h3><p>给定一个非负整数num，对于任意i，0 ≤ i ≤ num，计算i的值对应的二进制数中“1” 的个数，将这些结果返回为一个数组。</p>\n<p>例如：</p>\n<p>当num = 5时，返回值为[0,1,1,2,1,2]。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** </span></div><div class=\"line\">  * @param &#123;number&#125; num </div><div class=\"line\">  * @return &#123;number[]&#125; </div><div class=\"line\">  * /</div><div class=\"line\">var countBits = function(num) &#123;</div><div class=\"line\">\t//在此处实现代码</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题咋一看还挺简单的，无非是：</p>\n<ul>\n<li>实现一个方法<code>countBit</code>，对任意非负整数n，计算它的二进制数中“1”的个数</li>\n<li>循环i从0到num，求<code>countBit(i)</code>，将值放在数组中返回。</li>\n</ul>\n<p>JavaScript中，计算<code>countBit</code>可以取巧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> n.toString(<span class=\"number\">2</span>).replace(<span class=\"regexp\">/0/g</span>,<span class=\"string\">\"\"</span>).length;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码里，我们直接对n用toString(2)转成二进制表示的字符串，然后去掉其中的0，剩下的就是“1”的个数。</p>\n<p>然后，我们写一下完整的程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> n.toString(<span class=\"number\">2</span>).replace(<span class=\"regexp\">/0/g</span>,<span class=\"string\">''</span>).length;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [];   </div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(countBit(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种写法十分讨巧，好处是<code>countBit</code>利用JavaScript语言特性实现得十分简洁，坏处是如果将来要将它改写成其他语言的版本，就有可能懵B了，它不是很通用，而且它的性能还取决于Number.prototype.toString(2)和String.prototype.replace的实现。</p>\n<p>所以为了追求更好的写法，我们有必要考虑一下<code>countBit</code>的通用实现法。</p>\n<p>我们说，求一个整数的二进制表示中“1”的个数，最普通的当然是一个O(logN) 的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    \tret += n &amp; <span class=\"number\">1</span>;</div><div class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这么实现也很简洁不是吗？但是这么实现是否最优？建议此处思考10秒钟再往下看。</p>\n<hr>\n<h3 id=\"更快的countBit\"><a href=\"#更快的countBit\" class=\"headerlink\" title=\"更快的countBit\"></a>更快的countBit</h3><p>上一个版本的<code>countBit</code>的时间复杂度已经是O(logN) 了，难道还可以更快吗？当然是可以的，我们不需要去判断每一位是不是“1”，也能知道n的二进制中有几个“1”。</p>\n<p>有一个诀窍，是基于以下一个定律：</p>\n<ul>\n<li>对于任意 n， n ≥ 1，有如下等式成立：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">countBit(n &amp; (n - <span class=\"number\">1</span>)) === countBit(n) - <span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>这个很容易理解，大家只要想一下，对于任意n，n – 1的二进制数表示正好是n的二进制数的最末一个“1”退位，因此n &amp; n – 1正好将n的最末一位“1”消去，例如：</p>\n<ul>\n<li><strong>6</strong>的二进制数是110， <strong>5 = 6 – 1</strong>的二进制数是101，<code>6 &amp; 5</code>的二进制数是<code>110 &amp; 101 == 100</code></li>\n<li><strong>88</strong>的二进制数是1011000，<strong>87 = 88 – 1</strong>的二进制数是 1010111，<code>88 &amp; 87的二进制数是1011000 &amp; 1010111 == 1010000</code></li>\n</ul>\n<p>于是，我们有了一个更快的算法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    \tret++;</div><div class=\"line\">        n &amp;= n - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(countBit(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的<code>countBit(88)</code>只循环3次，而上一版本的<code>countBit(88)</code>却需要循环7次。</p>\n<p>优化到了这个程度，是不是一切都结束了呢？从算法上来说似乎已经是极致了？真的吗？再给大家 30 秒时间思考一下，然后再往下看。</p>\n<hr>\n<h3 id=\"countBits的时间复杂度\"><a href=\"#countBits的时间复杂度\" class=\"headerlink\" title=\"countBits的时间复杂度\"></a>countBits的时间复杂度</h3><p>考虑<code>countBits</code>， 上面的算法：</p>\n<ul>\n<li>最初版本的时间复杂度是O(N*M)，M取决于Number.prototype.toString和String.prototype.replace的复杂度。</li>\n<li>第二版本的时间复杂度是O(N*logN)</li>\n<li>最后版本的时间复杂度是O(N*M)，M是N的二进制数中的“1”的个数，介于1 ~ logN之间。</li>\n</ul>\n<p>上面三个版本的<code>countBits</code>的时间复杂度都大于O(N)。那么有没有时间复杂度O(N)的算法呢？</p>\n<p>实际上，最后版本已经为我们提示了答案，答案就在上面的那个定律里，我把那个等式再写一遍：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">countBit(n &amp; (n - <span class=\"number\">1</span>)) === countBit(n) - <span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>也就是说，如果我们知道了<code>countBit(n &amp; (n - 1))</code>，那么我们也就知道了<code>countBit(n)</code>！</p>\n<p>而我们知道<code>countBit(0)</code>的值是 0，于是，我们可以很简单的递推：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(ret[i &amp; i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原来就这么简单，你想到了吗 ╮(╯▽╰)╭</p>\n<p>以上就是所有的内容，简单的题目思考起来很有意思吧？程序员就应该追求完美的算法，不是吗？</p>\n<p>转载整理自：<a href=\"http://web.jobbole.com/86266/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<p>小胡子哥<a href=\"http://weibo.com/173248656?is_all=1\">@Barret李靖</a>给我推荐了一个写算法刷题的地方<a href=\"https://leetcode.com/\">leetcode.com</a>，没有<a href=\"http://acm.zju.edu.cn/\">ACM</a>那么难，但题目很有趣。而且据说这些题目都来源于一些公司的面试题。好吧，解解别人公司的面试题其实很好玩，既能整理思路锻炼能力，又不用担心漏题 ╮(╯▽╰)╭。</p>\n<p>长话短说，让我们来看<a href=\"https://leetcode.com/problems/counting-bits/\">一道题</a>：</p>\n<h3 id=\"统计“1”的个数\"><a href=\"#统计“1”的个数\" class=\"headerlink\" title=\"统计“1”的个数\"></a>统计“1”的个数</h3><p>给定一个非负整数num，对于任意i，0 ≤ i ≤ num，计算i的值对应的二进制数中“1” 的个数，将这些结果返回为一个数组。</p>\n<p>例如：</p>\n<p>当num = 5时，返回值为[0,1,1,2,1,2]。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/** </div><div class=\"line\">  * @param &#123;number&#125; num </div><div class=\"line\">  * @return &#123;number[]&#125; </div><div class=\"line\">  * /</div><div class=\"line\">var countBits = function(num) &#123;</div><div class=\"line\">\t//在此处实现代码</div><div class=\"line\">&#125;;</span></div></pre></td></tr></table></figure>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>这道题咋一看还挺简单的，无非是：</p>\n<ul>\n<li>实现一个方法<code>countBit</code>，对任意非负整数n，计算它的二进制数中“1”的个数</li>\n<li>循环i从0到num，求<code>countBit(i)</code>，将值放在数组中返回。</li>\n</ul>\n<p>JavaScript中，计算<code>countBit</code>可以取巧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> n.toString(<span class=\"number\">2</span>).replace(<span class=\"regexp\">/0/g</span>,<span class=\"string\">\"\"</span>).length;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码里，我们直接对n用toString(2)转成二进制表示的字符串，然后去掉其中的0，剩下的就是“1”的个数。</p>\n<p>然后，我们写一下完整的程序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> n.toString(<span class=\"number\">2</span>).replace(<span class=\"regexp\">/0/g</span>,<span class=\"string\">''</span>).length;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [];   </div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(countBit(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这种写法十分讨巧，好处是<code>countBit</code>利用JavaScript语言特性实现得十分简洁，坏处是如果将来要将它改写成其他语言的版本，就有可能懵B了，它不是很通用，而且它的性能还取决于Number.prototype.toString(2)和String.prototype.replace的实现。</p>\n<p>所以为了追求更好的写法，我们有必要考虑一下<code>countBit</code>的通用实现法。</p>\n<p>我们说，求一个整数的二进制表示中“1”的个数，最普通的当然是一个O(logN) 的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    \tret += n &amp; <span class=\"number\">1</span>;</div><div class=\"line\">        n &gt;&gt;= <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这么实现也很简洁不是吗？但是这么实现是否最优？建议此处思考10秒钟再往下看。</p>\n<hr>\n<h3 id=\"更快的countBit\"><a href=\"#更快的countBit\" class=\"headerlink\" title=\"更快的countBit\"></a>更快的countBit</h3><p>上一个版本的<code>countBit</code>的时间复杂度已经是O(logN) 了，难道还可以更快吗？当然是可以的，我们不需要去判断每一位是不是“1”，也能知道n的二进制中有几个“1”。</p>\n<p>有一个诀窍，是基于以下一个定律：</p>\n<ul>\n<li>对于任意 n， n ≥ 1，有如下等式成立：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">countBit(n &amp; (n - <span class=\"number\">1</span>)) === countBit(n) - <span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>这个很容易理解，大家只要想一下，对于任意n，n – 1的二进制数表示正好是n的二进制数的最末一个“1”退位，因此n &amp; n – 1正好将n的最末一位“1”消去，例如：</p>\n<ul>\n<li><strong>6</strong>的二进制数是110， <strong>5 = 6 – 1</strong>的二进制数是101，<code>6 &amp; 5</code>的二进制数是<code>110 &amp; 101 == 100</code></li>\n<li><strong>88</strong>的二进制数是1011000，<strong>87 = 88 – 1</strong>的二进制数是 1010111，<code>88 &amp; 87的二进制数是1011000 &amp; 1010111 == 1010000</code></li>\n</ul>\n<p>于是，我们有了一个更快的算法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBit</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    \tret++;</div><div class=\"line\">        n &amp;= n - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(countBit(i));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的<code>countBit(88)</code>只循环3次，而上一版本的<code>countBit(88)</code>却需要循环7次。</p>\n<p>优化到了这个程度，是不是一切都结束了呢？从算法上来说似乎已经是极致了？真的吗？再给大家 30 秒时间思考一下，然后再往下看。</p>\n<hr>\n<h3 id=\"countBits的时间复杂度\"><a href=\"#countBits的时间复杂度\" class=\"headerlink\" title=\"countBits的时间复杂度\"></a>countBits的时间复杂度</h3><p>考虑<code>countBits</code>， 上面的算法：</p>\n<ul>\n<li>最初版本的时间复杂度是O(N*M)，M取决于Number.prototype.toString和String.prototype.replace的复杂度。</li>\n<li>第二版本的时间复杂度是O(N*logN)</li>\n<li>最后版本的时间复杂度是O(N*M)，M是N的二进制数中的“1”的个数，介于1 ~ logN之间。</li>\n</ul>\n<p>上面三个版本的<code>countBits</code>的时间复杂度都大于O(N)。那么有没有时间复杂度O(N)的算法呢？</p>\n<p>实际上，最后版本已经为我们提示了答案，答案就在上面的那个定律里，我把那个等式再写一遍：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">countBit(n &amp; (n - <span class=\"number\">1</span>)) === countBit(n) - <span class=\"number\">1</span></div></pre></td></tr></table></figure>\n<p>也就是说，如果我们知道了<code>countBit(n &amp; (n - 1))</code>，那么我们也就知道了<code>countBit(n)</code>！</p>\n<p>而我们知道<code>countBit(0)</code>的值是 0，于是，我们可以很简单的递推：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countBits</span>(<span class=\"params\">nums</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> ret = [<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= nums; i++)&#123;</div><div class=\"line\">    \tret.push(ret[i &amp; i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原来就这么简单，你想到了吗 ╮(╯▽╰)╭</p>\n<p>以上就是所有的内容，简单的题目思考起来很有意思吧？程序员就应该追求完美的算法，不是吗？</p>\n<p>转载整理自：<a href=\"http://web.jobbole.com/86266/\">http://web.jobbole.com</a></p>\n"},{"title":"切片式图片切换效果","date":"2015-02-09T16:00:00.000Z","_content":"\n今天刷CSDN论坛，突然想做一个切片式的图片切换效果，所以，试着就写了一下，代码如下，演示[点击这里](https://jsfiddle.net/Lionney/4t6adL39/)\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t\n</head>\n<body>\n\t<style type=\"text/css\">\n\t.display{\n\t\twidth: 650px;\n\t}\n\t.block{\n\t\tfloat: left;\n\t\tmargin: 2px;\n\t\twidth: 126px;\n\t\theight: 90px;\n\t\tbackground: url(img/blank.jpg) no-repeat;\n\t\tbackground-position:1000px 1000px;\n\t\ttransition: all 1s;\n\t}\n\t.block.trans{\n\t\tmargin: 0px;\n\t}\n\t</style>\n\t\n\t<div class=\"display\"></div>\n\t<a href=\"javascript:next();\">next</a>\n\t\n\t<script type=\"text/javascript\" src=\"http://libs.useso.com/js/jquery/1.11.1/jquery.min.js\"></script>\n\t<script type=\"text/javascript\">\n\tvar wBase=126;//切片的宽度\n\tvar hBase=90;//切片的高度\n\tvar count=0;//遍历计数器\n\tvar x=0;//图片的x坐标\n\tvar y=0;//图片的y坐标\n\tvar imgUrl=\"img/img.jpg\";//图片地址\n\tvar i=1;//demo使用，为了展现两张图片切换效果\n\tvar divBlock = '<div class=\"block\"></div>';\n\t\n\tfor (var k = 0; k < 20; k++) {\n\t\t$('.display').append(divBlock);\n\t}\n\t\n\tvar blocks=$('.block');//收集所有切片\n\t\n\tfunction loadImg(){\n\t\t//如果所有切片加载完毕，边距设置为0，并停止计时器，并初始化计数器\n\t\tif(count==20){\n\t\t\tblocks.css({\n\t\t\t\t'margin': '0px'\n\t\t\t});\n\t\t\tcount=0;\n\t\t\tclearInterval(time);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(count!=0 && count%5==0){\n\t\t\t//不为第一张切片并且一行处理完毕，x坐标清零，y坐标增加一个切片高度\n\t\t\tx=0;\n\t\t\ty+=hBase;\n\t\t}else{\n\t\t\t//否则，y坐标不变，x坐标增加一个切片宽度\n\t\t\tx+=wBase;\n\t\t}\n\t\t\n\t\t//如果为第一个切片，说明刚刚开始加载图片，所以，边距设置为2，并初始化坐标\n\t\tif(count==0){\n\t\t\tblocks.css({\n\t\t\t\t'margin': '2px'\n\t\t\t});\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t}\n\t\t\n\t\tblocks.eq(count).css({\n\t\t\t'background-image': 'url('+imgUrl+')',\n\t\t\t'background-position': (x*-1)+'px '+(y*-1)+'px'\n\t\t});\n\t\t\n\t\tcount++;\n\t}\n\t\n\tvar time=setInterval(loadImg,100);\n\t\n\t//下一张事件函数\n\tfunction next(){\n\t\tif(i>0){\n\t\t\timgUrl=\"img/_cat.jpg\";\n\t\t}else{\n\t\t\timgUrl=\"img/img.jpg\";\n\t\t}\n\t\ti*=-1;\n\t\tblocks.css({\n\t\t\t'background-position': wBase+'px '+hBase+'px'\n\t\t});\n\t\ttime=setInterval(loadImg,100);\n\t}\n\t</script>\n</body>\n</html>\n```\n","source":"_posts/切片式图片切换效果.md","raw":"---\ntitle: 切片式图片切换效果\ntags: [html,javascript]\ndate: 2015/02/10\n---\n\n今天刷CSDN论坛，突然想做一个切片式的图片切换效果，所以，试着就写了一下，代码如下，演示[点击这里](https://jsfiddle.net/Lionney/4t6adL39/)\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t\n</head>\n<body>\n\t<style type=\"text/css\">\n\t.display{\n\t\twidth: 650px;\n\t}\n\t.block{\n\t\tfloat: left;\n\t\tmargin: 2px;\n\t\twidth: 126px;\n\t\theight: 90px;\n\t\tbackground: url(img/blank.jpg) no-repeat;\n\t\tbackground-position:1000px 1000px;\n\t\ttransition: all 1s;\n\t}\n\t.block.trans{\n\t\tmargin: 0px;\n\t}\n\t</style>\n\t\n\t<div class=\"display\"></div>\n\t<a href=\"javascript:next();\">next</a>\n\t\n\t<script type=\"text/javascript\" src=\"http://libs.useso.com/js/jquery/1.11.1/jquery.min.js\"></script>\n\t<script type=\"text/javascript\">\n\tvar wBase=126;//切片的宽度\n\tvar hBase=90;//切片的高度\n\tvar count=0;//遍历计数器\n\tvar x=0;//图片的x坐标\n\tvar y=0;//图片的y坐标\n\tvar imgUrl=\"img/img.jpg\";//图片地址\n\tvar i=1;//demo使用，为了展现两张图片切换效果\n\tvar divBlock = '<div class=\"block\"></div>';\n\t\n\tfor (var k = 0; k < 20; k++) {\n\t\t$('.display').append(divBlock);\n\t}\n\t\n\tvar blocks=$('.block');//收集所有切片\n\t\n\tfunction loadImg(){\n\t\t//如果所有切片加载完毕，边距设置为0，并停止计时器，并初始化计数器\n\t\tif(count==20){\n\t\t\tblocks.css({\n\t\t\t\t'margin': '0px'\n\t\t\t});\n\t\t\tcount=0;\n\t\t\tclearInterval(time);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(count!=0 && count%5==0){\n\t\t\t//不为第一张切片并且一行处理完毕，x坐标清零，y坐标增加一个切片高度\n\t\t\tx=0;\n\t\t\ty+=hBase;\n\t\t}else{\n\t\t\t//否则，y坐标不变，x坐标增加一个切片宽度\n\t\t\tx+=wBase;\n\t\t}\n\t\t\n\t\t//如果为第一个切片，说明刚刚开始加载图片，所以，边距设置为2，并初始化坐标\n\t\tif(count==0){\n\t\t\tblocks.css({\n\t\t\t\t'margin': '2px'\n\t\t\t});\n\t\t\tx=0;\n\t\t\ty=0;\n\t\t}\n\t\t\n\t\tblocks.eq(count).css({\n\t\t\t'background-image': 'url('+imgUrl+')',\n\t\t\t'background-position': (x*-1)+'px '+(y*-1)+'px'\n\t\t});\n\t\t\n\t\tcount++;\n\t}\n\t\n\tvar time=setInterval(loadImg,100);\n\t\n\t//下一张事件函数\n\tfunction next(){\n\t\tif(i>0){\n\t\t\timgUrl=\"img/_cat.jpg\";\n\t\t}else{\n\t\t\timgUrl=\"img/img.jpg\";\n\t\t}\n\t\ti*=-1;\n\t\tblocks.css({\n\t\t\t'background-position': wBase+'px '+hBase+'px'\n\t\t});\n\t\ttime=setInterval(loadImg,100);\n\t}\n\t</script>\n</body>\n</html>\n```\n","slug":"切片式图片切换效果","published":1,"updated":"2016-08-17T06:22:19.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpll004468dd7kbpk6ec","content":"<p>今天刷CSDN论坛，突然想做一个切片式的图片切换效果，所以，试着就写了一下，代码如下，演示<a href=\"https://jsfiddle.net/Lionney/4t6adL39/\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">\t</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">\t&lt;style type=&quot;text/css&quot;&gt;</div><div class=\"line\">\t.display&#123;</div><div class=\"line\">\t\twidth: 650px;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t.block&#123;</div><div class=\"line\">\t\tfloat: left;</div><div class=\"line\">\t\tmargin: 2px;</div><div class=\"line\">\t\twidth: 126px;</div><div class=\"line\">\t\theight: 90px;</div><div class=\"line\">\t\tbackground: url(img/blank.jpg) no-repeat;</div><div class=\"line\">\t\tbackground-position:1000px 1000px;</div><div class=\"line\">\t\ttransition: all 1s;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t.block.trans&#123;</div><div class=\"line\">\t\tmargin: 0px;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/style&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;div class=&quot;display&quot;&gt;&lt;/div&gt;</div><div class=\"line\">\t&lt;a href=&quot;javascript:next();&quot;&gt;next&lt;/a&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;script type=&quot;text/javascript&quot; src=&quot;http://libs.useso.com/js/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">\tvar wBase=126;//切片的宽度</div><div class=\"line\">\tvar hBase=90;//切片的高度</div><div class=\"line\">\tvar count=0;//遍历计数器</div><div class=\"line\">\tvar x=0;//图片的x坐标</div><div class=\"line\">\tvar y=0;//图片的y坐标</div><div class=\"line\">\tvar imgUrl=&quot;img/img.jpg&quot;;//图片地址</div><div class=\"line\">\tvar i=1;//demo使用，为了展现两张图片切换效果</div><div class=\"line\">\tvar divBlock = &apos;&lt;div class=&quot;block&quot;&gt;&lt;/div&gt;&apos;;</div><div class=\"line\">\t</div><div class=\"line\">\tfor (var k = 0; k &lt; 20; k++) &#123;</div><div class=\"line\">\t\t$(&apos;.display&apos;).append(divBlock);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar blocks=$(&apos;.block&apos;);//收集所有切片</div><div class=\"line\">\t</div><div class=\"line\">\tfunction loadImg()&#123;</div><div class=\"line\">\t\t//如果所有切片加载完毕，边距设置为0，并停止计时器，并初始化计数器</div><div class=\"line\">\t\tif(count==20)&#123;</div><div class=\"line\">\t\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t\t&apos;margin&apos;: &apos;0px&apos;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tcount=0;</div><div class=\"line\">\t\t\tclearInterval(time);</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tif(count!=0 &amp;&amp; count%5==0)&#123;</div><div class=\"line\">\t\t\t//不为第一张切片并且一行处理完毕，x坐标清零，y坐标增加一个切片高度</div><div class=\"line\">\t\t\tx=0;</div><div class=\"line\">\t\t\ty+=hBase;</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t//否则，y坐标不变，x坐标增加一个切片宽度</div><div class=\"line\">\t\t\tx+=wBase;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//如果为第一个切片，说明刚刚开始加载图片，所以，边距设置为2，并初始化坐标</div><div class=\"line\">\t\tif(count==0)&#123;</div><div class=\"line\">\t\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t\t&apos;margin&apos;: &apos;2px&apos;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tx=0;</div><div class=\"line\">\t\t\ty=0;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tblocks.eq(count).css(&#123;</div><div class=\"line\">\t\t\t&apos;background-image&apos;: &apos;url(&apos;+imgUrl+&apos;)&apos;,</div><div class=\"line\">\t\t\t&apos;background-position&apos;: (x*-1)+&apos;px &apos;+(y*-1)+&apos;px&apos;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tcount++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar time=setInterval(loadImg,100);</div><div class=\"line\">\t</div><div class=\"line\">\t//下一张事件函数</div><div class=\"line\">\tfunction next()&#123;</div><div class=\"line\">\t\tif(i&gt;0)&#123;</div><div class=\"line\">\t\t\timgUrl=&quot;img/_cat.jpg&quot;;</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\timgUrl=&quot;img/img.jpg&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ti*=-1;</div><div class=\"line\">\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t&apos;background-position&apos;: wBase+&apos;px &apos;+hBase+&apos;px&apos;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\ttime=setInterval(loadImg,100);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>今天刷CSDN论坛，突然想做一个切片式的图片切换效果，所以，试着就写了一下，代码如下，演示<a href=\"https://jsfiddle.net/Lionney/4t6adL39/\">点击这里</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">\t</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">\t&lt;style type=&quot;text/css&quot;&gt;</div><div class=\"line\">\t.display&#123;</div><div class=\"line\">\t\twidth: 650px;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t.block&#123;</div><div class=\"line\">\t\tfloat: left;</div><div class=\"line\">\t\tmargin: 2px;</div><div class=\"line\">\t\twidth: 126px;</div><div class=\"line\">\t\theight: 90px;</div><div class=\"line\">\t\tbackground: url(img/blank.jpg) no-repeat;</div><div class=\"line\">\t\tbackground-position:1000px 1000px;</div><div class=\"line\">\t\ttransition: all 1s;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t.block.trans&#123;</div><div class=\"line\">\t\tmargin: 0px;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/style&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;div class=&quot;display&quot;&gt;&lt;/div&gt;</div><div class=\"line\">\t&lt;a href=&quot;javascript:next();&quot;&gt;next&lt;/a&gt;</div><div class=\"line\">\t</div><div class=\"line\">\t&lt;script type=&quot;text/javascript&quot; src=&quot;http://libs.useso.com/js/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">\t&lt;script type=&quot;text/javascript&quot;&gt;</div><div class=\"line\">\tvar wBase=126;//切片的宽度</div><div class=\"line\">\tvar hBase=90;//切片的高度</div><div class=\"line\">\tvar count=0;//遍历计数器</div><div class=\"line\">\tvar x=0;//图片的x坐标</div><div class=\"line\">\tvar y=0;//图片的y坐标</div><div class=\"line\">\tvar imgUrl=&quot;img/img.jpg&quot;;//图片地址</div><div class=\"line\">\tvar i=1;//demo使用，为了展现两张图片切换效果</div><div class=\"line\">\tvar divBlock = &apos;&lt;div class=&quot;block&quot;&gt;&lt;/div&gt;&apos;;</div><div class=\"line\">\t</div><div class=\"line\">\tfor (var k = 0; k &lt; 20; k++) &#123;</div><div class=\"line\">\t\t$(&apos;.display&apos;).append(divBlock);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar blocks=$(&apos;.block&apos;);//收集所有切片</div><div class=\"line\">\t</div><div class=\"line\">\tfunction loadImg()&#123;</div><div class=\"line\">\t\t//如果所有切片加载完毕，边距设置为0，并停止计时器，并初始化计数器</div><div class=\"line\">\t\tif(count==20)&#123;</div><div class=\"line\">\t\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t\t&apos;margin&apos;: &apos;0px&apos;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tcount=0;</div><div class=\"line\">\t\t\tclearInterval(time);</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tif(count!=0 &amp;&amp; count%5==0)&#123;</div><div class=\"line\">\t\t\t//不为第一张切片并且一行处理完毕，x坐标清零，y坐标增加一个切片高度</div><div class=\"line\">\t\t\tx=0;</div><div class=\"line\">\t\t\ty+=hBase;</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\t//否则，y坐标不变，x坐标增加一个切片宽度</div><div class=\"line\">\t\t\tx+=wBase;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t//如果为第一个切片，说明刚刚开始加载图片，所以，边距设置为2，并初始化坐标</div><div class=\"line\">\t\tif(count==0)&#123;</div><div class=\"line\">\t\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t\t&apos;margin&apos;: &apos;2px&apos;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t\tx=0;</div><div class=\"line\">\t\t\ty=0;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tblocks.eq(count).css(&#123;</div><div class=\"line\">\t\t\t&apos;background-image&apos;: &apos;url(&apos;+imgUrl+&apos;)&apos;,</div><div class=\"line\">\t\t\t&apos;background-position&apos;: (x*-1)+&apos;px &apos;+(y*-1)+&apos;px&apos;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\t</div><div class=\"line\">\t\tcount++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t</div><div class=\"line\">\tvar time=setInterval(loadImg,100);</div><div class=\"line\">\t</div><div class=\"line\">\t//下一张事件函数</div><div class=\"line\">\tfunction next()&#123;</div><div class=\"line\">\t\tif(i&gt;0)&#123;</div><div class=\"line\">\t\t\timgUrl=&quot;img/_cat.jpg&quot;;</div><div class=\"line\">\t\t&#125;else&#123;</div><div class=\"line\">\t\t\timgUrl=&quot;img/img.jpg&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\ti*=-1;</div><div class=\"line\">\t\tblocks.css(&#123;</div><div class=\"line\">\t\t\t&apos;background-position&apos;: wBase+&apos;px &apos;+hBase+&apos;px&apos;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\ttime=setInterval(loadImg,100);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&lt;/script&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n"},{"title":"前端开发指南","date":"2015-02-11T16:00:00.000Z","_content":"\n### 使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数\n把字符串解析为整数的时候，有个好习惯是指定第二个基数参数 -- 它会确定该字符串被转换成几进制。当字符串以 0 开头的时候，缺省情况下会触发 16 进制作为基数。大部分初级和中级用户只会用到 10 这个基数。 感谢 João Moreno 记录的这个 勘误。\n\n```\nalert( parseInt(\"08\") ); // alerts: 2\nalert( parseInt(\"08\", 10) ); // alerts: 8\n```\n\n### 避免比较 true 和 false\n\n直接比较 true 和 false 的值是没有必要的。有时候也许明确一下有好处，但它还是额外的代码。\n\n```\nif (foo === true) {\n    // 用了 === 倒是不错，可这是多余的\n}\nif (foo) {\n    // 赞！\n}\nif (!bar) {\n    // 反过来也赞\n}\n```\n\n### 避免污染全局命名空间\n\n```\n// 被污染的全局命名空间\nvar settingA = true;\nvar settingB = false;\nvar settingC = \"test\";\n\n// 用 settings 作为对象命名\nvar settings = {\n    settingA: true,\n    settingB: false,\n    settingC: \"test\"\n}\n```\n\n### 函数调用不要传输太多的参数\n\n对于可读性而不是其他因素来说，下面这种方式真是糟透了：\n\n```\nfunction greet(name, language, age, gender, hairColour, eyeColour) {\n    alert(name);\n}\n```\n\n下面的例子预先构建了一个对象作为参数，或者把内联对象传递过去，这样就好多了。\n\n```\nfunction greet(user) {\n    alert(user.name);\n}\n\ngreet({\n    name: \"Bob\",\n    gender: \"male\"\n});\n\n```\n\n### 检测特性，而不是检测浏览器类型\n\n来源：[http://coderlmn.github.io/Front-End-Development-Guidelines/](http://coderlmn.github.io/Front-End-Development-Guidelines/)\n","source":"_posts/前端开发指南.md","raw":"---\ntitle: 前端开发指南\ntags: [javascript]\ndate: 2015/02/12\n---\n\n### 使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数\n把字符串解析为整数的时候，有个好习惯是指定第二个基数参数 -- 它会确定该字符串被转换成几进制。当字符串以 0 开头的时候，缺省情况下会触发 16 进制作为基数。大部分初级和中级用户只会用到 10 这个基数。 感谢 João Moreno 记录的这个 勘误。\n\n```\nalert( parseInt(\"08\") ); // alerts: 2\nalert( parseInt(\"08\", 10) ); // alerts: 8\n```\n\n### 避免比较 true 和 false\n\n直接比较 true 和 false 的值是没有必要的。有时候也许明确一下有好处，但它还是额外的代码。\n\n```\nif (foo === true) {\n    // 用了 === 倒是不错，可这是多余的\n}\nif (foo) {\n    // 赞！\n}\nif (!bar) {\n    // 反过来也赞\n}\n```\n\n### 避免污染全局命名空间\n\n```\n// 被污染的全局命名空间\nvar settingA = true;\nvar settingB = false;\nvar settingC = \"test\";\n\n// 用 settings 作为对象命名\nvar settings = {\n    settingA: true,\n    settingB: false,\n    settingC: \"test\"\n}\n```\n\n### 函数调用不要传输太多的参数\n\n对于可读性而不是其他因素来说，下面这种方式真是糟透了：\n\n```\nfunction greet(name, language, age, gender, hairColour, eyeColour) {\n    alert(name);\n}\n```\n\n下面的例子预先构建了一个对象作为参数，或者把内联对象传递过去，这样就好多了。\n\n```\nfunction greet(user) {\n    alert(user.name);\n}\n\ngreet({\n    name: \"Bob\",\n    gender: \"male\"\n});\n\n```\n\n### 检测特性，而不是检测浏览器类型\n\n来源：[http://coderlmn.github.io/Front-End-Development-Guidelines/](http://coderlmn.github.io/Front-End-Development-Guidelines/)\n","slug":"前端开发指南","published":1,"updated":"2016-08-17T06:22:19.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cplp004668dd040szyss","content":"<h3 id=\"使用-parseInt-的时候，总是指定第二个-‘radix’-参数\"><a href=\"#使用-parseInt-的时候，总是指定第二个-‘radix’-参数\" class=\"headerlink\" title=\"使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数\"></a>使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数</h3><p>把字符串解析为整数的时候，有个好习惯是指定第二个基数参数 – 它会确定该字符串被转换成几进制。当字符串以 0 开头的时候，缺省情况下会触发 16 进制作为基数。大部分初级和中级用户只会用到 10 这个基数。 感谢 João Moreno 记录的这个 勘误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">alert( parseInt(&quot;08&quot;) ); // alerts: 2</div><div class=\"line\">alert( parseInt(&quot;08&quot;, 10) ); // alerts: 8</div></pre></td></tr></table></figure>\n<h3 id=\"避免比较-true-和-false\"><a href=\"#避免比较-true-和-false\" class=\"headerlink\" title=\"避免比较 true 和 false\"></a>避免比较 true 和 false</h3><p>直接比较 true 和 false 的值是没有必要的。有时候也许明确一下有好处，但它还是额外的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (foo === true) &#123;</div><div class=\"line\">    // 用了 === 倒是不错，可这是多余的</div><div class=\"line\">&#125;</div><div class=\"line\">if (foo) &#123;</div><div class=\"line\">    // 赞！</div><div class=\"line\">&#125;</div><div class=\"line\">if (!bar) &#123;</div><div class=\"line\">    // 反过来也赞</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"避免污染全局命名空间\"><a href=\"#避免污染全局命名空间\" class=\"headerlink\" title=\"避免污染全局命名空间\"></a>避免污染全局命名空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 被污染的全局命名空间</div><div class=\"line\">var settingA = true;</div><div class=\"line\">var settingB = false;</div><div class=\"line\">var settingC = &quot;test&quot;;</div><div class=\"line\"></div><div class=\"line\">// 用 settings 作为对象命名</div><div class=\"line\">var settings = &#123;</div><div class=\"line\">    settingA: true,</div><div class=\"line\">    settingB: false,</div><div class=\"line\">    settingC: &quot;test&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数调用不要传输太多的参数\"><a href=\"#函数调用不要传输太多的参数\" class=\"headerlink\" title=\"函数调用不要传输太多的参数\"></a>函数调用不要传输太多的参数</h3><p>对于可读性而不是其他因素来说，下面这种方式真是糟透了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function greet(name, language, age, gender, hairColour, eyeColour) &#123;</div><div class=\"line\">    alert(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子预先构建了一个对象作为参数，或者把内联对象传递过去，这样就好多了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function greet(user) &#123;</div><div class=\"line\">    alert(user.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">greet(&#123;</div><div class=\"line\">    name: &quot;Bob&quot;,</div><div class=\"line\">    gender: &quot;male&quot;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"检测特性，而不是检测浏览器类型\"><a href=\"#检测特性，而不是检测浏览器类型\" class=\"headerlink\" title=\"检测特性，而不是检测浏览器类型\"></a>检测特性，而不是检测浏览器类型</h3><p>来源：<a href=\"http://coderlmn.github.io/Front-End-Development-Guidelines/\" target=\"_blank\" rel=\"external\">http://coderlmn.github.io/Front-End-Development-Guidelines/</a></p>\n","excerpt":"","more":"<h3 id=\"使用-parseInt-的时候，总是指定第二个-‘radix’-参数\"><a href=\"#使用-parseInt-的时候，总是指定第二个-‘radix’-参数\" class=\"headerlink\" title=\"使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数\"></a>使用 .parseInt() 的时候，总是指定第二个 ‘radix’ 参数</h3><p>把字符串解析为整数的时候，有个好习惯是指定第二个基数参数 – 它会确定该字符串被转换成几进制。当字符串以 0 开头的时候，缺省情况下会触发 16 进制作为基数。大部分初级和中级用户只会用到 10 这个基数。 感谢 João Moreno 记录的这个 勘误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">alert( parseInt(&quot;08&quot;) ); // alerts: 2</div><div class=\"line\">alert( parseInt(&quot;08&quot;, 10) ); // alerts: 8</div></pre></td></tr></table></figure>\n<h3 id=\"避免比较-true-和-false\"><a href=\"#避免比较-true-和-false\" class=\"headerlink\" title=\"避免比较 true 和 false\"></a>避免比较 true 和 false</h3><p>直接比较 true 和 false 的值是没有必要的。有时候也许明确一下有好处，但它还是额外的代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (foo === true) &#123;</div><div class=\"line\">    // 用了 === 倒是不错，可这是多余的</div><div class=\"line\">&#125;</div><div class=\"line\">if (foo) &#123;</div><div class=\"line\">    // 赞！</div><div class=\"line\">&#125;</div><div class=\"line\">if (!bar) &#123;</div><div class=\"line\">    // 反过来也赞</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"避免污染全局命名空间\"><a href=\"#避免污染全局命名空间\" class=\"headerlink\" title=\"避免污染全局命名空间\"></a>避免污染全局命名空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// 被污染的全局命名空间</div><div class=\"line\">var settingA = true;</div><div class=\"line\">var settingB = false;</div><div class=\"line\">var settingC = &quot;test&quot;;</div><div class=\"line\"></div><div class=\"line\">// 用 settings 作为对象命名</div><div class=\"line\">var settings = &#123;</div><div class=\"line\">    settingA: true,</div><div class=\"line\">    settingB: false,</div><div class=\"line\">    settingC: &quot;test&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数调用不要传输太多的参数\"><a href=\"#函数调用不要传输太多的参数\" class=\"headerlink\" title=\"函数调用不要传输太多的参数\"></a>函数调用不要传输太多的参数</h3><p>对于可读性而不是其他因素来说，下面这种方式真是糟透了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function greet(name, language, age, gender, hairColour, eyeColour) &#123;</div><div class=\"line\">    alert(name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子预先构建了一个对象作为参数，或者把内联对象传递过去，这样就好多了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function greet(user) &#123;</div><div class=\"line\">    alert(user.name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">greet(&#123;</div><div class=\"line\">    name: &quot;Bob&quot;,</div><div class=\"line\">    gender: &quot;male&quot;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"检测特性，而不是检测浏览器类型\"><a href=\"#检测特性，而不是检测浏览器类型\" class=\"headerlink\" title=\"检测特性，而不是检测浏览器类型\"></a>检测特性，而不是检测浏览器类型</h3><p>来源：<a href=\"http://coderlmn.github.io/Front-End-Development-Guidelines/\">http://coderlmn.github.io/Front-End-Development-Guidelines/</a></p>\n"},{"title":"取得文件扩展名","date":"2015-02-07T16:00:00.000Z","_content":"\n### 问题 1: 怎样取得文件扩展名?\n\n```\nvar file1 = \"50.xsl\";\nvar file2 = \"30.doc\";\ngetFileExtension(file1); //returs xsl\ngetFileExtension(file2); //returs doc\n\nfunction getFileExtension(filename) {\n  /*TODO*/\n}\n```\n\n**解决方法 1: 正则表达式**\n\n```\nfunction getFileExtension1(filename) {\n  return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;\n}\n```\n\n**解决方法 2: String的split方法**\n\n```\nfunction getFileExtension2(filename) {\n  return filename.split('.').pop();\n}\n```\n\n这两种解决方法不能解决一些边缘情况，这有另一个更加强大的解决方法。\n\n**解决方法 3: String的slice、lastIndexOf方法**\n\n```\nfunction getFileExtension3(filename) {\n  return filename.slice((filename.lastIndexOf(\".\") - 1 >>> 0) + 2);\n}\n\nconsole.log(getFileExtension3(''));                            // ''\nconsole.log(getFileExtension3('filename'));                    // ''\nconsole.log(getFileExtension3('filename.txt'));                // 'txt'   \nconsole.log(getFileExtension3('.hiddenfile'));                 // ''\nconsole.log(getFileExtension3('filename.with.many.dots.ext')); // 'ext'\n```\n\n### 这是如何实现的呢?\n\n`String.lastIndexOf()`方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回-1。\n\n对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»>) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。\n\n`String.prototype.slice()`从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为\"\"。\n\n### 对比\n\n| 解决方法                              | 参数                                       | 结果                                       |\n| :-------------------------------- | :--------------------------------------- | :--------------------------------------- |\n| 解决方法 1: Regular Expression        | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | undefined/undefined/‘txt’/‘hiddenfile’/‘ext’ |\n| 解决方法 2: String split              | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | ‘filename’/‘txt’/‘hiddenfile’/‘ext’      |\n| 解决方法 3: String slice, lastIndexOf | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | ‘’/‘txt’/‘’/‘ext’                        |\n","source":"_posts/取得文件扩展名.md","raw":"---\ntitle: 取得文件扩展名\ntags: [javascript]\ndate: 2015/02/08\n---\n\n### 问题 1: 怎样取得文件扩展名?\n\n```\nvar file1 = \"50.xsl\";\nvar file2 = \"30.doc\";\ngetFileExtension(file1); //returs xsl\ngetFileExtension(file2); //returs doc\n\nfunction getFileExtension(filename) {\n  /*TODO*/\n}\n```\n\n**解决方法 1: 正则表达式**\n\n```\nfunction getFileExtension1(filename) {\n  return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;\n}\n```\n\n**解决方法 2: String的split方法**\n\n```\nfunction getFileExtension2(filename) {\n  return filename.split('.').pop();\n}\n```\n\n这两种解决方法不能解决一些边缘情况，这有另一个更加强大的解决方法。\n\n**解决方法 3: String的slice、lastIndexOf方法**\n\n```\nfunction getFileExtension3(filename) {\n  return filename.slice((filename.lastIndexOf(\".\") - 1 >>> 0) + 2);\n}\n\nconsole.log(getFileExtension3(''));                            // ''\nconsole.log(getFileExtension3('filename'));                    // ''\nconsole.log(getFileExtension3('filename.txt'));                // 'txt'   \nconsole.log(getFileExtension3('.hiddenfile'));                 // ''\nconsole.log(getFileExtension3('filename.with.many.dots.ext')); // 'ext'\n```\n\n### 这是如何实现的呢?\n\n`String.lastIndexOf()`方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回-1。\n\n对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和-1无符号右移操作符(»>) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。\n\n`String.prototype.slice()`从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为\"\"。\n\n### 对比\n\n| 解决方法                              | 参数                                       | 结果                                       |\n| :-------------------------------- | :--------------------------------------- | :--------------------------------------- |\n| 解决方法 1: Regular Expression        | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | undefined/undefined/‘txt’/‘hiddenfile’/‘ext’ |\n| 解决方法 2: String split              | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | ‘filename’/‘txt’/‘hiddenfile’/‘ext’      |\n| 解决方法 3: String slice, lastIndexOf | ‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’ | ‘’/‘txt’/‘’/‘ext’                        |\n","slug":"取得文件扩展名","published":1,"updated":"2016-08-17T06:22:19.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cplr004968dd2876tyvx","content":"<h3 id=\"问题-1-怎样取得文件扩展名\"><a href=\"#问题-1-怎样取得文件扩展名\" class=\"headerlink\" title=\"问题 1: 怎样取得文件扩展名?\"></a>问题 1: 怎样取得文件扩展名?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var file1 = &quot;50.xsl&quot;;</div><div class=\"line\">var file2 = &quot;30.doc&quot;;</div><div class=\"line\">getFileExtension(file1); //returs xsl</div><div class=\"line\">getFileExtension(file2); //returs doc</div><div class=\"line\"></div><div class=\"line\">function getFileExtension(filename) &#123;</div><div class=\"line\">  /*TODO*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方法 1: 正则表达式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension1(filename) &#123;</div><div class=\"line\">  return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方法 2: String的split方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension2(filename) &#123;</div><div class=\"line\">  return filename.split(&apos;.&apos;).pop();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这两种解决方法不能解决一些边缘情况，这有另一个更加强大的解决方法。</p>\n<p><strong>解决方法 3: String的slice、lastIndexOf方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension3(filename) &#123;</div><div class=\"line\">  return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getFileExtension3(&apos;&apos;));                            // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename&apos;));                    // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename.txt&apos;));                // &apos;txt&apos;   </div><div class=\"line\">console.log(getFileExtension3(&apos;.hiddenfile&apos;));                 // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename.with.many.dots.ext&apos;)); // &apos;ext&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"这是如何实现的呢\"><a href=\"#这是如何实现的呢\" class=\"headerlink\" title=\"这是如何实现的呢?\"></a>这是如何实现的呢?</h3><p><code>String.lastIndexOf()</code>方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回-1。</p>\n<p>对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。</p>\n<p><code>String.prototype.slice()</code>从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">解决方法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">解决方法 1: Regular Expression</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">undefined/undefined/‘txt’/‘hiddenfile’/‘ext’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解决方法 2: String split</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">‘filename’/‘txt’/‘hiddenfile’/‘ext’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解决方法 3: String slice, lastIndexOf</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">‘’/‘txt’/‘’/‘ext’</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h3 id=\"问题-1-怎样取得文件扩展名\"><a href=\"#问题-1-怎样取得文件扩展名\" class=\"headerlink\" title=\"问题 1: 怎样取得文件扩展名?\"></a>问题 1: 怎样取得文件扩展名?</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var file1 = &quot;50.xsl&quot;;</div><div class=\"line\">var file2 = &quot;30.doc&quot;;</div><div class=\"line\">getFileExtension(file1); //returs xsl</div><div class=\"line\">getFileExtension(file2); //returs doc</div><div class=\"line\"></div><div class=\"line\">function getFileExtension(filename) &#123;</div><div class=\"line\">  /*TODO*/</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方法 1: 正则表达式</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension1(filename) &#123;</div><div class=\"line\">  return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方法 2: String的split方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension2(filename) &#123;</div><div class=\"line\">  return filename.split(&apos;.&apos;).pop();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这两种解决方法不能解决一些边缘情况，这有另一个更加强大的解决方法。</p>\n<p><strong>解决方法 3: String的slice、lastIndexOf方法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function getFileExtension3(filename) &#123;</div><div class=\"line\">  return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(getFileExtension3(&apos;&apos;));                            // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename&apos;));                    // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename.txt&apos;));                // &apos;txt&apos;   </div><div class=\"line\">console.log(getFileExtension3(&apos;.hiddenfile&apos;));                 // &apos;&apos;</div><div class=\"line\">console.log(getFileExtension3(&apos;filename.with.many.dots.ext&apos;)); // &apos;ext&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"这是如何实现的呢\"><a href=\"#这是如何实现的呢\" class=\"headerlink\" title=\"这是如何实现的呢?\"></a>这是如何实现的呢?</h3><p><code>String.lastIndexOf()</code>方法返回指定值（本例中的’.’）在调用该方法的字符串中最后出现的位置，如果没找到则返回-1。</p>\n<p>对于’filename’和’.hiddenfile’，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。</p>\n<p><code>String.prototype.slice()</code>从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为””。</p>\n<h3 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">解决方法</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">解决方法 1: Regular Expression</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">undefined/undefined/‘txt’/‘hiddenfile’/‘ext’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解决方法 2: String split</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">‘filename’/‘txt’/‘hiddenfile’/‘ext’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">解决方法 3: String slice, lastIndexOf</td>\n<td style=\"text-align:left\">‘filename’/‘filename.txt’/‘.hiddenfile’/‘filename.with.many.dots.ext’</td>\n<td style=\"text-align:left\">‘’/‘txt’/‘’/‘ext’</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"善用meta","date":"2015-02-05T16:00:00.000Z","_content":"\n## 前言\n\n在移动前端第一弹：viewport详解中，我们讲了viewport，那是一个关于meta的故事。这次我们会就将meta这个故事讲得更广阔、更有意思一些。\n\n写过HTML的童鞋，应该都对这个不陌生，或用它来定义页面编码，或用它来定义搜索引擎抓取方式，或用它定义页面关键字，描述等等。\n\n### meta列表\n\n好的meta使用，能更好地提高页面的可用性及被检索的几率。\n\n这里并不会列出所有的meta使用方式，只挑选一些常用及实际意义比较大的讲讲，当然也包括一些厂商私有定制的。\n\n## 常规\n\n### 声明文档使用的字符编码\n\n```\n<meta charset=\"utf-8\" />\n```\n\n该声明用来指定文档的编码，除了utf-8，可选值还有：ISO-8859-1、BIG5、iso-8859-2, iso-2022-jp, iso-2022-kr, gb2312等\n\n当然，你可能还见过使用另外一种方式来定义文档字符编码：\n\n```\n<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n```\n\n相对于这种方式，更推荐你使用第1种，言外之意，就是推荐使用HTML5。\n\n### 声明页面刷新或跳转\n\n```\n<meta http-equiv=\"refresh\" content=\"10\" />\n<meta http-equiv=\"refresh\" content=\"10; url=http://www.doyoe.com\" />\n```\n\n该声明用来指定页面自刷新或者跳转到其它页面，其中的时间单位是s。\n\n### 声明页面过期时间\n\n```\n<meta http-equiv=\"expires\" content=\"0\" />\n<meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08:21:57 GMT\" />\n```\n\n该声明用来指定页面的过期时间，一旦网页过期，从服务器上重新请求，其中时间必须使用GMT格式，或者直接是0（即不缓存）\n\n### 声明页面是否缓存\n\n```\n<meta http-equiv=\"pragma\" content=\"no-cache\" />\n<meta http-equiv=\"cache-control\" content=\"no-cache\" />\n```\n\n上述语句都可以用来指定文档不被缓存。一些仍然在使用HTTP/1.0的可以使用第1条，第2条由HTTP/1.1提供，常用值还有：public, no-cache, no-store等\n\n### 声明作者信息\n\n```\n<meta name=\"author\" content=\"joy, dooyoe@gmail.com\" />\n```\n\n### 声明文档关键字\n\n```\n<meta name=\"keywords\" content=\"CSS, HTML, JavaScript, 前端\" />\n```\n\n多关键字之间以半角逗号分隔\n\n### 声明文档描述\n\n```\n<meta name=\"description\" content=\"这是一份meta列表\" />\n```\n\n文档描述内容最好是完整的一句话，以不超过50个字符为宜\n\n### 声明使用的浏览器及版本\n\nx-ua-compatible设置是从IE8开始增加的（很明显，只适用于IE），对于过往的版本无法识别。\n开发者可以通过设置x-ua-compatible来指定渲染引擎的类型和版本，并且因为需求不同可以有多种不同的设置：\n\n**Case1:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=7\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=4\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=xx\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=50\" />\n```\n\n+ 当直接指定content为IE的某个具体版本，如上述代码第1条，客户端的IE将会使用IE7.0标准模式对页面进行渲染，并忽略Doctype定义。\n+ 当指定的IE版本在客户端IE中不存在时，IE将会尝试将该值转换为最为接近的版本。\n> 例如指定一个错误的或者低于5.0的IE版本，如上述代码第2，3条，客户端的IE将会使用IE5.0对页面进行渲染，由于IE5.0并没有标准模式，所以将会直接使用quirks mode来渲染；\n> 如果指定一个大于客户端IE的版本，如上述代码第4条，假定客户端IE的最高版本为9.0，那么IE会将该值转换为IE=9，即使用IE9.0标准模式对页面进行渲染。\n\n**Case2:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=EmulateIE7\" />\n```\n\n当指定的content值加了Emulate前缀时，如上述代码，客户端IE将会根据Doctype定义来决定如何来对页面进行渲染。假设页面使用了标准的Doctype，那么此定义效果等同Case1；假设页面并没有使用标准的Doctype，那么将使用quirks mode来渲染。\n\n**Case3:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=Edge\" />\n```\n\n当指定的content值为IE=Edge时，如上述代码，客户端的IE将会使用最高的标准模式对页面进行渲染。\n\n**Case4:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=7, 10, 11\" />\n```\n\n当指定的content值有多个版本时，如上述代码，假定客户端IE版本为8.0或者9.0，则使用IE7.0标准模式对页面进行渲染；假定客户端IE版本为10.0或者11.0，则直接使用对应版本的标准模式对页面进行渲染。\n\n**Case5:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=Edge, chrome=1\" />\n```\n\n当指定的content值为IE=Edge, chrome=1时，如上述代码，假定客户端安装了Google Chrome Frame，则在IE中使用chrome的渲染引擎来渲染页面，否则，将会使用客户端IE最高的标准模式对页面进行渲染。\n\n### 声明搜索引擎抓取方式\n\n```\n<meta name=\"robots\" content=\"index\" />\n```\n\n通知搜索引擎文档是否需要被索引。可选值有：\n\n+ all（默认值，索引当前页并跟踪链接，相当于：index, follow）\n+ none（忽略当前页，相当于：noindex, nofollow）\n+ index（索引当前页）\n+ noindex（不索引当前页）\n+ follow（跟踪当前页链接，不论当前页是否被索引）\n+ nofollow（不跟踪当前页链接，不论当前页是否被索引）\n\n如果声明冲突，某些引擎可能会做严格处理：\n\n```\n<meta name=\"robots\" content=\"noindex\" />\n<meta name=\"robots\" content=\"index\" />\n```\n\n类似上述代码，在Google引擎中，会执行noindex这个更为严格的声明。\n\n需要注意的是并不是所有搜索引擎都支持robots meta，比较保守的做法是配合robots.txt使用。\n\n### 声明搜索引擎抓取间隔\n\n```\n<meta name=\"revisit-after\" content=\"10 days\" />\n```\n\n有时候你可能并不希望站点一直被搜索引擎抓取，而是每间隔一段时间才来访问一次，这时，可以声明revisit-after meta。\n\n## 移动\n\n### 声明viewport视口\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" />\n```\n\n该声明用于指定在移动设备上页面的布局视口如何设置。对于viewport meta的详细设置，请参考：[viewport详解](viewport详解.md)\n\n### 声明添加到主屏幕的Web App标题\n\niOS Safari允许用户将一个网页添加到主屏幕然后像App一样来操作它。我们知道每个App下方都会有一个名字，iOS Safari提供了一个私有的meta来定义这个名字，代码如下：\n\n```\n<meta name=\"apple-mobile-web-app-title\" content=\"Web App名称\" />\n```\n\nAndroid Chrome31.0，Android Browser5.0也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一iOS和Android平台定义Web app名称的方式，可以使用title标签来定义，代码如下：\n\n```\n<title>Web App名称</title>\n```\n\n但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。\n\n### 声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\n\n当我们将一个网页添加到主屏幕时，会更希望它能有像App一样的表现，没有地址栏和状态栏全屏显示，代码如下：\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n该方案在 iOS 和 Android5.0+ 上都通用。\n\n### 声明添加到主屏幕时设置系统顶栏颜色\n\n当我们将一个网页添加到主屏幕时，还可以对 系统显示手机信号、时间、电池的顶部状态栏 颜色进行设置，前提是开启了：\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n有了这个前提，你可以通过下面的方式来进行定义：\n\n```\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n```\n\ncontent只有3个固定值可选：default | black | black-translucent\n\n+ 如果设置为 default，状态栏将为正常的，即白色，网页从状态栏以下开始显示；\n+ 如果设置为 black，状态栏将为黑色，网页从状态栏以下开始显示；\n+ 如果设置为 black-translucent，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上；\n+ 该设置只在 iOS 上有效。\n\n### 电话号码识别\n\n在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：\n\n+ 7位数字，形如：1234567\n+ 带括号及加号的数字，形如：(+86)123456789\n+ 双连接线的数字，形如：00-00-00111\n+ 11位数字，形如：13800138000\n\n可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。\n\n**关闭电话号码识别：**\n\n```\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n**开启拨打电话功能：**\n\n```\n<a href=\"tel:123456\">123456</a>\n```\n\n**开启发送短信功能：**\n\n```\n<a href=\"sms:123456\">123456</a>\n```\n\n在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。\n\n**关闭邮箱地址识别：**\n\n```\n<meta name=\"format-detection\" content=\"email=no\" />\n```\n\n**开启邮件发送：**\n\n```\n<a href=\"mailto:dooyoe@gmail.com\">dooyoe@gmail.com</a>\n```\n\n如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下：\n\n```\n<meta name=\"format-detection\" content=\"telephone=no,email=no\" />\n```\n\n## 附注\n\n部分meta定义来自于[trip](https://github.com/doyoe/trip)\n\n转载：[http://web.jobbole.com](http://web.jobbole.com/85860/)\n","source":"_posts/善用meta.md","raw":"---\ntitle: 善用meta\ntags: [html]\ndate: 2015/02/06\n---\n\n## 前言\n\n在移动前端第一弹：viewport详解中，我们讲了viewport，那是一个关于meta的故事。这次我们会就将meta这个故事讲得更广阔、更有意思一些。\n\n写过HTML的童鞋，应该都对这个不陌生，或用它来定义页面编码，或用它来定义搜索引擎抓取方式，或用它定义页面关键字，描述等等。\n\n### meta列表\n\n好的meta使用，能更好地提高页面的可用性及被检索的几率。\n\n这里并不会列出所有的meta使用方式，只挑选一些常用及实际意义比较大的讲讲，当然也包括一些厂商私有定制的。\n\n## 常规\n\n### 声明文档使用的字符编码\n\n```\n<meta charset=\"utf-8\" />\n```\n\n该声明用来指定文档的编码，除了utf-8，可选值还有：ISO-8859-1、BIG5、iso-8859-2, iso-2022-jp, iso-2022-kr, gb2312等\n\n当然，你可能还见过使用另外一种方式来定义文档字符编码：\n\n```\n<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />\n```\n\n相对于这种方式，更推荐你使用第1种，言外之意，就是推荐使用HTML5。\n\n### 声明页面刷新或跳转\n\n```\n<meta http-equiv=\"refresh\" content=\"10\" />\n<meta http-equiv=\"refresh\" content=\"10; url=http://www.doyoe.com\" />\n```\n\n该声明用来指定页面自刷新或者跳转到其它页面，其中的时间单位是s。\n\n### 声明页面过期时间\n\n```\n<meta http-equiv=\"expires\" content=\"0\" />\n<meta http-equiv=\"expires\" content=\"Wed, 26 Feb 1997 08:21:57 GMT\" />\n```\n\n该声明用来指定页面的过期时间，一旦网页过期，从服务器上重新请求，其中时间必须使用GMT格式，或者直接是0（即不缓存）\n\n### 声明页面是否缓存\n\n```\n<meta http-equiv=\"pragma\" content=\"no-cache\" />\n<meta http-equiv=\"cache-control\" content=\"no-cache\" />\n```\n\n上述语句都可以用来指定文档不被缓存。一些仍然在使用HTTP/1.0的可以使用第1条，第2条由HTTP/1.1提供，常用值还有：public, no-cache, no-store等\n\n### 声明作者信息\n\n```\n<meta name=\"author\" content=\"joy, dooyoe@gmail.com\" />\n```\n\n### 声明文档关键字\n\n```\n<meta name=\"keywords\" content=\"CSS, HTML, JavaScript, 前端\" />\n```\n\n多关键字之间以半角逗号分隔\n\n### 声明文档描述\n\n```\n<meta name=\"description\" content=\"这是一份meta列表\" />\n```\n\n文档描述内容最好是完整的一句话，以不超过50个字符为宜\n\n### 声明使用的浏览器及版本\n\nx-ua-compatible设置是从IE8开始增加的（很明显，只适用于IE），对于过往的版本无法识别。\n开发者可以通过设置x-ua-compatible来指定渲染引擎的类型和版本，并且因为需求不同可以有多种不同的设置：\n\n**Case1:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=7\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=4\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=xx\" />\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=50\" />\n```\n\n+ 当直接指定content为IE的某个具体版本，如上述代码第1条，客户端的IE将会使用IE7.0标准模式对页面进行渲染，并忽略Doctype定义。\n+ 当指定的IE版本在客户端IE中不存在时，IE将会尝试将该值转换为最为接近的版本。\n> 例如指定一个错误的或者低于5.0的IE版本，如上述代码第2，3条，客户端的IE将会使用IE5.0对页面进行渲染，由于IE5.0并没有标准模式，所以将会直接使用quirks mode来渲染；\n> 如果指定一个大于客户端IE的版本，如上述代码第4条，假定客户端IE的最高版本为9.0，那么IE会将该值转换为IE=9，即使用IE9.0标准模式对页面进行渲染。\n\n**Case2:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=EmulateIE7\" />\n```\n\n当指定的content值加了Emulate前缀时，如上述代码，客户端IE将会根据Doctype定义来决定如何来对页面进行渲染。假设页面使用了标准的Doctype，那么此定义效果等同Case1；假设页面并没有使用标准的Doctype，那么将使用quirks mode来渲染。\n\n**Case3:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=Edge\" />\n```\n\n当指定的content值为IE=Edge时，如上述代码，客户端的IE将会使用最高的标准模式对页面进行渲染。\n\n**Case4:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=7, 10, 11\" />\n```\n\n当指定的content值有多个版本时，如上述代码，假定客户端IE版本为8.0或者9.0，则使用IE7.0标准模式对页面进行渲染；假定客户端IE版本为10.0或者11.0，则直接使用对应版本的标准模式对页面进行渲染。\n\n**Case5:**\n\n```\n<meta http-equiv=\"x-ua-compatible\" content=\"IE=Edge, chrome=1\" />\n```\n\n当指定的content值为IE=Edge, chrome=1时，如上述代码，假定客户端安装了Google Chrome Frame，则在IE中使用chrome的渲染引擎来渲染页面，否则，将会使用客户端IE最高的标准模式对页面进行渲染。\n\n### 声明搜索引擎抓取方式\n\n```\n<meta name=\"robots\" content=\"index\" />\n```\n\n通知搜索引擎文档是否需要被索引。可选值有：\n\n+ all（默认值，索引当前页并跟踪链接，相当于：index, follow）\n+ none（忽略当前页，相当于：noindex, nofollow）\n+ index（索引当前页）\n+ noindex（不索引当前页）\n+ follow（跟踪当前页链接，不论当前页是否被索引）\n+ nofollow（不跟踪当前页链接，不论当前页是否被索引）\n\n如果声明冲突，某些引擎可能会做严格处理：\n\n```\n<meta name=\"robots\" content=\"noindex\" />\n<meta name=\"robots\" content=\"index\" />\n```\n\n类似上述代码，在Google引擎中，会执行noindex这个更为严格的声明。\n\n需要注意的是并不是所有搜索引擎都支持robots meta，比较保守的做法是配合robots.txt使用。\n\n### 声明搜索引擎抓取间隔\n\n```\n<meta name=\"revisit-after\" content=\"10 days\" />\n```\n\n有时候你可能并不希望站点一直被搜索引擎抓取，而是每间隔一段时间才来访问一次，这时，可以声明revisit-after meta。\n\n## 移动\n\n### 声明viewport视口\n\n```\n<meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\" />\n```\n\n该声明用于指定在移动设备上页面的布局视口如何设置。对于viewport meta的详细设置，请参考：[viewport详解](viewport详解.md)\n\n### 声明添加到主屏幕的Web App标题\n\niOS Safari允许用户将一个网页添加到主屏幕然后像App一样来操作它。我们知道每个App下方都会有一个名字，iOS Safari提供了一个私有的meta来定义这个名字，代码如下：\n\n```\n<meta name=\"apple-mobile-web-app-title\" content=\"Web App名称\" />\n```\n\nAndroid Chrome31.0，Android Browser5.0也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一iOS和Android平台定义Web app名称的方式，可以使用title标签来定义，代码如下：\n\n```\n<title>Web App名称</title>\n```\n\n但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。\n\n### 声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\n\n当我们将一个网页添加到主屏幕时，会更希望它能有像App一样的表现，没有地址栏和状态栏全屏显示，代码如下：\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n该方案在 iOS 和 Android5.0+ 上都通用。\n\n### 声明添加到主屏幕时设置系统顶栏颜色\n\n当我们将一个网页添加到主屏幕时，还可以对 系统显示手机信号、时间、电池的顶部状态栏 颜色进行设置，前提是开启了：\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n有了这个前提，你可以通过下面的方式来进行定义：\n\n```\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n```\n\ncontent只有3个固定值可选：default | black | black-translucent\n\n+ 如果设置为 default，状态栏将为正常的，即白色，网页从状态栏以下开始显示；\n+ 如果设置为 black，状态栏将为黑色，网页从状态栏以下开始显示；\n+ 如果设置为 black-translucent，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上；\n+ 该设置只在 iOS 上有效。\n\n### 电话号码识别\n\n在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：\n\n+ 7位数字，形如：1234567\n+ 带括号及加号的数字，形如：(+86)123456789\n+ 双连接线的数字，形如：00-00-00111\n+ 11位数字，形如：13800138000\n\n可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。\n\n**关闭电话号码识别：**\n\n```\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n**开启拨打电话功能：**\n\n```\n<a href=\"tel:123456\">123456</a>\n```\n\n**开启发送短信功能：**\n\n```\n<a href=\"sms:123456\">123456</a>\n```\n\n在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。\n\n**关闭邮箱地址识别：**\n\n```\n<meta name=\"format-detection\" content=\"email=no\" />\n```\n\n**开启邮件发送：**\n\n```\n<a href=\"mailto:dooyoe@gmail.com\">dooyoe@gmail.com</a>\n```\n\n如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下：\n\n```\n<meta name=\"format-detection\" content=\"telephone=no,email=no\" />\n```\n\n## 附注\n\n部分meta定义来自于[trip](https://github.com/doyoe/trip)\n\n转载：[http://web.jobbole.com](http://web.jobbole.com/85860/)\n","slug":"善用meta","published":1,"updated":"2016-08-17T06:22:19.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpls004b68ddnxtfod5d","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在移动前端第一弹：viewport详解中，我们讲了viewport，那是一个关于meta的故事。这次我们会就将meta这个故事讲得更广阔、更有意思一些。</p>\n<p>写过HTML的童鞋，应该都对这个不陌生，或用它来定义页面编码，或用它来定义搜索引擎抓取方式，或用它定义页面关键字，描述等等。</p>\n<h3 id=\"meta列表\"><a href=\"#meta列表\" class=\"headerlink\" title=\"meta列表\"></a>meta列表</h3><p>好的meta使用，能更好地提高页面的可用性及被检索的几率。</p>\n<p>这里并不会列出所有的meta使用方式，只挑选一些常用及实际意义比较大的讲讲，当然也包括一些厂商私有定制的。</p>\n<h2 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h2><h3 id=\"声明文档使用的字符编码\"><a href=\"#声明文档使用的字符编码\" class=\"headerlink\" title=\"声明文档使用的字符编码\"></a>声明文档使用的字符编码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta charset=&quot;utf-8&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定文档的编码，除了utf-8，可选值还有：ISO-8859-1、BIG5、iso-8859-2, iso-2022-jp, iso-2022-kr, gb2312等</p>\n<p>当然，你可能还见过使用另外一种方式来定义文档字符编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>相对于这种方式，更推荐你使用第1种，言外之意，就是推荐使用HTML5。</p>\n<h3 id=\"声明页面刷新或跳转\"><a href=\"#声明页面刷新或跳转\" class=\"headerlink\" title=\"声明页面刷新或跳转\"></a>声明页面刷新或跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10; url=http://www.doyoe.com&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定页面自刷新或者跳转到其它页面，其中的时间单位是s。</p>\n<h3 id=\"声明页面过期时间\"><a href=\"#声明页面过期时间\" class=\"headerlink\" title=\"声明页面过期时间\"></a>声明页面过期时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定页面的过期时间，一旦网页过期，从服务器上重新请求，其中时间必须使用GMT格式，或者直接是0（即不缓存）</p>\n<h3 id=\"声明页面是否缓存\"><a href=\"#声明页面是否缓存\" class=\"headerlink\" title=\"声明页面是否缓存\"></a>声明页面是否缓存</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>上述语句都可以用来指定文档不被缓存。一些仍然在使用HTTP/1.0的可以使用第1条，第2条由HTTP/1.1提供，常用值还有：public, no-cache, no-store等</p>\n<h3 id=\"声明作者信息\"><a href=\"#声明作者信息\" class=\"headerlink\" title=\"声明作者信息\"></a>声明作者信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;author&quot; content=&quot;joy, dooyoe@gmail.com&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"声明文档关键字\"><a href=\"#声明文档关键字\" class=\"headerlink\" title=\"声明文档关键字\"></a>声明文档关键字</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;keywords&quot; content=&quot;CSS, HTML, JavaScript, 前端&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>多关键字之间以半角逗号分隔</p>\n<h3 id=\"声明文档描述\"><a href=\"#声明文档描述\" class=\"headerlink\" title=\"声明文档描述\"></a>声明文档描述</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;description&quot; content=&quot;这是一份meta列表&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>文档描述内容最好是完整的一句话，以不超过50个字符为宜</p>\n<h3 id=\"声明使用的浏览器及版本\"><a href=\"#声明使用的浏览器及版本\" class=\"headerlink\" title=\"声明使用的浏览器及版本\"></a>声明使用的浏览器及版本</h3><p>x-ua-compatible设置是从IE8开始增加的（很明显，只适用于IE），对于过往的版本无法识别。<br>开发者可以通过设置x-ua-compatible来指定渲染引擎的类型和版本，并且因为需求不同可以有多种不同的设置：</p>\n<p><strong>Case1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=4&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=xx&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=50&quot; /&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>当直接指定content为IE的某个具体版本，如上述代码第1条，客户端的IE将会使用IE7.0标准模式对页面进行渲染，并忽略Doctype定义。</li>\n<li>当指定的IE版本在客户端IE中不存在时，IE将会尝试将该值转换为最为接近的版本。<blockquote>\n<p>例如指定一个错误的或者低于5.0的IE版本，如上述代码第2，3条，客户端的IE将会使用IE5.0对页面进行渲染，由于IE5.0并没有标准模式，所以将会直接使用quirks mode来渲染；<br>如果指定一个大于客户端IE的版本，如上述代码第4条，假定客户端IE的最高版本为9.0，那么IE会将该值转换为IE=9，即使用IE9.0标准模式对页面进行渲染。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Case2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值加了Emulate前缀时，如上述代码，客户端IE将会根据Doctype定义来决定如何来对页面进行渲染。假设页面使用了标准的Doctype，那么此定义效果等同Case1；假设页面并没有使用标准的Doctype，那么将使用quirks mode来渲染。</p>\n<p><strong>Case3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值为IE=Edge时，如上述代码，客户端的IE将会使用最高的标准模式对页面进行渲染。</p>\n<p><strong>Case4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7, 10, 11&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值有多个版本时，如上述代码，假定客户端IE版本为8.0或者9.0，则使用IE7.0标准模式对页面进行渲染；假定客户端IE版本为10.0或者11.0，则直接使用对应版本的标准模式对页面进行渲染。</p>\n<p><strong>Case5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge, chrome=1&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值为IE=Edge, chrome=1时，如上述代码，假定客户端安装了Google Chrome Frame，则在IE中使用chrome的渲染引擎来渲染页面，否则，将会使用客户端IE最高的标准模式对页面进行渲染。</p>\n<h3 id=\"声明搜索引擎抓取方式\"><a href=\"#声明搜索引擎抓取方式\" class=\"headerlink\" title=\"声明搜索引擎抓取方式\"></a>声明搜索引擎抓取方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;index&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>通知搜索引擎文档是否需要被索引。可选值有：</p>\n<ul>\n<li>all（默认值，索引当前页并跟踪链接，相当于：index, follow）</li>\n<li>none（忽略当前页，相当于：noindex, nofollow）</li>\n<li>index（索引当前页）</li>\n<li>noindex（不索引当前页）</li>\n<li>follow（跟踪当前页链接，不论当前页是否被索引）</li>\n<li>nofollow（不跟踪当前页链接，不论当前页是否被索引）</li>\n</ul>\n<p>如果声明冲突，某些引擎可能会做严格处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;</div><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;index&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>类似上述代码，在Google引擎中，会执行noindex这个更为严格的声明。</p>\n<p>需要注意的是并不是所有搜索引擎都支持robots meta，比较保守的做法是配合robots.txt使用。</p>\n<h3 id=\"声明搜索引擎抓取间隔\"><a href=\"#声明搜索引擎抓取间隔\" class=\"headerlink\" title=\"声明搜索引擎抓取间隔\"></a>声明搜索引擎抓取间隔</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;revisit-after&quot; content=&quot;10 days&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>有时候你可能并不希望站点一直被搜索引擎抓取，而是每间隔一段时间才来访问一次，这时，可以声明revisit-after meta。</p>\n<h2 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h2><h3 id=\"声明viewport视口\"><a href=\"#声明viewport视口\" class=\"headerlink\" title=\"声明viewport视口\"></a>声明viewport视口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用于指定在移动设备上页面的布局视口如何设置。对于viewport meta的详细设置，请参考：<a href=\"viewport详解.md\">viewport详解</a></p>\n<h3 id=\"声明添加到主屏幕的Web-App标题\"><a href=\"#声明添加到主屏幕的Web-App标题\" class=\"headerlink\" title=\"声明添加到主屏幕的Web App标题\"></a>声明添加到主屏幕的Web App标题</h3><p>iOS Safari允许用户将一个网页添加到主屏幕然后像App一样来操作它。我们知道每个App下方都会有一个名字，iOS Safari提供了一个私有的meta来定义这个名字，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Web App名称&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>Android Chrome31.0，Android Browser5.0也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一iOS和Android平台定义Web app名称的方式，可以使用title标签来定义，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;title&gt;Web App名称&lt;/title&gt;</div></pre></td></tr></table></figure>\n<p>但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。</p>\n<h3 id=\"声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\"><a href=\"#声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\" class=\"headerlink\" title=\"声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\"></a>声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）</h3><p>当我们将一个网页添加到主屏幕时，会更希望它能有像App一样的表现，没有地址栏和状态栏全屏显示，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该方案在 iOS 和 Android5.0+ 上都通用。</p>\n<h3 id=\"声明添加到主屏幕时设置系统顶栏颜色\"><a href=\"#声明添加到主屏幕时设置系统顶栏颜色\" class=\"headerlink\" title=\"声明添加到主屏幕时设置系统顶栏颜色\"></a>声明添加到主屏幕时设置系统顶栏颜色</h3><p>当我们将一个网页添加到主屏幕时，还可以对 系统显示手机信号、时间、电池的顶部状态栏 颜色进行设置，前提是开启了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>有了这个前提，你可以通过下面的方式来进行定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>content只有3个固定值可选：default | black | black-translucent</p>\n<ul>\n<li>如果设置为 default，状态栏将为正常的，即白色，网页从状态栏以下开始显示；</li>\n<li>如果设置为 black，状态栏将为黑色，网页从状态栏以下开始显示；</li>\n<li>如果设置为 black-translucent，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上；</li>\n<li>该设置只在 iOS 上有效。</li>\n</ul>\n<h3 id=\"电话号码识别\"><a href=\"#电话号码识别\" class=\"headerlink\" title=\"电话号码识别\"></a>电话号码识别</h3><p>在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：</p>\n<ul>\n<li>7位数字，形如：1234567</li>\n<li>带括号及加号的数字，形如：(+86)123456789</li>\n<li>双连接线的数字，形如：00-00-00111</li>\n<li>11位数字，形如：13800138000</li>\n</ul>\n<p>可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。</p>\n<p><strong>关闭电话号码识别：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启拨打电话功能：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启发送短信功能：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。</p>\n<p><strong>关闭邮箱地址识别：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启邮件发送：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"附注\"><a href=\"#附注\" class=\"headerlink\" title=\"附注\"></a>附注</h2><p>部分meta定义来自于<a href=\"https://github.com/doyoe/trip\" target=\"_blank\" rel=\"external\">trip</a></p>\n<p>转载：<a href=\"http://web.jobbole.com/85860/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在移动前端第一弹：viewport详解中，我们讲了viewport，那是一个关于meta的故事。这次我们会就将meta这个故事讲得更广阔、更有意思一些。</p>\n<p>写过HTML的童鞋，应该都对这个不陌生，或用它来定义页面编码，或用它来定义搜索引擎抓取方式，或用它定义页面关键字，描述等等。</p>\n<h3 id=\"meta列表\"><a href=\"#meta列表\" class=\"headerlink\" title=\"meta列表\"></a>meta列表</h3><p>好的meta使用，能更好地提高页面的可用性及被检索的几率。</p>\n<p>这里并不会列出所有的meta使用方式，只挑选一些常用及实际意义比较大的讲讲，当然也包括一些厂商私有定制的。</p>\n<h2 id=\"常规\"><a href=\"#常规\" class=\"headerlink\" title=\"常规\"></a>常规</h2><h3 id=\"声明文档使用的字符编码\"><a href=\"#声明文档使用的字符编码\" class=\"headerlink\" title=\"声明文档使用的字符编码\"></a>声明文档使用的字符编码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta charset=&quot;utf-8&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定文档的编码，除了utf-8，可选值还有：ISO-8859-1、BIG5、iso-8859-2, iso-2022-jp, iso-2022-kr, gb2312等</p>\n<p>当然，你可能还见过使用另外一种方式来定义文档字符编码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>相对于这种方式，更推荐你使用第1种，言外之意，就是推荐使用HTML5。</p>\n<h3 id=\"声明页面刷新或跳转\"><a href=\"#声明页面刷新或跳转\" class=\"headerlink\" title=\"声明页面刷新或跳转\"></a>声明页面刷新或跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10; url=http://www.doyoe.com&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定页面自刷新或者跳转到其它页面，其中的时间单位是s。</p>\n<h3 id=\"声明页面过期时间\"><a href=\"#声明页面过期时间\" class=\"headerlink\" title=\"声明页面过期时间\"></a>声明页面过期时间</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用来指定页面的过期时间，一旦网页过期，从服务器上重新请求，其中时间必须使用GMT格式，或者直接是0（即不缓存）</p>\n<h3 id=\"声明页面是否缓存\"><a href=\"#声明页面是否缓存\" class=\"headerlink\" title=\"声明页面是否缓存\"></a>声明页面是否缓存</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>上述语句都可以用来指定文档不被缓存。一些仍然在使用HTTP/1.0的可以使用第1条，第2条由HTTP/1.1提供，常用值还有：public, no-cache, no-store等</p>\n<h3 id=\"声明作者信息\"><a href=\"#声明作者信息\" class=\"headerlink\" title=\"声明作者信息\"></a>声明作者信息</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;author&quot; content=&quot;joy, dooyoe@gmail.com&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"声明文档关键字\"><a href=\"#声明文档关键字\" class=\"headerlink\" title=\"声明文档关键字\"></a>声明文档关键字</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;keywords&quot; content=&quot;CSS, HTML, JavaScript, 前端&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>多关键字之间以半角逗号分隔</p>\n<h3 id=\"声明文档描述\"><a href=\"#声明文档描述\" class=\"headerlink\" title=\"声明文档描述\"></a>声明文档描述</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;description&quot; content=&quot;这是一份meta列表&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>文档描述内容最好是完整的一句话，以不超过50个字符为宜</p>\n<h3 id=\"声明使用的浏览器及版本\"><a href=\"#声明使用的浏览器及版本\" class=\"headerlink\" title=\"声明使用的浏览器及版本\"></a>声明使用的浏览器及版本</h3><p>x-ua-compatible设置是从IE8开始增加的（很明显，只适用于IE），对于过往的版本无法识别。<br>开发者可以通过设置x-ua-compatible来指定渲染引擎的类型和版本，并且因为需求不同可以有多种不同的设置：</p>\n<p><strong>Case1:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=4&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=xx&quot; /&gt;</div><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=50&quot; /&gt;</div></pre></td></tr></table></figure>\n<ul>\n<li>当直接指定content为IE的某个具体版本，如上述代码第1条，客户端的IE将会使用IE7.0标准模式对页面进行渲染，并忽略Doctype定义。</li>\n<li>当指定的IE版本在客户端IE中不存在时，IE将会尝试将该值转换为最为接近的版本。<blockquote>\n<p>例如指定一个错误的或者低于5.0的IE版本，如上述代码第2，3条，客户端的IE将会使用IE5.0对页面进行渲染，由于IE5.0并没有标准模式，所以将会直接使用quirks mode来渲染；<br>如果指定一个大于客户端IE的版本，如上述代码第4条，假定客户端IE的最高版本为9.0，那么IE会将该值转换为IE=9，即使用IE9.0标准模式对页面进行渲染。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>Case2:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=EmulateIE7&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值加了Emulate前缀时，如上述代码，客户端IE将会根据Doctype定义来决定如何来对页面进行渲染。假设页面使用了标准的Doctype，那么此定义效果等同Case1；假设页面并没有使用标准的Doctype，那么将使用quirks mode来渲染。</p>\n<p><strong>Case3:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值为IE=Edge时，如上述代码，客户端的IE将会使用最高的标准模式对页面进行渲染。</p>\n<p><strong>Case4:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7, 10, 11&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值有多个版本时，如上述代码，假定客户端IE版本为8.0或者9.0，则使用IE7.0标准模式对页面进行渲染；假定客户端IE版本为10.0或者11.0，则直接使用对应版本的标准模式对页面进行渲染。</p>\n<p><strong>Case5:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge, chrome=1&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>当指定的content值为IE=Edge, chrome=1时，如上述代码，假定客户端安装了Google Chrome Frame，则在IE中使用chrome的渲染引擎来渲染页面，否则，将会使用客户端IE最高的标准模式对页面进行渲染。</p>\n<h3 id=\"声明搜索引擎抓取方式\"><a href=\"#声明搜索引擎抓取方式\" class=\"headerlink\" title=\"声明搜索引擎抓取方式\"></a>声明搜索引擎抓取方式</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;index&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>通知搜索引擎文档是否需要被索引。可选值有：</p>\n<ul>\n<li>all（默认值，索引当前页并跟踪链接，相当于：index, follow）</li>\n<li>none（忽略当前页，相当于：noindex, nofollow）</li>\n<li>index（索引当前页）</li>\n<li>noindex（不索引当前页）</li>\n<li>follow（跟踪当前页链接，不论当前页是否被索引）</li>\n<li>nofollow（不跟踪当前页链接，不论当前页是否被索引）</li>\n</ul>\n<p>如果声明冲突，某些引擎可能会做严格处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;</div><div class=\"line\">&lt;meta name=&quot;robots&quot; content=&quot;index&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>类似上述代码，在Google引擎中，会执行noindex这个更为严格的声明。</p>\n<p>需要注意的是并不是所有搜索引擎都支持robots meta，比较保守的做法是配合robots.txt使用。</p>\n<h3 id=\"声明搜索引擎抓取间隔\"><a href=\"#声明搜索引擎抓取间隔\" class=\"headerlink\" title=\"声明搜索引擎抓取间隔\"></a>声明搜索引擎抓取间隔</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;revisit-after&quot; content=&quot;10 days&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>有时候你可能并不希望站点一直被搜索引擎抓取，而是每间隔一段时间才来访问一次，这时，可以声明revisit-after meta。</p>\n<h2 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h2><h3 id=\"声明viewport视口\"><a href=\"#声明viewport视口\" class=\"headerlink\" title=\"声明viewport视口\"></a>声明viewport视口</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该声明用于指定在移动设备上页面的布局视口如何设置。对于viewport meta的详细设置，请参考：<a href=\"viewport详解.md\">viewport详解</a></p>\n<h3 id=\"声明添加到主屏幕的Web-App标题\"><a href=\"#声明添加到主屏幕的Web-App标题\" class=\"headerlink\" title=\"声明添加到主屏幕的Web App标题\"></a>声明添加到主屏幕的Web App标题</h3><p>iOS Safari允许用户将一个网页添加到主屏幕然后像App一样来操作它。我们知道每个App下方都会有一个名字，iOS Safari提供了一个私有的meta来定义这个名字，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Web App名称&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>Android Chrome31.0，Android Browser5.0也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一iOS和Android平台定义Web app名称的方式，可以使用title标签来定义，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;title&gt;Web App名称&lt;/title&gt;</div></pre></td></tr></table></figure>\n<p>但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。</p>\n<h3 id=\"声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\"><a href=\"#声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\" class=\"headerlink\" title=\"声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）\"></a>声明添加到主屏幕时隐藏地址栏和状态栏（即全屏）</h3><p>当我们将一个网页添加到主屏幕时，会更希望它能有像App一样的表现，没有地址栏和状态栏全屏显示，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>该方案在 iOS 和 Android5.0+ 上都通用。</p>\n<h3 id=\"声明添加到主屏幕时设置系统顶栏颜色\"><a href=\"#声明添加到主屏幕时设置系统顶栏颜色\" class=\"headerlink\" title=\"声明添加到主屏幕时设置系统顶栏颜色\"></a>声明添加到主屏幕时设置系统顶栏颜色</h3><p>当我们将一个网页添加到主屏幕时，还可以对 系统显示手机信号、时间、电池的顶部状态栏 颜色进行设置，前提是开启了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>有了这个前提，你可以通过下面的方式来进行定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;</div></pre></td></tr></table></figure>\n<p>content只有3个固定值可选：default | black | black-translucent</p>\n<ul>\n<li>如果设置为 default，状态栏将为正常的，即白色，网页从状态栏以下开始显示；</li>\n<li>如果设置为 black，状态栏将为黑色，网页从状态栏以下开始显示；</li>\n<li>如果设置为 black-translucent，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上；</li>\n<li>该设置只在 iOS 上有效。</li>\n</ul>\n<h3 id=\"电话号码识别\"><a href=\"#电话号码识别\" class=\"headerlink\" title=\"电话号码识别\"></a>电话号码识别</h3><p>在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：</p>\n<ul>\n<li>7位数字，形如：1234567</li>\n<li>带括号及加号的数字，形如：(+86)123456789</li>\n<li>双连接线的数字，形如：00-00-00111</li>\n<li>11位数字，形如：13800138000</li>\n</ul>\n<p>可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。</p>\n<p><strong>关闭电话号码识别：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启拨打电话功能：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启发送短信功能：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。</p>\n<p><strong>关闭邮箱地址识别：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<p><strong>开启邮件发送：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;a href=&quot;mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt;</div></pre></td></tr></table></figure>\n<p>如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"附注\"><a href=\"#附注\" class=\"headerlink\" title=\"附注\"></a>附注</h2><p>部分meta定义来自于<a href=\"https://github.com/doyoe/trip\">trip</a></p>\n<p>转载：<a href=\"http://web.jobbole.com/85860/\">http://web.jobbole.com</a></p>\n"},{"title":"在Ubuntu上安装PPTP的VPN服务","date":"2016-06-13T16:00:00.000Z","_content":"\n### 安装PPTP服务。\n\n```bash\n# apt-get update\n# apt-get install pptpd \n```\n\n### 编辑/etc/pptpd.conf。\n\n取消这两行的注释(用于分配给连接过来的VPN用户):\n\n```\nlocalip 192.168.0.1(本地侦听王大地址)\nremoteip 192.168.0.234-238,192.168.0.245（客户端分配地址） \n```\n\n### 增加VPN登录用户。\n\n编辑/etc/ppp/chap-secrets添加记录\n\nusername pptpd password \n\n+ username 表示登录的用户名\n+ password 表示用户的密码\n+ pptpd 表示pptpd的服务名称，这里不要修改\n+ `*`表示登录的用户可以向任何地方连接 \n\n### 设置DNS解析。\n\n编辑/etc/ppp/pptpd-options，找到\"ms-dns\"项目，修改成OpenDNS的地址如下：\n\n```\nms-dns 208.67.222.222\nms-dns 208.67.220.220 \n```\n\n### 配置/etc/sysctl.conf，以允许转发。\n\n首先，找到net.ipv4.ip_forward项，修改为：\n\n```\nnet.ipv4.ip_forward=1\n```\n\n然后，运行如下命令：\n\n```bash\n# sysctl -p \n```\n\n### 重启pptpd服务。\n\n```bash\n# /etc/init.d/pptpd restart \n```\n\n### 配置iptables。\n\n```bash\n# /sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE \n```\n\n### 保存并配置重启后的iptables。\n\n```bash\n# iptables-save > /etc/iptables-rules\n```\n\n修改/etc/network/interfaces，在eth0下添加：\n\n```bash\npre-up iptables-restore < /etc/iptables-rules\n```\n\n注意清理nash-hotplug，否则CPU总是占用97%\n\n修改/etc/rc.local文件，在exit 0之前添加此命令：pkill -9 nash","source":"_posts/在Ubuntu上安装PPTP的VPN服务.md","raw":"---\ntitle: 在Ubuntu上安装PPTP的VPN服务\ntags: [linux,ubuntu]\ndate: 2016/06/14\n---\n\n### 安装PPTP服务。\n\n```bash\n# apt-get update\n# apt-get install pptpd \n```\n\n### 编辑/etc/pptpd.conf。\n\n取消这两行的注释(用于分配给连接过来的VPN用户):\n\n```\nlocalip 192.168.0.1(本地侦听王大地址)\nremoteip 192.168.0.234-238,192.168.0.245（客户端分配地址） \n```\n\n### 增加VPN登录用户。\n\n编辑/etc/ppp/chap-secrets添加记录\n\nusername pptpd password \n\n+ username 表示登录的用户名\n+ password 表示用户的密码\n+ pptpd 表示pptpd的服务名称，这里不要修改\n+ `*`表示登录的用户可以向任何地方连接 \n\n### 设置DNS解析。\n\n编辑/etc/ppp/pptpd-options，找到\"ms-dns\"项目，修改成OpenDNS的地址如下：\n\n```\nms-dns 208.67.222.222\nms-dns 208.67.220.220 \n```\n\n### 配置/etc/sysctl.conf，以允许转发。\n\n首先，找到net.ipv4.ip_forward项，修改为：\n\n```\nnet.ipv4.ip_forward=1\n```\n\n然后，运行如下命令：\n\n```bash\n# sysctl -p \n```\n\n### 重启pptpd服务。\n\n```bash\n# /etc/init.d/pptpd restart \n```\n\n### 配置iptables。\n\n```bash\n# /sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE \n```\n\n### 保存并配置重启后的iptables。\n\n```bash\n# iptables-save > /etc/iptables-rules\n```\n\n修改/etc/network/interfaces，在eth0下添加：\n\n```bash\npre-up iptables-restore < /etc/iptables-rules\n```\n\n注意清理nash-hotplug，否则CPU总是占用97%\n\n修改/etc/rc.local文件，在exit 0之前添加此命令：pkill -9 nash","slug":"在Ubuntu上安装PPTP的VPN服务","published":1,"updated":"2016-08-17T06:22:19.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cplw004e68ddm63ja3bu","content":"<h3 id=\"安装PPTP服务。\"><a href=\"#安装PPTP服务。\" class=\"headerlink\" title=\"安装PPTP服务。\"></a>安装PPTP服务。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># apt-get update</span></div><div class=\"line\"><span class=\"comment\"># apt-get install pptpd</span></div></pre></td></tr></table></figure>\n<h3 id=\"编辑-etc-pptpd-conf。\"><a href=\"#编辑-etc-pptpd-conf。\" class=\"headerlink\" title=\"编辑/etc/pptpd.conf。\"></a>编辑/etc/pptpd.conf。</h3><p>取消这两行的注释(用于分配给连接过来的VPN用户):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">localip 192.168.0.1(本地侦听王大地址)</div><div class=\"line\">remoteip 192.168.0.234-238,192.168.0.245（客户端分配地址）</div></pre></td></tr></table></figure>\n<h3 id=\"增加VPN登录用户。\"><a href=\"#增加VPN登录用户。\" class=\"headerlink\" title=\"增加VPN登录用户。\"></a>增加VPN登录用户。</h3><p>编辑/etc/ppp/chap-secrets添加记录</p>\n<p>username pptpd password </p>\n<ul>\n<li>username 表示登录的用户名</li>\n<li>password 表示用户的密码</li>\n<li>pptpd 表示pptpd的服务名称，这里不要修改</li>\n<li><code>*</code>表示登录的用户可以向任何地方连接 </li>\n</ul>\n<h3 id=\"设置DNS解析。\"><a href=\"#设置DNS解析。\" class=\"headerlink\" title=\"设置DNS解析。\"></a>设置DNS解析。</h3><p>编辑/etc/ppp/pptpd-options，找到”ms-dns”项目，修改成OpenDNS的地址如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">ms-dns 208.67.222.222</div><div class=\"line\">ms-dns 208.67.220.220</div></pre></td></tr></table></figure>\n<h3 id=\"配置-etc-sysctl-conf，以允许转发。\"><a href=\"#配置-etc-sysctl-conf，以允许转发。\" class=\"headerlink\" title=\"配置/etc/sysctl.conf，以允许转发。\"></a>配置/etc/sysctl.conf，以允许转发。</h3><p>首先，找到net.ipv4.ip_forward项，修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">net.ipv4.ip_forward=1</div></pre></td></tr></table></figure>\n<p>然后，运行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># sysctl -p</span></div></pre></td></tr></table></figure>\n<h3 id=\"重启pptpd服务。\"><a href=\"#重启pptpd服务。\" class=\"headerlink\" title=\"重启pptpd服务。\"></a>重启pptpd服务。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /etc/init.d/pptpd restart</span></div></pre></td></tr></table></figure>\n<h3 id=\"配置iptables。\"><a href=\"#配置iptables。\" class=\"headerlink\" title=\"配置iptables。\"></a>配置iptables。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</span></div></pre></td></tr></table></figure>\n<h3 id=\"保存并配置重启后的iptables。\"><a href=\"#保存并配置重启后的iptables。\" class=\"headerlink\" title=\"保存并配置重启后的iptables。\"></a>保存并配置重启后的iptables。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># iptables-save &gt; /etc/iptables-rules</span></div></pre></td></tr></table></figure>\n<p>修改/etc/network/interfaces，在eth0下添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">pre-up iptables-restore &lt; /etc/iptables-rules</div></pre></td></tr></table></figure>\n<p>注意清理nash-hotplug，否则CPU总是占用97%</p>\n<p>修改/etc/rc.local文件，在exit 0之前添加此命令：pkill -9 nash</p>\n","excerpt":"","more":"<h3 id=\"安装PPTP服务。\"><a href=\"#安装PPTP服务。\" class=\"headerlink\" title=\"安装PPTP服务。\"></a>安装PPTP服务。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># apt-get update</span></div><div class=\"line\"><span class=\"comment\"># apt-get install pptpd</span></div></pre></td></tr></table></figure>\n<h3 id=\"编辑-etc-pptpd-conf。\"><a href=\"#编辑-etc-pptpd-conf。\" class=\"headerlink\" title=\"编辑/etc/pptpd.conf。\"></a>编辑/etc/pptpd.conf。</h3><p>取消这两行的注释(用于分配给连接过来的VPN用户):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">localip 192.168.0.1(本地侦听王大地址)</div><div class=\"line\">remoteip 192.168.0.234-238,192.168.0.245（客户端分配地址）</div></pre></td></tr></table></figure>\n<h3 id=\"增加VPN登录用户。\"><a href=\"#增加VPN登录用户。\" class=\"headerlink\" title=\"增加VPN登录用户。\"></a>增加VPN登录用户。</h3><p>编辑/etc/ppp/chap-secrets添加记录</p>\n<p>username pptpd password </p>\n<ul>\n<li>username 表示登录的用户名</li>\n<li>password 表示用户的密码</li>\n<li>pptpd 表示pptpd的服务名称，这里不要修改</li>\n<li><code>*</code>表示登录的用户可以向任何地方连接 </li>\n</ul>\n<h3 id=\"设置DNS解析。\"><a href=\"#设置DNS解析。\" class=\"headerlink\" title=\"设置DNS解析。\"></a>设置DNS解析。</h3><p>编辑/etc/ppp/pptpd-options，找到”ms-dns”项目，修改成OpenDNS的地址如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">ms-dns 208.67.222.222</div><div class=\"line\">ms-dns 208.67.220.220</div></pre></td></tr></table></figure>\n<h3 id=\"配置-etc-sysctl-conf，以允许转发。\"><a href=\"#配置-etc-sysctl-conf，以允许转发。\" class=\"headerlink\" title=\"配置/etc/sysctl.conf，以允许转发。\"></a>配置/etc/sysctl.conf，以允许转发。</h3><p>首先，找到net.ipv4.ip_forward项，修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">net.ipv4.ip_forward=1</div></pre></td></tr></table></figure>\n<p>然后，运行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># sysctl -p</span></div></pre></td></tr></table></figure>\n<h3 id=\"重启pptpd服务。\"><a href=\"#重启pptpd服务。\" class=\"headerlink\" title=\"重启pptpd服务。\"></a>重启pptpd服务。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /etc/init.d/pptpd restart</span></div></pre></td></tr></table></figure>\n<h3 id=\"配置iptables。\"><a href=\"#配置iptables。\" class=\"headerlink\" title=\"配置iptables。\"></a>配置iptables。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># /sbin/iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</span></div></pre></td></tr></table></figure>\n<h3 id=\"保存并配置重启后的iptables。\"><a href=\"#保存并配置重启后的iptables。\" class=\"headerlink\" title=\"保存并配置重启后的iptables。\"></a>保存并配置重启后的iptables。</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># iptables-save &gt; /etc/iptables-rules</span></div></pre></td></tr></table></figure>\n<p>修改/etc/network/interfaces，在eth0下添加：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">pre-up iptables-restore &lt; /etc/iptables-rules</div></pre></td></tr></table></figure>\n<p>注意清理nash-hotplug，否则CPU总是占用97%</p>\n<p>修改/etc/rc.local文件，在exit 0之前添加此命令：pkill -9 nash</p>\n"},{"title":"如何正确配置Nginx+PHP","date":"2013-08-07T16:00:00.000Z","_content":"\n关于linux服务器的配置一直令我头疼，会出现各式各样的问题，解决问题都无从下手，所以，一直以来，也很佩服做系统运维的技术人员，他们真的是在整理乱麻。看过许多配置服务器的文章，可以这样说，没有一个可以让我把服务器配置成功的，不是服务器无响应，要不就是PHP跑不起来，再就是mysql无法启动。所以放弃了，现在只用lnmp这种集成的来总署服务器。\n\n下面这篇文章不算是教你配置服务器，而是告诉你，应该怎样优化，是否行得通，读者自行验证吧！\n\n---\n\n对很多人而言，配置Nginx+PHP无外乎就是搜索一篇教程，然后拷贝粘贴。听上去似乎也没什么问题，可惜实际上网络上很多资料本身年久失修，漏洞百出，如果大家不求甚解，一味的拷贝粘贴，早晚有一天会为此付出代价。\n\n假设我们用PHP实现了一个前端控制器，或者直白点说就是统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。\n\n**一般这样配置**\n\n此时很多教程会教大家这样配置Nginx+PHP：\n\n```\nserver {\n    listen 80;\n    server_name foo.com;\n\n    root /path;\n\n    location / {\n        index index.html index.htm index.php;\n\n        if (!-e $request_filename) {\n            rewrite . /index.php last;\n        }\n    }\n\n    location ~ /.php$ {\n        include fastcgi_params;\n        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;\n        fastcgi_pass 127.0.0.1:9000;\n        fastcgi_index index.php;\n    }\n}\n```\n\n这里面有很多错误，或者说至少是坏味道的地方，大家看看能发现几个。\n\n我们有必要先了解一下Nginx配置文件里指令的继承关系：\n\nNginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。\n\n**让我们先从「index」指令入手吧**\n\n在问题配置中它是在「location」中定义的：\n\n```\nlocation / {\n    index index.html index.htm index.php;\n}\n```\n\n一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。\n\n**接下来看看「if」指令**\n\n说它是大家误解最深的Nginx指令毫不为过：\n\n```\nif (!-e $request_filename) {\n    rewrite . /index.php last;\n}\n```\n\n很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：\n\n```\ntry_files $uri $uri/ /index.php;\n```\n\n除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。\n\n**下面看看「fastcgi_params」配置文件**\n\n```\ninclude fastcgi_params;\n```\n\nNginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：\n\n```\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n```\n\n注意：$document_root 和 $fastcgi_script_name 之间没有 /。\n\n原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。\n\n不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。\n\n此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：\n\n```\ntry_files $uri =404;\n```\n\n**改良后的版本**\n\n依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：\n\n```\nserver {\n    listen 80;\n    server_name foo.com;\n\n    root /path;\n    index index.html index.htm index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ /.php$ {\n        try_files $uri =404;\n\n        include fastcgi.conf;\n        fastcgi_pass 127.0.0.1:9000;\n    }\n}\n```\n\n转载：[http://www.codeceo.com](http://www.codeceo.com/article/nginx-php-config.html)\n","source":"_posts/如何正确配置Nginx+PHP.md","raw":"---\ntitle: 如何正确配置Nginx+PHP\ntags: [linux,nginx,php]\ndate: 2013/08/08\n---\n\n关于linux服务器的配置一直令我头疼，会出现各式各样的问题，解决问题都无从下手，所以，一直以来，也很佩服做系统运维的技术人员，他们真的是在整理乱麻。看过许多配置服务器的文章，可以这样说，没有一个可以让我把服务器配置成功的，不是服务器无响应，要不就是PHP跑不起来，再就是mysql无法启动。所以放弃了，现在只用lnmp这种集成的来总署服务器。\n\n下面这篇文章不算是教你配置服务器，而是告诉你，应该怎样优化，是否行得通，读者自行验证吧！\n\n---\n\n对很多人而言，配置Nginx+PHP无外乎就是搜索一篇教程，然后拷贝粘贴。听上去似乎也没什么问题，可惜实际上网络上很多资料本身年久失修，漏洞百出，如果大家不求甚解，一味的拷贝粘贴，早晚有一天会为此付出代价。\n\n假设我们用PHP实现了一个前端控制器，或者直白点说就是统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。\n\n**一般这样配置**\n\n此时很多教程会教大家这样配置Nginx+PHP：\n\n```\nserver {\n    listen 80;\n    server_name foo.com;\n\n    root /path;\n\n    location / {\n        index index.html index.htm index.php;\n\n        if (!-e $request_filename) {\n            rewrite . /index.php last;\n        }\n    }\n\n    location ~ /.php$ {\n        include fastcgi_params;\n        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;\n        fastcgi_pass 127.0.0.1:9000;\n        fastcgi_index index.php;\n    }\n}\n```\n\n这里面有很多错误，或者说至少是坏味道的地方，大家看看能发现几个。\n\n我们有必要先了解一下Nginx配置文件里指令的继承关系：\n\nNginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。\n\n**让我们先从「index」指令入手吧**\n\n在问题配置中它是在「location」中定义的：\n\n```\nlocation / {\n    index index.html index.htm index.php;\n}\n```\n\n一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。\n\n**接下来看看「if」指令**\n\n说它是大家误解最深的Nginx指令毫不为过：\n\n```\nif (!-e $request_filename) {\n    rewrite . /index.php last;\n}\n```\n\n很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：\n\n```\ntry_files $uri $uri/ /index.php;\n```\n\n除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。\n\n**下面看看「fastcgi_params」配置文件**\n\n```\ninclude fastcgi_params;\n```\n\nNginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：\n\n```\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n```\n\n注意：$document_root 和 $fastcgi_script_name 之间没有 /。\n\n原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。\n\n不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。\n\n此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：\n\n```\ntry_files $uri =404;\n```\n\n**改良后的版本**\n\n依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：\n\n```\nserver {\n    listen 80;\n    server_name foo.com;\n\n    root /path;\n    index index.html index.htm index.php;\n\n    location / {\n        try_files $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~ /.php$ {\n        try_files $uri =404;\n\n        include fastcgi.conf;\n        fastcgi_pass 127.0.0.1:9000;\n    }\n}\n```\n\n转载：[http://www.codeceo.com](http://www.codeceo.com/article/nginx-php-config.html)\n","slug":"如何正确配置Nginx+PHP","published":1,"updated":"2016-08-17T06:22:19.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm0004g68ddpqgx09op","content":"<p>关于linux服务器的配置一直令我头疼，会出现各式各样的问题，解决问题都无从下手，所以，一直以来，也很佩服做系统运维的技术人员，他们真的是在整理乱麻。看过许多配置服务器的文章，可以这样说，没有一个可以让我把服务器配置成功的，不是服务器无响应，要不就是PHP跑不起来，再就是mysql无法启动。所以放弃了，现在只用lnmp这种集成的来总署服务器。</p>\n<p>下面这篇文章不算是教你配置服务器，而是告诉你，应该怎样优化，是否行得通，读者自行验证吧！</p>\n<hr>\n<p>对很多人而言，配置Nginx+PHP无外乎就是搜索一篇教程，然后拷贝粘贴。听上去似乎也没什么问题，可惜实际上网络上很多资料本身年久失修，漏洞百出，如果大家不求甚解，一味的拷贝粘贴，早晚有一天会为此付出代价。</p>\n<p>假设我们用PHP实现了一个前端控制器，或者直白点说就是统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p>\n<p><strong>一般这样配置</strong></p>\n<p>此时很多教程会教大家这样配置Nginx+PHP：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    server_name foo.com;</div><div class=\"line\"></div><div class=\"line\">    root /path;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        index index.html index.htm index.php;</div><div class=\"line\"></div><div class=\"line\">        if (!-e $request_filename) &#123;</div><div class=\"line\">            rewrite . /index.php last;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ /.php$ &#123;</div><div class=\"line\">        include fastcgi_params;</div><div class=\"line\">        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;</div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">        fastcgi_index index.php;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面有很多错误，或者说至少是坏味道的地方，大家看看能发现几个。</p>\n<p>我们有必要先了解一下Nginx配置文件里指令的继承关系：</p>\n<p>Nginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。</p>\n<p><strong>让我们先从「index」指令入手吧</strong></p>\n<p>在问题配置中它是在「location」中定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">location / &#123;</div><div class=\"line\">    index index.html index.htm index.php;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p>\n<p><strong>接下来看看「if」指令</strong></p>\n<p>说它是大家误解最深的Nginx指令毫不为过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!-e $request_filename) &#123;</div><div class=\"line\">    rewrite . /index.php last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">try_files $uri $uri/ /index.php;</div></pre></td></tr></table></figure>\n<p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。</p>\n<p><strong>下面看看「fastcgi_params」配置文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">include fastcgi_params;</div></pre></td></tr></table></figure>\n<p>Nginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</div></pre></td></tr></table></figure>\n<p>注意：$document_root 和 $fastcgi_script_name 之间没有 /。</p>\n<p>原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p>\n<p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p>\n<p>此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">try_files $uri =404;</div></pre></td></tr></table></figure>\n<p><strong>改良后的版本</strong></p>\n<p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    server_name foo.com;</div><div class=\"line\"></div><div class=\"line\">    root /path;</div><div class=\"line\">    index index.html index.htm index.php;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        try_files $uri $uri/ /index.php$is_args$args;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ /.php$ &#123;</div><div class=\"line\">        try_files $uri =404;</div><div class=\"line\"></div><div class=\"line\">        include fastcgi.conf;</div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转载：<a href=\"http://www.codeceo.com/article/nginx-php-config.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a></p>\n","excerpt":"","more":"<p>关于linux服务器的配置一直令我头疼，会出现各式各样的问题，解决问题都无从下手，所以，一直以来，也很佩服做系统运维的技术人员，他们真的是在整理乱麻。看过许多配置服务器的文章，可以这样说，没有一个可以让我把服务器配置成功的，不是服务器无响应，要不就是PHP跑不起来，再就是mysql无法启动。所以放弃了，现在只用lnmp这种集成的来总署服务器。</p>\n<p>下面这篇文章不算是教你配置服务器，而是告诉你，应该怎样优化，是否行得通，读者自行验证吧！</p>\n<hr>\n<p>对很多人而言，配置Nginx+PHP无外乎就是搜索一篇教程，然后拷贝粘贴。听上去似乎也没什么问题，可惜实际上网络上很多资料本身年久失修，漏洞百出，如果大家不求甚解，一味的拷贝粘贴，早晚有一天会为此付出代价。</p>\n<p>假设我们用PHP实现了一个前端控制器，或者直白点说就是统一入口：把PHP请求都发送到同一个文件上，然后在此文件里通过解析「REQUEST_URI」实现路由。</p>\n<p><strong>一般这样配置</strong></p>\n<p>此时很多教程会教大家这样配置Nginx+PHP：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    server_name foo.com;</div><div class=\"line\"></div><div class=\"line\">    root /path;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        index index.html index.htm index.php;</div><div class=\"line\"></div><div class=\"line\">        if (!-e $request_filename) &#123;</div><div class=\"line\">            rewrite . /index.php last;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ /.php$ &#123;</div><div class=\"line\">        include fastcgi_params;</div><div class=\"line\">        fastcgi_param SCRIPT_FILENAME /path$fastcgi_script_name;</div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">        fastcgi_index index.php;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里面有很多错误，或者说至少是坏味道的地方，大家看看能发现几个。</p>\n<p>我们有必要先了解一下Nginx配置文件里指令的继承关系：</p>\n<p>Nginx配置文件分为好多块，常见的从外到内依次是「http」、「server」、「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。</p>\n<p><strong>让我们先从「index」指令入手吧</strong></p>\n<p>在问题配置中它是在「location」中定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">location / &#123;</div><div class=\"line\">    index index.html index.htm index.php;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>一旦未来需要加入新的「location」，必然会出现重复定义的「index」指令，这是因为多个「location」是平级的关系，不存在继承，此时应该在「server」里定义「index」，借助继承关系，「index」指令在所有的「location」中都能生效。</p>\n<p><strong>接下来看看「if」指令</strong></p>\n<p>说它是大家误解最深的Nginx指令毫不为过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!-e $request_filename) &#123;</div><div class=\"line\">    rewrite . /index.php last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>很多人喜欢用「if」指令做一系列的检查，不过这实际上是「try_files」指令的职责：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">try_files $uri $uri/ /index.php;</div></pre></td></tr></table></figure>\n<p>除此以外，初学者往往会认为「if」指令是内核级的指令，但是实际上它是rewrite模块的一部分，加上Nginx配置实际上是声明式的，而非过程式的，所以当其和非rewrite模块的指令混用时，结果可能会非你所愿。</p>\n<p><strong>下面看看「fastcgi_params」配置文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">include fastcgi_params;</div></pre></td></tr></table></figure>\n<p>Nginx有两份fastcgi配置文件，分别是「fastcgi_params」和「fastcgi.conf」，它们没有太大的差异，唯一的区别是后者比前者多了一行「SCRIPT_FILENAME」的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</div></pre></td></tr></table></figure>\n<p>注意：$document_root 和 $fastcgi_script_name 之间没有 /。</p>\n<p>原本Nginx只有「fastcgi_params」，后来发现很多人在定义「SCRIPT_FILENAME」时使用了硬编码的方式，于是为了规范用法便引入了「fastcgi.conf」。</p>\n<p>不过这样的话就产生一个疑问：为什么一定要引入一个新的配置文件，而不是修改旧的配置文件？这是因为「fastcgi_param」指令是数组型的，和普通指令相同的是：内层替换外层；和普通指令不同的是：当在同级多次使用的时候，是新增而不是替换。换句话说，如果在同级定义两次「SCRIPT_FILENAME」，那么它们都会被发送到后端，这可能会导致一些潜在的问题，为了避免此类情况，便引入了一个新的配置文件。</p>\n<p>此外，我们还需要考虑一个安全问题：在PHP开启「cgi.fix_pathinfo」的情况下，PHP可能会把错误的文件类型当作PHP文件来解析。如果Nginx和PHP安装在同一台服务器上的话，那么最简单的解决方法是用「try_files」指令做一次过滤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">try_files $uri =404;</div></pre></td></tr></table></figure>\n<p><strong>改良后的版本</strong></p>\n<p>依照前面的分析，给出一份改良后的版本，是不是比开始的版本清爽了很多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    server_name foo.com;</div><div class=\"line\"></div><div class=\"line\">    root /path;</div><div class=\"line\">    index index.html index.htm index.php;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        try_files $uri $uri/ /index.php$is_args$args;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ /.php$ &#123;</div><div class=\"line\">        try_files $uri =404;</div><div class=\"line\"></div><div class=\"line\">        include fastcgi.conf;</div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>转载：<a href=\"http://www.codeceo.com/article/nginx-php-config.html\">http://www.codeceo.com</a></p>\n"},{"title":"学习并运用JavaScript的原生函数","date":"2015-01-26T16:00:00.000Z","_content":"\n尽管 JavaScript 总是让人产生误解，但是它已经成为了最流行的编程语言之一。理解 JavaScript 的内在原理很困难。同样的，迫使 JavaScript 成为常规规范，如面向对象或函数编程，同样具有挑战性。这里我强调阐明 JavaScript 核心部分的原生函数。\n\n在这篇文章中，我将讨论以下几种行为：\n\n- Call/Apply\n- Bind\n- Map\n- Filter\n\n首先我会定义这个函数(利用Mozilla的声明方式)，然后提供一个例子，最后实现此函数。\n\n为了解释这些行为，我需要先解释一下复杂的 this 关键字以及类似数组的 arguments 对象。\n\n### this 和 arguments 对象\n\nJavaScript 的作用域是基于函数而言的，术语一般称为作用域，变量和方法的作用域都是当前函数。此外，函数执行的作用域是他们被定义的作用域而不是执行的作用域。如果你想了解更多有关于作用域的知识，可以参考你应该知道的4种 JavaScript 设计模式这篇文章。this对象引用当前函数的上下文并且可以以多种方式被调用。例如，它可以被绑定到 window 对象（全局作用域）。\n\n```javascript\nthis.globalVar = {\n    myGlobalVarsMethod: function (){\n        // Implementation\n    }\n};\n\nconsole.log(this.globalVar); // { myGlobalVarsMethod: [Function] }\n```\n\n并且变量可以绑定到已存在的函数中，如下：\n\n```javascript\nthis.globalVariable = 'globalVariable';\nfunction globalFunction (){\n    this.innerVariable = 'innerVariable';\n    console.log(this.globalVariable === undefined); // false\n    console.log(this.innerVariable === 'innerVariable'); // true\n    return {\n        innerFunction: function () {\n            console.log(this.globalVariable === undefined); // true\n            console.log(this.innerVariable === undefined); // true\n        }\n    }\n}\n\nglobalFunction().innerFunction();\n```\n\n这里存在被绑定到每一个调用函数的 this 对象。严格模式下，如果变量未定义就会抛出异常/错误( TypeErrors )。在生产环境下严格模式者会被优先考虑；然而，我故意选择不使用此模式以避免抛出异常。下面是严格模式下的一个简单例子：\n\n```javascript\nthis.globalVar = 'globalVar';\nfunction nonStrictFunctionTest () {\n    return function () {\n        console.log(this.globalVar); // globalVar\n    }\n}\n\nfunction strictFunctionTest () {\n    'use strict'; // Strict Mode\n    return function () {\n        console.log(this.globalVar); // TypeError: Cannot read property 'globalVar' of undefined\n    }\n}\n\nnonStrictFunctionTest()();\nstrictFunctionTest()();\n```\n\n可能很多 JavaScript 开发人员不知道，创建函数时会有一个arguments对象。这是一个类似数组的对象（仅具有属性的长度）。arguments主要有三个属性，即callee(调用方法)，length，和caller（调用函数的参考）。\n\n在一个函数中声明变量参数会替换/覆盖原先的参数对象。\n\n如下列出的一些参数对象：\n\n```javascript\nfunction fn (){\n    console.log(typeof arguments); // [object Object]\n    console.log(arguments[0]); // DeathStar\n    console.log(arguments[1]); // Tatooine\n    arguments.push(\"Naboo\"); // TypeError: undefined is not a function\n    var arguments = \"Star Wars\";\n    console.log(arguments[5]); // W\n}\n\nfn(\"DeathStar\", \"Tatooine\");\n```\n\n按照如下所示，用 arguments 创建一个数组：\n\n```javascript\nvar args = Array.prototype.slice.call(arguments);\nCall/Apply\n```\n\n无论 call 还是 apply 都是调用对象的一个方法。关于使用点操作符，call 和 apply 都接受其作为第一个参数。如上所述，每一个函数都保持在其所定义的特定作用域内。因此，当你调用对象时必须考虑到函数的作用域。\n\nMozilla 浏览器的apply和call调用声明如下所示：\n\n```javascript\nfun.apply(thisArg, [argsArray])\nfun.call(thisArg[, arg1[, arg2[, ...]]])\n```\n\n通过传递 thisArg 参数，在特定的上下文中，被调用的函数可以访问或修改对象。下面的例子阐明了 call 的使用。\n\n```javascript\nthis.lightSaberColor = 'none';\nvar darthVader = {\n    team: 'Empire',\n    lightSaberColor: 'Red'\n};\n\nvar printLightSaberColor = function(){\n    console.log(this.lightSaberColor);\n}\n\nprintLightSaberColor() // none\nprintLightSaberColor.call(darthVader); // Red\nprintLightSaberColor.apply(darthVader); // Red\n```\n\n注意：第一次调用默认为全局作用域(window)，然而，第二次为 darthvader。\n\ncall 和 apply 主要的区别在于他们的声明方式不同。call 需要参数分开传递，而 apply 需要传入由参数组成的数组。我是这样记忆的：“Apply uses an Array。”当你的程序无关乎参数数目时，apply 方法可能会更加适用。\n\nCurrying(柯里化)(部分函数应用)是应用 call 和 apply 的一个函数式编程。Currying 允许我们创建返回已知条件的函数。这里是一个 currying 函数：\n\n```javascript\nvar curry = function(fun) {\n  // nothing to curry. return function\n  if (arguments.length < 1) {\n    return this;\n  }\n\n  // Create an array with the functions arguments\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Apply fn with fn's arguments\n    return fun.apply(this, args.concat(Array.prototype.slice.call(arguments, 0)));\n  };\n};\n\n// Creating function that already predefines adding 1 to a\nfunction addOneToNumber(a) {\n    console.log(1 + a);\n}\n\n// addOneCurried is of function\nvar addOneCurried = curry(addOneToNumber);\nconsole.log(addOneCurried(10)); // 11\n```\n\n虽然 arguments 不是数组，但是 Array.prototype.slice可以将类数组的对象转换成新数组。\n\n### Bind\n\nbind方法用于明确指定调用 this 方法。在作用域方面，类似于 call 和 apply 。当你将一个对象绑定到一个函数的 this对象时，你就会用到 bind。\n\n如下是bind的声明：\n\n```javascript\nfun.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n通俗地说，我们是通过 bind 向函数 fun 传递 thisArg 参数。实质上就是每次 fun 函数都必须通过传递 thisArg 参数调用 bind 方法。让我们在一个简单的例子中仔细看看。\n\n```javascript\nvar lukeSkywalker = {\n    mother: 'Padme Amidala',\n    father: 'Anakin Skywalker'.\n}\n\nvar getFather = function(){\n    console.log(this.father);\n}\n\ngetFather(); // undefined\ngetFather.bind(lukeSkywalker)(); // Anakin Skywalker\ngetFather(lukeSkywalker); // undefined\n```\n\n第一个getfather()返回值为 undefined 是因为在这里 father 属性没有被定义。那这时 this 代表什么呢？只要我们不明确的指定它，它就代表 window 的全局对象。第二个getfather()返回 “Anakin Skywalker”是因为getfather()中的 this 指代的是 lukeskywalker。许多Java/C++ 开发人员会设想最后一个getfather()的调用将返回预想的结果–虽然再次返回全局对象。\n\n如下这里是 bind 的实现原理：\n\n```javascript\nFunction.prototype.bind = function(scope) {\n  var _that = this;\n  return function() {\n    return _that.apply(scope, arguments);\n  }\n}\n```\n\n这里 JavaScript 的作用域是合乎逻辑的，返回函数的 this 对象是不同于 bind 的 this 对象的。因此，将 this 暂时缓存给变量 _that 保证了其正确的作用域范围。否则，this.apply(scope,arguments) 将会未定义。\n\n### Map\n\nJavaScript 的 map 函数是遍历数组，同时转换每个元素的函数编程技术。它用 modified 元素创建了一个新数组并以回调的方式返回。关于我提到的修改或转换元素，实践表明，如果元素是对象(而不是原语),这只是克隆对象并不是从物理上改变了原生的。\n\n以下是该方法的声明：\n\n```javascript\narr.map(callback[, thisArg])\n```\n\n回调方法有三个参数，即 currentValue，index，和 array。\n\n这里是一个有关于 map 的简单例子：\n\n````javascript\nfunction Jedi(name) {\n    this.name = name;\n}\n\nvar kit = new Jedi('Kit');\nvar count = new Jedi('Count');\nvar mace = new Jedi('Mace');\nvar jedis = [kit, count, mace];\nvar lastNames = ['Fisto', 'Dooku', 'Windu'];\nvar jedisWithFullNames = jedis.map(function(currentValue, index, array) {\n    var clonedJedi = (JSON.parse(JSON.stringify(currentValue))) // Clone currentValue\n    clonedJedi.name = currentValue.name + \" \" + lastNames[index];\n    return clonedJedi;\n});\n\njedisWithFullNames.map(function(currentValue) {\n    console.log(currentValue.name);\n});\n\n/**\nOutput:\nKit Fisto\nCount Dooku\nMace Windu\n*/\n````\n\n了解了 map 是用来做什么的，让我们看一下它具体是如何实现的：\n\n```javascript\nArray.prototype.map = function (fun, thisArg) {\n    if(typeof fun !== 'function') {\n        throw new Error(\"The first argument must be of type function\");\n    }\n  \n    var arr = [];\n    thisArg = (thisArg) ? thisArg : this;\n    thisArg.forEach(function(element) {\n        arr[arr.length] = fun.call(thisArgs, element);\n    });\n\n    return arr;\n}\n```\n\n注：这是一个简单的实现。到 ECMAScript 5看全部的实现，并查阅其规范。\n\n### Filter\n\nfilter 方法是数组的另外一种表现行为。类似于 map，filter 返回一个新的数组并接受一个函数和一个可选的 thisArg 参数。然而，返回的数组仅包含适合在回调函数测试的特定条件的元素。回调函数必须返回一个 Boolean –返回 true 的元素才会被接受并插入到返回的数组。\n\n关于 filter 有许多应用，包括选择偶数，用一个特定的属性选择对象，或选择有效的电话号码。\n\n这里是其中一种声明方法：\n\n```javascript\narr.filter(callback[, thisArg])\n```\n\n同样的，thisArg 是可选的参数并且回调函数接受三个参数，currentValue，index 和 array。\n\n这里是一个有关于 filter 的例子：\n\n```javascript\nfunction Person(name, side) {\n    this.name = name;\n    this.side = side;\n}\n\nvar hanSolo = new Person('Han Solo','Rebels');\nvar bobaFett = new Person('Boba Fett','Empire');\nvar princessLeia = new Person('Princess Leia', 'Rebels');\nvar people = [hanSolo, bobaFett, princessLeia];\nvar enemies = people.filter(function (currentValue, index, array) {\n    return currentValue.side === 'Empire';\n})\n\n.map(function(currentValue) {\n    console.log(currentValue.name + \" fights for the \" + currentValue.side + \".\");\n});\n\n/**\nOutput:\nBoba Fett fights for the Empire.\n*/\n```\n\n有趣的是，array 方法可以创造有趣的，复杂的操作。\n\n最后，让我们看看 filter 的实现：\n\n```javascript\nArray.prototype.filter = function(fun, thisArg) {\n    if(typeof fun !== 'function') {\n        throw new Error(\"The first argument must be of type function\");\n    }\n\n    var arr = [];\n    thisArg = (thisArg) ? thisArg : this;\n    thisArg.forEach(function(element) {\n      if (fun.call(thisArg, element)) {\n        arr[arr.length] = element;\n      }\n    });\n\n    return arr;\n};\n```\n\n这里是 ECMAScript 的实现规范。\n\n### 总结\n\n还有更多令人困惑但是很有用的原生函数。它们是值得用数组和函数来回顾其中的每一种方法。\n\n希望这篇文章可以有助于你理解 JavaScript 的内部原理和词法作用域。尽管与实践紧密相连，call、apply，和bind 还是很难把握的。为了避免传统的循环技术你可以尝试使用 map 和 filter 方法 。\n\n> 作者：Devan Patel\n>\n> 翻译自：https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them\n>\n> 感谢：[typora](http://www.typora.io/)\n\n","source":"_posts/学习并运用JavaScript的原生函数.md","raw":"---\ntitle: 学习并运用JavaScript的原生函数\ntags: [javascript]\ndate: 2015/01/27\n---\n\n尽管 JavaScript 总是让人产生误解，但是它已经成为了最流行的编程语言之一。理解 JavaScript 的内在原理很困难。同样的，迫使 JavaScript 成为常规规范，如面向对象或函数编程，同样具有挑战性。这里我强调阐明 JavaScript 核心部分的原生函数。\n\n在这篇文章中，我将讨论以下几种行为：\n\n- Call/Apply\n- Bind\n- Map\n- Filter\n\n首先我会定义这个函数(利用Mozilla的声明方式)，然后提供一个例子，最后实现此函数。\n\n为了解释这些行为，我需要先解释一下复杂的 this 关键字以及类似数组的 arguments 对象。\n\n### this 和 arguments 对象\n\nJavaScript 的作用域是基于函数而言的，术语一般称为作用域，变量和方法的作用域都是当前函数。此外，函数执行的作用域是他们被定义的作用域而不是执行的作用域。如果你想了解更多有关于作用域的知识，可以参考你应该知道的4种 JavaScript 设计模式这篇文章。this对象引用当前函数的上下文并且可以以多种方式被调用。例如，它可以被绑定到 window 对象（全局作用域）。\n\n```javascript\nthis.globalVar = {\n    myGlobalVarsMethod: function (){\n        // Implementation\n    }\n};\n\nconsole.log(this.globalVar); // { myGlobalVarsMethod: [Function] }\n```\n\n并且变量可以绑定到已存在的函数中，如下：\n\n```javascript\nthis.globalVariable = 'globalVariable';\nfunction globalFunction (){\n    this.innerVariable = 'innerVariable';\n    console.log(this.globalVariable === undefined); // false\n    console.log(this.innerVariable === 'innerVariable'); // true\n    return {\n        innerFunction: function () {\n            console.log(this.globalVariable === undefined); // true\n            console.log(this.innerVariable === undefined); // true\n        }\n    }\n}\n\nglobalFunction().innerFunction();\n```\n\n这里存在被绑定到每一个调用函数的 this 对象。严格模式下，如果变量未定义就会抛出异常/错误( TypeErrors )。在生产环境下严格模式者会被优先考虑；然而，我故意选择不使用此模式以避免抛出异常。下面是严格模式下的一个简单例子：\n\n```javascript\nthis.globalVar = 'globalVar';\nfunction nonStrictFunctionTest () {\n    return function () {\n        console.log(this.globalVar); // globalVar\n    }\n}\n\nfunction strictFunctionTest () {\n    'use strict'; // Strict Mode\n    return function () {\n        console.log(this.globalVar); // TypeError: Cannot read property 'globalVar' of undefined\n    }\n}\n\nnonStrictFunctionTest()();\nstrictFunctionTest()();\n```\n\n可能很多 JavaScript 开发人员不知道，创建函数时会有一个arguments对象。这是一个类似数组的对象（仅具有属性的长度）。arguments主要有三个属性，即callee(调用方法)，length，和caller（调用函数的参考）。\n\n在一个函数中声明变量参数会替换/覆盖原先的参数对象。\n\n如下列出的一些参数对象：\n\n```javascript\nfunction fn (){\n    console.log(typeof arguments); // [object Object]\n    console.log(arguments[0]); // DeathStar\n    console.log(arguments[1]); // Tatooine\n    arguments.push(\"Naboo\"); // TypeError: undefined is not a function\n    var arguments = \"Star Wars\";\n    console.log(arguments[5]); // W\n}\n\nfn(\"DeathStar\", \"Tatooine\");\n```\n\n按照如下所示，用 arguments 创建一个数组：\n\n```javascript\nvar args = Array.prototype.slice.call(arguments);\nCall/Apply\n```\n\n无论 call 还是 apply 都是调用对象的一个方法。关于使用点操作符，call 和 apply 都接受其作为第一个参数。如上所述，每一个函数都保持在其所定义的特定作用域内。因此，当你调用对象时必须考虑到函数的作用域。\n\nMozilla 浏览器的apply和call调用声明如下所示：\n\n```javascript\nfun.apply(thisArg, [argsArray])\nfun.call(thisArg[, arg1[, arg2[, ...]]])\n```\n\n通过传递 thisArg 参数，在特定的上下文中，被调用的函数可以访问或修改对象。下面的例子阐明了 call 的使用。\n\n```javascript\nthis.lightSaberColor = 'none';\nvar darthVader = {\n    team: 'Empire',\n    lightSaberColor: 'Red'\n};\n\nvar printLightSaberColor = function(){\n    console.log(this.lightSaberColor);\n}\n\nprintLightSaberColor() // none\nprintLightSaberColor.call(darthVader); // Red\nprintLightSaberColor.apply(darthVader); // Red\n```\n\n注意：第一次调用默认为全局作用域(window)，然而，第二次为 darthvader。\n\ncall 和 apply 主要的区别在于他们的声明方式不同。call 需要参数分开传递，而 apply 需要传入由参数组成的数组。我是这样记忆的：“Apply uses an Array。”当你的程序无关乎参数数目时，apply 方法可能会更加适用。\n\nCurrying(柯里化)(部分函数应用)是应用 call 和 apply 的一个函数式编程。Currying 允许我们创建返回已知条件的函数。这里是一个 currying 函数：\n\n```javascript\nvar curry = function(fun) {\n  // nothing to curry. return function\n  if (arguments.length < 1) {\n    return this;\n  }\n\n  // Create an array with the functions arguments\n  var args = Array.prototype.slice.call(arguments, 1);\n  return function() {\n    // Apply fn with fn's arguments\n    return fun.apply(this, args.concat(Array.prototype.slice.call(arguments, 0)));\n  };\n};\n\n// Creating function that already predefines adding 1 to a\nfunction addOneToNumber(a) {\n    console.log(1 + a);\n}\n\n// addOneCurried is of function\nvar addOneCurried = curry(addOneToNumber);\nconsole.log(addOneCurried(10)); // 11\n```\n\n虽然 arguments 不是数组，但是 Array.prototype.slice可以将类数组的对象转换成新数组。\n\n### Bind\n\nbind方法用于明确指定调用 this 方法。在作用域方面，类似于 call 和 apply 。当你将一个对象绑定到一个函数的 this对象时，你就会用到 bind。\n\n如下是bind的声明：\n\n```javascript\nfun.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n通俗地说，我们是通过 bind 向函数 fun 传递 thisArg 参数。实质上就是每次 fun 函数都必须通过传递 thisArg 参数调用 bind 方法。让我们在一个简单的例子中仔细看看。\n\n```javascript\nvar lukeSkywalker = {\n    mother: 'Padme Amidala',\n    father: 'Anakin Skywalker'.\n}\n\nvar getFather = function(){\n    console.log(this.father);\n}\n\ngetFather(); // undefined\ngetFather.bind(lukeSkywalker)(); // Anakin Skywalker\ngetFather(lukeSkywalker); // undefined\n```\n\n第一个getfather()返回值为 undefined 是因为在这里 father 属性没有被定义。那这时 this 代表什么呢？只要我们不明确的指定它，它就代表 window 的全局对象。第二个getfather()返回 “Anakin Skywalker”是因为getfather()中的 this 指代的是 lukeskywalker。许多Java/C++ 开发人员会设想最后一个getfather()的调用将返回预想的结果–虽然再次返回全局对象。\n\n如下这里是 bind 的实现原理：\n\n```javascript\nFunction.prototype.bind = function(scope) {\n  var _that = this;\n  return function() {\n    return _that.apply(scope, arguments);\n  }\n}\n```\n\n这里 JavaScript 的作用域是合乎逻辑的，返回函数的 this 对象是不同于 bind 的 this 对象的。因此，将 this 暂时缓存给变量 _that 保证了其正确的作用域范围。否则，this.apply(scope,arguments) 将会未定义。\n\n### Map\n\nJavaScript 的 map 函数是遍历数组，同时转换每个元素的函数编程技术。它用 modified 元素创建了一个新数组并以回调的方式返回。关于我提到的修改或转换元素，实践表明，如果元素是对象(而不是原语),这只是克隆对象并不是从物理上改变了原生的。\n\n以下是该方法的声明：\n\n```javascript\narr.map(callback[, thisArg])\n```\n\n回调方法有三个参数，即 currentValue，index，和 array。\n\n这里是一个有关于 map 的简单例子：\n\n````javascript\nfunction Jedi(name) {\n    this.name = name;\n}\n\nvar kit = new Jedi('Kit');\nvar count = new Jedi('Count');\nvar mace = new Jedi('Mace');\nvar jedis = [kit, count, mace];\nvar lastNames = ['Fisto', 'Dooku', 'Windu'];\nvar jedisWithFullNames = jedis.map(function(currentValue, index, array) {\n    var clonedJedi = (JSON.parse(JSON.stringify(currentValue))) // Clone currentValue\n    clonedJedi.name = currentValue.name + \" \" + lastNames[index];\n    return clonedJedi;\n});\n\njedisWithFullNames.map(function(currentValue) {\n    console.log(currentValue.name);\n});\n\n/**\nOutput:\nKit Fisto\nCount Dooku\nMace Windu\n*/\n````\n\n了解了 map 是用来做什么的，让我们看一下它具体是如何实现的：\n\n```javascript\nArray.prototype.map = function (fun, thisArg) {\n    if(typeof fun !== 'function') {\n        throw new Error(\"The first argument must be of type function\");\n    }\n  \n    var arr = [];\n    thisArg = (thisArg) ? thisArg : this;\n    thisArg.forEach(function(element) {\n        arr[arr.length] = fun.call(thisArgs, element);\n    });\n\n    return arr;\n}\n```\n\n注：这是一个简单的实现。到 ECMAScript 5看全部的实现，并查阅其规范。\n\n### Filter\n\nfilter 方法是数组的另外一种表现行为。类似于 map，filter 返回一个新的数组并接受一个函数和一个可选的 thisArg 参数。然而，返回的数组仅包含适合在回调函数测试的特定条件的元素。回调函数必须返回一个 Boolean –返回 true 的元素才会被接受并插入到返回的数组。\n\n关于 filter 有许多应用，包括选择偶数，用一个特定的属性选择对象，或选择有效的电话号码。\n\n这里是其中一种声明方法：\n\n```javascript\narr.filter(callback[, thisArg])\n```\n\n同样的，thisArg 是可选的参数并且回调函数接受三个参数，currentValue，index 和 array。\n\n这里是一个有关于 filter 的例子：\n\n```javascript\nfunction Person(name, side) {\n    this.name = name;\n    this.side = side;\n}\n\nvar hanSolo = new Person('Han Solo','Rebels');\nvar bobaFett = new Person('Boba Fett','Empire');\nvar princessLeia = new Person('Princess Leia', 'Rebels');\nvar people = [hanSolo, bobaFett, princessLeia];\nvar enemies = people.filter(function (currentValue, index, array) {\n    return currentValue.side === 'Empire';\n})\n\n.map(function(currentValue) {\n    console.log(currentValue.name + \" fights for the \" + currentValue.side + \".\");\n});\n\n/**\nOutput:\nBoba Fett fights for the Empire.\n*/\n```\n\n有趣的是，array 方法可以创造有趣的，复杂的操作。\n\n最后，让我们看看 filter 的实现：\n\n```javascript\nArray.prototype.filter = function(fun, thisArg) {\n    if(typeof fun !== 'function') {\n        throw new Error(\"The first argument must be of type function\");\n    }\n\n    var arr = [];\n    thisArg = (thisArg) ? thisArg : this;\n    thisArg.forEach(function(element) {\n      if (fun.call(thisArg, element)) {\n        arr[arr.length] = element;\n      }\n    });\n\n    return arr;\n};\n```\n\n这里是 ECMAScript 的实现规范。\n\n### 总结\n\n还有更多令人困惑但是很有用的原生函数。它们是值得用数组和函数来回顾其中的每一种方法。\n\n希望这篇文章可以有助于你理解 JavaScript 的内部原理和词法作用域。尽管与实践紧密相连，call、apply，和bind 还是很难把握的。为了避免传统的循环技术你可以尝试使用 map 和 filter 方法 。\n\n> 作者：Devan Patel\n>\n> 翻译自：https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them\n>\n> 感谢：[typora](http://www.typora.io/)\n\n","slug":"学习并运用JavaScript的原生函数","published":1,"updated":"2016-08-17T06:22:19.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm2004i68dd1c0p5wf5","content":"<p>尽管 JavaScript 总是让人产生误解，但是它已经成为了最流行的编程语言之一。理解 JavaScript 的内在原理很困难。同样的，迫使 JavaScript 成为常规规范，如面向对象或函数编程，同样具有挑战性。这里我强调阐明 JavaScript 核心部分的原生函数。</p>\n<p>在这篇文章中，我将讨论以下几种行为：</p>\n<ul>\n<li>Call/Apply</li>\n<li>Bind</li>\n<li>Map</li>\n<li>Filter</li>\n</ul>\n<p>首先我会定义这个函数(利用Mozilla的声明方式)，然后提供一个例子，最后实现此函数。</p>\n<p>为了解释这些行为，我需要先解释一下复杂的 this 关键字以及类似数组的 arguments 对象。</p>\n<h3 id=\"this-和-arguments-对象\"><a href=\"#this-和-arguments-对象\" class=\"headerlink\" title=\"this 和 arguments 对象\"></a>this 和 arguments 对象</h3><p>JavaScript 的作用域是基于函数而言的，术语一般称为作用域，变量和方法的作用域都是当前函数。此外，函数执行的作用域是他们被定义的作用域而不是执行的作用域。如果你想了解更多有关于作用域的知识，可以参考你应该知道的4种 JavaScript 设计模式这篇文章。this对象引用当前函数的上下文并且可以以多种方式被调用。例如，它可以被绑定到 window 对象（全局作用域）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVar = &#123;</div><div class=\"line\">    myGlobalVarsMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Implementation</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// &#123; myGlobalVarsMethod: [Function] &#125;</span></div></pre></td></tr></table></figure>\n<p>并且变量可以绑定到已存在的函数中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVariable = <span class=\"string\">'globalVariable'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunction</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.innerVariable = <span class=\"string\">'innerVariable'</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.innerVariable === <span class=\"string\">'innerVariable'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        innerFunction: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.innerVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">globalFunction().innerFunction();</div></pre></td></tr></table></figure>\n<p>这里存在被绑定到每一个调用函数的 this 对象。严格模式下，如果变量未定义就会抛出异常/错误( TypeErrors )。在生产环境下严格模式者会被优先考虑；然而，我故意选择不使用此模式以避免抛出异常。下面是严格模式下的一个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVar = <span class=\"string\">'globalVar'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nonStrictFunctionTest</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// globalVar</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strictFunctionTest</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">    'use strict'</span>; <span class=\"comment\">// Strict Mode</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// TypeError: Cannot read property 'globalVar' of undefined</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">nonStrictFunctionTest()();</div><div class=\"line\">strictFunctionTest()();</div></pre></td></tr></table></figure>\n<p>可能很多 JavaScript 开发人员不知道，创建函数时会有一个arguments对象。这是一个类似数组的对象（仅具有属性的长度）。arguments主要有三个属性，即callee(调用方法)，length，和caller（调用函数的参考）。</p>\n<p>在一个函数中声明变量参数会替换/覆盖原先的参数对象。</p>\n<p>如下列出的一些参数对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [object Object]</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]); <span class=\"comment\">// DeathStar</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]); <span class=\"comment\">// Tatooine</span></div><div class=\"line\">    <span class=\"built_in\">arguments</span>.push(<span class=\"string\">\"Naboo\"</span>); <span class=\"comment\">// TypeError: undefined is not a function</span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"string\">\"Star Wars\"</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">5</span>]); <span class=\"comment\">// W</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn(<span class=\"string\">\"DeathStar\"</span>, <span class=\"string\">\"Tatooine\"</span>);</div></pre></td></tr></table></figure>\n<p>按照如下所示，用 arguments 创建一个数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">Call/Apply</div></pre></td></tr></table></figure>\n<p>无论 call 还是 apply 都是调用对象的一个方法。关于使用点操作符，call 和 apply 都接受其作为第一个参数。如上所述，每一个函数都保持在其所定义的特定作用域内。因此，当你调用对象时必须考虑到函数的作用域。</p>\n<p>Mozilla 浏览器的apply和call调用声明如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">fun.apply(thisArg, [argsArray])</div><div class=\"line\">fun.call(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>\n<p>通过传递 thisArg 参数，在特定的上下文中，被调用的函数可以访问或修改对象。下面的例子阐明了 call 的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.lightSaberColor = <span class=\"string\">'none'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> darthVader = &#123;</div><div class=\"line\">    team: <span class=\"string\">'Empire'</span>,</div><div class=\"line\">    lightSaberColor: <span class=\"string\">'Red'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> printLightSaberColor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.lightSaberColor);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">printLightSaberColor() <span class=\"comment\">// none</span></div><div class=\"line\">printLightSaberColor.call(darthVader); <span class=\"comment\">// Red</span></div><div class=\"line\">printLightSaberColor.apply(darthVader); <span class=\"comment\">// Red</span></div></pre></td></tr></table></figure>\n<p>注意：第一次调用默认为全局作用域(window)，然而，第二次为 darthvader。</p>\n<p>call 和 apply 主要的区别在于他们的声明方式不同。call 需要参数分开传递，而 apply 需要传入由参数组成的数组。我是这样记忆的：“Apply uses an Array。”当你的程序无关乎参数数目时，apply 方法可能会更加适用。</p>\n<p>Currying(柯里化)(部分函数应用)是应用 call 和 apply 的一个函数式编程。Currying 允许我们创建返回已知条件的函数。这里是一个 currying 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// nothing to curry. return function</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Create an array with the functions arguments</span></div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Apply fn with fn's arguments</span></div><div class=\"line\">    <span class=\"keyword\">return</span> fun.apply(<span class=\"keyword\">this</span>, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)));</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Creating function that already predefines adding 1 to a</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOneToNumber</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// addOneCurried is of function</span></div><div class=\"line\"><span class=\"keyword\">var</span> addOneCurried = curry(addOneToNumber);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(addOneCurried(<span class=\"number\">10</span>)); <span class=\"comment\">// 11</span></div></pre></td></tr></table></figure>\n<p>虽然 arguments 不是数组，但是 Array.prototype.slice可以将类数组的对象转换成新数组。</p>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><p>bind方法用于明确指定调用 this 方法。在作用域方面，类似于 call 和 apply 。当你将一个对象绑定到一个函数的 this对象时，你就会用到 bind。</p>\n<p>如下是bind的声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">fun.bind(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>\n<p>通俗地说，我们是通过 bind 向函数 fun 传递 thisArg 参数。实质上就是每次 fun 函数都必须通过传递 thisArg 参数调用 bind 方法。让我们在一个简单的例子中仔细看看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> lukeSkywalker = &#123;</div><div class=\"line\">    mother: <span class=\"string\">'Padme Amidala'</span>,</div><div class=\"line\">    father: <span class=\"string\">'Anakin Skywalker'</span>.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> getFather = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.father);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">getFather(); <span class=\"comment\">// undefined</span></div><div class=\"line\">getFather.bind(lukeSkywalker)(); <span class=\"comment\">// Anakin Skywalker</span></div><div class=\"line\">getFather(lukeSkywalker); <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>第一个getfather()返回值为 undefined 是因为在这里 father 属性没有被定义。那这时 this 代表什么呢？只要我们不明确的指定它，它就代表 window 的全局对象。第二个getfather()返回 “Anakin Skywalker”是因为getfather()中的 this 指代的是 lukeskywalker。许多Java/C++ 开发人员会设想最后一个getfather()的调用将返回预想的结果–虽然再次返回全局对象。</p>\n<p>如下这里是 bind 的实现原理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _that = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _that.apply(scope, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里 JavaScript 的作用域是合乎逻辑的，返回函数的 this 对象是不同于 bind 的 this 对象的。因此，将 this 暂时缓存给变量 _that 保证了其正确的作用域范围。否则，this.apply(scope,arguments) 将会未定义。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>JavaScript 的 map 函数是遍历数组，同时转换每个元素的函数编程技术。它用 modified 元素创建了一个新数组并以回调的方式返回。关于我提到的修改或转换元素，实践表明，如果元素是对象(而不是原语),这只是克隆对象并不是从物理上改变了原生的。</p>\n<p>以下是该方法的声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>\n<p>回调方法有三个参数，即 currentValue，index，和 array。</p>\n<p>这里是一个有关于 map 的简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Jedi</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> kit = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Kit'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Count'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> mace = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Mace'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jedis = [kit, count, mace];</div><div class=\"line\"><span class=\"keyword\">var</span> lastNames = [<span class=\"string\">'Fisto'</span>, <span class=\"string\">'Dooku'</span>, <span class=\"string\">'Windu'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> jedisWithFullNames = jedis.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> clonedJedi = (<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(currentValue))) <span class=\"comment\">// Clone currentValue</span></div><div class=\"line\">    clonedJedi.name = currentValue.name + <span class=\"string\">\" \"</span> + lastNames[index];</div><div class=\"line\">    <span class=\"keyword\">return</span> clonedJedi;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">jedisWithFullNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(currentValue.name);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">Output:</div><div class=\"line\">Kit Fisto</div><div class=\"line\">Count Dooku</div><div class=\"line\">Mace Windu</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>了解了 map 是用来做什么的，让我们看一下它具体是如何实现的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fun, thisArg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fun !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"The first argument must be of type function\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    thisArg = (thisArg) ? thisArg : <span class=\"keyword\">this</span>;</div><div class=\"line\">    thisArg.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">        arr[arr.length] = fun.call(thisArgs, element);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：这是一个简单的实现。到 ECMAScript 5看全部的实现，并查阅其规范。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>filter 方法是数组的另外一种表现行为。类似于 map，filter 返回一个新的数组并接受一个函数和一个可选的 thisArg 参数。然而，返回的数组仅包含适合在回调函数测试的特定条件的元素。回调函数必须返回一个 Boolean –返回 true 的元素才会被接受并插入到返回的数组。</p>\n<p>关于 filter 有许多应用，包括选择偶数，用一个特定的属性选择对象，或选择有效的电话号码。</p>\n<p>这里是其中一种声明方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>\n<p>同样的，thisArg 是可选的参数并且回调函数接受三个参数，currentValue，index 和 array。</p>\n<p>这里是一个有关于 filter 的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, side</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.side = side;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> hanSolo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Han Solo'</span>,<span class=\"string\">'Rebels'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bobaFett = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Boba Fett'</span>,<span class=\"string\">'Empire'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> princessLeia = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Princess Leia'</span>, <span class=\"string\">'Rebels'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> people = [hanSolo, bobaFett, princessLeia];</div><div class=\"line\"><span class=\"keyword\">var</span> enemies = people.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">currentValue, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> currentValue.side === <span class=\"string\">'Empire'</span>;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(currentValue.name + <span class=\"string\">\" fights for the \"</span> + currentValue.side + <span class=\"string\">\".\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">Output:</div><div class=\"line\">Boba Fett fights for the Empire.</div><div class=\"line\">*/</div></pre></td></tr></table></figure>\n<p>有趣的是，array 方法可以创造有趣的，复杂的操作。</p>\n<p>最后，让我们看看 filter 的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun, thisArg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fun !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"The first argument must be of type function\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    thisArg = (thisArg) ? thisArg : <span class=\"keyword\">this</span>;</div><div class=\"line\">    thisArg.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (fun.call(thisArg, element)) &#123;</div><div class=\"line\">        arr[arr.length] = element;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里是 ECMAScript 的实现规范。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>还有更多令人困惑但是很有用的原生函数。它们是值得用数组和函数来回顾其中的每一种方法。</p>\n<p>希望这篇文章可以有助于你理解 JavaScript 的内部原理和词法作用域。尽管与实践紧密相连，call、apply，和bind 还是很难把握的。为了避免传统的循环技术你可以尝试使用 map 和 filter 方法 。</p>\n<blockquote>\n<p>作者：Devan Patel</p>\n<p>翻译自：<a href=\"https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them\" target=\"_blank\" rel=\"external\">https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them</a></p>\n<p>感谢：<a href=\"http://www.typora.io/\" target=\"_blank\" rel=\"external\">typora</a></p>\n</blockquote>\n","excerpt":"","more":"<p>尽管 JavaScript 总是让人产生误解，但是它已经成为了最流行的编程语言之一。理解 JavaScript 的内在原理很困难。同样的，迫使 JavaScript 成为常规规范，如面向对象或函数编程，同样具有挑战性。这里我强调阐明 JavaScript 核心部分的原生函数。</p>\n<p>在这篇文章中，我将讨论以下几种行为：</p>\n<ul>\n<li>Call/Apply</li>\n<li>Bind</li>\n<li>Map</li>\n<li>Filter</li>\n</ul>\n<p>首先我会定义这个函数(利用Mozilla的声明方式)，然后提供一个例子，最后实现此函数。</p>\n<p>为了解释这些行为，我需要先解释一下复杂的 this 关键字以及类似数组的 arguments 对象。</p>\n<h3 id=\"this-和-arguments-对象\"><a href=\"#this-和-arguments-对象\" class=\"headerlink\" title=\"this 和 arguments 对象\"></a>this 和 arguments 对象</h3><p>JavaScript 的作用域是基于函数而言的，术语一般称为作用域，变量和方法的作用域都是当前函数。此外，函数执行的作用域是他们被定义的作用域而不是执行的作用域。如果你想了解更多有关于作用域的知识，可以参考你应该知道的4种 JavaScript 设计模式这篇文章。this对象引用当前函数的上下文并且可以以多种方式被调用。例如，它可以被绑定到 window 对象（全局作用域）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVar = &#123;</div><div class=\"line\">    myGlobalVarsMethod: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">// Implementation</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// &#123; myGlobalVarsMethod: [Function] &#125;</span></div></pre></td></tr></table></figure>\n<p>并且变量可以绑定到已存在的函数中，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVariable = <span class=\"string\">'globalVariable'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">globalFunction</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.innerVariable = <span class=\"string\">'innerVariable'</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// false</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.innerVariable === <span class=\"string\">'innerVariable'</span>); <span class=\"comment\">// true</span></div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        innerFunction: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.innerVariable === <span class=\"literal\">undefined</span>); <span class=\"comment\">// true</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">globalFunction().innerFunction();</div></pre></td></tr></table></figure>\n<p>这里存在被绑定到每一个调用函数的 this 对象。严格模式下，如果变量未定义就会抛出异常/错误( TypeErrors )。在生产环境下严格模式者会被优先考虑；然而，我故意选择不使用此模式以避免抛出异常。下面是严格模式下的一个简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.globalVar = <span class=\"string\">'globalVar'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nonStrictFunctionTest</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// globalVar</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">strictFunctionTest</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\"><span class=\"meta\">    'use strict'</span>; <span class=\"comment\">// Strict Mode</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.globalVar); <span class=\"comment\">// TypeError: Cannot read property 'globalVar' of undefined</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">nonStrictFunctionTest()();</div><div class=\"line\">strictFunctionTest()();</div></pre></td></tr></table></figure>\n<p>可能很多 JavaScript 开发人员不知道，创建函数时会有一个arguments对象。这是一个类似数组的对象（仅具有属性的长度）。arguments主要有三个属性，即callee(调用方法)，length，和caller（调用函数的参考）。</p>\n<p>在一个函数中声明变量参数会替换/覆盖原先的参数对象。</p>\n<p>如下列出的一些参数对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// [object Object]</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]); <span class=\"comment\">// DeathStar</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>]); <span class=\"comment\">// Tatooine</span></div><div class=\"line\">    <span class=\"built_in\">arguments</span>.push(<span class=\"string\">\"Naboo\"</span>); <span class=\"comment\">// TypeError: undefined is not a function</span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"string\">\"Star Wars\"</span>;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">5</span>]); <span class=\"comment\">// W</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn(<span class=\"string\">\"DeathStar\"</span>, <span class=\"string\">\"Tatooine\"</span>);</div></pre></td></tr></table></figure>\n<p>按照如下所示，用 arguments 创建一个数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</div><div class=\"line\">Call/Apply</div></pre></td></tr></table></figure>\n<p>无论 call 还是 apply 都是调用对象的一个方法。关于使用点操作符，call 和 apply 都接受其作为第一个参数。如上所述，每一个函数都保持在其所定义的特定作用域内。因此，当你调用对象时必须考虑到函数的作用域。</p>\n<p>Mozilla 浏览器的apply和call调用声明如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">fun.apply(thisArg, [argsArray])</div><div class=\"line\">fun.call(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>\n<p>通过传递 thisArg 参数，在特定的上下文中，被调用的函数可以访问或修改对象。下面的例子阐明了 call 的使用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>.lightSaberColor = <span class=\"string\">'none'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> darthVader = &#123;</div><div class=\"line\">    team: <span class=\"string\">'Empire'</span>,</div><div class=\"line\">    lightSaberColor: <span class=\"string\">'Red'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> printLightSaberColor = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.lightSaberColor);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">printLightSaberColor() <span class=\"comment\">// none</span></div><div class=\"line\">printLightSaberColor.call(darthVader); <span class=\"comment\">// Red</span></div><div class=\"line\">printLightSaberColor.apply(darthVader); <span class=\"comment\">// Red</span></div></pre></td></tr></table></figure>\n<p>注意：第一次调用默认为全局作用域(window)，然而，第二次为 darthvader。</p>\n<p>call 和 apply 主要的区别在于他们的声明方式不同。call 需要参数分开传递，而 apply 需要传入由参数组成的数组。我是这样记忆的：“Apply uses an Array。”当你的程序无关乎参数数目时，apply 方法可能会更加适用。</p>\n<p>Currying(柯里化)(部分函数应用)是应用 call 和 apply 的一个函数式编程。Currying 允许我们创建返回已知条件的函数。这里是一个 currying 函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// nothing to curry. return function</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt; <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Create an array with the functions arguments</span></div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Apply fn with fn's arguments</span></div><div class=\"line\">    <span class=\"keyword\">return</span> fun.apply(<span class=\"keyword\">this</span>, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)));</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Creating function that already predefines adding 1 to a</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addOneToNumber</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + a);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// addOneCurried is of function</span></div><div class=\"line\"><span class=\"keyword\">var</span> addOneCurried = curry(addOneToNumber);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(addOneCurried(<span class=\"number\">10</span>)); <span class=\"comment\">// 11</span></div></pre></td></tr></table></figure>\n<p>虽然 arguments 不是数组，但是 Array.prototype.slice可以将类数组的对象转换成新数组。</p>\n<h3 id=\"Bind\"><a href=\"#Bind\" class=\"headerlink\" title=\"Bind\"></a>Bind</h3><p>bind方法用于明确指定调用 this 方法。在作用域方面，类似于 call 和 apply 。当你将一个对象绑定到一个函数的 this对象时，你就会用到 bind。</p>\n<p>如下是bind的声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">fun.bind(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>\n<p>通俗地说，我们是通过 bind 向函数 fun 传递 thisArg 参数。实质上就是每次 fun 函数都必须通过传递 thisArg 参数调用 bind 方法。让我们在一个简单的例子中仔细看看。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> lukeSkywalker = &#123;</div><div class=\"line\">    mother: <span class=\"string\">'Padme Amidala'</span>,</div><div class=\"line\">    father: <span class=\"string\">'Anakin Skywalker'</span>.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> getFather = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.father);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">getFather(); <span class=\"comment\">// undefined</span></div><div class=\"line\">getFather.bind(lukeSkywalker)(); <span class=\"comment\">// Anakin Skywalker</span></div><div class=\"line\">getFather(lukeSkywalker); <span class=\"comment\">// undefined</span></div></pre></td></tr></table></figure>\n<p>第一个getfather()返回值为 undefined 是因为在这里 father 属性没有被定义。那这时 this 代表什么呢？只要我们不明确的指定它，它就代表 window 的全局对象。第二个getfather()返回 “Anakin Skywalker”是因为getfather()中的 this 指代的是 lukeskywalker。许多Java/C++ 开发人员会设想最后一个getfather()的调用将返回预想的结果–虽然再次返回全局对象。</p>\n<p>如下这里是 bind 的实现原理：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">scope</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> _that = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> _that.apply(scope, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里 JavaScript 的作用域是合乎逻辑的，返回函数的 this 对象是不同于 bind 的 this 对象的。因此，将 this 暂时缓存给变量 _that 保证了其正确的作用域范围。否则，this.apply(scope,arguments) 将会未定义。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>JavaScript 的 map 函数是遍历数组，同时转换每个元素的函数编程技术。它用 modified 元素创建了一个新数组并以回调的方式返回。关于我提到的修改或转换元素，实践表明，如果元素是对象(而不是原语),这只是克隆对象并不是从物理上改变了原生的。</p>\n<p>以下是该方法的声明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">arr.map(callback[, thisArg])</div></pre></td></tr></table></figure>\n<p>回调方法有三个参数，即 currentValue，index，和 array。</p>\n<p>这里是一个有关于 map 的简单例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Jedi</span>(<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> kit = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Kit'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Count'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> mace = <span class=\"keyword\">new</span> Jedi(<span class=\"string\">'Mace'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> jedis = [kit, count, mace];</div><div class=\"line\"><span class=\"keyword\">var</span> lastNames = [<span class=\"string\">'Fisto'</span>, <span class=\"string\">'Dooku'</span>, <span class=\"string\">'Windu'</span>];</div><div class=\"line\"><span class=\"keyword\">var</span> jedisWithFullNames = jedis.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> clonedJedi = (<span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(currentValue))) <span class=\"comment\">// Clone currentValue</span></div><div class=\"line\">    clonedJedi.name = currentValue.name + <span class=\"string\">\" \"</span> + lastNames[index];</div><div class=\"line\">    <span class=\"keyword\">return</span> clonedJedi;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">jedisWithFullNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(currentValue.name);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">Output:</div><div class=\"line\">Kit Fisto</div><div class=\"line\">Count Dooku</div><div class=\"line\">Mace Windu</div><div class=\"line\">*/</span></div></pre></td></tr></table></figure>\n<p>了解了 map 是用来做什么的，让我们看一下它具体是如何实现的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fun, thisArg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fun !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"The first argument must be of type function\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  </div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    thisArg = (thisArg) ? thisArg : <span class=\"keyword\">this</span>;</div><div class=\"line\">    thisArg.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">        arr[arr.length] = fun.call(thisArgs, element);</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注：这是一个简单的实现。到 ECMAScript 5看全部的实现，并查阅其规范。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p>filter 方法是数组的另外一种表现行为。类似于 map，filter 返回一个新的数组并接受一个函数和一个可选的 thisArg 参数。然而，返回的数组仅包含适合在回调函数测试的特定条件的元素。回调函数必须返回一个 Boolean –返回 true 的元素才会被接受并插入到返回的数组。</p>\n<p>关于 filter 有许多应用，包括选择偶数，用一个特定的属性选择对象，或选择有效的电话号码。</p>\n<p>这里是其中一种声明方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">arr.filter(callback[, thisArg])</div></pre></td></tr></table></figure>\n<p>同样的，thisArg 是可选的参数并且回调函数接受三个参数，currentValue，index 和 array。</p>\n<p>这里是一个有关于 filter 的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, side</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.side = side;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> hanSolo = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Han Solo'</span>,<span class=\"string\">'Rebels'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> bobaFett = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Boba Fett'</span>,<span class=\"string\">'Empire'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> princessLeia = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Princess Leia'</span>, <span class=\"string\">'Rebels'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> people = [hanSolo, bobaFett, princessLeia];</div><div class=\"line\"><span class=\"keyword\">var</span> enemies = people.filter(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">currentValue, index, array</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> currentValue.side === <span class=\"string\">'Empire'</span>;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">currentValue</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(currentValue.name + <span class=\"string\">\" fights for the \"</span> + currentValue.side + <span class=\"string\">\".\"</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">Output:</div><div class=\"line\">Boba Fett fights for the Empire.</div><div class=\"line\">*/</span></div></pre></td></tr></table></figure>\n<p>有趣的是，array 方法可以创造有趣的，复杂的操作。</p>\n<p>最后，让我们看看 filter 的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Array</span>.prototype.filter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fun, thisArg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> fun !== <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">\"The first argument must be of type function\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> arr = [];</div><div class=\"line\">    thisArg = (thisArg) ? thisArg : <span class=\"keyword\">this</span>;</div><div class=\"line\">    thisArg.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (fun.call(thisArg, element)) &#123;</div><div class=\"line\">        arr[arr.length] = element;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> arr;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里是 ECMAScript 的实现规范。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>还有更多令人困惑但是很有用的原生函数。它们是值得用数组和函数来回顾其中的每一种方法。</p>\n<p>希望这篇文章可以有助于你理解 JavaScript 的内部原理和词法作用域。尽管与实践紧密相连，call、apply，和bind 还是很难把握的。为了避免传统的循环技术你可以尝试使用 map 和 filter 方法 。</p>\n<blockquote>\n<p>作者：Devan Patel</p>\n<p>翻译自：<a href=\"https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them\">https://scotch.io/tutorials/learning-javascript-native-functions-and-how-to-use-them</a></p>\n<p>感谢：<a href=\"http://www.typora.io/\">typora</a></p>\n</blockquote>\n"},{"title":"学会享受孤独是通往成功的第一步","date":"2016-03-01T16:00:00.000Z","_content":"\n我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。\n\n所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？\n\n> 人类所有的不幸都来源于害怕和厌恶孤独。\n> –拉布吕耶尔（Jean de la Bruyere）\n\n一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。\n\n能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：\n\n### 1、有助恢复精力\n\n我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。\n\n### 2、可以做任何你想做的事情\n\n和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。\n\n### 3、学会相信自己\n\n自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。\n\n### 4、提高自己的情商\n\n情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。\n\n### 5、可以提升自信\n\n学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。\n\n### 6、可以更会欣赏别人\n\n独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。\n\n### 7、提升效率\n\n俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。\n\n### 总结一下\n\n独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。\n\n附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。\n\n作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。\n\n[http://www.codeceo.com/article/learn-alone-for-success.html](http://www.codeceo.com/article/learn-alone-for-success.html)\n","source":"_posts/学会享受孤独是通往成功的第一步.md","raw":"---\ntitle: 学会享受孤独是通往成功的第一步\ntags: [其它]\ndate: 2016/03/02\n---\n\n我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。\n\n所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？\n\n> 人类所有的不幸都来源于害怕和厌恶孤独。\n> –拉布吕耶尔（Jean de la Bruyere）\n\n一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。\n\n能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：\n\n### 1、有助恢复精力\n\n我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。\n\n### 2、可以做任何你想做的事情\n\n和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。\n\n### 3、学会相信自己\n\n自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。\n\n### 4、提高自己的情商\n\n情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。\n\n### 5、可以提升自信\n\n学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。\n\n### 6、可以更会欣赏别人\n\n独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。\n\n### 7、提升效率\n\n俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。\n\n### 总结一下\n\n独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。\n\n附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。\n\n作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。\n\n[http://www.codeceo.com/article/learn-alone-for-success.html](http://www.codeceo.com/article/learn-alone-for-success.html)\n","slug":"学会享受孤独是通往成功的第一步","published":1,"updated":"2016-08-17T06:22:19.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm4004l68ddhqqqzsik","content":"<p>我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。</p>\n<p>所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？</p>\n<blockquote>\n<p>人类所有的不幸都来源于害怕和厌恶孤独。<br>–拉布吕耶尔（Jean de la Bruyere）</p>\n</blockquote>\n<p>一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。</p>\n<p>能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：</p>\n<h3 id=\"1、有助恢复精力\"><a href=\"#1、有助恢复精力\" class=\"headerlink\" title=\"1、有助恢复精力\"></a>1、有助恢复精力</h3><p>我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。</p>\n<h3 id=\"2、可以做任何你想做的事情\"><a href=\"#2、可以做任何你想做的事情\" class=\"headerlink\" title=\"2、可以做任何你想做的事情\"></a>2、可以做任何你想做的事情</h3><p>和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。</p>\n<h3 id=\"3、学会相信自己\"><a href=\"#3、学会相信自己\" class=\"headerlink\" title=\"3、学会相信自己\"></a>3、学会相信自己</h3><p>自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。</p>\n<h3 id=\"4、提高自己的情商\"><a href=\"#4、提高自己的情商\" class=\"headerlink\" title=\"4、提高自己的情商\"></a>4、提高自己的情商</h3><p>情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。</p>\n<h3 id=\"5、可以提升自信\"><a href=\"#5、可以提升自信\" class=\"headerlink\" title=\"5、可以提升自信\"></a>5、可以提升自信</h3><p>学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。</p>\n<h3 id=\"6、可以更会欣赏别人\"><a href=\"#6、可以更会欣赏别人\" class=\"headerlink\" title=\"6、可以更会欣赏别人\"></a>6、可以更会欣赏别人</h3><p>独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。</p>\n<h3 id=\"7、提升效率\"><a href=\"#7、提升效率\" class=\"headerlink\" title=\"7、提升效率\"></a>7、提升效率</h3><p>俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&amp;M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。</p>\n<p>附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。</p>\n<p>作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。</p>\n<p><a href=\"http://www.codeceo.com/article/learn-alone-for-success.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/learn-alone-for-success.html</a></p>\n","excerpt":"","more":"<p>我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。</p>\n<p>所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？</p>\n<blockquote>\n<p>人类所有的不幸都来源于害怕和厌恶孤独。<br>–拉布吕耶尔（Jean de la Bruyere）</p>\n</blockquote>\n<p>一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。</p>\n<p>能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：</p>\n<h3 id=\"1、有助恢复精力\"><a href=\"#1、有助恢复精力\" class=\"headerlink\" title=\"1、有助恢复精力\"></a>1、有助恢复精力</h3><p>我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。</p>\n<h3 id=\"2、可以做任何你想做的事情\"><a href=\"#2、可以做任何你想做的事情\" class=\"headerlink\" title=\"2、可以做任何你想做的事情\"></a>2、可以做任何你想做的事情</h3><p>和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。</p>\n<h3 id=\"3、学会相信自己\"><a href=\"#3、学会相信自己\" class=\"headerlink\" title=\"3、学会相信自己\"></a>3、学会相信自己</h3><p>自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。</p>\n<h3 id=\"4、提高自己的情商\"><a href=\"#4、提高自己的情商\" class=\"headerlink\" title=\"4、提高自己的情商\"></a>4、提高自己的情商</h3><p>情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。</p>\n<h3 id=\"5、可以提升自信\"><a href=\"#5、可以提升自信\" class=\"headerlink\" title=\"5、可以提升自信\"></a>5、可以提升自信</h3><p>学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。</p>\n<h3 id=\"6、可以更会欣赏别人\"><a href=\"#6、可以更会欣赏别人\" class=\"headerlink\" title=\"6、可以更会欣赏别人\"></a>6、可以更会欣赏别人</h3><p>独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。</p>\n<h3 id=\"7、提升效率\"><a href=\"#7、提升效率\" class=\"headerlink\" title=\"7、提升效率\"></a>7、提升效率</h3><p>俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&amp;M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。</p>\n<p>附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。</p>\n<p>作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。</p>\n<p><a href=\"http://www.codeceo.com/article/learn-alone-for-success.html\">http://www.codeceo.com/article/learn-alone-for-success.html</a></p>\n"},{"title":"安装VirtualBox增强功能（命令行）","date":"2012-01-04T16:00:00.000Z","_content":"\n###安装VirtualBox增强功能\n\n1、加载VBoxGuestAdditons.iso镜像文件，直接通过Linux虚拟机窗口的菜单“设备”->“安装增强功能”来添加镜像文件，虚拟机会自动添加镜像到/dev/cdrom文件中去，添加镜像后无需重启。\n\n2、挂载VBoxGuestAddition.iso镜像文件，使用命令：\n\n```\n$sudo mount /dev/cdrom /mnt\n```\n\n此时会出现提示：`mount: block device /dev/sr0 is write-protected, mounting read-only.`此提示无需理会。\n\n3、使用`ls /mnt`命令查看是否加载成功，加载成功，请进行下一步。\n\n4、运行VBoxLinuxAdditions.run，使用命令：\n\n```\n$sudo /mnt/VBoxLinuxAdditions.run\n```\n\n计算机会花上数十秒的时间编译安装增强功能，请耐心等待。\n\n如果出现类似于failed的字样，请尝试安装gcc和make程序后重试。\n\n如果安装失败，请尝试安装如下包：\n\n```\n$yum install gcc\n```\n\n从软件仓库下载gcc,然后安装，这个是编译器\n\n```\n$yum install make\n```\n\n安装make，这个是自动编译源码的工具，写好makefile就可以方便编译\n\n```\n$yum install kernel-headers\n```\n\n安装内核，编译内核，驱动必要的\n\n```\n$yum install kernel-devel\n```\n\n同上\n\n###挂载虚拟文件夹\n\n此时，可以尝试挂载自己的虚拟文件夹了。\n\n现在设置里面添加Windows端共享文件夹，功能在“设置”->“共享文件夹”内：\n\n1、点击”共享文件夹路径“选择需要共享的文件夹（确保不为空），比如D:\\www\n\n2、输入“共享文件夹名称”，名称建议和文件夹名不一致比如htdoc\n\n3、选择“自动挂载”和“固定分配”（此处有误，不建议选择自动挂载）\n\n4、在Windows端做好处理之后，尝试挂载共享文件夹了，使用命令如下：\n\n```\n$sudo mount -t vboxsf htdoc /mnt\n```\n\n5、通过命令 ls /mnt 查看是否挂载成功，如果显示了D:\\www文件夹内的文件，则表示虚拟文件夹挂载成功。\n\n如果出现了：`./sbin/mount.vboxsf:mounting failed with the error:No such device`这样的错误提示，请检查VirtualBox增强功能是否编译安装成功。\n","source":"_posts/安装VirtualBox增强功能（命令行）.md","raw":"---\ntitle: 安装VirtualBox增强功能（命令行）\ntags: [virtualbox]\ndate: 2012/01/05\n---\n\n###安装VirtualBox增强功能\n\n1、加载VBoxGuestAdditons.iso镜像文件，直接通过Linux虚拟机窗口的菜单“设备”->“安装增强功能”来添加镜像文件，虚拟机会自动添加镜像到/dev/cdrom文件中去，添加镜像后无需重启。\n\n2、挂载VBoxGuestAddition.iso镜像文件，使用命令：\n\n```\n$sudo mount /dev/cdrom /mnt\n```\n\n此时会出现提示：`mount: block device /dev/sr0 is write-protected, mounting read-only.`此提示无需理会。\n\n3、使用`ls /mnt`命令查看是否加载成功，加载成功，请进行下一步。\n\n4、运行VBoxLinuxAdditions.run，使用命令：\n\n```\n$sudo /mnt/VBoxLinuxAdditions.run\n```\n\n计算机会花上数十秒的时间编译安装增强功能，请耐心等待。\n\n如果出现类似于failed的字样，请尝试安装gcc和make程序后重试。\n\n如果安装失败，请尝试安装如下包：\n\n```\n$yum install gcc\n```\n\n从软件仓库下载gcc,然后安装，这个是编译器\n\n```\n$yum install make\n```\n\n安装make，这个是自动编译源码的工具，写好makefile就可以方便编译\n\n```\n$yum install kernel-headers\n```\n\n安装内核，编译内核，驱动必要的\n\n```\n$yum install kernel-devel\n```\n\n同上\n\n###挂载虚拟文件夹\n\n此时，可以尝试挂载自己的虚拟文件夹了。\n\n现在设置里面添加Windows端共享文件夹，功能在“设置”->“共享文件夹”内：\n\n1、点击”共享文件夹路径“选择需要共享的文件夹（确保不为空），比如D:\\www\n\n2、输入“共享文件夹名称”，名称建议和文件夹名不一致比如htdoc\n\n3、选择“自动挂载”和“固定分配”（此处有误，不建议选择自动挂载）\n\n4、在Windows端做好处理之后，尝试挂载共享文件夹了，使用命令如下：\n\n```\n$sudo mount -t vboxsf htdoc /mnt\n```\n\n5、通过命令 ls /mnt 查看是否挂载成功，如果显示了D:\\www文件夹内的文件，则表示虚拟文件夹挂载成功。\n\n如果出现了：`./sbin/mount.vboxsf:mounting failed with the error:No such device`这样的错误提示，请检查VirtualBox增强功能是否编译安装成功。\n","slug":"安装VirtualBox增强功能（命令行）","published":1,"updated":"2016-08-17T06:22:19.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm5004n68dd1qkgbpgw","content":"<p>###安装VirtualBox增强功能</p>\n<p>1、加载VBoxGuestAdditons.iso镜像文件，直接通过Linux虚拟机窗口的菜单“设备”-&gt;“安装增强功能”来添加镜像文件，虚拟机会自动添加镜像到/dev/cdrom文件中去，添加镜像后无需重启。</p>\n<p>2、挂载VBoxGuestAddition.iso镜像文件，使用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo mount /dev/cdrom /mnt</div></pre></td></tr></table></figure>\n<p>此时会出现提示：<code>mount: block device /dev/sr0 is write-protected, mounting read-only.</code>此提示无需理会。</p>\n<p>3、使用<code>ls /mnt</code>命令查看是否加载成功，加载成功，请进行下一步。</p>\n<p>4、运行VBoxLinuxAdditions.run，使用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo /mnt/VBoxLinuxAdditions.run</div></pre></td></tr></table></figure>\n<p>计算机会花上数十秒的时间编译安装增强功能，请耐心等待。</p>\n<p>如果出现类似于failed的字样，请尝试安装gcc和make程序后重试。</p>\n<p>如果安装失败，请尝试安装如下包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install gcc</div></pre></td></tr></table></figure>\n<p>从软件仓库下载gcc,然后安装，这个是编译器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install make</div></pre></td></tr></table></figure>\n<p>安装make，这个是自动编译源码的工具，写好makefile就可以方便编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install kernel-headers</div></pre></td></tr></table></figure>\n<p>安装内核，编译内核，驱动必要的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install kernel-devel</div></pre></td></tr></table></figure>\n<p>同上</p>\n<p>###挂载虚拟文件夹</p>\n<p>此时，可以尝试挂载自己的虚拟文件夹了。</p>\n<p>现在设置里面添加Windows端共享文件夹，功能在“设置”-&gt;“共享文件夹”内：</p>\n<p>1、点击”共享文件夹路径“选择需要共享的文件夹（确保不为空），比如D:\\www</p>\n<p>2、输入“共享文件夹名称”，名称建议和文件夹名不一致比如htdoc</p>\n<p>3、选择“自动挂载”和“固定分配”（此处有误，不建议选择自动挂载）</p>\n<p>4、在Windows端做好处理之后，尝试挂载共享文件夹了，使用命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo mount -t vboxsf htdoc /mnt</div></pre></td></tr></table></figure>\n<p>5、通过命令 ls /mnt 查看是否挂载成功，如果显示了D:\\www文件夹内的文件，则表示虚拟文件夹挂载成功。</p>\n<p>如果出现了：<code>./sbin/mount.vboxsf:mounting failed with the error:No such device</code>这样的错误提示，请检查VirtualBox增强功能是否编译安装成功。</p>\n","excerpt":"","more":"<p>###安装VirtualBox增强功能</p>\n<p>1、加载VBoxGuestAdditons.iso镜像文件，直接通过Linux虚拟机窗口的菜单“设备”-&gt;“安装增强功能”来添加镜像文件，虚拟机会自动添加镜像到/dev/cdrom文件中去，添加镜像后无需重启。</p>\n<p>2、挂载VBoxGuestAddition.iso镜像文件，使用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo mount /dev/cdrom /mnt</div></pre></td></tr></table></figure>\n<p>此时会出现提示：<code>mount: block device /dev/sr0 is write-protected, mounting read-only.</code>此提示无需理会。</p>\n<p>3、使用<code>ls /mnt</code>命令查看是否加载成功，加载成功，请进行下一步。</p>\n<p>4、运行VBoxLinuxAdditions.run，使用命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo /mnt/VBoxLinuxAdditions.run</div></pre></td></tr></table></figure>\n<p>计算机会花上数十秒的时间编译安装增强功能，请耐心等待。</p>\n<p>如果出现类似于failed的字样，请尝试安装gcc和make程序后重试。</p>\n<p>如果安装失败，请尝试安装如下包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install gcc</div></pre></td></tr></table></figure>\n<p>从软件仓库下载gcc,然后安装，这个是编译器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install make</div></pre></td></tr></table></figure>\n<p>安装make，这个是自动编译源码的工具，写好makefile就可以方便编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install kernel-headers</div></pre></td></tr></table></figure>\n<p>安装内核，编译内核，驱动必要的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$yum install kernel-devel</div></pre></td></tr></table></figure>\n<p>同上</p>\n<p>###挂载虚拟文件夹</p>\n<p>此时，可以尝试挂载自己的虚拟文件夹了。</p>\n<p>现在设置里面添加Windows端共享文件夹，功能在“设置”-&gt;“共享文件夹”内：</p>\n<p>1、点击”共享文件夹路径“选择需要共享的文件夹（确保不为空），比如D:\\www</p>\n<p>2、输入“共享文件夹名称”，名称建议和文件夹名不一致比如htdoc</p>\n<p>3、选择“自动挂载”和“固定分配”（此处有误，不建议选择自动挂载）</p>\n<p>4、在Windows端做好处理之后，尝试挂载共享文件夹了，使用命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$sudo mount -t vboxsf htdoc /mnt</div></pre></td></tr></table></figure>\n<p>5、通过命令 ls /mnt 查看是否挂载成功，如果显示了D:\\www文件夹内的文件，则表示虚拟文件夹挂载成功。</p>\n<p>如果出现了：<code>./sbin/mount.vboxsf:mounting failed with the error:No such device</code>这样的错误提示，请检查VirtualBox增强功能是否编译安装成功。</p>\n"},{"title":"开发者必须知道的HTML5十五大新特性","date":"2015-02-13T16:00:00.000Z","_content":"\nHTML5想必大家都很熟悉了，因为太多的媒体在讨论这一技术。然而，你能准确地说出HTML5带来了哪些新特性吗？本文总结了HTML5带来的15项你必须知道的新特性。\n\n一起来看下：\n\n### 1.新的文档类型 (New Doctype)\n\n目前许多网页还在使用XHTML 1.0 并且要在第一行像这样声明文档类型：\n\n```html\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\" \n```\n\n在HTML5中，上面那种声明方式将失效。下面是HTML5中的声明方式：\n\n```html\n    <!DOCTYPE html> \n```\n\n### 2.脚本和链接无需type  (No More Types for Scripts and Links)\n\n在HTML4或XHTML中，你需要用下面的几行代码来给你的网页添加CSS和JavaScript文件。\n\n```html\n    <link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" type=\"text/css\" /> \n    <script type=\"text/javascript\" src=\"path/to/script.js\"></script> \n```\n\n而在HTML5中，你不再需要指定类型属性。因此，代码可以简化如下： \n\n```html\n    <link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" /> \n    <script src=\"path/to/script.js\"></script> \n```\n\n### 3.语义Header和Footer (The Semantic Header and Footer)\n在HTML4或XHTML中，你需要用下面的代码来声明“Header”和“Footer”。\n\n```html\n    <div id=\"header\"> \n        ... \n    </div> \n    .......... \n    <div id=\"footer\"> \n        ... \n    </div> \n```\n\n在HTML5中，有两个可以替代上述声明的元素，这可以使代码更简洁。\n\n```html\n    <header> \n        ... \n    </header> \n    <footer> \n        ... \n    </footer> \n```\n\n### 4.Hgroup\n在HTML5中，有许多新引入的元素，hgroup就是其中之一。假设我的网站名下面紧跟着一个子标题，我可以用`<h1>`和`<h2>`标签来分别定义。然而，这种定义没有说明这两者之间的关系。而且，h2标签的使用会带来更多问题，比如该页面上还有其他标题的时候。\n\n在HTML5中，我们可以用hgroup元素来将它们分组，这样就不会影响文件的大纲。\n\n```html\n    <header> \n        <hgroup> \n            <h1> Recall Fan Page </h1> \n            <h2> Only for people who want the memory of a lifetime. </h2> \n        </hgroup> \n    </header>\n```\n\n### 5.标记元素 (Mark Element)\n你可以把它当做高亮标签。被这个标签修饰的字符串应当和用户当前的行动相关。比如说，当我在某博客中搜索“Open your Mind”时，我可以利用一些JavaScript将出现的词组用`<mark>`修饰一下。\n\n```html\n    <h3> Search Results </h3> \n    <p> They were interrupted, just after Quato said, <mark>\"Open your Mind\"</mark>. \n    </p> \n```\n\n### 6.图形元素 (Figure Element)\n在HTML4或XHTML中，下面的这些代码被用来修饰图片的注释。\n\n```html\n    <img src=\"path/to/image\" alt=\"About image\" /> \n    <p>Image of Mars. </p> \n```\n\n然而，上述代码没有将文字和图片内在联系起来。因此，HTML5引入了`<figure>`元素。当和`<figcaption>`结合起来后，我们可以语义化地将注释和相应的图片联系起来。\n\n```html\n    <figure> \n        <img src=\"path/to/image\" alt=\"About image\" /> \n        <figcaption> \n            <p>This is an image of something interesting. </p> \n        </figcaption> \n    </figure> \n```\n\n### 7.重新定义`<small>` (Small Element redefined)\n在HTML4或XHTML中，`<small>`元素已经存在。然而，却没有如何正确使用这一元素的完整说明。在HTML5中，`<small>`被用来定义小字。试想下你网站底部的版权状态，根据对此元素新的HTML5定义，`<small>`可以正确地诠释这些信息。\n\n### 8.占位符 (Placeholder)\n在HTML4或XHTML中，你需要用JavaScript来给文本框添加占位符。比如，你可以提前设置好一些信息，当用户开始输入时，文本框中的文字就消失。\n\n而在HTML5中，新的“placeholder”就简化了这个问题。\n\n### 9.必要属性 (Required Attribute)\nHTML5中的新属性“required”指定了某一输入是否必需。有两种方法声明这一属性。\n\n```html\n    <input type=\"text\" name=\"someInput\" required> \n    <input type=\"text\" name=\"someInput\" required=\"required\"> \n```\n\n当文本框被指定必需时，如果空白的话表格就不能提交。下面是一个如何使用的例子。\n\n```html\n    <form method=\"post\" action=\"\"> \n        <label for=\"someInput\"> Your Name: </label> \n        <input type=\"text\" id=\"someInput\" name=\"someInput\" placeholder=\"Douglas Quaid\" required> \n        <button type=\"submit\">Go</button> \n    </form>\n```\n\n在上面那个例子中，如果输入内容空且表格被提交，输入框将被高亮显示。\n\n### 10.Autofocus 属性 (Autofocus Attribute)\n同样，HTML5的解决方案消除了对JavaScript的需要。如果一个特定的输入应该是“选择”或聚焦，默认情况下，我们现在可以利用自动聚焦属性。\n\n```html\n    <input type=\"text\" name=\"someInput\" placeholder=\"Douglas Quaid\" required autofocus> \n```\n\n### 11.Audio 支持 (Audio Support)\n目前我们需要依靠第三方插件来渲染音频。然而在HTML5中，<audio>元素被引进来了。\n\n```html\n    <audio autoplay=\"autoplay\" controls=\"controls\"> \n        <source src=\"file.ogg\" /> \n        <source src=\"file.mp3\" /> \n        <a href=\"file.mp3\">Download this file.</a> \n    </audio>\n```\n\n当使用`<audio>`元素时请记得包含两种音频格式。FireFox想要.ogg格式的文件，而Webkit浏览器则需要.mp3格式的。和往常一样，IE是不支持的，且Opera 10及以下版本只支持.wav格式。\n\n### 12.Video 支持 (Video Support)\nHTML5中不仅有`<audio>`元素，而且还有`<video>`。然而，和`<audio>`类似，HTML5中并没有指定视频解码器，它留给了浏览器来决定。虽然Safari和Internet Explorer9可以支持H.264格式的视频，Firefox和Opera是坚持开源Theora 和Vorbis格式。因此，指定HTML5的视频时，你必须提供这两种格式。\n\n```html\n    <video controls preload> \n        <source src=\"cohagenPhoneCall.ogv\" type=\"video/ogg; codecs='vorbis, theora'\" /> \n        <source src=\"cohagenPhoneCall.mp4\" type=\"video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'\" /> \n        <p> Your browser is old. <a href=\"cohagenPhoneCall.mp4\">Download this video instead.</a> </p> \n    </video> \n```\n\n### 13.视频预载 (Preload attribute in Videos element)\n当用户访问页面时这一属性使得视频得以预载。为了实现这个功能，可以在`<video>`元素中加上preload=”preload”或者只是preload。\n\n```html\n    <video preload> \n```\n\n### 14.显示控制条 (Display Controls)\n如果你使用过上面的每一个提到的技术点，你可能已经注意到，使用上面的代码，视频仅仅显示的是张图片，没有控制条。为了渲染出播放控制条，我们必须在video元素内指定controls属性。\n\n```html\n    <video preload controls> \n```\n\n### 15.正规表达式 (Regular Expressions)\n在HTML4或XHTML中，你需要用一些正规表达式来验证特定的文本。而HTML5中新的pattern属性让我们能够在标签处直接插入一个正规表达式。\n\n```html\n    <form action=\"\" method=\"post\"> \n        <label for=\"username\">Create a Username: </label> \n        <input type=\"text\" name=\"username\" id=\"username\" placeholder=\"4 <> 10\" pattern=\"[A-Za-z]{4,10}\" \n            autofocus \n            required> \n        <button type=\"submit\">Go </button> \n    </form> \n```\n\n### 结论\n事实上，还有很多新元素和特性，上面提到的只是一些我认为网站开发中常用的，剩下的就由你们自己去摸索啦。\n\n转载至[HTML5China.com](http://www.html5china.com/course/20120225_3483.html)\n","source":"_posts/开发者必须知道的HTML5十五大新特性.md","raw":"---\ntitle: 开发者必须知道的HTML5十五大新特性\ntags: [html]\ndate: 2015/02/14\n---\n\nHTML5想必大家都很熟悉了，因为太多的媒体在讨论这一技术。然而，你能准确地说出HTML5带来了哪些新特性吗？本文总结了HTML5带来的15项你必须知道的新特性。\n\n一起来看下：\n\n### 1.新的文档类型 (New Doctype)\n\n目前许多网页还在使用XHTML 1.0 并且要在第一行像这样声明文档类型：\n\n```html\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\" \n```\n\n在HTML5中，上面那种声明方式将失效。下面是HTML5中的声明方式：\n\n```html\n    <!DOCTYPE html> \n```\n\n### 2.脚本和链接无需type  (No More Types for Scripts and Links)\n\n在HTML4或XHTML中，你需要用下面的几行代码来给你的网页添加CSS和JavaScript文件。\n\n```html\n    <link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" type=\"text/css\" /> \n    <script type=\"text/javascript\" src=\"path/to/script.js\"></script> \n```\n\n而在HTML5中，你不再需要指定类型属性。因此，代码可以简化如下： \n\n```html\n    <link rel=\"stylesheet\" href=\"path/to/stylesheet.css\" /> \n    <script src=\"path/to/script.js\"></script> \n```\n\n### 3.语义Header和Footer (The Semantic Header and Footer)\n在HTML4或XHTML中，你需要用下面的代码来声明“Header”和“Footer”。\n\n```html\n    <div id=\"header\"> \n        ... \n    </div> \n    .......... \n    <div id=\"footer\"> \n        ... \n    </div> \n```\n\n在HTML5中，有两个可以替代上述声明的元素，这可以使代码更简洁。\n\n```html\n    <header> \n        ... \n    </header> \n    <footer> \n        ... \n    </footer> \n```\n\n### 4.Hgroup\n在HTML5中，有许多新引入的元素，hgroup就是其中之一。假设我的网站名下面紧跟着一个子标题，我可以用`<h1>`和`<h2>`标签来分别定义。然而，这种定义没有说明这两者之间的关系。而且，h2标签的使用会带来更多问题，比如该页面上还有其他标题的时候。\n\n在HTML5中，我们可以用hgroup元素来将它们分组，这样就不会影响文件的大纲。\n\n```html\n    <header> \n        <hgroup> \n            <h1> Recall Fan Page </h1> \n            <h2> Only for people who want the memory of a lifetime. </h2> \n        </hgroup> \n    </header>\n```\n\n### 5.标记元素 (Mark Element)\n你可以把它当做高亮标签。被这个标签修饰的字符串应当和用户当前的行动相关。比如说，当我在某博客中搜索“Open your Mind”时，我可以利用一些JavaScript将出现的词组用`<mark>`修饰一下。\n\n```html\n    <h3> Search Results </h3> \n    <p> They were interrupted, just after Quato said, <mark>\"Open your Mind\"</mark>. \n    </p> \n```\n\n### 6.图形元素 (Figure Element)\n在HTML4或XHTML中，下面的这些代码被用来修饰图片的注释。\n\n```html\n    <img src=\"path/to/image\" alt=\"About image\" /> \n    <p>Image of Mars. </p> \n```\n\n然而，上述代码没有将文字和图片内在联系起来。因此，HTML5引入了`<figure>`元素。当和`<figcaption>`结合起来后，我们可以语义化地将注释和相应的图片联系起来。\n\n```html\n    <figure> \n        <img src=\"path/to/image\" alt=\"About image\" /> \n        <figcaption> \n            <p>This is an image of something interesting. </p> \n        </figcaption> \n    </figure> \n```\n\n### 7.重新定义`<small>` (Small Element redefined)\n在HTML4或XHTML中，`<small>`元素已经存在。然而，却没有如何正确使用这一元素的完整说明。在HTML5中，`<small>`被用来定义小字。试想下你网站底部的版权状态，根据对此元素新的HTML5定义，`<small>`可以正确地诠释这些信息。\n\n### 8.占位符 (Placeholder)\n在HTML4或XHTML中，你需要用JavaScript来给文本框添加占位符。比如，你可以提前设置好一些信息，当用户开始输入时，文本框中的文字就消失。\n\n而在HTML5中，新的“placeholder”就简化了这个问题。\n\n### 9.必要属性 (Required Attribute)\nHTML5中的新属性“required”指定了某一输入是否必需。有两种方法声明这一属性。\n\n```html\n    <input type=\"text\" name=\"someInput\" required> \n    <input type=\"text\" name=\"someInput\" required=\"required\"> \n```\n\n当文本框被指定必需时，如果空白的话表格就不能提交。下面是一个如何使用的例子。\n\n```html\n    <form method=\"post\" action=\"\"> \n        <label for=\"someInput\"> Your Name: </label> \n        <input type=\"text\" id=\"someInput\" name=\"someInput\" placeholder=\"Douglas Quaid\" required> \n        <button type=\"submit\">Go</button> \n    </form>\n```\n\n在上面那个例子中，如果输入内容空且表格被提交，输入框将被高亮显示。\n\n### 10.Autofocus 属性 (Autofocus Attribute)\n同样，HTML5的解决方案消除了对JavaScript的需要。如果一个特定的输入应该是“选择”或聚焦，默认情况下，我们现在可以利用自动聚焦属性。\n\n```html\n    <input type=\"text\" name=\"someInput\" placeholder=\"Douglas Quaid\" required autofocus> \n```\n\n### 11.Audio 支持 (Audio Support)\n目前我们需要依靠第三方插件来渲染音频。然而在HTML5中，<audio>元素被引进来了。\n\n```html\n    <audio autoplay=\"autoplay\" controls=\"controls\"> \n        <source src=\"file.ogg\" /> \n        <source src=\"file.mp3\" /> \n        <a href=\"file.mp3\">Download this file.</a> \n    </audio>\n```\n\n当使用`<audio>`元素时请记得包含两种音频格式。FireFox想要.ogg格式的文件，而Webkit浏览器则需要.mp3格式的。和往常一样，IE是不支持的，且Opera 10及以下版本只支持.wav格式。\n\n### 12.Video 支持 (Video Support)\nHTML5中不仅有`<audio>`元素，而且还有`<video>`。然而，和`<audio>`类似，HTML5中并没有指定视频解码器，它留给了浏览器来决定。虽然Safari和Internet Explorer9可以支持H.264格式的视频，Firefox和Opera是坚持开源Theora 和Vorbis格式。因此，指定HTML5的视频时，你必须提供这两种格式。\n\n```html\n    <video controls preload> \n        <source src=\"cohagenPhoneCall.ogv\" type=\"video/ogg; codecs='vorbis, theora'\" /> \n        <source src=\"cohagenPhoneCall.mp4\" type=\"video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'\" /> \n        <p> Your browser is old. <a href=\"cohagenPhoneCall.mp4\">Download this video instead.</a> </p> \n    </video> \n```\n\n### 13.视频预载 (Preload attribute in Videos element)\n当用户访问页面时这一属性使得视频得以预载。为了实现这个功能，可以在`<video>`元素中加上preload=”preload”或者只是preload。\n\n```html\n    <video preload> \n```\n\n### 14.显示控制条 (Display Controls)\n如果你使用过上面的每一个提到的技术点，你可能已经注意到，使用上面的代码，视频仅仅显示的是张图片，没有控制条。为了渲染出播放控制条，我们必须在video元素内指定controls属性。\n\n```html\n    <video preload controls> \n```\n\n### 15.正规表达式 (Regular Expressions)\n在HTML4或XHTML中，你需要用一些正规表达式来验证特定的文本。而HTML5中新的pattern属性让我们能够在标签处直接插入一个正规表达式。\n\n```html\n    <form action=\"\" method=\"post\"> \n        <label for=\"username\">Create a Username: </label> \n        <input type=\"text\" name=\"username\" id=\"username\" placeholder=\"4 <> 10\" pattern=\"[A-Za-z]{4,10}\" \n            autofocus \n            required> \n        <button type=\"submit\">Go </button> \n    </form> \n```\n\n### 结论\n事实上，还有很多新元素和特性，上面提到的只是一些我认为网站开发中常用的，剩下的就由你们自己去摸索啦。\n\n转载至[HTML5China.com](http://www.html5china.com/course/20120225_3483.html)\n","slug":"开发者必须知道的HTML5十五大新特性","published":1,"updated":"2016-08-17T06:22:19.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm7004q68dd1ihd577p","content":"<p>HTML5想必大家都很熟悉了，因为太多的媒体在讨论这一技术。然而，你能准确地说出HTML5带来了哪些新特性吗？本文总结了HTML5带来的15项你必须知道的新特性。</p>\n<p>一起来看下：</p>\n<h3 id=\"1-新的文档类型-New-Doctype\"><a href=\"#1-新的文档类型-New-Doctype\" class=\"headerlink\" title=\"1.新的文档类型 (New Doctype)\"></a>1.新的文档类型 (New Doctype)</h3><p>目前许多网页还在使用XHTML 1.0 并且要在第一行像这样声明文档类型：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span></div></pre></td></tr></table></figure>\n<p>在HTML5中，上面那种声明方式将失效。下面是HTML5中的声明方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-脚本和链接无需type-No-More-Types-for-Scripts-and-Links\"><a href=\"#2-脚本和链接无需type-No-More-Types-for-Scripts-and-Links\" class=\"headerlink\" title=\"2.脚本和链接无需type  (No More Types for Scripts and Links)\"></a>2.脚本和链接无需type  (No More Types for Scripts and Links)</h3><p>在HTML4或XHTML中，你需要用下面的几行代码来给你的网页添加CSS和JavaScript文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"path/to/stylesheet.css\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而在HTML5中，你不再需要指定类型属性。因此，代码可以简化如下： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"path/to/stylesheet.css\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-语义Header和Footer-The-Semantic-Header-and-Footer\"><a href=\"#3-语义Header和Footer-The-Semantic-Header-and-Footer\" class=\"headerlink\" title=\"3.语义Header和Footer (The Semantic Header and Footer)\"></a>3.语义Header和Footer (The Semantic Header and Footer)</h3><p>在HTML4或XHTML中，你需要用下面的代码来声明“Header”和“Footer”。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"header\"</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\">.......... </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"footer\"</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在HTML5中，有两个可以替代上述声明的元素，这可以使代码更简洁。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-Hgroup\"><a href=\"#4-Hgroup\" class=\"headerlink\" title=\"4.Hgroup\"></a>4.Hgroup</h3><p>在HTML5中，有许多新引入的元素，hgroup就是其中之一。假设我的网站名下面紧跟着一个子标题，我可以用<code>&lt;h1&gt;</code>和<code>&lt;h2&gt;</code>标签来分别定义。然而，这种定义没有说明这两者之间的关系。而且，h2标签的使用会带来更多问题，比如该页面上还有其他标题的时候。</p>\n<p>在HTML5中，我们可以用hgroup元素来将它们分组，这样就不会影响文件的大纲。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hgroup</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span> Recall Fan Page <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span> Only for people who want the memory of a lifetime. <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">hgroup</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"5-标记元素-Mark-Element\"><a href=\"#5-标记元素-Mark-Element\" class=\"headerlink\" title=\"5.标记元素 (Mark Element)\"></a>5.标记元素 (Mark Element)</h3><p>你可以把它当做高亮标签。被这个标签修饰的字符串应当和用户当前的行动相关。比如说，当我在某博客中搜索“Open your Mind”时，我可以利用一些JavaScript将出现的词组用<code>&lt;mark&gt;</code>修饰一下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span> Search Results <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> They were interrupted, just after Quato said, <span class=\"tag\">&lt;<span class=\"name\">mark</span>&gt;</span>\"Open your Mind\"<span class=\"tag\">&lt;/<span class=\"name\">mark</span>&gt;</span>. </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"6-图形元素-Figure-Element\"><a href=\"#6-图形元素-Figure-Element\" class=\"headerlink\" title=\"6.图形元素 (Figure Element)\"></a>6.图形元素 (Figure Element)</h3><p>在HTML4或XHTML中，下面的这些代码被用来修饰图片的注释。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/image\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"About image\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Image of Mars. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然而，上述代码没有将文字和图片内在联系起来。因此，HTML5引入了<code>&lt;figure&gt;</code>元素。当和<code>&lt;figcaption&gt;</code>结合起来后，我们可以语义化地将注释和相应的图片联系起来。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/image\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"About image\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is an image of something interesting. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"7-重新定义-lt-small-gt-Small-Element-redefined\"><a href=\"#7-重新定义-lt-small-gt-Small-Element-redefined\" class=\"headerlink\" title=\"7.重新定义&lt;small&gt; (Small Element redefined)\"></a>7.重新定义<code>&lt;small&gt;</code> (Small Element redefined)</h3><p>在HTML4或XHTML中，<code>&lt;small&gt;</code>元素已经存在。然而，却没有如何正确使用这一元素的完整说明。在HTML5中，<code>&lt;small&gt;</code>被用来定义小字。试想下你网站底部的版权状态，根据对此元素新的HTML5定义，<code>&lt;small&gt;</code>可以正确地诠释这些信息。</p>\n<h3 id=\"8-占位符-Placeholder\"><a href=\"#8-占位符-Placeholder\" class=\"headerlink\" title=\"8.占位符 (Placeholder)\"></a>8.占位符 (Placeholder)</h3><p>在HTML4或XHTML中，你需要用JavaScript来给文本框添加占位符。比如，你可以提前设置好一些信息，当用户开始输入时，文本框中的文字就消失。</p>\n<p>而在HTML5中，新的“placeholder”就简化了这个问题。</p>\n<h3 id=\"9-必要属性-Required-Attribute\"><a href=\"#9-必要属性-Required-Attribute\" class=\"headerlink\" title=\"9.必要属性 (Required Attribute)\"></a>9.必要属性 (Required Attribute)</h3><p>HTML5中的新属性“required”指定了某一输入是否必需。有两种方法声明这一属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">required</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">required</span>=<span class=\"string\">\"required\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当文本框被指定必需时，如果空白的话表格就不能提交。下面是一个如何使用的例子。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"someInput\"</span>&gt;</span> Your Name: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Douglas Quaid\"</span> <span class=\"attr\">required</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Go<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在上面那个例子中，如果输入内容空且表格被提交，输入框将被高亮显示。</p>\n<h3 id=\"10-Autofocus-属性-Autofocus-Attribute\"><a href=\"#10-Autofocus-属性-Autofocus-Attribute\" class=\"headerlink\" title=\"10.Autofocus 属性 (Autofocus Attribute)\"></a>10.Autofocus 属性 (Autofocus Attribute)</h3><p>同样，HTML5的解决方案消除了对JavaScript的需要。如果一个特定的输入应该是“选择”或聚焦，默认情况下，我们现在可以利用自动聚焦属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Douglas Quaid\"</span> <span class=\"attr\">required</span> <span class=\"attr\">autofocus</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"11-Audio-支持-Audio-Support\"><a href=\"#11-Audio-支持-Audio-Support\" class=\"headerlink\" title=\"11.Audio 支持 (Audio Support)\"></a>11.Audio 支持 (Audio Support)</h3><p>目前我们需要依靠第三方插件来渲染音频。然而在HTML5中，<audio>元素被引进来了。</audio></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">autoplay</span>=<span class=\"string\">\"autoplay\"</span> <span class=\"attr\">controls</span>=<span class=\"string\">\"controls\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"file.ogg\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"file.mp3\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"file.mp3\"</span>&gt;</span>Download this file.<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当使用<code>&lt;audio&gt;</code>元素时请记得包含两种音频格式。FireFox想要.ogg格式的文件，而Webkit浏览器则需要.mp3格式的。和往常一样，IE是不支持的，且Opera 10及以下版本只支持.wav格式。</p>\n<h3 id=\"12-Video-支持-Video-Support\"><a href=\"#12-Video-支持-Video-Support\" class=\"headerlink\" title=\"12.Video 支持 (Video Support)\"></a>12.Video 支持 (Video Support)</h3><p>HTML5中不仅有<code>&lt;audio&gt;</code>元素，而且还有<code>&lt;video&gt;</code>。然而，和<code>&lt;audio&gt;</code>类似，HTML5中并没有指定视频解码器，它留给了浏览器来决定。虽然Safari和Internet Explorer9可以支持H.264格式的视频，Firefox和Opera是坚持开源Theora 和Vorbis格式。因此，指定HTML5的视频时，你必须提供这两种格式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">controls</span> <span class=\"attr\">preload</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cohagenPhoneCall.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs='vorbis, theora'\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cohagenPhoneCall.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> Your browser is old. <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"cohagenPhoneCall.mp4\"</span>&gt;</span>Download this video instead.<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"13-视频预载-Preload-attribute-in-Videos-element\"><a href=\"#13-视频预载-Preload-attribute-in-Videos-element\" class=\"headerlink\" title=\"13.视频预载 (Preload attribute in Videos element)\"></a>13.视频预载 (Preload attribute in Videos element)</h3><p>当用户访问页面时这一属性使得视频得以预载。为了实现这个功能，可以在<code>&lt;video&gt;</code>元素中加上preload=”preload”或者只是preload。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">preload</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"14-显示控制条-Display-Controls\"><a href=\"#14-显示控制条-Display-Controls\" class=\"headerlink\" title=\"14.显示控制条 (Display Controls)\"></a>14.显示控制条 (Display Controls)</h3><p>如果你使用过上面的每一个提到的技术点，你可能已经注意到，使用上面的代码，视频仅仅显示的是张图片，没有控制条。为了渲染出播放控制条，我们必须在video元素内指定controls属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">preload</span> <span class=\"attr\">controls</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"15-正规表达式-Regular-Expressions\"><a href=\"#15-正规表达式-Regular-Expressions\" class=\"headerlink\" title=\"15.正规表达式 (Regular Expressions)\"></a>15.正规表达式 (Regular Expressions)</h3><p>在HTML4或XHTML中，你需要用一些正规表达式来验证特定的文本。而HTML5中新的pattern属性让我们能够在标签处直接插入一个正规表达式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"username\"</span>&gt;</span>Create a Username: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"4 &lt;&gt; 10\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"[A-Za-z]&#123;4,10&#125;\"</span> </span></div><div class=\"line\">        <span class=\"attr\">autofocus</span> </div><div class=\"line\">        <span class=\"attr\">required</span>&gt; </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Go <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>事实上，还有很多新元素和特性，上面提到的只是一些我认为网站开发中常用的，剩下的就由你们自己去摸索啦。</p>\n<p>转载至<a href=\"http://www.html5china.com/course/20120225_3483.html\" target=\"_blank\" rel=\"external\">HTML5China.com</a></p>\n","excerpt":"","more":"<p>HTML5想必大家都很熟悉了，因为太多的媒体在讨论这一技术。然而，你能准确地说出HTML5带来了哪些新特性吗？本文总结了HTML5带来的15项你必须知道的新特性。</p>\n<p>一起来看下：</p>\n<h3 id=\"1-新的文档类型-New-Doctype\"><a href=\"#1-新的文档类型-New-Doctype\" class=\"headerlink\" title=\"1.新的文档类型 (New Doctype)\"></a>1.新的文档类型 (New Doctype)</h3><p>目前许多网页还在使用XHTML 1.0 并且要在第一行像这样声明文档类型：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span></div></pre></td></tr></table></figure>\n<p>在HTML5中，上面那种声明方式将失效。下面是HTML5中的声明方式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-脚本和链接无需type-No-More-Types-for-Scripts-and-Links\"><a href=\"#2-脚本和链接无需type-No-More-Types-for-Scripts-and-Links\" class=\"headerlink\" title=\"2.脚本和链接无需type  (No More Types for Scripts and Links)\"></a>2.脚本和链接无需type  (No More Types for Scripts and Links)</h3><p>在HTML4或XHTML中，你需要用下面的几行代码来给你的网页添加CSS和JavaScript文件。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"path/to/stylesheet.css\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>而在HTML5中，你不再需要指定类型属性。因此，代码可以简化如下： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"path/to/stylesheet.css\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/script.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-语义Header和Footer-The-Semantic-Header-and-Footer\"><a href=\"#3-语义Header和Footer-The-Semantic-Header-and-Footer\" class=\"headerlink\" title=\"3.语义Header和Footer (The Semantic Header and Footer)\"></a>3.语义Header和Footer (The Semantic Header and Footer)</h3><p>在HTML4或XHTML中，你需要用下面的代码来声明“Header”和“Footer”。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"header\"</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </div><div class=\"line\">.......... </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"footer\"</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在HTML5中，有两个可以替代上述声明的元素，这可以使代码更简洁。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span> </div><div class=\"line\">    ... </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-Hgroup\"><a href=\"#4-Hgroup\" class=\"headerlink\" title=\"4.Hgroup\"></a>4.Hgroup</h3><p>在HTML5中，有许多新引入的元素，hgroup就是其中之一。假设我的网站名下面紧跟着一个子标题，我可以用<code>&lt;h1&gt;</code>和<code>&lt;h2&gt;</code>标签来分别定义。然而，这种定义没有说明这两者之间的关系。而且，h2标签的使用会带来更多问题，比如该页面上还有其他标题的时候。</p>\n<p>在HTML5中，我们可以用hgroup元素来将它们分组，这样就不会影响文件的大纲。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">hgroup</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span> Recall Fan Page <span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span> Only for people who want the memory of a lifetime. <span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">hgroup</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"5-标记元素-Mark-Element\"><a href=\"#5-标记元素-Mark-Element\" class=\"headerlink\" title=\"5.标记元素 (Mark Element)\"></a>5.标记元素 (Mark Element)</h3><p>你可以把它当做高亮标签。被这个标签修饰的字符串应当和用户当前的行动相关。比如说，当我在某博客中搜索“Open your Mind”时，我可以利用一些JavaScript将出现的词组用<code>&lt;mark&gt;</code>修饰一下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span> Search Results <span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> They were interrupted, just after Quato said, <span class=\"tag\">&lt;<span class=\"name\">mark</span>&gt;</span>\"Open your Mind\"<span class=\"tag\">&lt;/<span class=\"name\">mark</span>&gt;</span>. </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"6-图形元素-Figure-Element\"><a href=\"#6-图形元素-Figure-Element\" class=\"headerlink\" title=\"6.图形元素 (Figure Element)\"></a>6.图形元素 (Figure Element)</h3><p>在HTML4或XHTML中，下面的这些代码被用来修饰图片的注释。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/image\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"About image\"</span> /&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Image of Mars. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>然而，上述代码没有将文字和图片内在联系起来。因此，HTML5引入了<code>&lt;figure&gt;</code>元素。当和<code>&lt;figcaption&gt;</code>结合起来后，我们可以语义化地将注释和相应的图片联系起来。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/image\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"About image\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span> </div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>This is an image of something interesting. <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"7-重新定义-lt-small-gt-Small-Element-redefined\"><a href=\"#7-重新定义-lt-small-gt-Small-Element-redefined\" class=\"headerlink\" title=\"7.重新定义&lt;small&gt; (Small Element redefined)\"></a>7.重新定义<code>&lt;small&gt;</code> (Small Element redefined)</h3><p>在HTML4或XHTML中，<code>&lt;small&gt;</code>元素已经存在。然而，却没有如何正确使用这一元素的完整说明。在HTML5中，<code>&lt;small&gt;</code>被用来定义小字。试想下你网站底部的版权状态，根据对此元素新的HTML5定义，<code>&lt;small&gt;</code>可以正确地诠释这些信息。</p>\n<h3 id=\"8-占位符-Placeholder\"><a href=\"#8-占位符-Placeholder\" class=\"headerlink\" title=\"8.占位符 (Placeholder)\"></a>8.占位符 (Placeholder)</h3><p>在HTML4或XHTML中，你需要用JavaScript来给文本框添加占位符。比如，你可以提前设置好一些信息，当用户开始输入时，文本框中的文字就消失。</p>\n<p>而在HTML5中，新的“placeholder”就简化了这个问题。</p>\n<h3 id=\"9-必要属性-Required-Attribute\"><a href=\"#9-必要属性-Required-Attribute\" class=\"headerlink\" title=\"9.必要属性 (Required Attribute)\"></a>9.必要属性 (Required Attribute)</h3><p>HTML5中的新属性“required”指定了某一输入是否必需。有两种方法声明这一属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">required</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">required</span>=<span class=\"string\">\"required\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当文本框被指定必需时，如果空白的话表格就不能提交。下面是一个如何使用的例子。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"someInput\"</span>&gt;</span> Your Name: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Douglas Quaid\"</span> <span class=\"attr\">required</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Go<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>在上面那个例子中，如果输入内容空且表格被提交，输入框将被高亮显示。</p>\n<h3 id=\"10-Autofocus-属性-Autofocus-Attribute\"><a href=\"#10-Autofocus-属性-Autofocus-Attribute\" class=\"headerlink\" title=\"10.Autofocus 属性 (Autofocus Attribute)\"></a>10.Autofocus 属性 (Autofocus Attribute)</h3><p>同样，HTML5的解决方案消除了对JavaScript的需要。如果一个特定的输入应该是“选择”或聚焦，默认情况下，我们现在可以利用自动聚焦属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"someInput\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"Douglas Quaid\"</span> <span class=\"attr\">required</span> <span class=\"attr\">autofocus</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"11-Audio-支持-Audio-Support\"><a href=\"#11-Audio-支持-Audio-Support\" class=\"headerlink\" title=\"11.Audio 支持 (Audio Support)\"></a>11.Audio 支持 (Audio Support)</h3><p>目前我们需要依靠第三方插件来渲染音频。然而在HTML5中，<audio>元素被引进来了。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">autoplay</span>=<span class=\"string\">\"autoplay\"</span> <span class=\"attr\">controls</span>=<span class=\"string\">\"controls\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"file.ogg\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"file.mp3\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"file.mp3\"</span>&gt;</span>Download this file.<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>当使用<code>&lt;audio&gt;</code>元素时请记得包含两种音频格式。FireFox想要.ogg格式的文件，而Webkit浏览器则需要.mp3格式的。和往常一样，IE是不支持的，且Opera 10及以下版本只支持.wav格式。</p>\n<h3 id=\"12-Video-支持-Video-Support\"><a href=\"#12-Video-支持-Video-Support\" class=\"headerlink\" title=\"12.Video 支持 (Video Support)\"></a>12.Video 支持 (Video Support)</h3><p>HTML5中不仅有<code>&lt;audio&gt;</code>元素，而且还有<code>&lt;video&gt;</code>。然而，和<code>&lt;audio&gt;</code>类似，HTML5中并没有指定视频解码器，它留给了浏览器来决定。虽然Safari和Internet Explorer9可以支持H.264格式的视频，Firefox和Opera是坚持开源Theora 和Vorbis格式。因此，指定HTML5的视频时，你必须提供这两种格式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">controls</span> <span class=\"attr\">preload</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cohagenPhoneCall.ogv\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/ogg; codecs='vorbis, theora'\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">src</span>=<span class=\"string\">\"cohagenPhoneCall.mp4\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"video/mp4; 'codecs='avc1.42E01E, mp4a.40.2'\"</span> /&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span> Your browser is old. <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"cohagenPhoneCall.mp4\"</span>&gt;</span>Download this video instead.<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"13-视频预载-Preload-attribute-in-Videos-element\"><a href=\"#13-视频预载-Preload-attribute-in-Videos-element\" class=\"headerlink\" title=\"13.视频预载 (Preload attribute in Videos element)\"></a>13.视频预载 (Preload attribute in Videos element)</h3><p>当用户访问页面时这一属性使得视频得以预载。为了实现这个功能，可以在<code>&lt;video&gt;</code>元素中加上preload=”preload”或者只是preload。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">preload</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"14-显示控制条-Display-Controls\"><a href=\"#14-显示控制条-Display-Controls\" class=\"headerlink\" title=\"14.显示控制条 (Display Controls)\"></a>14.显示控制条 (Display Controls)</h3><p>如果你使用过上面的每一个提到的技术点，你可能已经注意到，使用上面的代码，视频仅仅显示的是张图片，没有控制条。为了渲染出播放控制条，我们必须在video元素内指定controls属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">preload</span> <span class=\"attr\">controls</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"15-正规表达式-Regular-Expressions\"><a href=\"#15-正规表达式-Regular-Expressions\" class=\"headerlink\" title=\"15.正规表达式 (Regular Expressions)\"></a>15.正规表达式 (Regular Expressions)</h3><p>在HTML4或XHTML中，你需要用一些正规表达式来验证特定的文本。而HTML5中新的pattern属性让我们能够在标签处直接插入一个正规表达式。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"username\"</span>&gt;</span>Create a Username: <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">\"4 &lt;&gt; 10\"</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"[A-Za-z]&#123;4,10&#125;\"</span> </div><div class=\"line\">        <span class=\"attr\">autofocus</span> </div><div class=\"line\">        <span class=\"attr\">required</span>&gt;</span> </div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Go <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span> </div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>事实上，还有很多新元素和特性，上面提到的只是一些我认为网站开发中常用的，剩下的就由你们自己去摸索啦。</p>\n<p>转载至<a href=\"http://www.html5china.com/course/20120225_3483.html\">HTML5China.com</a></p>\n"},{"title":"有趣的JavaScript原生数组函数","date":"2016-08-08T16:00:00.000Z","_content":"\n在JavaScript中，创建数组可以使用Array构造函数，或者使用数组直接量[],后者是首选方法。Array对象继承自Object.prototype,对数组执行typeof操作符返回object而不是array。然而，[] instanceof Array也返回true。也就是说，类数组对象的实现更复杂，例如strings对象、arguments对象，arguments对象不是Array的实例，但有length属性，并能通过索引取值，所以能像数组一样进行循环操作。\n\n在本文中，我将复习一些数组原型的方法，并探索这些方法的用法。\n\n- 循环：.forEach\n- 判断：.some和.every\n- 区分.join和.concat\n- 栈和队列的实现：.pop, .push, .shift,和 .unshift\n- 模型映射：.map\n- 查询：.filter\n- 排序：.sort\n- 计算：.reduce和.reduceRight\n- 复制：.slice\n- 强大的.splice\n- 查找：.indexOf\n- 操作符：in\n- 走近.reverse\n\n### 循环：.forEach\n\n这是JavaScript中最简单的方法，但是IE7和IE8不支持此方法。\n\n.forEach 有一个回调函数作为参数，遍历数组时，每个数组元素均会调用它，回调函数接受三个参数：\n\n- value:当前元素\n- index:当前元素的索引\n- array:要遍历的数组\n\n此外，可以传递可选的第二个参数，作为每次函数调用的上下文（this）.\n\n```\n['_', 't', 'a', 'n', 'i', 'f', ']'].forEach(function (value, index, array) {\n    this.push(String.fromCharCode(value.charCodeAt() + index + 2))\n}, out = [])\nout.join('')\n// <- 'awesome'\n```\n\n后文会提及.join，在这个示例中，它用于拼接数组中的不同元素，效果类似于out[0] + ” + out[1] + ” + out[2] + ” + out[n]。\n\n不能中断.forEach循环，并且抛出异常也是不明智的选择。幸运的事我们有另外的方式来中断操作。\n\n### 判断：.some和.every\n\n如果你用过.NET中的枚举，这两个方法和.Any(x => x.IsAwesome) 、 .All(x => x.IsAwesome)类似。\n和.forEach的参数类似，需要一个包含value，index，和array三个参数的回调函数，并且也有一个可选的第二个上下文参数。MDN对.some的描述如下：\n\n> some将会给数组里的每一个元素执行一遍回调函数，直到回调函数返回true。如果找到目标元素，some立即返回true，否则some返回false。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。\n\n```\nmax = -Infinity\nsatisfied = [10, 12, 10, 8, 5, 23].some(function (value, index, array) {\n    if (value > max) max = value\n    return value < 10\n})\nconsole.log(max)\n// <- 12\nsatisfied\n// <- true\n```\n\n注意，当回调函数的value < 10时，中断函数循环。.every的运行原理和.some类似，但回调函数是返回false而不是true。\n\n### 区分.join和.concat\n\n.join和.concat 经常混淆。.join(separator)以separator作为分隔符拼接数组元素，并返回字符串形式，如果没有提供separator，将使用默认的,。.concat会创建一个新数组，作为源数组的浅拷贝。\n\n- .concat常用用法：array.concat(val, val2, val3, valn)\n- .concat返回一个新数组\n- array.concat()在没有参数的情况下，返回源数组的浅拷贝。\n\n浅拷贝意味着新数组和原数组保持相同的对象引用，这通常是好事。例如：\n\n```\nvar a = { foo: 'bar' }\nvar b = [1, 2, 3, a]\nvar c = b.concat()\nconsole.log(b === c)\n// <- false\nb[3] === a && c[3] === a\n// <- true\n```\n\n### 栈和队列的实现：.pop, .push, .shift和 .unshift\n\n每个人都知道.push可以再数组末尾添加元素，但是你知道可以使用[].push(‘a’, ‘b’, ‘c’, ‘d’, ‘z’)一次性添加多个元素吗？\n\n.pop 方法是.push 的反操作，它返回被删除的数组末尾元素。如果数组为空，将返回void 0 (undefined),使用.pop和.push可以创建LIFO (last in first out)栈。\n\n```\nfunction Stack () {\n    this._stack = []\n}\nStack.prototype.next = function () {\n    return this._stack.pop()\n}\nStack.prototype.add = function () {\n    return this._stack.push.apply(this._stack, arguments)\n}\nstack = new Stack()\nstack.add(1,2,3)\nstack.next()\n// <- 3\n相反，可以使用.shift和 .unshift创建FIFO (first in first out)队列。\n\nfunction Queue () {\n    this._queue = []\n}\nQueue.prototype.next = function () {\n    return this._queue.shift()\n}\nQueue.prototype.add = function () {\n    return this._queue.unshift.apply(this._queue, arguments)\n}\nqueue = new Queue()\nqueue.add(1,2,3)\nqueue.next()\n// <- 1\nUsing .shift (or .pop) is an easy way to loop through a set of array elements, while draining the array in the process.\nlist = [1,2,3,4,5,6,7,8,9,10]\nwhile (item = list.shift()) {\n    console.log(item)\n}\nlist\n// <- []\n```\n\n### 模型映射：.map\n\n> .map为数组中的每个元素提供了一个回调方法，并返回有调用结果构成的新数组。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。\n\nArray.prototype.map 和上面提到的.forEach、.some和 .every有相同的参数格式：.map(fn(value, index, array), thisArgument)\n\n```\nvalues = [void 0, null, false, '']\nvalues[7] = void 0\nresult = values.map(function(value, index, array){\n    console.log(value)\n    return value\n})\n// <- [undefined, null, false, '', undefined × 3, undefined]\n```\n\nundefined × 3很好地解释了.map不会对已删除的或未指定值的元素调用，但仍然会被包含在结果数组中。.map在创建或改变数组时非常有用，看下面的示例：\n\n```\n// casting\n[1, '2', '30', '9'].map(function (value) {\n    return parseInt(value, 10)\n})\n// 1, 2, 30, 9\n[97, 119, 101, 115, 111, 109, 101].map(String.fromCharCode).join('')\n// <- 'awesome'\n// a commonly used pattern is mapping to new objects\nitems.map(function (item) {\n    return {\n        id: item.id,\n        name: computeName(item)\n    }\n})\n```\n\n### 查询：.filter\n\n> filter对每个数组元素执行一次回调函数，并返回一个由回调函数返回true的元素组成的新数组。回调函数只会对已经指定值的数组项调用。\n\n通常用法：.filter(fn(value, index, array), thisArgument),跟C#中的LINQ表达式和SQL中的where语句类似，.filter只返回在回调函数中返回true值的元素。\n\n```\n[void 0, null, false, '', 1].filter(function (value) {\n    return value\n})\n// <- [1]\n[void 0, null, false, '', 1].filter(function (value) {\n    return !value\n})\n// <- [void 0, null, false, '']\n```\n\n### 排序：.sort(compareFunction)\n\n> 如果没有提供compareFunction，元素会被转换成字符串并按照字典排序。例如，”80″排在”9″之前，而不是在其后。\n\n跟大多数排序函数类似，Array.prototype.sort(fn(a,b))需要一个包含两个测试参数的回调函数,其返回值如下：\n\n- a在b之前则返回值小于0\n- a和b相等则返回值是0\n- a在b之后则返回值小于0\n\n```\n[9,80,3,10,5,6].sort()\n// <- [10, 3, 5, 6, 80, 9]\n[9,80,3,10,5,6].sort(function (a, b) {\n    return a - b\n})\n// <- [3, 5, 6, 9, 10, 80]\n```\n\n### 计算：.reduce和.reduceRight\n\n这两个函数比较难理解，.reduce会从左往右遍历数组，而.reduceRight则从右往左遍历数组，二者典型用法：.reduce(callback(previousValue,currentValue, index, array), initialValue)。\n\npreviousValue 是最后一次调用回调函数的返回值，initialValue则是其初始值，currentValue是当前元素值，index是当前元素索引，array是调用.reduce的数组。\n\n一个典型的用例，使用.reduce的求和函数。\n\n```\nArray.prototype.sum = function () {\n    return this.reduce(function (partial, value) {\n        return partial + value\n    }, 0)\n};\n[3,4,5,6,10].sum()\n// <- 28\n```\n\n如果想把数组拼接成一个字符串，可以用.join实现。然而，若数组值是对象，.join就不会按照我们的期望返回值了，除非对象有合理的valueOf或toString方法，在这种情况下，可以用.reduce实现：\n\n```\nfunction concat (input) {\n    return input.reduce(function (partial, value) {\n        if (partial) {\n            partial += ', '\n        }\n        return partial + value\n    }, '')\n}\nconcat([\n    { name: 'George' },\n    { name: 'Sam' },\n    { name: 'Pear' }\n])\n// <- 'George, Sam, Pear'\n```\n\n### 复制：.slice\n\n和.concat类似，调用没有参数的.slice()方法会返回源数组的一个浅拷贝。.slice有两个参数：一个是开始位置和一个结束位置。\nArray.prototype.slice 能被用来将类数组对象转换为真正的数组。\n\n```\nArray.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })\n// <- ['a', 'b']\n这对.concat不适用，因为它会用数组包裹类数组对象。\n\nArray.prototype.concat.call({ 0: 'a', 1: 'b', length: 2 })\n// <- [{ 0: 'a', 1: 'b', length: 2 }]\n```\n\n此外，.slice的另一个通常用法是从一个参数列表中删除一些元素，这可以将类数组对象转换为真正的数组。\n\n```\nfunction format (text, bold) {\n    if (bold) {\n        text = '<b>' + text + '</b>'\n    }\n    var values = Array.prototype.slice.call(arguments, 2)\n    values.forEach(function (value) {\n        text = text.replace('%s', value)\n    })\n    return text\n}\nformat('some%sthing%s %s', true, 'some', 'other', 'things')\n```\n\n### 强大的.splice\n\n.splice 是我最喜欢的原生数组函数，只需要调用一次，就允许你删除元素、插入新的元素，并能同时进行删除、插入操作。需要注意的是，不同于`.concat和.slice,这个函数会改变源数组。\n\n```\nvar source = [1,2,3,8,8,8,8,8,9,10,11,12,13]\nvar spliced = source.splice(3, 4, 4, 5, 6, 7)\nconsole.log(source)\n// <- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]\nspliced\n// <- [8, 8, 8, 8]\n```\n\n正如你看到的，.splice会返回删除的元素。如果你想遍历已经删除的数组时，这会非常方便。\n\n```\nvar source = [1,2,3,8,8,8,8,8,9,10,11,12,13]\nvar spliced = source.splice(9)\nspliced.forEach(function (value) {\n    console.log('removed', value)\n})\n// <- removed 10\n// <- removed 11\n// <- removed 12\n// <- removed 13\nconsole.log(source)\n// <- [1, 2, 3, 8, 8, 8, 8, 8, 9]\n```\n\n### 查找：.indexOf\n\n利用.indexOf 可以在数组中查找一个元素的位置，没有匹配元素则返回-1。我经常使用.indexOf的情况是当我有比较时，例如：a === ‘a’ || a === ‘b’ || a === ‘c’，或者只有两个比较，此时，可以使用.indexOf：['a', 'b', 'c'].indexOf(a) !== -1。\n\n注意，如果提供的引用相同，.indexOf也能查找对象。第二个可选参数用于指定开始查找的位置。\n\n```\nvar a = { foo: 'bar' }\nvar b = [a, 2]\nconsole.log(b.indexOf(1))\n// <- -1\nconsole.log(b.indexOf({ foo: 'bar' }))\n// <- -1\nconsole.log(b.indexOf(a))\n// <- 0\nconsole.log(b.indexOf(a, 1))\n// <- -1\nb.indexOf(2, 1)\n// <- 1\n```\n\n如果你想从后向前搜索，可以使用.lastIndexOf。\n\n### 操作符：in\n\n在面试中新手容易犯的错误是混淆.indexOf和in操作符:\n\n```\nvar a = [1, 2, 5]\n1 in a\n// <- true, but because of the 2!\n5 in a\n// <- false\n```\n\n问题是in操作符是检索对象的键而非值。当然，这在性能上比.indexOf快得多。\n\n```\nvar a = [3, 7, 6]\n1 in a === !!a[1]\n// <- true\n```\n\n### 走近.reverse\n\n该方法将数组中的元素倒置。\n\n```\nvar a = [1, 1, 7, 8]\na.reverse()\n// [8, 7, 1, 1]\n```\n\n.reverse 会修改数组本身。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/fun-with-javascript-native-array-functions.html)","source":"_posts/有趣的JavaScript原生数组函数.md","raw":"---\ntitle: 有趣的JavaScript原生数组函数\ntags: [javascript]\ndate: 2016/08/09\n---\n\n在JavaScript中，创建数组可以使用Array构造函数，或者使用数组直接量[],后者是首选方法。Array对象继承自Object.prototype,对数组执行typeof操作符返回object而不是array。然而，[] instanceof Array也返回true。也就是说，类数组对象的实现更复杂，例如strings对象、arguments对象，arguments对象不是Array的实例，但有length属性，并能通过索引取值，所以能像数组一样进行循环操作。\n\n在本文中，我将复习一些数组原型的方法，并探索这些方法的用法。\n\n- 循环：.forEach\n- 判断：.some和.every\n- 区分.join和.concat\n- 栈和队列的实现：.pop, .push, .shift,和 .unshift\n- 模型映射：.map\n- 查询：.filter\n- 排序：.sort\n- 计算：.reduce和.reduceRight\n- 复制：.slice\n- 强大的.splice\n- 查找：.indexOf\n- 操作符：in\n- 走近.reverse\n\n### 循环：.forEach\n\n这是JavaScript中最简单的方法，但是IE7和IE8不支持此方法。\n\n.forEach 有一个回调函数作为参数，遍历数组时，每个数组元素均会调用它，回调函数接受三个参数：\n\n- value:当前元素\n- index:当前元素的索引\n- array:要遍历的数组\n\n此外，可以传递可选的第二个参数，作为每次函数调用的上下文（this）.\n\n```\n['_', 't', 'a', 'n', 'i', 'f', ']'].forEach(function (value, index, array) {\n    this.push(String.fromCharCode(value.charCodeAt() + index + 2))\n}, out = [])\nout.join('')\n// <- 'awesome'\n```\n\n后文会提及.join，在这个示例中，它用于拼接数组中的不同元素，效果类似于out[0] + ” + out[1] + ” + out[2] + ” + out[n]。\n\n不能中断.forEach循环，并且抛出异常也是不明智的选择。幸运的事我们有另外的方式来中断操作。\n\n### 判断：.some和.every\n\n如果你用过.NET中的枚举，这两个方法和.Any(x => x.IsAwesome) 、 .All(x => x.IsAwesome)类似。\n和.forEach的参数类似，需要一个包含value，index，和array三个参数的回调函数，并且也有一个可选的第二个上下文参数。MDN对.some的描述如下：\n\n> some将会给数组里的每一个元素执行一遍回调函数，直到回调函数返回true。如果找到目标元素，some立即返回true，否则some返回false。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。\n\n```\nmax = -Infinity\nsatisfied = [10, 12, 10, 8, 5, 23].some(function (value, index, array) {\n    if (value > max) max = value\n    return value < 10\n})\nconsole.log(max)\n// <- 12\nsatisfied\n// <- true\n```\n\n注意，当回调函数的value < 10时，中断函数循环。.every的运行原理和.some类似，但回调函数是返回false而不是true。\n\n### 区分.join和.concat\n\n.join和.concat 经常混淆。.join(separator)以separator作为分隔符拼接数组元素，并返回字符串形式，如果没有提供separator，将使用默认的,。.concat会创建一个新数组，作为源数组的浅拷贝。\n\n- .concat常用用法：array.concat(val, val2, val3, valn)\n- .concat返回一个新数组\n- array.concat()在没有参数的情况下，返回源数组的浅拷贝。\n\n浅拷贝意味着新数组和原数组保持相同的对象引用，这通常是好事。例如：\n\n```\nvar a = { foo: 'bar' }\nvar b = [1, 2, 3, a]\nvar c = b.concat()\nconsole.log(b === c)\n// <- false\nb[3] === a && c[3] === a\n// <- true\n```\n\n### 栈和队列的实现：.pop, .push, .shift和 .unshift\n\n每个人都知道.push可以再数组末尾添加元素，但是你知道可以使用[].push(‘a’, ‘b’, ‘c’, ‘d’, ‘z’)一次性添加多个元素吗？\n\n.pop 方法是.push 的反操作，它返回被删除的数组末尾元素。如果数组为空，将返回void 0 (undefined),使用.pop和.push可以创建LIFO (last in first out)栈。\n\n```\nfunction Stack () {\n    this._stack = []\n}\nStack.prototype.next = function () {\n    return this._stack.pop()\n}\nStack.prototype.add = function () {\n    return this._stack.push.apply(this._stack, arguments)\n}\nstack = new Stack()\nstack.add(1,2,3)\nstack.next()\n// <- 3\n相反，可以使用.shift和 .unshift创建FIFO (first in first out)队列。\n\nfunction Queue () {\n    this._queue = []\n}\nQueue.prototype.next = function () {\n    return this._queue.shift()\n}\nQueue.prototype.add = function () {\n    return this._queue.unshift.apply(this._queue, arguments)\n}\nqueue = new Queue()\nqueue.add(1,2,3)\nqueue.next()\n// <- 1\nUsing .shift (or .pop) is an easy way to loop through a set of array elements, while draining the array in the process.\nlist = [1,2,3,4,5,6,7,8,9,10]\nwhile (item = list.shift()) {\n    console.log(item)\n}\nlist\n// <- []\n```\n\n### 模型映射：.map\n\n> .map为数组中的每个元素提供了一个回调方法，并返回有调用结果构成的新数组。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。\n\nArray.prototype.map 和上面提到的.forEach、.some和 .every有相同的参数格式：.map(fn(value, index, array), thisArgument)\n\n```\nvalues = [void 0, null, false, '']\nvalues[7] = void 0\nresult = values.map(function(value, index, array){\n    console.log(value)\n    return value\n})\n// <- [undefined, null, false, '', undefined × 3, undefined]\n```\n\nundefined × 3很好地解释了.map不会对已删除的或未指定值的元素调用，但仍然会被包含在结果数组中。.map在创建或改变数组时非常有用，看下面的示例：\n\n```\n// casting\n[1, '2', '30', '9'].map(function (value) {\n    return parseInt(value, 10)\n})\n// 1, 2, 30, 9\n[97, 119, 101, 115, 111, 109, 101].map(String.fromCharCode).join('')\n// <- 'awesome'\n// a commonly used pattern is mapping to new objects\nitems.map(function (item) {\n    return {\n        id: item.id,\n        name: computeName(item)\n    }\n})\n```\n\n### 查询：.filter\n\n> filter对每个数组元素执行一次回调函数，并返回一个由回调函数返回true的元素组成的新数组。回调函数只会对已经指定值的数组项调用。\n\n通常用法：.filter(fn(value, index, array), thisArgument),跟C#中的LINQ表达式和SQL中的where语句类似，.filter只返回在回调函数中返回true值的元素。\n\n```\n[void 0, null, false, '', 1].filter(function (value) {\n    return value\n})\n// <- [1]\n[void 0, null, false, '', 1].filter(function (value) {\n    return !value\n})\n// <- [void 0, null, false, '']\n```\n\n### 排序：.sort(compareFunction)\n\n> 如果没有提供compareFunction，元素会被转换成字符串并按照字典排序。例如，”80″排在”9″之前，而不是在其后。\n\n跟大多数排序函数类似，Array.prototype.sort(fn(a,b))需要一个包含两个测试参数的回调函数,其返回值如下：\n\n- a在b之前则返回值小于0\n- a和b相等则返回值是0\n- a在b之后则返回值小于0\n\n```\n[9,80,3,10,5,6].sort()\n// <- [10, 3, 5, 6, 80, 9]\n[9,80,3,10,5,6].sort(function (a, b) {\n    return a - b\n})\n// <- [3, 5, 6, 9, 10, 80]\n```\n\n### 计算：.reduce和.reduceRight\n\n这两个函数比较难理解，.reduce会从左往右遍历数组，而.reduceRight则从右往左遍历数组，二者典型用法：.reduce(callback(previousValue,currentValue, index, array), initialValue)。\n\npreviousValue 是最后一次调用回调函数的返回值，initialValue则是其初始值，currentValue是当前元素值，index是当前元素索引，array是调用.reduce的数组。\n\n一个典型的用例，使用.reduce的求和函数。\n\n```\nArray.prototype.sum = function () {\n    return this.reduce(function (partial, value) {\n        return partial + value\n    }, 0)\n};\n[3,4,5,6,10].sum()\n// <- 28\n```\n\n如果想把数组拼接成一个字符串，可以用.join实现。然而，若数组值是对象，.join就不会按照我们的期望返回值了，除非对象有合理的valueOf或toString方法，在这种情况下，可以用.reduce实现：\n\n```\nfunction concat (input) {\n    return input.reduce(function (partial, value) {\n        if (partial) {\n            partial += ', '\n        }\n        return partial + value\n    }, '')\n}\nconcat([\n    { name: 'George' },\n    { name: 'Sam' },\n    { name: 'Pear' }\n])\n// <- 'George, Sam, Pear'\n```\n\n### 复制：.slice\n\n和.concat类似，调用没有参数的.slice()方法会返回源数组的一个浅拷贝。.slice有两个参数：一个是开始位置和一个结束位置。\nArray.prototype.slice 能被用来将类数组对象转换为真正的数组。\n\n```\nArray.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })\n// <- ['a', 'b']\n这对.concat不适用，因为它会用数组包裹类数组对象。\n\nArray.prototype.concat.call({ 0: 'a', 1: 'b', length: 2 })\n// <- [{ 0: 'a', 1: 'b', length: 2 }]\n```\n\n此外，.slice的另一个通常用法是从一个参数列表中删除一些元素，这可以将类数组对象转换为真正的数组。\n\n```\nfunction format (text, bold) {\n    if (bold) {\n        text = '<b>' + text + '</b>'\n    }\n    var values = Array.prototype.slice.call(arguments, 2)\n    values.forEach(function (value) {\n        text = text.replace('%s', value)\n    })\n    return text\n}\nformat('some%sthing%s %s', true, 'some', 'other', 'things')\n```\n\n### 强大的.splice\n\n.splice 是我最喜欢的原生数组函数，只需要调用一次，就允许你删除元素、插入新的元素，并能同时进行删除、插入操作。需要注意的是，不同于`.concat和.slice,这个函数会改变源数组。\n\n```\nvar source = [1,2,3,8,8,8,8,8,9,10,11,12,13]\nvar spliced = source.splice(3, 4, 4, 5, 6, 7)\nconsole.log(source)\n// <- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]\nspliced\n// <- [8, 8, 8, 8]\n```\n\n正如你看到的，.splice会返回删除的元素。如果你想遍历已经删除的数组时，这会非常方便。\n\n```\nvar source = [1,2,3,8,8,8,8,8,9,10,11,12,13]\nvar spliced = source.splice(9)\nspliced.forEach(function (value) {\n    console.log('removed', value)\n})\n// <- removed 10\n// <- removed 11\n// <- removed 12\n// <- removed 13\nconsole.log(source)\n// <- [1, 2, 3, 8, 8, 8, 8, 8, 9]\n```\n\n### 查找：.indexOf\n\n利用.indexOf 可以在数组中查找一个元素的位置，没有匹配元素则返回-1。我经常使用.indexOf的情况是当我有比较时，例如：a === ‘a’ || a === ‘b’ || a === ‘c’，或者只有两个比较，此时，可以使用.indexOf：['a', 'b', 'c'].indexOf(a) !== -1。\n\n注意，如果提供的引用相同，.indexOf也能查找对象。第二个可选参数用于指定开始查找的位置。\n\n```\nvar a = { foo: 'bar' }\nvar b = [a, 2]\nconsole.log(b.indexOf(1))\n// <- -1\nconsole.log(b.indexOf({ foo: 'bar' }))\n// <- -1\nconsole.log(b.indexOf(a))\n// <- 0\nconsole.log(b.indexOf(a, 1))\n// <- -1\nb.indexOf(2, 1)\n// <- 1\n```\n\n如果你想从后向前搜索，可以使用.lastIndexOf。\n\n### 操作符：in\n\n在面试中新手容易犯的错误是混淆.indexOf和in操作符:\n\n```\nvar a = [1, 2, 5]\n1 in a\n// <- true, but because of the 2!\n5 in a\n// <- false\n```\n\n问题是in操作符是检索对象的键而非值。当然，这在性能上比.indexOf快得多。\n\n```\nvar a = [3, 7, 6]\n1 in a === !!a[1]\n// <- true\n```\n\n### 走近.reverse\n\n该方法将数组中的元素倒置。\n\n```\nvar a = [1, 1, 7, 8]\na.reverse()\n// [8, 7, 1, 1]\n```\n\n.reverse 会修改数组本身。\n\n转载自：[http://www.codeceo.com](http://www.codeceo.com/article/fun-with-javascript-native-array-functions.html)","slug":"有趣的JavaScript原生数组函数","published":1,"updated":"2016-08-17T06:22:19.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpm8004s68ddks7z7eev","content":"<p>在JavaScript中，创建数组可以使用Array构造函数，或者使用数组直接量[],后者是首选方法。Array对象继承自Object.prototype,对数组执行typeof操作符返回object而不是array。然而，[] instanceof Array也返回true。也就是说，类数组对象的实现更复杂，例如strings对象、arguments对象，arguments对象不是Array的实例，但有length属性，并能通过索引取值，所以能像数组一样进行循环操作。</p>\n<p>在本文中，我将复习一些数组原型的方法，并探索这些方法的用法。</p>\n<ul>\n<li>循环：.forEach</li>\n<li>判断：.some和.every</li>\n<li>区分.join和.concat</li>\n<li>栈和队列的实现：.pop, .push, .shift,和 .unshift</li>\n<li>模型映射：.map</li>\n<li>查询：.filter</li>\n<li>排序：.sort</li>\n<li>计算：.reduce和.reduceRight</li>\n<li>复制：.slice</li>\n<li>强大的.splice</li>\n<li>查找：.indexOf</li>\n<li>操作符：in</li>\n<li>走近.reverse</li>\n</ul>\n<h3 id=\"循环：-forEach\"><a href=\"#循环：-forEach\" class=\"headerlink\" title=\"循环：.forEach\"></a>循环：.forEach</h3><p>这是JavaScript中最简单的方法，但是IE7和IE8不支持此方法。</p>\n<p>.forEach 有一个回调函数作为参数，遍历数组时，每个数组元素均会调用它，回调函数接受三个参数：</p>\n<ul>\n<li>value:当前元素</li>\n<li>index:当前元素的索引</li>\n<li>array:要遍历的数组</li>\n</ul>\n<p>此外，可以传递可选的第二个参数，作为每次函数调用的上下文（this）.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[&apos;_&apos;, &apos;t&apos;, &apos;a&apos;, &apos;n&apos;, &apos;i&apos;, &apos;f&apos;, &apos;]&apos;].forEach(function (value, index, array) &#123;</div><div class=\"line\">    this.push(String.fromCharCode(value.charCodeAt() + index + 2))</div><div class=\"line\">&#125;, out = [])</div><div class=\"line\">out.join(&apos;&apos;)</div><div class=\"line\">// &lt;- &apos;awesome&apos;</div></pre></td></tr></table></figure>\n<p>后文会提及.join，在这个示例中，它用于拼接数组中的不同元素，效果类似于out[0] + ” + out[1] + ” + out[2] + ” + out[n]。</p>\n<p>不能中断.forEach循环，并且抛出异常也是不明智的选择。幸运的事我们有另外的方式来中断操作。</p>\n<h3 id=\"判断：-some和-every\"><a href=\"#判断：-some和-every\" class=\"headerlink\" title=\"判断：.some和.every\"></a>判断：.some和.every</h3><p>如果你用过.NET中的枚举，这两个方法和.Any(x =&gt; x.IsAwesome) 、 .All(x =&gt; x.IsAwesome)类似。<br>和.forEach的参数类似，需要一个包含value，index，和array三个参数的回调函数，并且也有一个可选的第二个上下文参数。MDN对.some的描述如下：</p>\n<blockquote>\n<p>some将会给数组里的每一个元素执行一遍回调函数，直到回调函数返回true。如果找到目标元素，some立即返回true，否则some返回false。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">max = -Infinity</div><div class=\"line\">satisfied = [10, 12, 10, 8, 5, 23].some(function (value, index, array) &#123;</div><div class=\"line\">    if (value &gt; max) max = value</div><div class=\"line\">    return value &lt; 10</div><div class=\"line\">&#125;)</div><div class=\"line\">console.log(max)</div><div class=\"line\">// &lt;- 12</div><div class=\"line\">satisfied</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<p>注意，当回调函数的value &lt; 10时，中断函数循环。.every的运行原理和.some类似，但回调函数是返回false而不是true。</p>\n<h3 id=\"区分-join和-concat\"><a href=\"#区分-join和-concat\" class=\"headerlink\" title=\"区分.join和.concat\"></a>区分.join和.concat</h3><p>.join和.concat 经常混淆。.join(separator)以separator作为分隔符拼接数组元素，并返回字符串形式，如果没有提供separator，将使用默认的,。.concat会创建一个新数组，作为源数组的浅拷贝。</p>\n<ul>\n<li>.concat常用用法：array.concat(val, val2, val3, valn)</li>\n<li>.concat返回一个新数组</li>\n<li>array.concat()在没有参数的情况下，返回源数组的浅拷贝。</li>\n</ul>\n<p>浅拷贝意味着新数组和原数组保持相同的对象引用，这通常是好事。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123; foo: &apos;bar&apos; &#125;</div><div class=\"line\">var b = [1, 2, 3, a]</div><div class=\"line\">var c = b.concat()</div><div class=\"line\">console.log(b === c)</div><div class=\"line\">// &lt;- false</div><div class=\"line\">b[3] === a &amp;&amp; c[3] === a</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<h3 id=\"栈和队列的实现：-pop-push-shift和-unshift\"><a href=\"#栈和队列的实现：-pop-push-shift和-unshift\" class=\"headerlink\" title=\"栈和队列的实现：.pop, .push, .shift和 .unshift\"></a>栈和队列的实现：.pop, .push, .shift和 .unshift</h3><p>每个人都知道.push可以再数组末尾添加元素，但是你知道可以使用[].push(‘a’, ‘b’, ‘c’, ‘d’, ‘z’)一次性添加多个元素吗？</p>\n<p>.pop 方法是.push 的反操作，它返回被删除的数组末尾元素。如果数组为空，将返回void 0 (undefined),使用.pop和.push可以创建LIFO (last in first out)栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Stack () &#123;</div><div class=\"line\">    this._stack = []</div><div class=\"line\">&#125;</div><div class=\"line\">Stack.prototype.next = function () &#123;</div><div class=\"line\">    return this._stack.pop()</div><div class=\"line\">&#125;</div><div class=\"line\">Stack.prototype.add = function () &#123;</div><div class=\"line\">    return this._stack.push.apply(this._stack, arguments)</div><div class=\"line\">&#125;</div><div class=\"line\">stack = new Stack()</div><div class=\"line\">stack.add(1,2,3)</div><div class=\"line\">stack.next()</div><div class=\"line\">// &lt;- 3</div><div class=\"line\">相反，可以使用.shift和 .unshift创建FIFO (first in first out)队列。</div><div class=\"line\"></div><div class=\"line\">function Queue () &#123;</div><div class=\"line\">    this._queue = []</div><div class=\"line\">&#125;</div><div class=\"line\">Queue.prototype.next = function () &#123;</div><div class=\"line\">    return this._queue.shift()</div><div class=\"line\">&#125;</div><div class=\"line\">Queue.prototype.add = function () &#123;</div><div class=\"line\">    return this._queue.unshift.apply(this._queue, arguments)</div><div class=\"line\">&#125;</div><div class=\"line\">queue = new Queue()</div><div class=\"line\">queue.add(1,2,3)</div><div class=\"line\">queue.next()</div><div class=\"line\">// &lt;- 1</div><div class=\"line\">Using .shift (or .pop) is an easy way to loop through a set of array elements, while draining the array in the process.</div><div class=\"line\">list = [1,2,3,4,5,6,7,8,9,10]</div><div class=\"line\">while (item = list.shift()) &#123;</div><div class=\"line\">    console.log(item)</div><div class=\"line\">&#125;</div><div class=\"line\">list</div><div class=\"line\">// &lt;- []</div></pre></td></tr></table></figure>\n<h3 id=\"模型映射：-map\"><a href=\"#模型映射：-map\" class=\"headerlink\" title=\"模型映射：.map\"></a>模型映射：.map</h3><blockquote>\n<p>.map为数组中的每个元素提供了一个回调方法，并返回有调用结果构成的新数组。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。</p>\n</blockquote>\n<p>Array.prototype.map 和上面提到的.forEach、.some和 .every有相同的参数格式：.map(fn(value, index, array), thisArgument)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">values = [void 0, null, false, &apos;&apos;]</div><div class=\"line\">values[7] = void 0</div><div class=\"line\">result = values.map(function(value, index, array)&#123;</div><div class=\"line\">    console.log(value)</div><div class=\"line\">    return value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [undefined, null, false, &apos;&apos;, undefined × 3, undefined]</div></pre></td></tr></table></figure>\n<p>undefined × 3很好地解释了.map不会对已删除的或未指定值的元素调用，但仍然会被包含在结果数组中。.map在创建或改变数组时非常有用，看下面的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// casting</div><div class=\"line\">[1, &apos;2&apos;, &apos;30&apos;, &apos;9&apos;].map(function (value) &#123;</div><div class=\"line\">    return parseInt(value, 10)</div><div class=\"line\">&#125;)</div><div class=\"line\">// 1, 2, 30, 9</div><div class=\"line\">[97, 119, 101, 115, 111, 109, 101].map(String.fromCharCode).join(&apos;&apos;)</div><div class=\"line\">// &lt;- &apos;awesome&apos;</div><div class=\"line\">// a commonly used pattern is mapping to new objects</div><div class=\"line\">items.map(function (item) &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        id: item.id,</div><div class=\"line\">        name: computeName(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"查询：-filter\"><a href=\"#查询：-filter\" class=\"headerlink\" title=\"查询：.filter\"></a>查询：.filter</h3><blockquote>\n<p>filter对每个数组元素执行一次回调函数，并返回一个由回调函数返回true的元素组成的新数组。回调函数只会对已经指定值的数组项调用。</p>\n</blockquote>\n<p>通常用法：.filter(fn(value, index, array), thisArgument),跟C#中的LINQ表达式和SQL中的where语句类似，.filter只返回在回调函数中返回true值的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[void 0, null, false, &apos;&apos;, 1].filter(function (value) &#123;</div><div class=\"line\">    return value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [1]</div><div class=\"line\">[void 0, null, false, &apos;&apos;, 1].filter(function (value) &#123;</div><div class=\"line\">    return !value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [void 0, null, false, &apos;&apos;]</div></pre></td></tr></table></figure>\n<h3 id=\"排序：-sort-compareFunction\"><a href=\"#排序：-sort-compareFunction\" class=\"headerlink\" title=\"排序：.sort(compareFunction)\"></a>排序：.sort(compareFunction)</h3><blockquote>\n<p>如果没有提供compareFunction，元素会被转换成字符串并按照字典排序。例如，”80″排在”9″之前，而不是在其后。</p>\n</blockquote>\n<p>跟大多数排序函数类似，Array.prototype.sort(fn(a,b))需要一个包含两个测试参数的回调函数,其返回值如下：</p>\n<ul>\n<li>a在b之前则返回值小于0</li>\n<li>a和b相等则返回值是0</li>\n<li>a在b之后则返回值小于0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[9,80,3,10,5,6].sort()</div><div class=\"line\">// &lt;- [10, 3, 5, 6, 80, 9]</div><div class=\"line\">[9,80,3,10,5,6].sort(function (a, b) &#123;</div><div class=\"line\">    return a - b</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [3, 5, 6, 9, 10, 80]</div></pre></td></tr></table></figure>\n<h3 id=\"计算：-reduce和-reduceRight\"><a href=\"#计算：-reduce和-reduceRight\" class=\"headerlink\" title=\"计算：.reduce和.reduceRight\"></a>计算：.reduce和.reduceRight</h3><p>这两个函数比较难理解，.reduce会从左往右遍历数组，而.reduceRight则从右往左遍历数组，二者典型用法：.reduce(callback(previousValue,currentValue, index, array), initialValue)。</p>\n<p>previousValue 是最后一次调用回调函数的返回值，initialValue则是其初始值，currentValue是当前元素值，index是当前元素索引，array是调用.reduce的数组。</p>\n<p>一个典型的用例，使用.reduce的求和函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.sum = function () &#123;</div><div class=\"line\">    return this.reduce(function (partial, value) &#123;</div><div class=\"line\">        return partial + value</div><div class=\"line\">    &#125;, 0)</div><div class=\"line\">&#125;;</div><div class=\"line\">[3,4,5,6,10].sum()</div><div class=\"line\">// &lt;- 28</div></pre></td></tr></table></figure>\n<p>如果想把数组拼接成一个字符串，可以用.join实现。然而，若数组值是对象，.join就不会按照我们的期望返回值了，除非对象有合理的valueOf或toString方法，在这种情况下，可以用.reduce实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function concat (input) &#123;</div><div class=\"line\">    return input.reduce(function (partial, value) &#123;</div><div class=\"line\">        if (partial) &#123;</div><div class=\"line\">            partial += &apos;, &apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return partial + value</div><div class=\"line\">    &#125;, &apos;&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">concat([</div><div class=\"line\">    &#123; name: &apos;George&apos; &#125;,</div><div class=\"line\">    &#123; name: &apos;Sam&apos; &#125;,</div><div class=\"line\">    &#123; name: &apos;Pear&apos; &#125;</div><div class=\"line\">])</div><div class=\"line\">// &lt;- &apos;George, Sam, Pear&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"复制：-slice\"><a href=\"#复制：-slice\" class=\"headerlink\" title=\"复制：.slice\"></a>复制：.slice</h3><p>和.concat类似，调用没有参数的.slice()方法会返回源数组的一个浅拷贝。.slice有两个参数：一个是开始位置和一个结束位置。<br>Array.prototype.slice 能被用来将类数组对象转换为真正的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</div><div class=\"line\">// &lt;- [&apos;a&apos;, &apos;b&apos;]</div><div class=\"line\">这对.concat不适用，因为它会用数组包裹类数组对象。</div><div class=\"line\"></div><div class=\"line\">Array.prototype.concat.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</div><div class=\"line\">// &lt;- [&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;]</div></pre></td></tr></table></figure>\n<p>此外，.slice的另一个通常用法是从一个参数列表中删除一些元素，这可以将类数组对象转换为真正的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function format (text, bold) &#123;</div><div class=\"line\">    if (bold) &#123;</div><div class=\"line\">        text = &apos;&lt;b&gt;&apos; + text + &apos;&lt;/b&gt;&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var values = Array.prototype.slice.call(arguments, 2)</div><div class=\"line\">    values.forEach(function (value) &#123;</div><div class=\"line\">        text = text.replace(&apos;%s&apos;, value)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return text</div><div class=\"line\">&#125;</div><div class=\"line\">format(&apos;some%sthing%s %s&apos;, true, &apos;some&apos;, &apos;other&apos;, &apos;things&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"强大的-splice\"><a href=\"#强大的-splice\" class=\"headerlink\" title=\"强大的.splice\"></a>强大的.splice</h3><p>.splice 是我最喜欢的原生数组函数，只需要调用一次，就允许你删除元素、插入新的元素，并能同时进行删除、插入操作。需要注意的是，不同于`.concat和.slice,这个函数会改变源数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]</div><div class=\"line\">var spliced = source.splice(3, 4, 4, 5, 6, 7)</div><div class=\"line\">console.log(source)</div><div class=\"line\">// &lt;- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]</div><div class=\"line\">spliced</div><div class=\"line\">// &lt;- [8, 8, 8, 8]</div></pre></td></tr></table></figure>\n<p>正如你看到的，.splice会返回删除的元素。如果你想遍历已经删除的数组时，这会非常方便。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]</div><div class=\"line\">var spliced = source.splice(9)</div><div class=\"line\">spliced.forEach(function (value) &#123;</div><div class=\"line\">    console.log(&apos;removed&apos;, value)</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- removed 10</div><div class=\"line\">// &lt;- removed 11</div><div class=\"line\">// &lt;- removed 12</div><div class=\"line\">// &lt;- removed 13</div><div class=\"line\">console.log(source)</div><div class=\"line\">// &lt;- [1, 2, 3, 8, 8, 8, 8, 8, 9]</div></pre></td></tr></table></figure>\n<h3 id=\"查找：-indexOf\"><a href=\"#查找：-indexOf\" class=\"headerlink\" title=\"查找：.indexOf\"></a>查找：.indexOf</h3><p>利用.indexOf 可以在数组中查找一个元素的位置，没有匹配元素则返回-1。我经常使用.indexOf的情况是当我有比较时，例如：a === ‘a’ || a === ‘b’ || a === ‘c’，或者只有两个比较，此时，可以使用.indexOf：[‘a’, ‘b’, ‘c’].indexOf(a) !== -1。</p>\n<p>注意，如果提供的引用相同，.indexOf也能查找对象。第二个可选参数用于指定开始查找的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123; foo: &apos;bar&apos; &#125;</div><div class=\"line\">var b = [a, 2]</div><div class=\"line\">console.log(b.indexOf(1))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">console.log(b.indexOf(&#123; foo: &apos;bar&apos; &#125;))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">console.log(b.indexOf(a))</div><div class=\"line\">// &lt;- 0</div><div class=\"line\">console.log(b.indexOf(a, 1))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">b.indexOf(2, 1)</div><div class=\"line\">// &lt;- 1</div></pre></td></tr></table></figure>\n<p>如果你想从后向前搜索，可以使用.lastIndexOf。</p>\n<h3 id=\"操作符：in\"><a href=\"#操作符：in\" class=\"headerlink\" title=\"操作符：in\"></a>操作符：in</h3><p>在面试中新手容易犯的错误是混淆.indexOf和in操作符:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 2, 5]</div><div class=\"line\">1 in a</div><div class=\"line\">// &lt;- true, but because of the 2!</div><div class=\"line\">5 in a</div><div class=\"line\">// &lt;- false</div></pre></td></tr></table></figure>\n<p>问题是in操作符是检索对象的键而非值。当然，这在性能上比.indexOf快得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [3, 7, 6]</div><div class=\"line\">1 in a === !!a[1]</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<h3 id=\"走近-reverse\"><a href=\"#走近-reverse\" class=\"headerlink\" title=\"走近.reverse\"></a>走近.reverse</h3><p>该方法将数组中的元素倒置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 1, 7, 8]</div><div class=\"line\">a.reverse()</div><div class=\"line\">// [8, 7, 1, 1]</div></pre></td></tr></table></figure>\n<p>.reverse 会修改数组本身。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/fun-with-javascript-native-array-functions.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com</a></p>\n","excerpt":"","more":"<p>在JavaScript中，创建数组可以使用Array构造函数，或者使用数组直接量[],后者是首选方法。Array对象继承自Object.prototype,对数组执行typeof操作符返回object而不是array。然而，[] instanceof Array也返回true。也就是说，类数组对象的实现更复杂，例如strings对象、arguments对象，arguments对象不是Array的实例，但有length属性，并能通过索引取值，所以能像数组一样进行循环操作。</p>\n<p>在本文中，我将复习一些数组原型的方法，并探索这些方法的用法。</p>\n<ul>\n<li>循环：.forEach</li>\n<li>判断：.some和.every</li>\n<li>区分.join和.concat</li>\n<li>栈和队列的实现：.pop, .push, .shift,和 .unshift</li>\n<li>模型映射：.map</li>\n<li>查询：.filter</li>\n<li>排序：.sort</li>\n<li>计算：.reduce和.reduceRight</li>\n<li>复制：.slice</li>\n<li>强大的.splice</li>\n<li>查找：.indexOf</li>\n<li>操作符：in</li>\n<li>走近.reverse</li>\n</ul>\n<h3 id=\"循环：-forEach\"><a href=\"#循环：-forEach\" class=\"headerlink\" title=\"循环：.forEach\"></a>循环：.forEach</h3><p>这是JavaScript中最简单的方法，但是IE7和IE8不支持此方法。</p>\n<p>.forEach 有一个回调函数作为参数，遍历数组时，每个数组元素均会调用它，回调函数接受三个参数：</p>\n<ul>\n<li>value:当前元素</li>\n<li>index:当前元素的索引</li>\n<li>array:要遍历的数组</li>\n</ul>\n<p>此外，可以传递可选的第二个参数，作为每次函数调用的上下文（this）.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[&apos;_&apos;, &apos;t&apos;, &apos;a&apos;, &apos;n&apos;, &apos;i&apos;, &apos;f&apos;, &apos;]&apos;].forEach(function (value, index, array) &#123;</div><div class=\"line\">    this.push(String.fromCharCode(value.charCodeAt() + index + 2))</div><div class=\"line\">&#125;, out = [])</div><div class=\"line\">out.join(&apos;&apos;)</div><div class=\"line\">// &lt;- &apos;awesome&apos;</div></pre></td></tr></table></figure>\n<p>后文会提及.join，在这个示例中，它用于拼接数组中的不同元素，效果类似于out[0] + ” + out[1] + ” + out[2] + ” + out[n]。</p>\n<p>不能中断.forEach循环，并且抛出异常也是不明智的选择。幸运的事我们有另外的方式来中断操作。</p>\n<h3 id=\"判断：-some和-every\"><a href=\"#判断：-some和-every\" class=\"headerlink\" title=\"判断：.some和.every\"></a>判断：.some和.every</h3><p>如果你用过.NET中的枚举，这两个方法和.Any(x =&gt; x.IsAwesome) 、 .All(x =&gt; x.IsAwesome)类似。<br>和.forEach的参数类似，需要一个包含value，index，和array三个参数的回调函数，并且也有一个可选的第二个上下文参数。MDN对.some的描述如下：</p>\n<blockquote>\n<p>some将会给数组里的每一个元素执行一遍回调函数，直到回调函数返回true。如果找到目标元素，some立即返回true，否则some返回false。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">max = -Infinity</div><div class=\"line\">satisfied = [10, 12, 10, 8, 5, 23].some(function (value, index, array) &#123;</div><div class=\"line\">    if (value &gt; max) max = value</div><div class=\"line\">    return value &lt; 10</div><div class=\"line\">&#125;)</div><div class=\"line\">console.log(max)</div><div class=\"line\">// &lt;- 12</div><div class=\"line\">satisfied</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<p>注意，当回调函数的value &lt; 10时，中断函数循环。.every的运行原理和.some类似，但回调函数是返回false而不是true。</p>\n<h3 id=\"区分-join和-concat\"><a href=\"#区分-join和-concat\" class=\"headerlink\" title=\"区分.join和.concat\"></a>区分.join和.concat</h3><p>.join和.concat 经常混淆。.join(separator)以separator作为分隔符拼接数组元素，并返回字符串形式，如果没有提供separator，将使用默认的,。.concat会创建一个新数组，作为源数组的浅拷贝。</p>\n<ul>\n<li>.concat常用用法：array.concat(val, val2, val3, valn)</li>\n<li>.concat返回一个新数组</li>\n<li>array.concat()在没有参数的情况下，返回源数组的浅拷贝。</li>\n</ul>\n<p>浅拷贝意味着新数组和原数组保持相同的对象引用，这通常是好事。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123; foo: &apos;bar&apos; &#125;</div><div class=\"line\">var b = [1, 2, 3, a]</div><div class=\"line\">var c = b.concat()</div><div class=\"line\">console.log(b === c)</div><div class=\"line\">// &lt;- false</div><div class=\"line\">b[3] === a &amp;&amp; c[3] === a</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<h3 id=\"栈和队列的实现：-pop-push-shift和-unshift\"><a href=\"#栈和队列的实现：-pop-push-shift和-unshift\" class=\"headerlink\" title=\"栈和队列的实现：.pop, .push, .shift和 .unshift\"></a>栈和队列的实现：.pop, .push, .shift和 .unshift</h3><p>每个人都知道.push可以再数组末尾添加元素，但是你知道可以使用[].push(‘a’, ‘b’, ‘c’, ‘d’, ‘z’)一次性添加多个元素吗？</p>\n<p>.pop 方法是.push 的反操作，它返回被删除的数组末尾元素。如果数组为空，将返回void 0 (undefined),使用.pop和.push可以创建LIFO (last in first out)栈。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function Stack () &#123;</div><div class=\"line\">    this._stack = []</div><div class=\"line\">&#125;</div><div class=\"line\">Stack.prototype.next = function () &#123;</div><div class=\"line\">    return this._stack.pop()</div><div class=\"line\">&#125;</div><div class=\"line\">Stack.prototype.add = function () &#123;</div><div class=\"line\">    return this._stack.push.apply(this._stack, arguments)</div><div class=\"line\">&#125;</div><div class=\"line\">stack = new Stack()</div><div class=\"line\">stack.add(1,2,3)</div><div class=\"line\">stack.next()</div><div class=\"line\">// &lt;- 3</div><div class=\"line\">相反，可以使用.shift和 .unshift创建FIFO (first in first out)队列。</div><div class=\"line\"></div><div class=\"line\">function Queue () &#123;</div><div class=\"line\">    this._queue = []</div><div class=\"line\">&#125;</div><div class=\"line\">Queue.prototype.next = function () &#123;</div><div class=\"line\">    return this._queue.shift()</div><div class=\"line\">&#125;</div><div class=\"line\">Queue.prototype.add = function () &#123;</div><div class=\"line\">    return this._queue.unshift.apply(this._queue, arguments)</div><div class=\"line\">&#125;</div><div class=\"line\">queue = new Queue()</div><div class=\"line\">queue.add(1,2,3)</div><div class=\"line\">queue.next()</div><div class=\"line\">// &lt;- 1</div><div class=\"line\">Using .shift (or .pop) is an easy way to loop through a set of array elements, while draining the array in the process.</div><div class=\"line\">list = [1,2,3,4,5,6,7,8,9,10]</div><div class=\"line\">while (item = list.shift()) &#123;</div><div class=\"line\">    console.log(item)</div><div class=\"line\">&#125;</div><div class=\"line\">list</div><div class=\"line\">// &lt;- []</div></pre></td></tr></table></figure>\n<h3 id=\"模型映射：-map\"><a href=\"#模型映射：-map\" class=\"headerlink\" title=\"模型映射：.map\"></a>模型映射：.map</h3><blockquote>\n<p>.map为数组中的每个元素提供了一个回调方法，并返回有调用结果构成的新数组。回调函数只对已经指定值的数组索引执行；它不会对已删除的或未指定值的元素调用。</p>\n</blockquote>\n<p>Array.prototype.map 和上面提到的.forEach、.some和 .every有相同的参数格式：.map(fn(value, index, array), thisArgument)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">values = [void 0, null, false, &apos;&apos;]</div><div class=\"line\">values[7] = void 0</div><div class=\"line\">result = values.map(function(value, index, array)&#123;</div><div class=\"line\">    console.log(value)</div><div class=\"line\">    return value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [undefined, null, false, &apos;&apos;, undefined × 3, undefined]</div></pre></td></tr></table></figure>\n<p>undefined × 3很好地解释了.map不会对已删除的或未指定值的元素调用，但仍然会被包含在结果数组中。.map在创建或改变数组时非常有用，看下面的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// casting</div><div class=\"line\">[1, &apos;2&apos;, &apos;30&apos;, &apos;9&apos;].map(function (value) &#123;</div><div class=\"line\">    return parseInt(value, 10)</div><div class=\"line\">&#125;)</div><div class=\"line\">// 1, 2, 30, 9</div><div class=\"line\">[97, 119, 101, 115, 111, 109, 101].map(String.fromCharCode).join(&apos;&apos;)</div><div class=\"line\">// &lt;- &apos;awesome&apos;</div><div class=\"line\">// a commonly used pattern is mapping to new objects</div><div class=\"line\">items.map(function (item) &#123;</div><div class=\"line\">    return &#123;</div><div class=\"line\">        id: item.id,</div><div class=\"line\">        name: computeName(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"查询：-filter\"><a href=\"#查询：-filter\" class=\"headerlink\" title=\"查询：.filter\"></a>查询：.filter</h3><blockquote>\n<p>filter对每个数组元素执行一次回调函数，并返回一个由回调函数返回true的元素组成的新数组。回调函数只会对已经指定值的数组项调用。</p>\n</blockquote>\n<p>通常用法：.filter(fn(value, index, array), thisArgument),跟C#中的LINQ表达式和SQL中的where语句类似，.filter只返回在回调函数中返回true值的元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[void 0, null, false, &apos;&apos;, 1].filter(function (value) &#123;</div><div class=\"line\">    return value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [1]</div><div class=\"line\">[void 0, null, false, &apos;&apos;, 1].filter(function (value) &#123;</div><div class=\"line\">    return !value</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [void 0, null, false, &apos;&apos;]</div></pre></td></tr></table></figure>\n<h3 id=\"排序：-sort-compareFunction\"><a href=\"#排序：-sort-compareFunction\" class=\"headerlink\" title=\"排序：.sort(compareFunction)\"></a>排序：.sort(compareFunction)</h3><blockquote>\n<p>如果没有提供compareFunction，元素会被转换成字符串并按照字典排序。例如，”80″排在”9″之前，而不是在其后。</p>\n</blockquote>\n<p>跟大多数排序函数类似，Array.prototype.sort(fn(a,b))需要一个包含两个测试参数的回调函数,其返回值如下：</p>\n<ul>\n<li>a在b之前则返回值小于0</li>\n<li>a和b相等则返回值是0</li>\n<li>a在b之后则返回值小于0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[9,80,3,10,5,6].sort()</div><div class=\"line\">// &lt;- [10, 3, 5, 6, 80, 9]</div><div class=\"line\">[9,80,3,10,5,6].sort(function (a, b) &#123;</div><div class=\"line\">    return a - b</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- [3, 5, 6, 9, 10, 80]</div></pre></td></tr></table></figure>\n<h3 id=\"计算：-reduce和-reduceRight\"><a href=\"#计算：-reduce和-reduceRight\" class=\"headerlink\" title=\"计算：.reduce和.reduceRight\"></a>计算：.reduce和.reduceRight</h3><p>这两个函数比较难理解，.reduce会从左往右遍历数组，而.reduceRight则从右往左遍历数组，二者典型用法：.reduce(callback(previousValue,currentValue, index, array), initialValue)。</p>\n<p>previousValue 是最后一次调用回调函数的返回值，initialValue则是其初始值，currentValue是当前元素值，index是当前元素索引，array是调用.reduce的数组。</p>\n<p>一个典型的用例，使用.reduce的求和函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.sum = function () &#123;</div><div class=\"line\">    return this.reduce(function (partial, value) &#123;</div><div class=\"line\">        return partial + value</div><div class=\"line\">    &#125;, 0)</div><div class=\"line\">&#125;;</div><div class=\"line\">[3,4,5,6,10].sum()</div><div class=\"line\">// &lt;- 28</div></pre></td></tr></table></figure>\n<p>如果想把数组拼接成一个字符串，可以用.join实现。然而，若数组值是对象，.join就不会按照我们的期望返回值了，除非对象有合理的valueOf或toString方法，在这种情况下，可以用.reduce实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function concat (input) &#123;</div><div class=\"line\">    return input.reduce(function (partial, value) &#123;</div><div class=\"line\">        if (partial) &#123;</div><div class=\"line\">            partial += &apos;, &apos;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return partial + value</div><div class=\"line\">    &#125;, &apos;&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">concat([</div><div class=\"line\">    &#123; name: &apos;George&apos; &#125;,</div><div class=\"line\">    &#123; name: &apos;Sam&apos; &#125;,</div><div class=\"line\">    &#123; name: &apos;Pear&apos; &#125;</div><div class=\"line\">])</div><div class=\"line\">// &lt;- &apos;George, Sam, Pear&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"复制：-slice\"><a href=\"#复制：-slice\" class=\"headerlink\" title=\"复制：.slice\"></a>复制：.slice</h3><p>和.concat类似，调用没有参数的.slice()方法会返回源数组的一个浅拷贝。.slice有两个参数：一个是开始位置和一个结束位置。<br>Array.prototype.slice 能被用来将类数组对象转换为真正的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Array.prototype.slice.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</div><div class=\"line\">// &lt;- [&apos;a&apos;, &apos;b&apos;]</div><div class=\"line\">这对.concat不适用，因为它会用数组包裹类数组对象。</div><div class=\"line\"></div><div class=\"line\">Array.prototype.concat.call(&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;)</div><div class=\"line\">// &lt;- [&#123; 0: &apos;a&apos;, 1: &apos;b&apos;, length: 2 &#125;]</div></pre></td></tr></table></figure>\n<p>此外，.slice的另一个通常用法是从一个参数列表中删除一些元素，这可以将类数组对象转换为真正的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function format (text, bold) &#123;</div><div class=\"line\">    if (bold) &#123;</div><div class=\"line\">        text = &apos;&lt;b&gt;&apos; + text + &apos;&lt;/b&gt;&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var values = Array.prototype.slice.call(arguments, 2)</div><div class=\"line\">    values.forEach(function (value) &#123;</div><div class=\"line\">        text = text.replace(&apos;%s&apos;, value)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return text</div><div class=\"line\">&#125;</div><div class=\"line\">format(&apos;some%sthing%s %s&apos;, true, &apos;some&apos;, &apos;other&apos;, &apos;things&apos;)</div></pre></td></tr></table></figure>\n<h3 id=\"强大的-splice\"><a href=\"#强大的-splice\" class=\"headerlink\" title=\"强大的.splice\"></a>强大的.splice</h3><p>.splice 是我最喜欢的原生数组函数，只需要调用一次，就允许你删除元素、插入新的元素，并能同时进行删除、插入操作。需要注意的是，不同于`.concat和.slice,这个函数会改变源数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]</div><div class=\"line\">var spliced = source.splice(3, 4, 4, 5, 6, 7)</div><div class=\"line\">console.log(source)</div><div class=\"line\">// &lt;- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]</div><div class=\"line\">spliced</div><div class=\"line\">// &lt;- [8, 8, 8, 8]</div></pre></td></tr></table></figure>\n<p>正如你看到的，.splice会返回删除的元素。如果你想遍历已经删除的数组时，这会非常方便。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]</div><div class=\"line\">var spliced = source.splice(9)</div><div class=\"line\">spliced.forEach(function (value) &#123;</div><div class=\"line\">    console.log(&apos;removed&apos;, value)</div><div class=\"line\">&#125;)</div><div class=\"line\">// &lt;- removed 10</div><div class=\"line\">// &lt;- removed 11</div><div class=\"line\">// &lt;- removed 12</div><div class=\"line\">// &lt;- removed 13</div><div class=\"line\">console.log(source)</div><div class=\"line\">// &lt;- [1, 2, 3, 8, 8, 8, 8, 8, 9]</div></pre></td></tr></table></figure>\n<h3 id=\"查找：-indexOf\"><a href=\"#查找：-indexOf\" class=\"headerlink\" title=\"查找：.indexOf\"></a>查找：.indexOf</h3><p>利用.indexOf 可以在数组中查找一个元素的位置，没有匹配元素则返回-1。我经常使用.indexOf的情况是当我有比较时，例如：a === ‘a’ || a === ‘b’ || a === ‘c’，或者只有两个比较，此时，可以使用.indexOf：[‘a’, ‘b’, ‘c’].indexOf(a) !== -1。</p>\n<p>注意，如果提供的引用相同，.indexOf也能查找对象。第二个可选参数用于指定开始查找的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = &#123; foo: &apos;bar&apos; &#125;</div><div class=\"line\">var b = [a, 2]</div><div class=\"line\">console.log(b.indexOf(1))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">console.log(b.indexOf(&#123; foo: &apos;bar&apos; &#125;))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">console.log(b.indexOf(a))</div><div class=\"line\">// &lt;- 0</div><div class=\"line\">console.log(b.indexOf(a, 1))</div><div class=\"line\">// &lt;- -1</div><div class=\"line\">b.indexOf(2, 1)</div><div class=\"line\">// &lt;- 1</div></pre></td></tr></table></figure>\n<p>如果你想从后向前搜索，可以使用.lastIndexOf。</p>\n<h3 id=\"操作符：in\"><a href=\"#操作符：in\" class=\"headerlink\" title=\"操作符：in\"></a>操作符：in</h3><p>在面试中新手容易犯的错误是混淆.indexOf和in操作符:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 2, 5]</div><div class=\"line\">1 in a</div><div class=\"line\">// &lt;- true, but because of the 2!</div><div class=\"line\">5 in a</div><div class=\"line\">// &lt;- false</div></pre></td></tr></table></figure>\n<p>问题是in操作符是检索对象的键而非值。当然，这在性能上比.indexOf快得多。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [3, 7, 6]</div><div class=\"line\">1 in a === !!a[1]</div><div class=\"line\">// &lt;- true</div></pre></td></tr></table></figure>\n<h3 id=\"走近-reverse\"><a href=\"#走近-reverse\" class=\"headerlink\" title=\"走近.reverse\"></a>走近.reverse</h3><p>该方法将数组中的元素倒置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var a = [1, 1, 7, 8]</div><div class=\"line\">a.reverse()</div><div class=\"line\">// [8, 7, 1, 1]</div></pre></td></tr></table></figure>\n<p>.reverse 会修改数组本身。</p>\n<p>转载自：<a href=\"http://www.codeceo.com/article/fun-with-javascript-native-array-functions.html\">http://www.codeceo.com</a></p>\n"},{"title":"毁灭程序员的15个障碍","date":"2016-01-01T16:00:00.000Z","_content":"\n会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。\n\n昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。\n\n没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。\n\n下面就是现实世界中的15个编程障碍。\n\n### 编程效率障碍No.1：会议\n\n最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。\n\n虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。\n\n### 编程效率障碍No.2：答复所有的电子邮件\n\n如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。\n\n有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？\n\n### 编程效率障碍No.3：试图衡量生产力\n\n总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。\n\n但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。\n\n衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。\n\n对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。\n\n### 编程效率障碍No.4：妄自尊大的开发人员\n\n对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。\n\n当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。\n\n妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。\n\n### 编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\n\n我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。\n\n每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。\n\n### 编程效率障碍No.6：非程序员经理\n\n总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。\n\n有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。\n\n### 编程效率障碍No.7：程序员经理\n\n虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。\n\n他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。\n\n### 编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\n\n虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。\n\n程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。\n\n尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。\n\n### 编程效率障碍No.9：自私或牛仔程序员\n\n你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。\n\n牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。\n\n很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。\n\n### 编程效率障碍No.10：可怜的文档\n\n写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。\n\n有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。\n\n### 编程效率障碍No.11：成为文档的奴隶\n\n虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。\n\n程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。\n\n### 编程效率障碍No.12：很容易导致分心的环境\n\n有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。\n\n虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。\n\n有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。\n\n虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。\n\n### 编程效率障碍No.13：“文化契合”\n\n你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？\n\n如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。\n\n### 编程效率障碍No.14：死守传统技术\n\n很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。\n\n他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。\n\n当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。\n\n### 编程效率障碍No.15：对最新的渴望\n\n最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。\n\n在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。\n","source":"_posts/毁灭程序员的15个障碍.md","raw":"---\ntitle: 毁灭程序员的15个障碍\ntags: [其它]\ndate: 2016/01/02\n---\n\n会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。\n\n昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。\n\n没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。\n\n下面就是现实世界中的15个编程障碍。\n\n### 编程效率障碍No.1：会议\n\n最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。\n\n虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。\n\n### 编程效率障碍No.2：答复所有的电子邮件\n\n如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。\n\n有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？\n\n### 编程效率障碍No.3：试图衡量生产力\n\n总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。\n\n但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。\n\n衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。\n\n对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。\n\n### 编程效率障碍No.4：妄自尊大的开发人员\n\n对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。\n\n当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。\n\n妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。\n\n### 编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\n\n我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。\n\n每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。\n\n### 编程效率障碍No.6：非程序员经理\n\n总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。\n\n有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。\n\n### 编程效率障碍No.7：程序员经理\n\n虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。\n\n他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。\n\n### 编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\n\n虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。\n\n程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。\n\n尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。\n\n### 编程效率障碍No.9：自私或牛仔程序员\n\n你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。\n\n牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。\n\n很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。\n\n### 编程效率障碍No.10：可怜的文档\n\n写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。\n\n有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。\n\n### 编程效率障碍No.11：成为文档的奴隶\n\n虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。\n\n程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。\n\n### 编程效率障碍No.12：很容易导致分心的环境\n\n有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。\n\n虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。\n\n有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。\n\n虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。\n\n### 编程效率障碍No.13：“文化契合”\n\n你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？\n\n如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。\n\n### 编程效率障碍No.14：死守传统技术\n\n很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。\n\n他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。\n\n当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。\n\n### 编程效率障碍No.15：对最新的渴望\n\n最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。\n\n在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。\n","slug":"毁灭程序员的15个障碍","published":1,"updated":"2016-08-17T06:22:19.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpma004v68dd25721p8k","content":"<p>会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。</p>\n<p>昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。</p>\n<p>没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。</p>\n<p>下面就是现实世界中的15个编程障碍。</p>\n<h3 id=\"编程效率障碍No-1：会议\"><a href=\"#编程效率障碍No-1：会议\" class=\"headerlink\" title=\"编程效率障碍No.1：会议\"></a>编程效率障碍No.1：会议</h3><p>最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。</p>\n<p>虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。</p>\n<h3 id=\"编程效率障碍No-2：答复所有的电子邮件\"><a href=\"#编程效率障碍No-2：答复所有的电子邮件\" class=\"headerlink\" title=\"编程效率障碍No.2：答复所有的电子邮件\"></a>编程效率障碍No.2：答复所有的电子邮件</h3><p>如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。</p>\n<p>有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？</p>\n<h3 id=\"编程效率障碍No-3：试图衡量生产力\"><a href=\"#编程效率障碍No-3：试图衡量生产力\" class=\"headerlink\" title=\"编程效率障碍No.3：试图衡量生产力\"></a>编程效率障碍No.3：试图衡量生产力</h3><p>总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。</p>\n<p>但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。</p>\n<p>衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。</p>\n<p>对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。</p>\n<h3 id=\"编程效率障碍No-4：妄自尊大的开发人员\"><a href=\"#编程效率障碍No-4：妄自尊大的开发人员\" class=\"headerlink\" title=\"编程效率障碍No.4：妄自尊大的开发人员\"></a>编程效率障碍No.4：妄自尊大的开发人员</h3><p>对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。</p>\n<p>当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。</p>\n<p>妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。</p>\n<h3 id=\"编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\"><a href=\"#编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\" class=\"headerlink\" title=\"编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\"></a>编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”</h3><p>我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。</p>\n<p>每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。</p>\n<h3 id=\"编程效率障碍No-6：非程序员经理\"><a href=\"#编程效率障碍No-6：非程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.6：非程序员经理\"></a>编程效率障碍No.6：非程序员经理</h3><p>总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。</p>\n<p>有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。</p>\n<h3 id=\"编程效率障碍No-7：程序员经理\"><a href=\"#编程效率障碍No-7：程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.7：程序员经理\"></a>编程效率障碍No.7：程序员经理</h3><p>虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。</p>\n<p>他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。</p>\n<h3 id=\"编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\"><a href=\"#编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\" class=\"headerlink\" title=\"编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\"></a>编程效率障碍No.8：善于社交的程序员，又名“brogrammer”</h3><p>虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。</p>\n<p>程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。</p>\n<p>尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。</p>\n<h3 id=\"编程效率障碍No-9：自私或牛仔程序员\"><a href=\"#编程效率障碍No-9：自私或牛仔程序员\" class=\"headerlink\" title=\"编程效率障碍No.9：自私或牛仔程序员\"></a>编程效率障碍No.9：自私或牛仔程序员</h3><p>你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。</p>\n<p>牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。</p>\n<p>很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。</p>\n<h3 id=\"编程效率障碍No-10：可怜的文档\"><a href=\"#编程效率障碍No-10：可怜的文档\" class=\"headerlink\" title=\"编程效率障碍No.10：可怜的文档\"></a>编程效率障碍No.10：可怜的文档</h3><p>写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。</p>\n<p>有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。</p>\n<h3 id=\"编程效率障碍No-11：成为文档的奴隶\"><a href=\"#编程效率障碍No-11：成为文档的奴隶\" class=\"headerlink\" title=\"编程效率障碍No.11：成为文档的奴隶\"></a>编程效率障碍No.11：成为文档的奴隶</h3><p>虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。</p>\n<p>程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。</p>\n<h3 id=\"编程效率障碍No-12：很容易导致分心的环境\"><a href=\"#编程效率障碍No-12：很容易导致分心的环境\" class=\"headerlink\" title=\"编程效率障碍No.12：很容易导致分心的环境\"></a>编程效率障碍No.12：很容易导致分心的环境</h3><p>有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。</p>\n<p>虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。</p>\n<p>有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。</p>\n<p>虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。</p>\n<h3 id=\"编程效率障碍No-13：“文化契合”\"><a href=\"#编程效率障碍No-13：“文化契合”\" class=\"headerlink\" title=\"编程效率障碍No.13：“文化契合”\"></a>编程效率障碍No.13：“文化契合”</h3><p>你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？</p>\n<p>如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。</p>\n<h3 id=\"编程效率障碍No-14：死守传统技术\"><a href=\"#编程效率障碍No-14：死守传统技术\" class=\"headerlink\" title=\"编程效率障碍No.14：死守传统技术\"></a>编程效率障碍No.14：死守传统技术</h3><p>很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。</p>\n<p>他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。</p>\n<p>当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。</p>\n<h3 id=\"编程效率障碍No-15：对最新的渴望\"><a href=\"#编程效率障碍No-15：对最新的渴望\" class=\"headerlink\" title=\"编程效率障碍No.15：对最新的渴望\"></a>编程效率障碍No.15：对最新的渴望</h3><p>最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。</p>\n<p>在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。</p>\n","excerpt":"","more":"<p>会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。</p>\n<p>昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。</p>\n<p>没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。</p>\n<p>下面就是现实世界中的15个编程障碍。</p>\n<h3 id=\"编程效率障碍No-1：会议\"><a href=\"#编程效率障碍No-1：会议\" class=\"headerlink\" title=\"编程效率障碍No.1：会议\"></a>编程效率障碍No.1：会议</h3><p>最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。</p>\n<p>虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。</p>\n<h3 id=\"编程效率障碍No-2：答复所有的电子邮件\"><a href=\"#编程效率障碍No-2：答复所有的电子邮件\" class=\"headerlink\" title=\"编程效率障碍No.2：答复所有的电子邮件\"></a>编程效率障碍No.2：答复所有的电子邮件</h3><p>如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。</p>\n<p>有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？</p>\n<h3 id=\"编程效率障碍No-3：试图衡量生产力\"><a href=\"#编程效率障碍No-3：试图衡量生产力\" class=\"headerlink\" title=\"编程效率障碍No.3：试图衡量生产力\"></a>编程效率障碍No.3：试图衡量生产力</h3><p>总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。</p>\n<p>但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。</p>\n<p>衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。</p>\n<p>对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。</p>\n<h3 id=\"编程效率障碍No-4：妄自尊大的开发人员\"><a href=\"#编程效率障碍No-4：妄自尊大的开发人员\" class=\"headerlink\" title=\"编程效率障碍No.4：妄自尊大的开发人员\"></a>编程效率障碍No.4：妄自尊大的开发人员</h3><p>对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。</p>\n<p>当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。</p>\n<p>妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。</p>\n<h3 id=\"编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\"><a href=\"#编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\" class=\"headerlink\" title=\"编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\"></a>编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”</h3><p>我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。</p>\n<p>每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。</p>\n<h3 id=\"编程效率障碍No-6：非程序员经理\"><a href=\"#编程效率障碍No-6：非程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.6：非程序员经理\"></a>编程效率障碍No.6：非程序员经理</h3><p>总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。</p>\n<p>有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。</p>\n<h3 id=\"编程效率障碍No-7：程序员经理\"><a href=\"#编程效率障碍No-7：程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.7：程序员经理\"></a>编程效率障碍No.7：程序员经理</h3><p>虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。</p>\n<p>他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。</p>\n<h3 id=\"编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\"><a href=\"#编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\" class=\"headerlink\" title=\"编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\"></a>编程效率障碍No.8：善于社交的程序员，又名“brogrammer”</h3><p>虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。</p>\n<p>程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。</p>\n<p>尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。</p>\n<h3 id=\"编程效率障碍No-9：自私或牛仔程序员\"><a href=\"#编程效率障碍No-9：自私或牛仔程序员\" class=\"headerlink\" title=\"编程效率障碍No.9：自私或牛仔程序员\"></a>编程效率障碍No.9：自私或牛仔程序员</h3><p>你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。</p>\n<p>牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。</p>\n<p>很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。</p>\n<h3 id=\"编程效率障碍No-10：可怜的文档\"><a href=\"#编程效率障碍No-10：可怜的文档\" class=\"headerlink\" title=\"编程效率障碍No.10：可怜的文档\"></a>编程效率障碍No.10：可怜的文档</h3><p>写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。</p>\n<p>有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。</p>\n<h3 id=\"编程效率障碍No-11：成为文档的奴隶\"><a href=\"#编程效率障碍No-11：成为文档的奴隶\" class=\"headerlink\" title=\"编程效率障碍No.11：成为文档的奴隶\"></a>编程效率障碍No.11：成为文档的奴隶</h3><p>虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。</p>\n<p>程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。</p>\n<h3 id=\"编程效率障碍No-12：很容易导致分心的环境\"><a href=\"#编程效率障碍No-12：很容易导致分心的环境\" class=\"headerlink\" title=\"编程效率障碍No.12：很容易导致分心的环境\"></a>编程效率障碍No.12：很容易导致分心的环境</h3><p>有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。</p>\n<p>虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。</p>\n<p>有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。</p>\n<p>虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。</p>\n<h3 id=\"编程效率障碍No-13：“文化契合”\"><a href=\"#编程效率障碍No-13：“文化契合”\" class=\"headerlink\" title=\"编程效率障碍No.13：“文化契合”\"></a>编程效率障碍No.13：“文化契合”</h3><p>你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？</p>\n<p>如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。</p>\n<h3 id=\"编程效率障碍No-14：死守传统技术\"><a href=\"#编程效率障碍No-14：死守传统技术\" class=\"headerlink\" title=\"编程效率障碍No.14：死守传统技术\"></a>编程效率障碍No.14：死守传统技术</h3><p>很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。</p>\n<p>他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。</p>\n<p>当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。</p>\n<h3 id=\"编程效率障碍No-15：对最新的渴望\"><a href=\"#编程效率障碍No-15：对最新的渴望\" class=\"headerlink\" title=\"编程效率障碍No.15：对最新的渴望\"></a>编程效率障碍No.15：对最新的渴望</h3><p>最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。</p>\n<p>在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。</p>\n"},{"title":"深入理解HTML5标签","date":"2015-02-04T16:00:00.000Z","_content":"\n在之前翻译的《如何写出高效率的HTML》一文中提到了一些关于语义化标签的相关内容，这里搜集整理了一些语义化标签方面的问题和解答，以供大家参考。\n\n语义化这个概念应该说是伴着HTML5应运而生，那么什么是HTML5中所谓的语义化？\n\n简单来说就是：描述内容的含义(meaning)\n\n比如说<p>标签就是段落的意思，在HTML5中所有的标签都有它书面上的语义。而没有语义的标签在HTML中有，在HTML5中就没有了，比如`<font>`标签。而HTML5又为了补充HTML现在的不足而加上了一些新的标签，如`<article>`、`<footer>`、`<header>`等等。而这些标签的分类叫法也从\"块级元素\"与\"行内元素\"变成了“外围内容”与“短语内容”。\n\n在HTML5中最基本的理念就是\"语义\"与\"显示\"分离，HTML5代码中出现的标签都是让开发人员或浏览器一看就知道是干什么用的东西，至于显示效果那是CSS3（Cascading Style Sheet）需要干的事情，所以在HTML5中这个两个好基友终于距离产生了美。\n\n那么语义化以后对HTML文档有什么好处么？\n\n可以提升可访问性与互操作性（兼容性会更好）；\n改进搜索引擎的优化；\n一般来说可以让HTML文件更小；\n让代码更好唯护，与CSS3的关系更和谐。\n\n### 1. HTML5中的`<nav>`、`<article>`、`<sections>`、`<aside>` 、`<footer>`这些标签的理解与用处？\n\n**第一，对这个几个标签的理解：**\n\nHTML5的设计者们可以说是用心良苦呀，他们认真分析HTML4.0中出来的问题，也就是当下最流行的写页面的方式就是\"DIV+CSS\"，我们也不难发现只要用到这个就可以把页面写即简单又漂亮。没有繁琐的标签在里面，需要什么功能就去加`<div>`标签就可以了。\n而`<div>`是什么呢？这个我们下一个问题详细说明。问题的关键在于`<div>`没有任何的语义，也就是说他要干的事是什么全凭开发者说了算。这就造成了严重的开发规范不统一，也就是说页面的导航栏是`<div>`，页面的边栏也是`<div>`，唯一区分它们的就是id。可能一些有心的开发者会把`<div>`的id写的语义明白些，比如：导航栏的id用`<nav>`，边栏的id用`<aside>`。这样的写法对其他的开发者看来还是很好的，因为看到id就可以知道这个`<div>`是干什么用的了。但是还是有一大部分的开发者会这么写，如：导航栏的id用div1，边栏的id用div2，这样的写法对用户来说的可能没有什么区别，因为开发者知道他们都代表什么，而对其他的开发者来说这真的是灭顶之灾，用英文来说就是“reading the fucking code”，而对开发者本身可能时间一长也不知道是什么意思了，但是下次开发的时候他们一定还有人是这么干的；\n\n回到正题，经过上面的介绍大家也许已经知道为什么在HTML5引用上面的标签了吧，就是为了解决开发规范不统一的问题同时也为了增强语义，有人也许会问为什么HTML5为什么那么在意语义？用了上面的标签可以说带来什么好处呢？这个答案用一个非常简单的话来说的那就是：为了统一规范与新功能的出现。\n他们这些标签功能就是代替`<div>`功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；\n\n**第二，这几个标签的语义与用法：**\n\n`<nav>`：标记导航（对应网页中重要的链接群就需要用这个标签）包含在`<nav>`中间的通常是`<ul>`无序列表。当然如果是面包屑链接就需用到`<ol>`有序列表，只要记住这个语义自己灵活发挥就是可以了。\n\n特别提示：\n\nHTML5规范不推荐对有辅助性的页脚链接用`<nav>`；\nHTML5中不允许将`<nav>`嵌套在`<address>`标签中。\n\n`<article>`：文章标记标签（表示的是一个文档、页面、应用或是网站中的一个独立的容器，原则上来讲就是聚合）。\n\n特别提示：\n\n`<article>`这个标签可以嵌套使用，但是他们必须是部分与整体的关系；\n同样不能用在`<address>`标签中；\n他与`<section>`标签容易混淆所以需要注意；\n`<section>`：区块定义标签（表示的是文档或是应用的一个一般的块），他一般是有一组相似的主题的内容，一般会包含一个标题。可以用这个标签来写：文章的章节，标签式对话框中的各种标签页等等类似的功能。这里你会发现他与`<article>`这个标签很像对不对？那么怎么的开发中正确的应用他们呢？\n其实也很简单，你就这样想：如果你的页面中需要一个单独的模块来实现一个单独的功能，也就是高聚合的情况，就用`<article>`，其他的时候都用`<section>`。\n\n`<aside>`：定义侧栏标签（表示一部分内容与页面的主体并不是有很大的关系，但是可以独立存在），用他可以实现：升式引用、侧栏、相关文章的链接框、广告、友情链接等等。\n\n特别提示：\n\n如果使用多个`<aside>`，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性；\n如果是与文章的主要内容有关系的图像需要用`<figure>`标签而。\n`<footer>`：页脚标签（与`<header>`标签对应的标签），用他可以实现的功能有：附录、索引、版权页、许可协议等。\n\n特别提示：\n\n页脚并不一定是要位于所在元素的末尾，不过通常是这样的；\n他不可以放在`<header>`标签中，也不可以相互嵌套，或是在`<address>`元素中。\n\n### 2. HTML5通用的容器`<div>`、`<span>`在HTML5中的生存含义？\n\n`<div>`这个标签在很久很久以前就已经出现在HTML中了，他的全拼是（division）。而在HTML5中的很多的新标签都是他的功能的统一定义而已，因为`<div>`本身没有任何的语义，但是可以对他增加CSS样式，这样就可以很好的为页面做出一些我们理想中的效果。那么在HTML5为什么他还存在呢？那就是因为，在某些时候你会发现你用HTML5中的任何一个标签都不合适你现在需要的语义，所以在这个时候就需要用到`<div>`这个标签了。既然说到`<div>`，那么也要说说与他相对应的`<span>`这个标签，他也是一个没有任何语义的标签，起到的功能与作用是和`<div>`一样的，只不过用法不一样：`<div>`是块级的无语义容器，`<span>`是短语的无语义容器。\n\n`<div>`的用法相信朋友们用的一定比我熟悉，所以这里关于他的用法就不多说了，只是针对在HTML5中对`<div>`的使用我提几点建议：\n如果你觉得用HTML5中的新的标签比用`<div>`合适就一定要用新的标签，因为`<div>`没有任何的语义，这个是HTML5所不倡导的；\n如果效果需要的话可以在HTML5新标签的外面加一个`<div>`标签，这样对HTML中的语义不会产生太大的影响。\n\n### 3. 元素title属性对语义的重要性是什么？\n\ntitle属性这个刚一看会不会想到`<title>`标签？但是不要弄到错了，他们是完全不同的东西。平时在我们开发的时候很少会用到这个属性，首先说一下它是干什么的吧，其实他就是一个具有提示作用的属性，对于屏幕阅读器来说可以为用户朗读文本，所以正确的使用可以提升页面的访问性。\n\n### 4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\n\n在写这个问题的答案之前先说说关于这些标签的理解与用法：\n明确html5的核心思想就是语义，所以不管是什么标签就看表达的意思，而不是看展现的效果；\n关于文本的相关标签可以适当的想象成是语文中的标点符号这样可以方便记意与运用；\n明白上面的两点我们在来说这些新的标签的语义与用法吧：\n`<address>`、`<figure>`、`<time>`这三个标签下一个问题中详细说这里就先不说了；\n`<strong>`、`<em>`这个两个标签在HTML4.0中就已经有了，但是在这里还是要说一下，因为在以前可能很少用到它们因为很少有人去注意语义；\n`<strong>`表示的是重要的文本（默认为粗体显示）——重点是语义上的表达而不是展现的效果这个需要记住哦\n`<em>`表示的是强调的文本（默认为斜体）\n`<mark>`标签是HTML5中的新元素，用来突出显示文本，它的效果就像是用荧光笔给重点的语句做标记一样；\n`<span>`标签这个也是在HTML中就已经有的了，以前的文章也大概的提过一下但是没有详细的说明，下面就详细的说明一下：\n`<span>`没有任何的语义，所以正确的使用方式是需要在没有其它合适有标签的时候才可以用它；\n它是短语级别的标签所以不会另起一行；\n同`<div>`一样在一定的情况下可以添加`<span>`标签利用微格式来增加语义；\n一般的情况下需要用CSS来控制它的显示样式因为它没有样式的展现样式；\n`<wbr>`一个与`<br>`很像的新标签，区别在于它不会强制换行；\n`<ruby>`、`<rp>`、`<rt>`这几个标签就像是语文中的音标一样；\n`<meter>`可以用它做一些测量结果的显示与投票结果的显示（现在的问题是浏览器对它的支持不好）；\n`<progress>`同样的一个进度条的显示，可以用做一些很好的与用户交互的效果，问题是浏览器的兼容现在也不好。\n\n### 5. HTML5中`<address>`、`<figure>`、`<time>`标签的正确用法与注意事项有哪些是你不知道的?\n\n`<address>`这个标签是新的，所以用他的人很少。至于正确的用法当然也很少有人去研究它，下面简单的总结一下：\n`<address>`是用来定义与HTML页面或页面一部分有关的作者、相关人员或组织的联系信息，通常位于页面底部或相关部分内；\n大多数时候，联系信息是作者的电子邮件或是指向联系信息页的链接，这个是正确的，不能用来标记“联系我们”中的办公地点，这是错误的用法；\n提供的信息要准确，不是说电子邮件的地址的正确性，而是说需要对应上提供信息的人，如果一个页面中有好多相关的人，那么提供信息的时候一定要确定信息准确性，不要张冠李戴；\n`<address>`标签中不能有`<h1>~<h6>`、`<article>`、`<address>`、`<aside>`、`<footer>`、`<header>`、`<hgroup>`、`<nav>`、`<section>`等标签；\n\n`<figure>`这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样，在HTML5之前是没有一个专门的标签来做这个事的，之前如果实现这个功能就是用没有语义的`<div>`标签；\n用法提示：\n1. `<figure>`元素可以包含多个内容块，但是只能有一个`<figcaption>`（可以理解成给图表加标题）标签；\n2. 可以用`<h1>~<h6>`来给`<figure>`增加标题；\n3. `<figcaption>`不能单独出现，需要有配套的内容一起出现。\n\n`<time>`可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间。\n\n需要注意的是：\n1. datetime中的时间最好与`<time>`标签中的文本元素日期一样，写法可以不一样；\n2. 如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性；\n3. 不要在`<time>`标签中使用不确切的时间如：“今天中午”、“上周末”；\n4. 如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题；\n5. <time>标签不能在嵌套另一个`<time>`标签；\n6. datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss\n\n其实作为新的标签，它们的用法还有很多，这里只是说了一些最基础的东西，不过我认为用会上面所有的东西就可以说是入门了。\n\n### 6. 关于`<em>`、`<strong>`与`<b>`、`<i>`的前世今生？\n\n各位开发过HTML的朋友都知道`<em>`与`<i>`、`<strong>`与`<b>`它们的展现形式一样的，一个是斜体一个是粗体，那么它们在HTML5中是怎么平相处的呢？下面我们来重点讲一下`<b>`、`<i>`的前世今生：\n\n在很早以前，互联网那时还没有一个叫作CSS的东西出现的时候，为了区分文本中的重点与特殊的含意的文字`<b>`、`<i>`这对兄弟出现了。在它们的帮助下，页面的文字与用户之间的交互得到了提升。\n然而好景不长，在互联网飞速发展的情况下，很快出现一个叫CSS的东西，它的责任就是用来控制页面的表现形式的，当然也包括`<b>`、`<i>`所表现的形式，所以在HTML4.0与XHTML1中就有开发人员建议废弃`<b>`、`<i>`，取面代之的就是`<strong>`、`<em>`+CSS，因为他们有语义性可以更好的与用户交互。可是问题并没有就此结束，因为在开发的时候在一些情况下发现用`<strong>`、`<em>`总是不能很的好的表示语义，为此，在HTML5中`<b>`、`<i>`又以修改后的面貌展现给我们了，所以在HTML5中又重新启用了`<b>`、`<i>`这对兄弟。\n\n那么具体在HTML5中什么时候用它们呢？\n\n`<b>`标签表示出于实用的目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其它的语义和语气，用于：关键词，产品名，操作指令等等；\n`<i>`标签表示一块不同于其它文字的文字，具有不同的语态或语气，用于：分类名称，技术术语，外语中的惯用词等等。\n\n### 7. 如何使用ARIA提升可访问性？\n\n语义真的有那么重要么？通过语义又怎么提高访问性与增加SEO的搜索的呢？因为现在一些SEO与浏览器或是屏幕阅读器（一个给残障人士用的文章阅读器）都在根据HTML5的新标准做一些新的功能，他们会跟具新的语义直接与自身的功能相对应。如果网页的开发者也是这么做的，那么你的网站的应用性会大大的增加。\n上面又强调了一下语义的重要性，下面告诉大家一个更好的增强语义的小窍门，一定要好好看哦，因为这个小窍门朋友们不一定知道的：\n概念介绍：WAI-ARIA(Web Accessibility Initiative's Accessible Rich Internet Applications)无障碍网页倡议之可访问的富互联网应用，简称ARIA，他就是一种技术规范。他在HTML提供的语义的基础之上，他会使用属性来填补一些语义上的空白。\nARIA的用法：\n正确运用ARIA中的地标角色：\nrole =\"banner\"(横幅)\nrole=\"navigation\"(导航)\nrole=\"main\"(主体)\nrole=\"complementary\"(补充性内容)\nrole=\"contentinfo\"(内容信息)\n\n> 小提示：地标角色只是ARIA规范中的一种，如果你感兴趣可以去官网阅读一下（地址：http://www.w3.org/TR/wai-aria/ ）\n> 将屏幕阅读器测试列入你的日常开发中；（因为他是最能直接反映出你的网站语义写的好不好的东西）；\n> 正确的为标签制定id与类（语义性一定要明显）；\n> 正确使用class类以及他提供的微格式；\n\n关于class的微格式，因为有很多人都知道或是认为class的属性是只能为一组元素应用CSS样式，其实并不是这样的，其实他还可以在不引用额外的标签下来增强语义，这就是微格式，微格式是使用约定的class名称来标示一块HTML从而来增强与应用程序、智能搜索与搜索机器人的交互。关于微格式的使用可以看看这个网址：http://microformats.org\n\n### 8. 你想到过网页文件的命名会影响你网站的体验么？\n\n这个一听第一感觉就是不靠谱，一个文件的名字还会影响到网站的体验？\n正确的答案确实是：是的！\n如：文件名： Html_First_Blog.htm 与 html-first-blog.html\n这个两个文件名不管是在用户的体验上与搜索引擎上都第二个完胜第一个。是不是有人会问为什么 ？？\n下面我就说一下有如下几点是需要我们注意的：\n\n文件名需要用小写字母：\n应用场景就是最简单的输入地址吧，你认为下面哪种写起来更方便，这个请自己体会吧：\nhttp://192.168.0.1/TestHtml/The_First/Html5.html\nhttp://192.168.0.1/testhtml/the-first/html5.html\n用短横线分隔单词：\n大家一定会认为，用\"_\"挺好，其实这是做C开发时候的写法，也可以说是习惯，但是在网站中“-”是搜索引擎更喜欢的style；\n使用标准的扩展名：\n现在用好多的网站都是用.htm的扩展名，这个浏览器也不会报错，但是标准的扩展名就是.html的所以大家以后写的时候就不要省时间少写一个字母“l”了。\n\n记住以上几点才是正确的写网页文件的命名方法哦，不要把写其它语言的方法放进来。\n","source":"_posts/深入理解HTML5标签.md","raw":"---\ntitle: 深入理解HTML5标签\ntags: [html,html5]\ndate: 2015/02/05\n---\n\n在之前翻译的《如何写出高效率的HTML》一文中提到了一些关于语义化标签的相关内容，这里搜集整理了一些语义化标签方面的问题和解答，以供大家参考。\n\n语义化这个概念应该说是伴着HTML5应运而生，那么什么是HTML5中所谓的语义化？\n\n简单来说就是：描述内容的含义(meaning)\n\n比如说<p>标签就是段落的意思，在HTML5中所有的标签都有它书面上的语义。而没有语义的标签在HTML中有，在HTML5中就没有了，比如`<font>`标签。而HTML5又为了补充HTML现在的不足而加上了一些新的标签，如`<article>`、`<footer>`、`<header>`等等。而这些标签的分类叫法也从\"块级元素\"与\"行内元素\"变成了“外围内容”与“短语内容”。\n\n在HTML5中最基本的理念就是\"语义\"与\"显示\"分离，HTML5代码中出现的标签都是让开发人员或浏览器一看就知道是干什么用的东西，至于显示效果那是CSS3（Cascading Style Sheet）需要干的事情，所以在HTML5中这个两个好基友终于距离产生了美。\n\n那么语义化以后对HTML文档有什么好处么？\n\n可以提升可访问性与互操作性（兼容性会更好）；\n改进搜索引擎的优化；\n一般来说可以让HTML文件更小；\n让代码更好唯护，与CSS3的关系更和谐。\n\n### 1. HTML5中的`<nav>`、`<article>`、`<sections>`、`<aside>` 、`<footer>`这些标签的理解与用处？\n\n**第一，对这个几个标签的理解：**\n\nHTML5的设计者们可以说是用心良苦呀，他们认真分析HTML4.0中出来的问题，也就是当下最流行的写页面的方式就是\"DIV+CSS\"，我们也不难发现只要用到这个就可以把页面写即简单又漂亮。没有繁琐的标签在里面，需要什么功能就去加`<div>`标签就可以了。\n而`<div>`是什么呢？这个我们下一个问题详细说明。问题的关键在于`<div>`没有任何的语义，也就是说他要干的事是什么全凭开发者说了算。这就造成了严重的开发规范不统一，也就是说页面的导航栏是`<div>`，页面的边栏也是`<div>`，唯一区分它们的就是id。可能一些有心的开发者会把`<div>`的id写的语义明白些，比如：导航栏的id用`<nav>`，边栏的id用`<aside>`。这样的写法对其他的开发者看来还是很好的，因为看到id就可以知道这个`<div>`是干什么用的了。但是还是有一大部分的开发者会这么写，如：导航栏的id用div1，边栏的id用div2，这样的写法对用户来说的可能没有什么区别，因为开发者知道他们都代表什么，而对其他的开发者来说这真的是灭顶之灾，用英文来说就是“reading the fucking code”，而对开发者本身可能时间一长也不知道是什么意思了，但是下次开发的时候他们一定还有人是这么干的；\n\n回到正题，经过上面的介绍大家也许已经知道为什么在HTML5引用上面的标签了吧，就是为了解决开发规范不统一的问题同时也为了增强语义，有人也许会问为什么HTML5为什么那么在意语义？用了上面的标签可以说带来什么好处呢？这个答案用一个非常简单的话来说的那就是：为了统一规范与新功能的出现。\n他们这些标签功能就是代替`<div>`功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；\n\n**第二，这几个标签的语义与用法：**\n\n`<nav>`：标记导航（对应网页中重要的链接群就需要用这个标签）包含在`<nav>`中间的通常是`<ul>`无序列表。当然如果是面包屑链接就需用到`<ol>`有序列表，只要记住这个语义自己灵活发挥就是可以了。\n\n特别提示：\n\nHTML5规范不推荐对有辅助性的页脚链接用`<nav>`；\nHTML5中不允许将`<nav>`嵌套在`<address>`标签中。\n\n`<article>`：文章标记标签（表示的是一个文档、页面、应用或是网站中的一个独立的容器，原则上来讲就是聚合）。\n\n特别提示：\n\n`<article>`这个标签可以嵌套使用，但是他们必须是部分与整体的关系；\n同样不能用在`<address>`标签中；\n他与`<section>`标签容易混淆所以需要注意；\n`<section>`：区块定义标签（表示的是文档或是应用的一个一般的块），他一般是有一组相似的主题的内容，一般会包含一个标题。可以用这个标签来写：文章的章节，标签式对话框中的各种标签页等等类似的功能。这里你会发现他与`<article>`这个标签很像对不对？那么怎么的开发中正确的应用他们呢？\n其实也很简单，你就这样想：如果你的页面中需要一个单独的模块来实现一个单独的功能，也就是高聚合的情况，就用`<article>`，其他的时候都用`<section>`。\n\n`<aside>`：定义侧栏标签（表示一部分内容与页面的主体并不是有很大的关系，但是可以独立存在），用他可以实现：升式引用、侧栏、相关文章的链接框、广告、友情链接等等。\n\n特别提示：\n\n如果使用多个`<aside>`，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性；\n如果是与文章的主要内容有关系的图像需要用`<figure>`标签而。\n`<footer>`：页脚标签（与`<header>`标签对应的标签），用他可以实现的功能有：附录、索引、版权页、许可协议等。\n\n特别提示：\n\n页脚并不一定是要位于所在元素的末尾，不过通常是这样的；\n他不可以放在`<header>`标签中，也不可以相互嵌套，或是在`<address>`元素中。\n\n### 2. HTML5通用的容器`<div>`、`<span>`在HTML5中的生存含义？\n\n`<div>`这个标签在很久很久以前就已经出现在HTML中了，他的全拼是（division）。而在HTML5中的很多的新标签都是他的功能的统一定义而已，因为`<div>`本身没有任何的语义，但是可以对他增加CSS样式，这样就可以很好的为页面做出一些我们理想中的效果。那么在HTML5为什么他还存在呢？那就是因为，在某些时候你会发现你用HTML5中的任何一个标签都不合适你现在需要的语义，所以在这个时候就需要用到`<div>`这个标签了。既然说到`<div>`，那么也要说说与他相对应的`<span>`这个标签，他也是一个没有任何语义的标签，起到的功能与作用是和`<div>`一样的，只不过用法不一样：`<div>`是块级的无语义容器，`<span>`是短语的无语义容器。\n\n`<div>`的用法相信朋友们用的一定比我熟悉，所以这里关于他的用法就不多说了，只是针对在HTML5中对`<div>`的使用我提几点建议：\n如果你觉得用HTML5中的新的标签比用`<div>`合适就一定要用新的标签，因为`<div>`没有任何的语义，这个是HTML5所不倡导的；\n如果效果需要的话可以在HTML5新标签的外面加一个`<div>`标签，这样对HTML中的语义不会产生太大的影响。\n\n### 3. 元素title属性对语义的重要性是什么？\n\ntitle属性这个刚一看会不会想到`<title>`标签？但是不要弄到错了，他们是完全不同的东西。平时在我们开发的时候很少会用到这个属性，首先说一下它是干什么的吧，其实他就是一个具有提示作用的属性，对于屏幕阅读器来说可以为用户朗读文本，所以正确的使用可以提升页面的访问性。\n\n### 4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\n\n在写这个问题的答案之前先说说关于这些标签的理解与用法：\n明确html5的核心思想就是语义，所以不管是什么标签就看表达的意思，而不是看展现的效果；\n关于文本的相关标签可以适当的想象成是语文中的标点符号这样可以方便记意与运用；\n明白上面的两点我们在来说这些新的标签的语义与用法吧：\n`<address>`、`<figure>`、`<time>`这三个标签下一个问题中详细说这里就先不说了；\n`<strong>`、`<em>`这个两个标签在HTML4.0中就已经有了，但是在这里还是要说一下，因为在以前可能很少用到它们因为很少有人去注意语义；\n`<strong>`表示的是重要的文本（默认为粗体显示）——重点是语义上的表达而不是展现的效果这个需要记住哦\n`<em>`表示的是强调的文本（默认为斜体）\n`<mark>`标签是HTML5中的新元素，用来突出显示文本，它的效果就像是用荧光笔给重点的语句做标记一样；\n`<span>`标签这个也是在HTML中就已经有的了，以前的文章也大概的提过一下但是没有详细的说明，下面就详细的说明一下：\n`<span>`没有任何的语义，所以正确的使用方式是需要在没有其它合适有标签的时候才可以用它；\n它是短语级别的标签所以不会另起一行；\n同`<div>`一样在一定的情况下可以添加`<span>`标签利用微格式来增加语义；\n一般的情况下需要用CSS来控制它的显示样式因为它没有样式的展现样式；\n`<wbr>`一个与`<br>`很像的新标签，区别在于它不会强制换行；\n`<ruby>`、`<rp>`、`<rt>`这几个标签就像是语文中的音标一样；\n`<meter>`可以用它做一些测量结果的显示与投票结果的显示（现在的问题是浏览器对它的支持不好）；\n`<progress>`同样的一个进度条的显示，可以用做一些很好的与用户交互的效果，问题是浏览器的兼容现在也不好。\n\n### 5. HTML5中`<address>`、`<figure>`、`<time>`标签的正确用法与注意事项有哪些是你不知道的?\n\n`<address>`这个标签是新的，所以用他的人很少。至于正确的用法当然也很少有人去研究它，下面简单的总结一下：\n`<address>`是用来定义与HTML页面或页面一部分有关的作者、相关人员或组织的联系信息，通常位于页面底部或相关部分内；\n大多数时候，联系信息是作者的电子邮件或是指向联系信息页的链接，这个是正确的，不能用来标记“联系我们”中的办公地点，这是错误的用法；\n提供的信息要准确，不是说电子邮件的地址的正确性，而是说需要对应上提供信息的人，如果一个页面中有好多相关的人，那么提供信息的时候一定要确定信息准确性，不要张冠李戴；\n`<address>`标签中不能有`<h1>~<h6>`、`<article>`、`<address>`、`<aside>`、`<footer>`、`<header>`、`<hgroup>`、`<nav>`、`<section>`等标签；\n\n`<figure>`这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样，在HTML5之前是没有一个专门的标签来做这个事的，之前如果实现这个功能就是用没有语义的`<div>`标签；\n用法提示：\n1. `<figure>`元素可以包含多个内容块，但是只能有一个`<figcaption>`（可以理解成给图表加标题）标签；\n2. 可以用`<h1>~<h6>`来给`<figure>`增加标题；\n3. `<figcaption>`不能单独出现，需要有配套的内容一起出现。\n\n`<time>`可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间。\n\n需要注意的是：\n1. datetime中的时间最好与`<time>`标签中的文本元素日期一样，写法可以不一样；\n2. 如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性；\n3. 不要在`<time>`标签中使用不确切的时间如：“今天中午”、“上周末”；\n4. 如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题；\n5. <time>标签不能在嵌套另一个`<time>`标签；\n6. datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss\n\n其实作为新的标签，它们的用法还有很多，这里只是说了一些最基础的东西，不过我认为用会上面所有的东西就可以说是入门了。\n\n### 6. 关于`<em>`、`<strong>`与`<b>`、`<i>`的前世今生？\n\n各位开发过HTML的朋友都知道`<em>`与`<i>`、`<strong>`与`<b>`它们的展现形式一样的，一个是斜体一个是粗体，那么它们在HTML5中是怎么平相处的呢？下面我们来重点讲一下`<b>`、`<i>`的前世今生：\n\n在很早以前，互联网那时还没有一个叫作CSS的东西出现的时候，为了区分文本中的重点与特殊的含意的文字`<b>`、`<i>`这对兄弟出现了。在它们的帮助下，页面的文字与用户之间的交互得到了提升。\n然而好景不长，在互联网飞速发展的情况下，很快出现一个叫CSS的东西，它的责任就是用来控制页面的表现形式的，当然也包括`<b>`、`<i>`所表现的形式，所以在HTML4.0与XHTML1中就有开发人员建议废弃`<b>`、`<i>`，取面代之的就是`<strong>`、`<em>`+CSS，因为他们有语义性可以更好的与用户交互。可是问题并没有就此结束，因为在开发的时候在一些情况下发现用`<strong>`、`<em>`总是不能很的好的表示语义，为此，在HTML5中`<b>`、`<i>`又以修改后的面貌展现给我们了，所以在HTML5中又重新启用了`<b>`、`<i>`这对兄弟。\n\n那么具体在HTML5中什么时候用它们呢？\n\n`<b>`标签表示出于实用的目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其它的语义和语气，用于：关键词，产品名，操作指令等等；\n`<i>`标签表示一块不同于其它文字的文字，具有不同的语态或语气，用于：分类名称，技术术语，外语中的惯用词等等。\n\n### 7. 如何使用ARIA提升可访问性？\n\n语义真的有那么重要么？通过语义又怎么提高访问性与增加SEO的搜索的呢？因为现在一些SEO与浏览器或是屏幕阅读器（一个给残障人士用的文章阅读器）都在根据HTML5的新标准做一些新的功能，他们会跟具新的语义直接与自身的功能相对应。如果网页的开发者也是这么做的，那么你的网站的应用性会大大的增加。\n上面又强调了一下语义的重要性，下面告诉大家一个更好的增强语义的小窍门，一定要好好看哦，因为这个小窍门朋友们不一定知道的：\n概念介绍：WAI-ARIA(Web Accessibility Initiative's Accessible Rich Internet Applications)无障碍网页倡议之可访问的富互联网应用，简称ARIA，他就是一种技术规范。他在HTML提供的语义的基础之上，他会使用属性来填补一些语义上的空白。\nARIA的用法：\n正确运用ARIA中的地标角色：\nrole =\"banner\"(横幅)\nrole=\"navigation\"(导航)\nrole=\"main\"(主体)\nrole=\"complementary\"(补充性内容)\nrole=\"contentinfo\"(内容信息)\n\n> 小提示：地标角色只是ARIA规范中的一种，如果你感兴趣可以去官网阅读一下（地址：http://www.w3.org/TR/wai-aria/ ）\n> 将屏幕阅读器测试列入你的日常开发中；（因为他是最能直接反映出你的网站语义写的好不好的东西）；\n> 正确的为标签制定id与类（语义性一定要明显）；\n> 正确使用class类以及他提供的微格式；\n\n关于class的微格式，因为有很多人都知道或是认为class的属性是只能为一组元素应用CSS样式，其实并不是这样的，其实他还可以在不引用额外的标签下来增强语义，这就是微格式，微格式是使用约定的class名称来标示一块HTML从而来增强与应用程序、智能搜索与搜索机器人的交互。关于微格式的使用可以看看这个网址：http://microformats.org\n\n### 8. 你想到过网页文件的命名会影响你网站的体验么？\n\n这个一听第一感觉就是不靠谱，一个文件的名字还会影响到网站的体验？\n正确的答案确实是：是的！\n如：文件名： Html_First_Blog.htm 与 html-first-blog.html\n这个两个文件名不管是在用户的体验上与搜索引擎上都第二个完胜第一个。是不是有人会问为什么 ？？\n下面我就说一下有如下几点是需要我们注意的：\n\n文件名需要用小写字母：\n应用场景就是最简单的输入地址吧，你认为下面哪种写起来更方便，这个请自己体会吧：\nhttp://192.168.0.1/TestHtml/The_First/Html5.html\nhttp://192.168.0.1/testhtml/the-first/html5.html\n用短横线分隔单词：\n大家一定会认为，用\"_\"挺好，其实这是做C开发时候的写法，也可以说是习惯，但是在网站中“-”是搜索引擎更喜欢的style；\n使用标准的扩展名：\n现在用好多的网站都是用.htm的扩展名，这个浏览器也不会报错，但是标准的扩展名就是.html的所以大家以后写的时候就不要省时间少写一个字母“l”了。\n\n记住以上几点才是正确的写网页文件的命名方法哦，不要把写其它语言的方法放进来。\n","slug":"深入理解HTML5标签","published":1,"updated":"2016-08-17T06:22:19.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmc004x68dd8tyujsw5","content":"<p>在之前翻译的《如何写出高效率的HTML》一文中提到了一些关于语义化标签的相关内容，这里搜集整理了一些语义化标签方面的问题和解答，以供大家参考。</p>\n<p>语义化这个概念应该说是伴着HTML5应运而生，那么什么是HTML5中所谓的语义化？</p>\n<p>简单来说就是：描述内容的含义(meaning)</p>\n<p>比如说</p><p>标签就是段落的意思，在HTML5中所有的标签都有它书面上的语义。而没有语义的标签在HTML中有，在HTML5中就没有了，比如<code>&lt;font&gt;</code>标签。而HTML5又为了补充HTML现在的不足而加上了一些新的标签，如<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code>等等。而这些标签的分类叫法也从”块级元素”与”行内元素”变成了“外围内容”与“短语内容”。</p>\n<p>在HTML5中最基本的理念就是”语义”与”显示”分离，HTML5代码中出现的标签都是让开发人员或浏览器一看就知道是干什么用的东西，至于显示效果那是CSS3（Cascading Style Sheet）需要干的事情，所以在HTML5中这个两个好基友终于距离产生了美。</p>\n<p>那么语义化以后对HTML文档有什么好处么？</p>\n<p>可以提升可访问性与互操作性（兼容性会更好）；<br>改进搜索引擎的优化；<br>一般来说可以让HTML文件更小；<br>让代码更好唯护，与CSS3的关系更和谐。</p>\n<h3 id=\"1-HTML5中的-lt-nav-gt-、-lt-article-gt-、-lt-sections-gt-、-lt-aside-gt-、-lt-footer-gt-这些标签的理解与用处？\"><a href=\"#1-HTML5中的-lt-nav-gt-、-lt-article-gt-、-lt-sections-gt-、-lt-aside-gt-、-lt-footer-gt-这些标签的理解与用处？\" class=\"headerlink\" title=\"1. HTML5中的&lt;nav&gt;、&lt;article&gt;、&lt;sections&gt;、&lt;aside&gt; 、&lt;footer&gt;这些标签的理解与用处？\"></a>1. HTML5中的<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;sections&gt;</code>、<code>&lt;aside&gt;</code> 、<code>&lt;footer&gt;</code>这些标签的理解与用处？</h3><p><strong>第一，对这个几个标签的理解：</strong></p>\n<p>HTML5的设计者们可以说是用心良苦呀，他们认真分析HTML4.0中出来的问题，也就是当下最流行的写页面的方式就是”DIV+CSS”，我们也不难发现只要用到这个就可以把页面写即简单又漂亮。没有繁琐的标签在里面，需要什么功能就去加<code>&lt;div&gt;</code>标签就可以了。<br>而<code>&lt;div&gt;</code>是什么呢？这个我们下一个问题详细说明。问题的关键在于<code>&lt;div&gt;</code>没有任何的语义，也就是说他要干的事是什么全凭开发者说了算。这就造成了严重的开发规范不统一，也就是说页面的导航栏是<code>&lt;div&gt;</code>，页面的边栏也是<code>&lt;div&gt;</code>，唯一区分它们的就是id。可能一些有心的开发者会把<code>&lt;div&gt;</code>的id写的语义明白些，比如：导航栏的id用<code>&lt;nav&gt;</code>，边栏的id用<code>&lt;aside&gt;</code>。这样的写法对其他的开发者看来还是很好的，因为看到id就可以知道这个<code>&lt;div&gt;</code>是干什么用的了。但是还是有一大部分的开发者会这么写，如：导航栏的id用div1，边栏的id用div2，这样的写法对用户来说的可能没有什么区别，因为开发者知道他们都代表什么，而对其他的开发者来说这真的是灭顶之灾，用英文来说就是“reading the fucking code”，而对开发者本身可能时间一长也不知道是什么意思了，但是下次开发的时候他们一定还有人是这么干的；</p>\n<p>回到正题，经过上面的介绍大家也许已经知道为什么在HTML5引用上面的标签了吧，就是为了解决开发规范不统一的问题同时也为了增强语义，有人也许会问为什么HTML5为什么那么在意语义？用了上面的标签可以说带来什么好处呢？这个答案用一个非常简单的话来说的那就是：为了统一规范与新功能的出现。<br>他们这些标签功能就是代替<code>&lt;div&gt;</code>功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；</p>\n<p><strong>第二，这几个标签的语义与用法：</strong></p>\n<p><code>&lt;nav&gt;</code>：标记导航（对应网页中重要的链接群就需要用这个标签）包含在<code>&lt;nav&gt;</code>中间的通常是<code>&lt;ul&gt;</code>无序列表。当然如果是面包屑链接就需用到<code>&lt;ol&gt;</code>有序列表，只要记住这个语义自己灵活发挥就是可以了。</p>\n<p>特别提示：</p>\n<p>HTML5规范不推荐对有辅助性的页脚链接用<code>&lt;nav&gt;</code>；<br>HTML5中不允许将<code>&lt;nav&gt;</code>嵌套在<code>&lt;address&gt;</code>标签中。</p>\n<p><code>&lt;article&gt;</code>：文章标记标签（表示的是一个文档、页面、应用或是网站中的一个独立的容器，原则上来讲就是聚合）。</p>\n<p>特别提示：</p>\n<p><code>&lt;article&gt;</code>这个标签可以嵌套使用，但是他们必须是部分与整体的关系；<br>同样不能用在<code>&lt;address&gt;</code>标签中；<br>他与<code>&lt;section&gt;</code>标签容易混淆所以需要注意；<br><code>&lt;section&gt;</code>：区块定义标签（表示的是文档或是应用的一个一般的块），他一般是有一组相似的主题的内容，一般会包含一个标题。可以用这个标签来写：文章的章节，标签式对话框中的各种标签页等等类似的功能。这里你会发现他与<code>&lt;article&gt;</code>这个标签很像对不对？那么怎么的开发中正确的应用他们呢？<br>其实也很简单，你就这样想：如果你的页面中需要一个单独的模块来实现一个单独的功能，也就是高聚合的情况，就用<code>&lt;article&gt;</code>，其他的时候都用<code>&lt;section&gt;</code>。</p>\n<p><code>&lt;aside&gt;</code>：定义侧栏标签（表示一部分内容与页面的主体并不是有很大的关系，但是可以独立存在），用他可以实现：升式引用、侧栏、相关文章的链接框、广告、友情链接等等。</p>\n<p>特别提示：</p>\n<p>如果使用多个<code>&lt;aside&gt;</code>，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性；<br>如果是与文章的主要内容有关系的图像需要用<code>&lt;figure&gt;</code>标签而。<br><code>&lt;footer&gt;</code>：页脚标签（与<code>&lt;header&gt;</code>标签对应的标签），用他可以实现的功能有：附录、索引、版权页、许可协议等。</p>\n<p>特别提示：</p>\n<p>页脚并不一定是要位于所在元素的末尾，不过通常是这样的；<br>他不可以放在<code>&lt;header&gt;</code>标签中，也不可以相互嵌套，或是在<code>&lt;address&gt;</code>元素中。</p>\n<h3 id=\"2-HTML5通用的容器-lt-div-gt-、-lt-span-gt-在HTML5中的生存含义？\"><a href=\"#2-HTML5通用的容器-lt-div-gt-、-lt-span-gt-在HTML5中的生存含义？\" class=\"headerlink\" title=\"2. HTML5通用的容器&lt;div&gt;、&lt;span&gt;在HTML5中的生存含义？\"></a>2. HTML5通用的容器<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>在HTML5中的生存含义？</h3><p><code>&lt;div&gt;</code>这个标签在很久很久以前就已经出现在HTML中了，他的全拼是（division）。而在HTML5中的很多的新标签都是他的功能的统一定义而已，因为<code>&lt;div&gt;</code>本身没有任何的语义，但是可以对他增加CSS样式，这样就可以很好的为页面做出一些我们理想中的效果。那么在HTML5为什么他还存在呢？那就是因为，在某些时候你会发现你用HTML5中的任何一个标签都不合适你现在需要的语义，所以在这个时候就需要用到<code>&lt;div&gt;</code>这个标签了。既然说到<code>&lt;div&gt;</code>，那么也要说说与他相对应的<code>&lt;span&gt;</code>这个标签，他也是一个没有任何语义的标签，起到的功能与作用是和<code>&lt;div&gt;</code>一样的，只不过用法不一样：<code>&lt;div&gt;</code>是块级的无语义容器，<code>&lt;span&gt;</code>是短语的无语义容器。</p>\n<p><code>&lt;div&gt;</code>的用法相信朋友们用的一定比我熟悉，所以这里关于他的用法就不多说了，只是针对在HTML5中对<code>&lt;div&gt;</code>的使用我提几点建议：<br>如果你觉得用HTML5中的新的标签比用<code>&lt;div&gt;</code>合适就一定要用新的标签，因为<code>&lt;div&gt;</code>没有任何的语义，这个是HTML5所不倡导的；<br>如果效果需要的话可以在HTML5新标签的外面加一个<code>&lt;div&gt;</code>标签，这样对HTML中的语义不会产生太大的影响。</p>\n<h3 id=\"3-元素title属性对语义的重要性是什么？\"><a href=\"#3-元素title属性对语义的重要性是什么？\" class=\"headerlink\" title=\"3. 元素title属性对语义的重要性是什么？\"></a>3. 元素title属性对语义的重要性是什么？</h3><p>title属性这个刚一看会不会想到<code>&lt;title&gt;</code>标签？但是不要弄到错了，他们是完全不同的东西。平时在我们开发的时候很少会用到这个属性，首先说一下它是干什么的吧，其实他就是一个具有提示作用的属性，对于屏幕阅读器来说可以为用户朗读文本，所以正确的使用可以提升页面的访问性。</p>\n<h3 id=\"4-HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\"><a href=\"#4-HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\" class=\"headerlink\" title=\"4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\"></a>4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？</h3><p>在写这个问题的答案之前先说说关于这些标签的理解与用法：<br>明确html5的核心思想就是语义，所以不管是什么标签就看表达的意思，而不是看展现的效果；<br>关于文本的相关标签可以适当的想象成是语文中的标点符号这样可以方便记意与运用；<br>明白上面的两点我们在来说这些新的标签的语义与用法吧：<br><code>&lt;address&gt;</code>、<code>&lt;figure&gt;</code>、<code>&lt;time&gt;</code>这三个标签下一个问题中详细说这里就先不说了；<br><code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>这个两个标签在HTML4.0中就已经有了，但是在这里还是要说一下，因为在以前可能很少用到它们因为很少有人去注意语义；<br><code>&lt;strong&gt;</code>表示的是重要的文本（默认为粗体显示）——重点是语义上的表达而不是展现的效果这个需要记住哦<br><code>&lt;em&gt;</code>表示的是强调的文本（默认为斜体）<br><code>&lt;mark&gt;</code>标签是HTML5中的新元素，用来突出显示文本，它的效果就像是用荧光笔给重点的语句做标记一样；<br><code>&lt;span&gt;</code>标签这个也是在HTML中就已经有的了，以前的文章也大概的提过一下但是没有详细的说明，下面就详细的说明一下：<br><code>&lt;span&gt;</code>没有任何的语义，所以正确的使用方式是需要在没有其它合适有标签的时候才可以用它；<br>它是短语级别的标签所以不会另起一行；<br>同<code>&lt;div&gt;</code>一样在一定的情况下可以添加<code>&lt;span&gt;</code>标签利用微格式来增加语义；<br>一般的情况下需要用CSS来控制它的显示样式因为它没有样式的展现样式；<br><code>&lt;wbr&gt;</code>一个与<code>&lt;br&gt;</code>很像的新标签，区别在于它不会强制换行；<br><code>&lt;ruby&gt;</code>、<code>&lt;rp&gt;</code>、<code>&lt;rt&gt;</code>这几个标签就像是语文中的音标一样；<br><code>&lt;meter&gt;</code>可以用它做一些测量结果的显示与投票结果的显示（现在的问题是浏览器对它的支持不好）；<br><code>&lt;progress&gt;</code>同样的一个进度条的显示，可以用做一些很好的与用户交互的效果，问题是浏览器的兼容现在也不好。</p>\n<h3 id=\"5-HTML5中-lt-address-gt-、-lt-figure-gt-、-lt-time-gt-标签的正确用法与注意事项有哪些是你不知道的\"><a href=\"#5-HTML5中-lt-address-gt-、-lt-figure-gt-、-lt-time-gt-标签的正确用法与注意事项有哪些是你不知道的\" class=\"headerlink\" title=\"5. HTML5中&lt;address&gt;、&lt;figure&gt;、&lt;time&gt;标签的正确用法与注意事项有哪些是你不知道的?\"></a>5. HTML5中<code>&lt;address&gt;</code>、<code>&lt;figure&gt;</code>、<code>&lt;time&gt;</code>标签的正确用法与注意事项有哪些是你不知道的?</h3><p><code>&lt;address&gt;</code>这个标签是新的，所以用他的人很少。至于正确的用法当然也很少有人去研究它，下面简单的总结一下：<br><code>&lt;address&gt;</code>是用来定义与HTML页面或页面一部分有关的作者、相关人员或组织的联系信息，通常位于页面底部或相关部分内；<br>大多数时候，联系信息是作者的电子邮件或是指向联系信息页的链接，这个是正确的，不能用来标记“联系我们”中的办公地点，这是错误的用法；<br>提供的信息要准确，不是说电子邮件的地址的正确性，而是说需要对应上提供信息的人，如果一个页面中有好多相关的人，那么提供信息的时候一定要确定信息准确性，不要张冠李戴；<br><code>&lt;address&gt;</code>标签中不能有<code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;address&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;hgroup&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>等标签；</p>\n<p><code>&lt;figure&gt;</code>这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样，在HTML5之前是没有一个专门的标签来做这个事的，之前如果实现这个功能就是用没有语义的<code>&lt;div&gt;</code>标签；<br>用法提示：</p>\n<ol>\n<li><code>&lt;figure&gt;</code>元素可以包含多个内容块，但是只能有一个<code>&lt;figcaption&gt;</code>（可以理解成给图表加标题）标签；</li>\n<li>可以用<code>&lt;h1&gt;~&lt;h6&gt;</code>来给<code>&lt;figure&gt;</code>增加标题；</li>\n<li><code>&lt;figcaption&gt;</code>不能单独出现，需要有配套的内容一起出现。</li>\n</ol>\n<p><code>&lt;time&gt;</code>可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间。</p>\n<p>需要注意的是：</p>\n<ol>\n<li>datetime中的时间最好与<code>&lt;time&gt;</code>标签中的文本元素日期一样，写法可以不一样；</li>\n<li>如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性；</li>\n<li>不要在<code>&lt;time&gt;</code>标签中使用不确切的时间如：“今天中午”、“上周末”；</li>\n<li>如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题；</li>\n<li><time>标签不能在嵌套另一个<code>&lt;time&gt;</code>标签；</time></li>\n<li>datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss</li>\n</ol>\n<p>其实作为新的标签，它们的用法还有很多，这里只是说了一些最基础的东西，不过我认为用会上面所有的东西就可以说是入门了。</p>\n<h3 id=\"6-关于-lt-em-gt-、-lt-strong-gt-与-lt-b-gt-、-lt-i-gt-的前世今生？\"><a href=\"#6-关于-lt-em-gt-、-lt-strong-gt-与-lt-b-gt-、-lt-i-gt-的前世今生？\" class=\"headerlink\" title=\"6. 关于&lt;em&gt;、&lt;strong&gt;与&lt;b&gt;、&lt;i&gt;的前世今生？\"></a>6. 关于<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>与<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>的前世今生？</h3><p>各位开发过HTML的朋友都知道<code>&lt;em&gt;</code>与<code>&lt;i&gt;</code>、<code>&lt;strong&gt;</code>与<code>&lt;b&gt;</code>它们的展现形式一样的，一个是斜体一个是粗体，那么它们在HTML5中是怎么平相处的呢？下面我们来重点讲一下<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>的前世今生：</p>\n<p>在很早以前，互联网那时还没有一个叫作CSS的东西出现的时候，为了区分文本中的重点与特殊的含意的文字<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>这对兄弟出现了。在它们的帮助下，页面的文字与用户之间的交互得到了提升。<br>然而好景不长，在互联网飞速发展的情况下，很快出现一个叫CSS的东西，它的责任就是用来控制页面的表现形式的，当然也包括<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>所表现的形式，所以在HTML4.0与XHTML1中就有开发人员建议废弃<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>，取面代之的就是<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>+CSS，因为他们有语义性可以更好的与用户交互。可是问题并没有就此结束，因为在开发的时候在一些情况下发现用<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>总是不能很的好的表示语义，为此，在HTML5中<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>又以修改后的面貌展现给我们了，所以在HTML5中又重新启用了<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>这对兄弟。</p>\n<p>那么具体在HTML5中什么时候用它们呢？</p>\n<p><code>&lt;b&gt;</code>标签表示出于实用的目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其它的语义和语气，用于：关键词，产品名，操作指令等等；<br><code>&lt;i&gt;</code>标签表示一块不同于其它文字的文字，具有不同的语态或语气，用于：分类名称，技术术语，外语中的惯用词等等。</p>\n<h3 id=\"7-如何使用ARIA提升可访问性？\"><a href=\"#7-如何使用ARIA提升可访问性？\" class=\"headerlink\" title=\"7. 如何使用ARIA提升可访问性？\"></a>7. 如何使用ARIA提升可访问性？</h3><p>语义真的有那么重要么？通过语义又怎么提高访问性与增加SEO的搜索的呢？因为现在一些SEO与浏览器或是屏幕阅读器（一个给残障人士用的文章阅读器）都在根据HTML5的新标准做一些新的功能，他们会跟具新的语义直接与自身的功能相对应。如果网页的开发者也是这么做的，那么你的网站的应用性会大大的增加。<br>上面又强调了一下语义的重要性，下面告诉大家一个更好的增强语义的小窍门，一定要好好看哦，因为这个小窍门朋友们不一定知道的：<br>概念介绍：WAI-ARIA(Web Accessibility Initiative’s Accessible Rich Internet Applications)无障碍网页倡议之可访问的富互联网应用，简称ARIA，他就是一种技术规范。他在HTML提供的语义的基础之上，他会使用属性来填补一些语义上的空白。<br>ARIA的用法：<br>正确运用ARIA中的地标角色：<br>role =”banner”(横幅)<br>role=”navigation”(导航)<br>role=”main”(主体)<br>role=”complementary”(补充性内容)<br>role=”contentinfo”(内容信息)</p>\n<blockquote>\n<p>小提示：地标角色只是ARIA规范中的一种，如果你感兴趣可以去官网阅读一下（地址：<a href=\"http://www.w3.org/TR/wai-aria/\" target=\"_blank\" rel=\"external\">http://www.w3.org/TR/wai-aria/</a> ）<br>将屏幕阅读器测试列入你的日常开发中；（因为他是最能直接反映出你的网站语义写的好不好的东西）；<br>正确的为标签制定id与类（语义性一定要明显）；<br>正确使用class类以及他提供的微格式；</p>\n</blockquote>\n<p>关于class的微格式，因为有很多人都知道或是认为class的属性是只能为一组元素应用CSS样式，其实并不是这样的，其实他还可以在不引用额外的标签下来增强语义，这就是微格式，微格式是使用约定的class名称来标示一块HTML从而来增强与应用程序、智能搜索与搜索机器人的交互。关于微格式的使用可以看看这个网址：<a href=\"http://microformats.org\" target=\"_blank\" rel=\"external\">http://microformats.org</a></p>\n<h3 id=\"8-你想到过网页文件的命名会影响你网站的体验么？\"><a href=\"#8-你想到过网页文件的命名会影响你网站的体验么？\" class=\"headerlink\" title=\"8. 你想到过网页文件的命名会影响你网站的体验么？\"></a>8. 你想到过网页文件的命名会影响你网站的体验么？</h3><p>这个一听第一感觉就是不靠谱，一个文件的名字还会影响到网站的体验？<br>正确的答案确实是：是的！<br>如：文件名： Html_First_Blog.htm 与 html-first-blog.html<br>这个两个文件名不管是在用户的体验上与搜索引擎上都第二个完胜第一个。是不是有人会问为什么 ？？<br>下面我就说一下有如下几点是需要我们注意的：</p>\n<p>文件名需要用小写字母：<br>应用场景就是最简单的输入地址吧，你认为下面哪种写起来更方便，这个请自己体会吧：<br><a href=\"http://192.168.0.1/TestHtml/The_First/Html5.html\" target=\"_blank\" rel=\"external\">http://192.168.0.1/TestHtml/The_First/Html5.html</a><br><a href=\"http://192.168.0.1/testhtml/the-first/html5.html\" target=\"_blank\" rel=\"external\">http://192.168.0.1/testhtml/the-first/html5.html</a><br>用短横线分隔单词：<br>大家一定会认为，用”_”挺好，其实这是做C开发时候的写法，也可以说是习惯，但是在网站中“-”是搜索引擎更喜欢的style；<br>使用标准的扩展名：<br>现在用好多的网站都是用.htm的扩展名，这个浏览器也不会报错，但是标准的扩展名就是.html的所以大家以后写的时候就不要省时间少写一个字母“l”了。</p>\n<p>记住以上几点才是正确的写网页文件的命名方法哦，不要把写其它语言的方法放进来。</p>\n","excerpt":"","more":"<p>在之前翻译的《如何写出高效率的HTML》一文中提到了一些关于语义化标签的相关内容，这里搜集整理了一些语义化标签方面的问题和解答，以供大家参考。</p>\n<p>语义化这个概念应该说是伴着HTML5应运而生，那么什么是HTML5中所谓的语义化？</p>\n<p>简单来说就是：描述内容的含义(meaning)</p>\n<p>比如说<p>标签就是段落的意思，在HTML5中所有的标签都有它书面上的语义。而没有语义的标签在HTML中有，在HTML5中就没有了，比如<code>&lt;font&gt;</code>标签。而HTML5又为了补充HTML现在的不足而加上了一些新的标签，如<code>&lt;article&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code>等等。而这些标签的分类叫法也从”块级元素”与”行内元素”变成了“外围内容”与“短语内容”。</p>\n<p>在HTML5中最基本的理念就是”语义”与”显示”分离，HTML5代码中出现的标签都是让开发人员或浏览器一看就知道是干什么用的东西，至于显示效果那是CSS3（Cascading Style Sheet）需要干的事情，所以在HTML5中这个两个好基友终于距离产生了美。</p>\n<p>那么语义化以后对HTML文档有什么好处么？</p>\n<p>可以提升可访问性与互操作性（兼容性会更好）；<br>改进搜索引擎的优化；<br>一般来说可以让HTML文件更小；<br>让代码更好唯护，与CSS3的关系更和谐。</p>\n<h3 id=\"1-HTML5中的-lt-nav-gt-、-lt-article-gt-、-lt-sections-gt-、-lt-aside-gt-、-lt-footer-gt-这些标签的理解与用处？\"><a href=\"#1-HTML5中的-lt-nav-gt-、-lt-article-gt-、-lt-sections-gt-、-lt-aside-gt-、-lt-footer-gt-这些标签的理解与用处？\" class=\"headerlink\" title=\"1. HTML5中的&lt;nav&gt;、&lt;article&gt;、&lt;sections&gt;、&lt;aside&gt; 、&lt;footer&gt;这些标签的理解与用处？\"></a>1. HTML5中的<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;sections&gt;</code>、<code>&lt;aside&gt;</code> 、<code>&lt;footer&gt;</code>这些标签的理解与用处？</h3><p><strong>第一，对这个几个标签的理解：</strong></p>\n<p>HTML5的设计者们可以说是用心良苦呀，他们认真分析HTML4.0中出来的问题，也就是当下最流行的写页面的方式就是”DIV+CSS”，我们也不难发现只要用到这个就可以把页面写即简单又漂亮。没有繁琐的标签在里面，需要什么功能就去加<code>&lt;div&gt;</code>标签就可以了。<br>而<code>&lt;div&gt;</code>是什么呢？这个我们下一个问题详细说明。问题的关键在于<code>&lt;div&gt;</code>没有任何的语义，也就是说他要干的事是什么全凭开发者说了算。这就造成了严重的开发规范不统一，也就是说页面的导航栏是<code>&lt;div&gt;</code>，页面的边栏也是<code>&lt;div&gt;</code>，唯一区分它们的就是id。可能一些有心的开发者会把<code>&lt;div&gt;</code>的id写的语义明白些，比如：导航栏的id用<code>&lt;nav&gt;</code>，边栏的id用<code>&lt;aside&gt;</code>。这样的写法对其他的开发者看来还是很好的，因为看到id就可以知道这个<code>&lt;div&gt;</code>是干什么用的了。但是还是有一大部分的开发者会这么写，如：导航栏的id用div1，边栏的id用div2，这样的写法对用户来说的可能没有什么区别，因为开发者知道他们都代表什么，而对其他的开发者来说这真的是灭顶之灾，用英文来说就是“reading the fucking code”，而对开发者本身可能时间一长也不知道是什么意思了，但是下次开发的时候他们一定还有人是这么干的；</p>\n<p>回到正题，经过上面的介绍大家也许已经知道为什么在HTML5引用上面的标签了吧，就是为了解决开发规范不统一的问题同时也为了增强语义，有人也许会问为什么HTML5为什么那么在意语义？用了上面的标签可以说带来什么好处呢？这个答案用一个非常简单的话来说的那就是：为了统一规范与新功能的出现。<br>他们这些标签功能就是代替<code>&lt;div&gt;</code>功能中的一部分，他们没有任何的默认样式，除了会让文本另起一行外；</p>\n<p><strong>第二，这几个标签的语义与用法：</strong></p>\n<p><code>&lt;nav&gt;</code>：标记导航（对应网页中重要的链接群就需要用这个标签）包含在<code>&lt;nav&gt;</code>中间的通常是<code>&lt;ul&gt;</code>无序列表。当然如果是面包屑链接就需用到<code>&lt;ol&gt;</code>有序列表，只要记住这个语义自己灵活发挥就是可以了。</p>\n<p>特别提示：</p>\n<p>HTML5规范不推荐对有辅助性的页脚链接用<code>&lt;nav&gt;</code>；<br>HTML5中不允许将<code>&lt;nav&gt;</code>嵌套在<code>&lt;address&gt;</code>标签中。</p>\n<p><code>&lt;article&gt;</code>：文章标记标签（表示的是一个文档、页面、应用或是网站中的一个独立的容器，原则上来讲就是聚合）。</p>\n<p>特别提示：</p>\n<p><code>&lt;article&gt;</code>这个标签可以嵌套使用，但是他们必须是部分与整体的关系；<br>同样不能用在<code>&lt;address&gt;</code>标签中；<br>他与<code>&lt;section&gt;</code>标签容易混淆所以需要注意；<br><code>&lt;section&gt;</code>：区块定义标签（表示的是文档或是应用的一个一般的块），他一般是有一组相似的主题的内容，一般会包含一个标题。可以用这个标签来写：文章的章节，标签式对话框中的各种标签页等等类似的功能。这里你会发现他与<code>&lt;article&gt;</code>这个标签很像对不对？那么怎么的开发中正确的应用他们呢？<br>其实也很简单，你就这样想：如果你的页面中需要一个单独的模块来实现一个单独的功能，也就是高聚合的情况，就用<code>&lt;article&gt;</code>，其他的时候都用<code>&lt;section&gt;</code>。</p>\n<p><code>&lt;aside&gt;</code>：定义侧栏标签（表示一部分内容与页面的主体并不是有很大的关系，但是可以独立存在），用他可以实现：升式引用、侧栏、相关文章的链接框、广告、友情链接等等。</p>\n<p>特别提示：</p>\n<p>如果使用多个<code>&lt;aside&gt;</code>，标签应该在主要内容的后面，这样有利于SEO的搜索与提升可访问性；<br>如果是与文章的主要内容有关系的图像需要用<code>&lt;figure&gt;</code>标签而。<br><code>&lt;footer&gt;</code>：页脚标签（与<code>&lt;header&gt;</code>标签对应的标签），用他可以实现的功能有：附录、索引、版权页、许可协议等。</p>\n<p>特别提示：</p>\n<p>页脚并不一定是要位于所在元素的末尾，不过通常是这样的；<br>他不可以放在<code>&lt;header&gt;</code>标签中，也不可以相互嵌套，或是在<code>&lt;address&gt;</code>元素中。</p>\n<h3 id=\"2-HTML5通用的容器-lt-div-gt-、-lt-span-gt-在HTML5中的生存含义？\"><a href=\"#2-HTML5通用的容器-lt-div-gt-、-lt-span-gt-在HTML5中的生存含义？\" class=\"headerlink\" title=\"2. HTML5通用的容器&lt;div&gt;、&lt;span&gt;在HTML5中的生存含义？\"></a>2. HTML5通用的容器<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>在HTML5中的生存含义？</h3><p><code>&lt;div&gt;</code>这个标签在很久很久以前就已经出现在HTML中了，他的全拼是（division）。而在HTML5中的很多的新标签都是他的功能的统一定义而已，因为<code>&lt;div&gt;</code>本身没有任何的语义，但是可以对他增加CSS样式，这样就可以很好的为页面做出一些我们理想中的效果。那么在HTML5为什么他还存在呢？那就是因为，在某些时候你会发现你用HTML5中的任何一个标签都不合适你现在需要的语义，所以在这个时候就需要用到<code>&lt;div&gt;</code>这个标签了。既然说到<code>&lt;div&gt;</code>，那么也要说说与他相对应的<code>&lt;span&gt;</code>这个标签，他也是一个没有任何语义的标签，起到的功能与作用是和<code>&lt;div&gt;</code>一样的，只不过用法不一样：<code>&lt;div&gt;</code>是块级的无语义容器，<code>&lt;span&gt;</code>是短语的无语义容器。</p>\n<p><code>&lt;div&gt;</code>的用法相信朋友们用的一定比我熟悉，所以这里关于他的用法就不多说了，只是针对在HTML5中对<code>&lt;div&gt;</code>的使用我提几点建议：<br>如果你觉得用HTML5中的新的标签比用<code>&lt;div&gt;</code>合适就一定要用新的标签，因为<code>&lt;div&gt;</code>没有任何的语义，这个是HTML5所不倡导的；<br>如果效果需要的话可以在HTML5新标签的外面加一个<code>&lt;div&gt;</code>标签，这样对HTML中的语义不会产生太大的影响。</p>\n<h3 id=\"3-元素title属性对语义的重要性是什么？\"><a href=\"#3-元素title属性对语义的重要性是什么？\" class=\"headerlink\" title=\"3. 元素title属性对语义的重要性是什么？\"></a>3. 元素title属性对语义的重要性是什么？</h3><p>title属性这个刚一看会不会想到<code>&lt;title&gt;</code>标签？但是不要弄到错了，他们是完全不同的东西。平时在我们开发的时候很少会用到这个属性，首先说一下它是干什么的吧，其实他就是一个具有提示作用的属性，对于屏幕阅读器来说可以为用户朗读文本，所以正确的使用可以提升页面的访问性。</p>\n<h3 id=\"4-HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\"><a href=\"#4-HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\" class=\"headerlink\" title=\"4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？\"></a>4. HTML5中的新标签对于写文本启到一些重要影响的标签有哪些？</h3><p>在写这个问题的答案之前先说说关于这些标签的理解与用法：<br>明确html5的核心思想就是语义，所以不管是什么标签就看表达的意思，而不是看展现的效果；<br>关于文本的相关标签可以适当的想象成是语文中的标点符号这样可以方便记意与运用；<br>明白上面的两点我们在来说这些新的标签的语义与用法吧：<br><code>&lt;address&gt;</code>、<code>&lt;figure&gt;</code>、<code>&lt;time&gt;</code>这三个标签下一个问题中详细说这里就先不说了；<br><code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>这个两个标签在HTML4.0中就已经有了，但是在这里还是要说一下，因为在以前可能很少用到它们因为很少有人去注意语义；<br><code>&lt;strong&gt;</code>表示的是重要的文本（默认为粗体显示）——重点是语义上的表达而不是展现的效果这个需要记住哦<br><code>&lt;em&gt;</code>表示的是强调的文本（默认为斜体）<br><code>&lt;mark&gt;</code>标签是HTML5中的新元素，用来突出显示文本，它的效果就像是用荧光笔给重点的语句做标记一样；<br><code>&lt;span&gt;</code>标签这个也是在HTML中就已经有的了，以前的文章也大概的提过一下但是没有详细的说明，下面就详细的说明一下：<br><code>&lt;span&gt;</code>没有任何的语义，所以正确的使用方式是需要在没有其它合适有标签的时候才可以用它；<br>它是短语级别的标签所以不会另起一行；<br>同<code>&lt;div&gt;</code>一样在一定的情况下可以添加<code>&lt;span&gt;</code>标签利用微格式来增加语义；<br>一般的情况下需要用CSS来控制它的显示样式因为它没有样式的展现样式；<br><code>&lt;wbr&gt;</code>一个与<code>&lt;br&gt;</code>很像的新标签，区别在于它不会强制换行；<br><code>&lt;ruby&gt;</code>、<code>&lt;rp&gt;</code>、<code>&lt;rt&gt;</code>这几个标签就像是语文中的音标一样；<br><code>&lt;meter&gt;</code>可以用它做一些测量结果的显示与投票结果的显示（现在的问题是浏览器对它的支持不好）；<br><code>&lt;progress&gt;</code>同样的一个进度条的显示，可以用做一些很好的与用户交互的效果，问题是浏览器的兼容现在也不好。</p>\n<h3 id=\"5-HTML5中-lt-address-gt-、-lt-figure-gt-、-lt-time-gt-标签的正确用法与注意事项有哪些是你不知道的\"><a href=\"#5-HTML5中-lt-address-gt-、-lt-figure-gt-、-lt-time-gt-标签的正确用法与注意事项有哪些是你不知道的\" class=\"headerlink\" title=\"5. HTML5中&lt;address&gt;、&lt;figure&gt;、&lt;time&gt;标签的正确用法与注意事项有哪些是你不知道的?\"></a>5. HTML5中<code>&lt;address&gt;</code>、<code>&lt;figure&gt;</code>、<code>&lt;time&gt;</code>标签的正确用法与注意事项有哪些是你不知道的?</h3><p><code>&lt;address&gt;</code>这个标签是新的，所以用他的人很少。至于正确的用法当然也很少有人去研究它，下面简单的总结一下：<br><code>&lt;address&gt;</code>是用来定义与HTML页面或页面一部分有关的作者、相关人员或组织的联系信息，通常位于页面底部或相关部分内；<br>大多数时候，联系信息是作者的电子邮件或是指向联系信息页的链接，这个是正确的，不能用来标记“联系我们”中的办公地点，这是错误的用法；<br>提供的信息要准确，不是说电子邮件的地址的正确性，而是说需要对应上提供信息的人，如果一个页面中有好多相关的人，那么提供信息的时候一定要确定信息准确性，不要张冠李戴；<br><code>&lt;address&gt;</code>标签中不能有<code>&lt;h1&gt;~&lt;h6&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;address&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;hgroup&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;section&gt;</code>等标签；</p>\n<p><code>&lt;figure&gt;</code>这个元素是用来引入图表、图形、照片等，对应的场景就是像是杂志中的图片一样，在HTML5之前是没有一个专门的标签来做这个事的，之前如果实现这个功能就是用没有语义的<code>&lt;div&gt;</code>标签；<br>用法提示：</p>\n<ol>\n<li><code>&lt;figure&gt;</code>元素可以包含多个内容块，但是只能有一个<code>&lt;figcaption&gt;</code>（可以理解成给图表加标题）标签；</li>\n<li>可以用<code>&lt;h1&gt;~&lt;h6&gt;</code>来给<code>&lt;figure&gt;</code>增加标题；</li>\n<li><code>&lt;figcaption&gt;</code>不能单独出现，需要有配套的内容一起出现。</li>\n</ol>\n<p><code>&lt;time&gt;</code>可以通过这个标签标记一个具体的时间或日期，应用场景通常就是一篇文章的发表时间。</p>\n<p>需要注意的是：</p>\n<ol>\n<li>datetime中的时间最好与<code>&lt;time&gt;</code>标签中的文本元素日期一样，写法可以不一样；</li>\n<li>如果这个时间是代表整个文章或是页面的时间需要添加pubdate属性；</li>\n<li>不要在<code>&lt;time&gt;</code>标签中使用不确切的时间如：“今天中午”、“上周末”；</li>\n<li>如果 使用pubdate属性需要注意的是要在同一个父标签下面不要出现张冠李戴的问题；</li>\n<li><time>标签不能在嵌套另一个<code>&lt;time&gt;</code>标签；</li>\n<li>datatime中的时间格式需要是标准的机器可能的时间 如:YYYY-MM-DDThh:mm:ss</li>\n</ol>\n<p>其实作为新的标签，它们的用法还有很多，这里只是说了一些最基础的东西，不过我认为用会上面所有的东西就可以说是入门了。</p>\n<h3 id=\"6-关于-lt-em-gt-、-lt-strong-gt-与-lt-b-gt-、-lt-i-gt-的前世今生？\"><a href=\"#6-关于-lt-em-gt-、-lt-strong-gt-与-lt-b-gt-、-lt-i-gt-的前世今生？\" class=\"headerlink\" title=\"6. 关于&lt;em&gt;、&lt;strong&gt;与&lt;b&gt;、&lt;i&gt;的前世今生？\"></a>6. 关于<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>与<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>的前世今生？</h3><p>各位开发过HTML的朋友都知道<code>&lt;em&gt;</code>与<code>&lt;i&gt;</code>、<code>&lt;strong&gt;</code>与<code>&lt;b&gt;</code>它们的展现形式一样的，一个是斜体一个是粗体，那么它们在HTML5中是怎么平相处的呢？下面我们来重点讲一下<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>的前世今生：</p>\n<p>在很早以前，互联网那时还没有一个叫作CSS的东西出现的时候，为了区分文本中的重点与特殊的含意的文字<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>这对兄弟出现了。在它们的帮助下，页面的文字与用户之间的交互得到了提升。<br>然而好景不长，在互联网飞速发展的情况下，很快出现一个叫CSS的东西，它的责任就是用来控制页面的表现形式的，当然也包括<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>所表现的形式，所以在HTML4.0与XHTML1中就有开发人员建议废弃<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>，取面代之的就是<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>+CSS，因为他们有语义性可以更好的与用户交互。可是问题并没有就此结束，因为在开发的时候在一些情况下发现用<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>总是不能很的好的表示语义，为此，在HTML5中<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>又以修改后的面貌展现给我们了，所以在HTML5中又重新启用了<code>&lt;b&gt;</code>、<code>&lt;i&gt;</code>这对兄弟。</p>\n<p>那么具体在HTML5中什么时候用它们呢？</p>\n<p><code>&lt;b&gt;</code>标签表示出于实用的目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其它的语义和语气，用于：关键词，产品名，操作指令等等；<br><code>&lt;i&gt;</code>标签表示一块不同于其它文字的文字，具有不同的语态或语气，用于：分类名称，技术术语，外语中的惯用词等等。</p>\n<h3 id=\"7-如何使用ARIA提升可访问性？\"><a href=\"#7-如何使用ARIA提升可访问性？\" class=\"headerlink\" title=\"7. 如何使用ARIA提升可访问性？\"></a>7. 如何使用ARIA提升可访问性？</h3><p>语义真的有那么重要么？通过语义又怎么提高访问性与增加SEO的搜索的呢？因为现在一些SEO与浏览器或是屏幕阅读器（一个给残障人士用的文章阅读器）都在根据HTML5的新标准做一些新的功能，他们会跟具新的语义直接与自身的功能相对应。如果网页的开发者也是这么做的，那么你的网站的应用性会大大的增加。<br>上面又强调了一下语义的重要性，下面告诉大家一个更好的增强语义的小窍门，一定要好好看哦，因为这个小窍门朋友们不一定知道的：<br>概念介绍：WAI-ARIA(Web Accessibility Initiative’s Accessible Rich Internet Applications)无障碍网页倡议之可访问的富互联网应用，简称ARIA，他就是一种技术规范。他在HTML提供的语义的基础之上，他会使用属性来填补一些语义上的空白。<br>ARIA的用法：<br>正确运用ARIA中的地标角色：<br>role =”banner”(横幅)<br>role=”navigation”(导航)<br>role=”main”(主体)<br>role=”complementary”(补充性内容)<br>role=”contentinfo”(内容信息)</p>\n<blockquote>\n<p>小提示：地标角色只是ARIA规范中的一种，如果你感兴趣可以去官网阅读一下（地址：<a href=\"http://www.w3.org/TR/wai-aria/\">http://www.w3.org/TR/wai-aria/</a> ）<br>将屏幕阅读器测试列入你的日常开发中；（因为他是最能直接反映出你的网站语义写的好不好的东西）；<br>正确的为标签制定id与类（语义性一定要明显）；<br>正确使用class类以及他提供的微格式；</p>\n</blockquote>\n<p>关于class的微格式，因为有很多人都知道或是认为class的属性是只能为一组元素应用CSS样式，其实并不是这样的，其实他还可以在不引用额外的标签下来增强语义，这就是微格式，微格式是使用约定的class名称来标示一块HTML从而来增强与应用程序、智能搜索与搜索机器人的交互。关于微格式的使用可以看看这个网址：<a href=\"http://microformats.org\">http://microformats.org</a></p>\n<h3 id=\"8-你想到过网页文件的命名会影响你网站的体验么？\"><a href=\"#8-你想到过网页文件的命名会影响你网站的体验么？\" class=\"headerlink\" title=\"8. 你想到过网页文件的命名会影响你网站的体验么？\"></a>8. 你想到过网页文件的命名会影响你网站的体验么？</h3><p>这个一听第一感觉就是不靠谱，一个文件的名字还会影响到网站的体验？<br>正确的答案确实是：是的！<br>如：文件名： Html_First_Blog.htm 与 html-first-blog.html<br>这个两个文件名不管是在用户的体验上与搜索引擎上都第二个完胜第一个。是不是有人会问为什么 ？？<br>下面我就说一下有如下几点是需要我们注意的：</p>\n<p>文件名需要用小写字母：<br>应用场景就是最简单的输入地址吧，你认为下面哪种写起来更方便，这个请自己体会吧：<br><a href=\"http://192.168.0.1/TestHtml/The_First/Html5.html\">http://192.168.0.1/TestHtml/The_First/Html5.html</a><br><a href=\"http://192.168.0.1/testhtml/the-first/html5.html\">http://192.168.0.1/testhtml/the-first/html5.html</a><br>用短横线分隔单词：<br>大家一定会认为，用”_”挺好，其实这是做C开发时候的写法，也可以说是习惯，但是在网站中“-”是搜索引擎更喜欢的style；<br>使用标准的扩展名：<br>现在用好多的网站都是用.htm的扩展名，这个浏览器也不会报错，但是标准的扩展名就是.html的所以大家以后写的时候就不要省时间少写一个字母“l”了。</p>\n<p>记住以上几点才是正确的写网页文件的命名方法哦，不要把写其它语言的方法放进来。</p>\n"},{"title":"用数组建立一个简单的循环","date":"2016-08-10T08:24:24.000Z","_content":"\n有时我们需要不停的循环数组的元素，就像一组旋转的图片，或者音乐的播放列表。这里告诉你如何使一个数组拥有循环的能力：\n\n```javascript\nvar aList = ['A','B','C','D','E'];\n\nfunction make_looper( arr ){\n\n    arr.loop_idx = 0;\n\n    // 返回当前的元素\n    arr.current = function(){\n\n      if( this.loop_idx < 0 ){// 第一次检查\n        this.loop_idx = this.length - 1;// 更新 loop_idx\n      }\n\n      if( this.loop_idx >= this.length ){// 第二次检查\n        this.loop_idx = 0;// 更新 loop_idx\n      }\n\n      return arr[ this.loop_idx ];//返回元素\n    };\n    \n    // 增加 loop_idx 然后返回新的当前元素\n    arr.next = function(){\n      this.loop_idx++;\n      return this.current();\n    };\n    // 减少 loop_idx 然后返回新的当前元素\n    arr.prev = function(){\n      this.loop_idx--;\n      return this.current();\n    };\n}\n\nmake_looper( aList);\n\naList.current();// -> A\naList.next();// -> B\naList.next();// -> C\naList.next();// -> D\naList.next();// -> E\naList.next();// -> A\naList.pop() ;// -> E\naList.prev();// -> D\naList.prev();// -> C\naList.prev();// -> B\naList.prev();// -> A\naList.prev();// -> D\n```\n\n使用 `%` ( 取模 ) 操作符更优雅。取模返回除法的余数 ( `2 % 5 = 1` and `5 % 5 = 0`)：\n\n```javascript\nvar aList = ['A','B','C','D','E'];\n\n\nfunction make_looper( arr ){\n\n    arr.loop_idx = 0;\n\n    // return current item\n    arr.current = function(){\n      this.loop_idx = ( this.loop_idx ) % this.length;// 无需检查 !!\n      return arr[ this.loop_idx ];\n    };\n\n    // 增加 loop_idx 然后返回新的当前元素\n    arr.next = function(){\n      this.loop_idx++;\n      return this.current();\n    };\n    \n    // 减少 loop_idx 然后返回新的当前元素\n    arr.prev = function(){\n      this.loop_idx += this.length - 1;\n      return this.current();\n    };\n}\n\nmake_looper( aList);\n\naList.current();// -> A\naList.next();// -> B\naList.next();// -> C\naList.next();// -> D\naList.next();// -> E\naList.next();// -> A\naList.pop() ;// -> E\naList.prev();// -> D\naList.prev();// -> C\naList.prev();// -> B\naList.prev();// -> A\naList.prev();// -> D\n```\n\n转载自：[http://www.jstips.co](http://www.jstips.co/zh_cn/make-easy-loop-on-array/)","source":"_posts/用数组建立一个简单的循环.md","raw":"---\ntitle: 用数组建立一个简单的循环\ntags: [javascript]\ndate: 2016/08/10 16:24:24\n---\n\n有时我们需要不停的循环数组的元素，就像一组旋转的图片，或者音乐的播放列表。这里告诉你如何使一个数组拥有循环的能力：\n\n```javascript\nvar aList = ['A','B','C','D','E'];\n\nfunction make_looper( arr ){\n\n    arr.loop_idx = 0;\n\n    // 返回当前的元素\n    arr.current = function(){\n\n      if( this.loop_idx < 0 ){// 第一次检查\n        this.loop_idx = this.length - 1;// 更新 loop_idx\n      }\n\n      if( this.loop_idx >= this.length ){// 第二次检查\n        this.loop_idx = 0;// 更新 loop_idx\n      }\n\n      return arr[ this.loop_idx ];//返回元素\n    };\n    \n    // 增加 loop_idx 然后返回新的当前元素\n    arr.next = function(){\n      this.loop_idx++;\n      return this.current();\n    };\n    // 减少 loop_idx 然后返回新的当前元素\n    arr.prev = function(){\n      this.loop_idx--;\n      return this.current();\n    };\n}\n\nmake_looper( aList);\n\naList.current();// -> A\naList.next();// -> B\naList.next();// -> C\naList.next();// -> D\naList.next();// -> E\naList.next();// -> A\naList.pop() ;// -> E\naList.prev();// -> D\naList.prev();// -> C\naList.prev();// -> B\naList.prev();// -> A\naList.prev();// -> D\n```\n\n使用 `%` ( 取模 ) 操作符更优雅。取模返回除法的余数 ( `2 % 5 = 1` and `5 % 5 = 0`)：\n\n```javascript\nvar aList = ['A','B','C','D','E'];\n\n\nfunction make_looper( arr ){\n\n    arr.loop_idx = 0;\n\n    // return current item\n    arr.current = function(){\n      this.loop_idx = ( this.loop_idx ) % this.length;// 无需检查 !!\n      return arr[ this.loop_idx ];\n    };\n\n    // 增加 loop_idx 然后返回新的当前元素\n    arr.next = function(){\n      this.loop_idx++;\n      return this.current();\n    };\n    \n    // 减少 loop_idx 然后返回新的当前元素\n    arr.prev = function(){\n      this.loop_idx += this.length - 1;\n      return this.current();\n    };\n}\n\nmake_looper( aList);\n\naList.current();// -> A\naList.next();// -> B\naList.next();// -> C\naList.next();// -> D\naList.next();// -> E\naList.next();// -> A\naList.pop() ;// -> E\naList.prev();// -> D\naList.prev();// -> C\naList.prev();// -> B\naList.prev();// -> A\naList.prev();// -> D\n```\n\n转载自：[http://www.jstips.co](http://www.jstips.co/zh_cn/make-easy-loop-on-array/)","slug":"用数组建立一个简单的循环","published":1,"updated":"2016-08-17T06:22:19.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpme005068ddk8qa2af8","content":"<p>有时我们需要不停的循环数组的元素，就像一组旋转的图片，或者音乐的播放列表。这里告诉你如何使一个数组拥有循环的能力：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aList = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_looper</span>(<span class=\"params\"> arr </span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    arr.loop_idx = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 返回当前的元素</span></div><div class=\"line\">    arr.current = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.loop_idx &lt; <span class=\"number\">0</span> )&#123;<span class=\"comment\">// 第一次检查</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loop_idx = <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>;<span class=\"comment\">// 更新 loop_idx</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.loop_idx &gt;= <span class=\"keyword\">this</span>.length )&#123;<span class=\"comment\">// 第二次检查</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loop_idx = <span class=\"number\">0</span>;<span class=\"comment\">// 更新 loop_idx</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> arr[ <span class=\"keyword\">this</span>.loop_idx ];<span class=\"comment\">//返回元素</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 增加 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx++;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">// 减少 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.prev = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx--;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">make_looper( aList);</div><div class=\"line\"></div><div class=\"line\">aList.current();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.pop() ;<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div></pre></td></tr></table></figure>\n<p>使用 <code>%</code> ( 取模 ) 操作符更优雅。取模返回除法的余数 ( <code>2 % 5 = 1</code> and <code>5 % 5 = 0</code>)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aList = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_looper</span>(<span class=\"params\"> arr </span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    arr.loop_idx = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// return current item</span></div><div class=\"line\">    arr.current = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx = ( <span class=\"keyword\">this</span>.loop_idx ) % <span class=\"keyword\">this</span>.length;<span class=\"comment\">// 无需检查 !!</span></div><div class=\"line\">      <span class=\"keyword\">return</span> arr[ <span class=\"keyword\">this</span>.loop_idx ];</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 增加 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx++;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 减少 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.prev = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx += <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">make_looper( aList);</div><div class=\"line\"></div><div class=\"line\">aList.current();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.pop() ;<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div></pre></td></tr></table></figure>\n<p>转载自：<a href=\"http://www.jstips.co/zh_cn/make-easy-loop-on-array/\" target=\"_blank\" rel=\"external\">http://www.jstips.co</a></p>\n","excerpt":"","more":"<p>有时我们需要不停的循环数组的元素，就像一组旋转的图片，或者音乐的播放列表。这里告诉你如何使一个数组拥有循环的能力：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aList = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_looper</span>(<span class=\"params\"> arr </span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    arr.loop_idx = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 返回当前的元素</span></div><div class=\"line\">    arr.current = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.loop_idx &lt; <span class=\"number\">0</span> )&#123;<span class=\"comment\">// 第一次检查</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loop_idx = <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>;<span class=\"comment\">// 更新 loop_idx</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>( <span class=\"keyword\">this</span>.loop_idx &gt;= <span class=\"keyword\">this</span>.length )&#123;<span class=\"comment\">// 第二次检查</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.loop_idx = <span class=\"number\">0</span>;<span class=\"comment\">// 更新 loop_idx</span></div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> arr[ <span class=\"keyword\">this</span>.loop_idx ];<span class=\"comment\">//返回元素</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 增加 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx++;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"comment\">// 减少 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.prev = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx--;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">make_looper( aList);</div><div class=\"line\"></div><div class=\"line\">aList.current();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.pop() ;<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div></pre></td></tr></table></figure>\n<p>使用 <code>%</code> ( 取模 ) 操作符更优雅。取模返回除法的余数 ( <code>2 % 5 = 1</code> and <code>5 % 5 = 0</code>)：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> aList = [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>,<span class=\"string\">'D'</span>,<span class=\"string\">'E'</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">make_looper</span>(<span class=\"params\"> arr </span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    arr.loop_idx = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// return current item</span></div><div class=\"line\">    arr.current = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx = ( <span class=\"keyword\">this</span>.loop_idx ) % <span class=\"keyword\">this</span>.length;<span class=\"comment\">// 无需检查 !!</span></div><div class=\"line\">      <span class=\"keyword\">return</span> arr[ <span class=\"keyword\">this</span>.loop_idx ];</div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 增加 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.next = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx++;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 减少 loop_idx 然后返回新的当前元素</span></div><div class=\"line\">    arr.prev = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.loop_idx += <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span>;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.current();</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">make_looper( aList);</div><div class=\"line\"></div><div class=\"line\">aList.current();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.next();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.pop() ;<span class=\"comment\">// -&gt; E</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; C</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; B</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; A</span></div><div class=\"line\">aList.prev();<span class=\"comment\">// -&gt; D</span></div></pre></td></tr></table></figure>\n<p>转载自：<a href=\"http://www.jstips.co/zh_cn/make-easy-loop-on-array/\">http://www.jstips.co</a></p>\n"},{"title":"解决IE下a标签点击有虚线边框的问题","date":"2015-02-14T16:00:00.000Z","_content":"\nAnimate Transition 能够以 12 种预设方式来切换图片，且该插件使用了硬件加速 CSS 转换，所以性能极好。该插件可用于网站外观设计，导航，甚至是移动应用程序中的页面切换。\n\n项目地址：[https://github.com/Rapid-Application-Development-JS/AnimateTransition](https://github.com/Rapid-Application-Development-JS/AnimateTransition)\n","source":"_posts/界面切换 jQuery 插件：Animate Transition.md","raw":"---\ntitle: 解决IE下a标签点击有虚线边框的问题\ntags: [html,css]\ndate: 2015/02/15\n---\n\nAnimate Transition 能够以 12 种预设方式来切换图片，且该插件使用了硬件加速 CSS 转换，所以性能极好。该插件可用于网站外观设计，导航，甚至是移动应用程序中的页面切换。\n\n项目地址：[https://github.com/Rapid-Application-Development-JS/AnimateTransition](https://github.com/Rapid-Application-Development-JS/AnimateTransition)\n","slug":"界面切换 jQuery 插件：Animate Transition","published":1,"updated":"2016-08-17T06:22:19.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmf005268dd8d8w070r","content":"<p>Animate Transition 能够以 12 种预设方式来切换图片，且该插件使用了硬件加速 CSS 转换，所以性能极好。该插件可用于网站外观设计，导航，甚至是移动应用程序中的页面切换。</p>\n<p>项目地址：<a href=\"https://github.com/Rapid-Application-Development-JS/AnimateTransition\" target=\"_blank\" rel=\"external\">https://github.com/Rapid-Application-Development-JS/AnimateTransition</a></p>\n","excerpt":"","more":"<p>Animate Transition 能够以 12 种预设方式来切换图片，且该插件使用了硬件加速 CSS 转换，所以性能极好。该插件可用于网站外观设计，导航，甚至是移动应用程序中的页面切换。</p>\n<p>项目地址：<a href=\"https://github.com/Rapid-Application-Development-JS/AnimateTransition\">https://github.com/Rapid-Application-Development-JS/AnimateTransition</a></p>\n"},{"title":"移动网页开发总结","date":"2015-01-24T16:00:00.000Z","_content":"\n### 添加网页标题图标\n\n```html\n<link rel=\"short icon\" style=\"image/x-icon\" href=\"taobaoLogo.ico\" >\n<link rel=\"icon\" style=\"image/x-icon\" href=\"taobaoLogo.ico\">\n```\n\n### 添加收藏图标\n\n```\n<link rel=\"bookmark\" style=\"image/x-icon\" href=\"taobaoLogo.ico\">\n```\n\n### 对safari移动浏览器的处理\n\n除了上面的这一句，下面的这些也是制作手机页面必须加上的\n\n```\n<!--开启对web app的支持-->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<!--主要是正对苹果手机将数字自动识别为号码-->\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n### 可选择的mata\n\n```html\n<!-- 忽略识别邮箱，主要是针对安卓手机会自动将符合邮箱格式的字符串识别为邮箱地址-->\n<meta content=\"email=no\" name=\"format-detection\" />\n<!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n<meta name=\"HandheldFriendly\" content=\"true\">\n<!-- 微软的老式浏览器 -->\n<meta name=\"MobileOptimized\" content=\"320\">\n<!-- uc强制竖屏 -->\n<meta name=\"screen-orientation\" content=\"portrait\">\n<!-- QQ强制竖屏 -->\n<meta name=\"x5-orientation\" content=\"portrait\">\n<!-- UC强制全屏 -->\n<meta name=\"full-screen\" content=\"yes\">\n<!-- QQ强制全屏 -->\n<meta name=\"x5-fullscreen\" content=\"true\">\n<!-- UC应用模式 -->\n<meta name=\"browsermode\" content=\"application\">\n<!-- QQ应用模式 -->\n<meta name=\"x5-page-mode\" content=\"app\">\n<!-- windows phone 点击无高光 -->\n<meta name=\"msapplication-tap-highlight\" content=\"no\">\n```\n\n### 获取滚动条的滚动值\n\n+ window.scrollY\n+ window.scrollX\n\n桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两 个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获 取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.\n\n### 禁止用户选择文本\n\n```css\n-webkit-user-select:none\n```\n\n这个属性是禁止用户选择文本，对安卓和苹果都是有效的\n\n**浅谈一下box-sizing**\n\n这个属性可能大家比较陌生吧， 因为这个属性是是CSS3中新加入的，为了实现一种我们平时比较难实现的效果设定的属性\n\n例如：我们在手机布局的时候，一般我们是采用百分比来对网页进行自适应的处理，也就是我们所说的自适应布局，我们可能有时会想要中效果就是，在左右内缩加上1px\n\n```css\ndiv{\n    padding-left:1px;\n    padding-right:1px;   \n}\n```\n\n但是采用自适应布局会出现把屏幕撑开，从而出现横向滚动条的效果，这个是我们在手机网页中开发的大忌，所以这个时候box-sizing就解决了我们的问题。\n\n| 说明             | 值                                     |\n| :------------- | :------------------------------------ |\n| 默认值：           | content-box                           |\n| 继承性：           | no                                    |\n| 版本：            | CSS3                                  |\n| JavaScript 语法： | *object*.style.boxSizing=\"border-box\" |\n\n> 语法：box-sizing: content-box|border-box|inherit;\n\n| 值           | 描述                                       |\n| ----------- | ---------------------------------------- |\n| content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n| border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n| inherit     | 规定应从父元素继承 box-sizing 属性的值。               |\n\n### box-shadow\n\n这个属性虽然在手机网页中不是很常见，但是在网页中确实比较常见的，原因是移动端的网页显示的比较小，相对来说比较简洁，但是这个效果却是极好的，自从有了这个特性以后，望门就可以将网页是的特定元素实现得更具立体感，完成以前的一些没有办法实现的效果。\n\n| 默认值：           | none                                     |\n| -------------- | ---------------------------------------- |\n| 继承性：           | no                                       |\n| 版本：            | CSS3                                     |\n| JavaScript 语法： | *object*.style.boxShadow=\"10px 10px 5px #888888\" |\n\n> box-shadow: h-shadow v-shadow blur spread color inset;\n\n注释：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。\n\n| 值          | 描述                        |\n| ---------- | ------------------------- |\n| *h-shadow* | 必需。水平阴影的位置。允许负值。          |\n| *v-shadow* | 必需。垂直阴影的位置。允许负值。          |\n| *blur*     | 可选。模糊距离。                  |\n| *spread*   | 可选。阴影的尺寸。                 |\n| *color*    | 可选。阴影的颜色。请参阅 CSS 颜色值。     |\n| inset      | 可选。将外部阴影 (outset) 改为内部阴影。 |\n\n### base64编码图片代替URL图片\n\n由于在网页加载的时候，没一张图片，都要进行HTTP资源请求，所以将图片进行编码，减小单次请求的流量，从而加快网站的加载速度，这个的实现可以使用在线的编码工具即可，地址：\n\nhttp://www.fishlee.net/Tools/GetImageBase64Code#codeResult\n\n### 移动端特殊的事件\n\n在HTML5出现之后，有一些新的事件\n\n- touchstart //当手指接触屏幕时触发\n- touchmove //当已经接触屏幕的手指开始移动后触发\n- touchend //当手指离开屏幕时触发\n- touchcancel//当某种touch事件非正常结束时触发\n\n执行事件的顺序：\n\n> touchstart>touchmove>touchend>touchcanel>click\n\n从上面的顺序我们不难分析出：在点击的时候，click会发生延迟，这样的延迟一般是300ms。\n\n### 手机图片和视频上传\n\n```html\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n\n### 动画特效开启加速\n\n 默认的移动浏览器是不会开启动画效果硬件加速的，但是这样的效果在低端的安卓手机中可能会出现意想不到的反效果\n\n动画加速可以采用，下列代码\n\n```css\n.div {\n   -webkit-transform: translate3d(0, 0, 0);\n   -moz-transform: translate3d(0, 0, 0);\n   -ms-transform: translate3d(0, 0, 0);\n   transform: translate3d(0, 0, 0);\n   /*Other transform properties here*/\n}\n```\n\n设置placeholder时候 focus时候文字没有隐藏\n\n```css\ninput:focus::-webkit-input-placeholder{\n    opacity: 0;\n}\n```\n\nandroid局部滚动时隐藏原生滚动条\n\n```css\n::-webkit-scrollbar{\n    opacity: 0;\n}\n```\n\n\n\n> 转载：[http://www.cnblogs.com](http://www.cnblogs.com/st-leslie/p/5196852.html)\n>\n> 感谢：[typora](http://www.typora.io)\n\n","source":"_posts/移动网页开发总结.md","raw":"---\ntitle: 移动网页开发总结\ntags: [html]\ndate: 2015/01/25\n---\n\n### 添加网页标题图标\n\n```html\n<link rel=\"short icon\" style=\"image/x-icon\" href=\"taobaoLogo.ico\" >\n<link rel=\"icon\" style=\"image/x-icon\" href=\"taobaoLogo.ico\">\n```\n\n### 添加收藏图标\n\n```\n<link rel=\"bookmark\" style=\"image/x-icon\" href=\"taobaoLogo.ico\">\n```\n\n### 对safari移动浏览器的处理\n\n除了上面的这一句，下面的这些也是制作手机页面必须加上的\n\n```\n<!--开启对web app的支持-->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<!--主要是正对苹果手机将数字自动识别为号码-->\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n### 可选择的mata\n\n```html\n<!-- 忽略识别邮箱，主要是针对安卓手机会自动将符合邮箱格式的字符串识别为邮箱地址-->\n<meta content=\"email=no\" name=\"format-detection\" />\n<!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n<meta name=\"HandheldFriendly\" content=\"true\">\n<!-- 微软的老式浏览器 -->\n<meta name=\"MobileOptimized\" content=\"320\">\n<!-- uc强制竖屏 -->\n<meta name=\"screen-orientation\" content=\"portrait\">\n<!-- QQ强制竖屏 -->\n<meta name=\"x5-orientation\" content=\"portrait\">\n<!-- UC强制全屏 -->\n<meta name=\"full-screen\" content=\"yes\">\n<!-- QQ强制全屏 -->\n<meta name=\"x5-fullscreen\" content=\"true\">\n<!-- UC应用模式 -->\n<meta name=\"browsermode\" content=\"application\">\n<!-- QQ应用模式 -->\n<meta name=\"x5-page-mode\" content=\"app\">\n<!-- windows phone 点击无高光 -->\n<meta name=\"msapplication-tap-highlight\" content=\"no\">\n```\n\n### 获取滚动条的滚动值\n\n+ window.scrollY\n+ window.scrollX\n\n桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两 个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获 取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.\n\n### 禁止用户选择文本\n\n```css\n-webkit-user-select:none\n```\n\n这个属性是禁止用户选择文本，对安卓和苹果都是有效的\n\n**浅谈一下box-sizing**\n\n这个属性可能大家比较陌生吧， 因为这个属性是是CSS3中新加入的，为了实现一种我们平时比较难实现的效果设定的属性\n\n例如：我们在手机布局的时候，一般我们是采用百分比来对网页进行自适应的处理，也就是我们所说的自适应布局，我们可能有时会想要中效果就是，在左右内缩加上1px\n\n```css\ndiv{\n    padding-left:1px;\n    padding-right:1px;   \n}\n```\n\n但是采用自适应布局会出现把屏幕撑开，从而出现横向滚动条的效果，这个是我们在手机网页中开发的大忌，所以这个时候box-sizing就解决了我们的问题。\n\n| 说明             | 值                                     |\n| :------------- | :------------------------------------ |\n| 默认值：           | content-box                           |\n| 继承性：           | no                                    |\n| 版本：            | CSS3                                  |\n| JavaScript 语法： | *object*.style.boxSizing=\"border-box\" |\n\n> 语法：box-sizing: content-box|border-box|inherit;\n\n| 值           | 描述                                       |\n| ----------- | ---------------------------------------- |\n| content-box | 这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 |\n| border-box  | 为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 |\n| inherit     | 规定应从父元素继承 box-sizing 属性的值。               |\n\n### box-shadow\n\n这个属性虽然在手机网页中不是很常见，但是在网页中确实比较常见的，原因是移动端的网页显示的比较小，相对来说比较简洁，但是这个效果却是极好的，自从有了这个特性以后，望门就可以将网页是的特定元素实现得更具立体感，完成以前的一些没有办法实现的效果。\n\n| 默认值：           | none                                     |\n| -------------- | ---------------------------------------- |\n| 继承性：           | no                                       |\n| 版本：            | CSS3                                     |\n| JavaScript 语法： | *object*.style.boxShadow=\"10px 10px 5px #888888\" |\n\n> box-shadow: h-shadow v-shadow blur spread color inset;\n\n注释：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。\n\n| 值          | 描述                        |\n| ---------- | ------------------------- |\n| *h-shadow* | 必需。水平阴影的位置。允许负值。          |\n| *v-shadow* | 必需。垂直阴影的位置。允许负值。          |\n| *blur*     | 可选。模糊距离。                  |\n| *spread*   | 可选。阴影的尺寸。                 |\n| *color*    | 可选。阴影的颜色。请参阅 CSS 颜色值。     |\n| inset      | 可选。将外部阴影 (outset) 改为内部阴影。 |\n\n### base64编码图片代替URL图片\n\n由于在网页加载的时候，没一张图片，都要进行HTTP资源请求，所以将图片进行编码，减小单次请求的流量，从而加快网站的加载速度，这个的实现可以使用在线的编码工具即可，地址：\n\nhttp://www.fishlee.net/Tools/GetImageBase64Code#codeResult\n\n### 移动端特殊的事件\n\n在HTML5出现之后，有一些新的事件\n\n- touchstart //当手指接触屏幕时触发\n- touchmove //当已经接触屏幕的手指开始移动后触发\n- touchend //当手指离开屏幕时触发\n- touchcancel//当某种touch事件非正常结束时触发\n\n执行事件的顺序：\n\n> touchstart>touchmove>touchend>touchcanel>click\n\n从上面的顺序我们不难分析出：在点击的时候，click会发生延迟，这样的延迟一般是300ms。\n\n### 手机图片和视频上传\n\n```html\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n\n### 动画特效开启加速\n\n 默认的移动浏览器是不会开启动画效果硬件加速的，但是这样的效果在低端的安卓手机中可能会出现意想不到的反效果\n\n动画加速可以采用，下列代码\n\n```css\n.div {\n   -webkit-transform: translate3d(0, 0, 0);\n   -moz-transform: translate3d(0, 0, 0);\n   -ms-transform: translate3d(0, 0, 0);\n   transform: translate3d(0, 0, 0);\n   /*Other transform properties here*/\n}\n```\n\n设置placeholder时候 focus时候文字没有隐藏\n\n```css\ninput:focus::-webkit-input-placeholder{\n    opacity: 0;\n}\n```\n\nandroid局部滚动时隐藏原生滚动条\n\n```css\n::-webkit-scrollbar{\n    opacity: 0;\n}\n```\n\n\n\n> 转载：[http://www.cnblogs.com](http://www.cnblogs.com/st-leslie/p/5196852.html)\n>\n> 感谢：[typora](http://www.typora.io)\n\n","slug":"移动网页开发总结","published":1,"updated":"2016-08-17T06:22:19.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmi005568dd4a6dy38m","content":"<h3 id=\"添加网页标题图标\"><a href=\"#添加网页标题图标\" class=\"headerlink\" title=\"添加网页标题图标\"></a>添加网页标题图标</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"short icon\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"image/x-icon\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"taobaoLogo.ico\"</span> &gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"icon\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"image/x-icon\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"taobaoLogo.ico\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"添加收藏图标\"><a href=\"#添加收藏图标\" class=\"headerlink\" title=\"添加收藏图标\"></a>添加收藏图标</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;bookmark&quot; style=&quot;image/x-icon&quot; href=&quot;taobaoLogo.ico&quot;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"对safari移动浏览器的处理\"><a href=\"#对safari移动浏览器的处理\" class=\"headerlink\" title=\"对safari移动浏览器的处理\"></a>对safari移动浏览器的处理</h3><p>除了上面的这一句，下面的这些也是制作手机页面必须加上的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!--开启对web app的支持--&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class=\"line\">&lt;!--主要是正对苹果手机将数字自动识别为号码--&gt;</div><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"可选择的mata\"><a href=\"#可选择的mata\" class=\"headerlink\" title=\"可选择的mata\"></a>可选择的mata</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 忽略识别邮箱，主要是针对安卓手机会自动将符合邮箱格式的字符串识别为邮箱地址--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"email=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HandheldFriendly\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 微软的老式浏览器 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MobileOptimized\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"320\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- uc强制竖屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"screen-orientation\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"portrait\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ强制竖屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-orientation\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"portrait\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- UC强制全屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"full-screen\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ强制全屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-fullscreen\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- UC应用模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"browsermode\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"application\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ应用模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-page-mode\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- windows phone 点击无高光 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msapplication-tap-highlight\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"获取滚动条的滚动值\"><a href=\"#获取滚动条的滚动值\" class=\"headerlink\" title=\"获取滚动条的滚动值\"></a>获取滚动条的滚动值</h3><ul>\n<li>window.scrollY</li>\n<li>window.scrollX</li>\n</ul>\n<p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两 个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获 取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.</p>\n<h3 id=\"禁止用户选择文本\"><a href=\"#禁止用户选择文本\" class=\"headerlink\" title=\"禁止用户选择文本\"></a>禁止用户选择文本</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">-webkit-user-select</span><span class=\"selector-pseudo\">:none</span></div></pre></td></tr></table></figure>\n<p>这个属性是禁止用户选择文本，对安卓和苹果都是有效的</p>\n<p><strong>浅谈一下box-sizing</strong></p>\n<p>这个属性可能大家比较陌生吧， 因为这个属性是是CSS3中新加入的，为了实现一种我们平时比较难实现的效果设定的属性</p>\n<p>例如：我们在手机布局的时候，一般我们是采用百分比来对网页进行自适应的处理，也就是我们所说的自适应布局，我们可能有时会想要中效果就是，在左右内缩加上1px</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">padding-left</span>:<span class=\"number\">1px</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-right</span>:<span class=\"number\">1px</span>;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是采用自适应布局会出现把屏幕撑开，从而出现横向滚动条的效果，这个是我们在手机网页中开发的大忌，所以这个时候box-sizing就解决了我们的问题。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">默认值：</td>\n<td style=\"text-align:left\">content-box</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">继承性：</td>\n<td style=\"text-align:left\">no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">版本：</td>\n<td style=\"text-align:left\">CSS3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">JavaScript 语法：</td>\n<td style=\"text-align:left\"><em>object</em>.style.boxSizing=”border-box”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>语法：box-sizing: content-box|border-box|inherit;</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content-box</td>\n<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>\n</tr>\n<tr>\n<td>border-box</td>\n<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应从父元素继承 box-sizing 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h3><p>这个属性虽然在手机网页中不是很常见，但是在网页中确实比较常见的，原因是移动端的网页显示的比较小，相对来说比较简洁，但是这个效果却是极好的，自从有了这个特性以后，望门就可以将网页是的特定元素实现得更具立体感，完成以前的一些没有办法实现的效果。</p>\n<table>\n<thead>\n<tr>\n<th>默认值：</th>\n<th>none</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>继承性：</td>\n<td>no</td>\n</tr>\n<tr>\n<td>版本：</td>\n<td>CSS3</td>\n</tr>\n<tr>\n<td>JavaScript 语法：</td>\n<td><em>object</em>.style.boxShadow=”10px 10px 5px #888888”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>box-shadow: h-shadow v-shadow blur spread color inset;</p>\n</blockquote>\n<p>注释：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>h-shadow</em></td>\n<td>必需。水平阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td><em>v-shadow</em></td>\n<td>必需。垂直阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td><em>blur</em></td>\n<td>可选。模糊距离。</td>\n</tr>\n<tr>\n<td><em>spread</em></td>\n<td>可选。阴影的尺寸。</td>\n</tr>\n<tr>\n<td><em>color</em></td>\n<td>可选。阴影的颜色。请参阅 CSS 颜色值。</td>\n</tr>\n<tr>\n<td>inset</td>\n<td>可选。将外部阴影 (outset) 改为内部阴影。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"base64编码图片代替URL图片\"><a href=\"#base64编码图片代替URL图片\" class=\"headerlink\" title=\"base64编码图片代替URL图片\"></a>base64编码图片代替URL图片</h3><p>由于在网页加载的时候，没一张图片，都要进行HTTP资源请求，所以将图片进行编码，减小单次请求的流量，从而加快网站的加载速度，这个的实现可以使用在线的编码工具即可，地址：</p>\n<p><a href=\"http://www.fishlee.net/Tools/GetImageBase64Code#codeResult\" target=\"_blank\" rel=\"external\">http://www.fishlee.net/Tools/GetImageBase64Code#codeResult</a></p>\n<h3 id=\"移动端特殊的事件\"><a href=\"#移动端特殊的事件\" class=\"headerlink\" title=\"移动端特殊的事件\"></a>移动端特殊的事件</h3><p>在HTML5出现之后，有一些新的事件</p>\n<ul>\n<li>touchstart //当手指接触屏幕时触发</li>\n<li>touchmove //当已经接触屏幕的手指开始移动后触发</li>\n<li>touchend //当手指离开屏幕时触发</li>\n<li>touchcancel//当某种touch事件非正常结束时触发</li>\n</ul>\n<p>执行事件的顺序：</p>\n<blockquote>\n<p>touchstart&gt;touchmove&gt;touchend&gt;touchcanel&gt;click</p>\n</blockquote>\n<p>从上面的顺序我们不难分析出：在点击的时候，click会发生延迟，这样的延迟一般是300ms。</p>\n<h3 id=\"手机图片和视频上传\"><a href=\"#手机图片和视频上传\" class=\"headerlink\" title=\"手机图片和视频上传\"></a>手机图片和视频上传</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 选择照片 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"image/*\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 选择视频 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"video/*\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"动画特效开启加速\"><a href=\"#动画特效开启加速\" class=\"headerlink\" title=\"动画特效开启加速\"></a>动画特效开启加速</h3><p> 默认的移动浏览器是不会开启动画效果硬件加速的，但是这样的效果在低端的安卓手机中可能会出现意想不到的反效果</p>\n<p>动画加速可以采用，下列代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.div</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">-moz-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">-ms-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"comment\">/*Other transform properties here*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置placeholder时候 focus时候文字没有隐藏</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>android局部滚动时隐藏原生滚动条</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>转载：<a href=\"http://www.cnblogs.com/st-leslie/p/5196852.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com</a></p>\n<p>感谢：<a href=\"http://www.typora.io\" target=\"_blank\" rel=\"external\">typora</a></p>\n</blockquote>\n","excerpt":"","more":"<h3 id=\"添加网页标题图标\"><a href=\"#添加网页标题图标\" class=\"headerlink\" title=\"添加网页标题图标\"></a>添加网页标题图标</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"short icon\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"image/x-icon\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"taobaoLogo.ico\"</span> &gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"icon\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"image/x-icon\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"taobaoLogo.ico\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"添加收藏图标\"><a href=\"#添加收藏图标\" class=\"headerlink\" title=\"添加收藏图标\"></a>添加收藏图标</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;link rel=&quot;bookmark&quot; style=&quot;image/x-icon&quot; href=&quot;taobaoLogo.ico&quot;&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"对safari移动浏览器的处理\"><a href=\"#对safari移动浏览器的处理\" class=\"headerlink\" title=\"对safari移动浏览器的处理\"></a>对safari移动浏览器的处理</h3><p>除了上面的这一句，下面的这些也是制作手机页面必须加上的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">&lt;!--开启对web app的支持--&gt;</div><div class=\"line\">&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;</div><div class=\"line\">&lt;!--主要是正对苹果手机将数字自动识别为号码--&gt;</div><div class=\"line\">&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"可选择的mata\"><a href=\"#可选择的mata\" class=\"headerlink\" title=\"可选择的mata\"></a>可选择的mata</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 忽略识别邮箱，主要是针对安卓手机会自动将符合邮箱格式的字符串识别为邮箱地址--&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">content</span>=<span class=\"string\">\"email=no\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"format-detection\"</span> /&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"HandheldFriendly\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 微软的老式浏览器 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"MobileOptimized\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"320\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- uc强制竖屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"screen-orientation\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"portrait\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ强制竖屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-orientation\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"portrait\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- UC强制全屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"full-screen\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"yes\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ强制全屏 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-fullscreen\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"true\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- UC应用模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"browsermode\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"application\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- QQ应用模式 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"x5-page-mode\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"app\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- windows phone 点击无高光 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msapplication-tap-highlight\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"获取滚动条的滚动值\"><a href=\"#获取滚动条的滚动值\" class=\"headerlink\" title=\"获取滚动条的滚动值\"></a>获取滚动条的滚动值</h3><ul>\n<li>window.scrollY</li>\n<li>window.scrollX</li>\n</ul>\n<p>桌面浏览器中想要获取滚动条的值是通过document.scrollTop和document.scrollLeft得到的，但在iOS中你会发现这两 个属性是未定义的，为什么呢？因为在iOS中没有滚动条的概念，在Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获 取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用woindow.scroll.</p>\n<h3 id=\"禁止用户选择文本\"><a href=\"#禁止用户选择文本\" class=\"headerlink\" title=\"禁止用户选择文本\"></a>禁止用户选择文本</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">-webkit-user-select</span><span class=\"selector-pseudo\">:none</span></div></pre></td></tr></table></figure>\n<p>这个属性是禁止用户选择文本，对安卓和苹果都是有效的</p>\n<p><strong>浅谈一下box-sizing</strong></p>\n<p>这个属性可能大家比较陌生吧， 因为这个属性是是CSS3中新加入的，为了实现一种我们平时比较难实现的效果设定的属性</p>\n<p>例如：我们在手机布局的时候，一般我们是采用百分比来对网页进行自适应的处理，也就是我们所说的自适应布局，我们可能有时会想要中效果就是，在左右内缩加上1px</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">padding-left</span>:<span class=\"number\">1px</span>;</div><div class=\"line\">    <span class=\"attribute\">padding-right</span>:<span class=\"number\">1px</span>;   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是采用自适应布局会出现把屏幕撑开，从而出现横向滚动条的效果，这个是我们在手机网页中开发的大忌，所以这个时候box-sizing就解决了我们的问题。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">默认值：</td>\n<td style=\"text-align:left\">content-box</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">继承性：</td>\n<td style=\"text-align:left\">no</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">版本：</td>\n<td style=\"text-align:left\">CSS3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">JavaScript 语法：</td>\n<td style=\"text-align:left\"><em>object</em>.style.boxSizing=”border-box”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>语法：box-sizing: content-box|border-box|inherit;</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>content-box</td>\n<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>\n</tr>\n<tr>\n<td>border-box</td>\n<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>\n</tr>\n<tr>\n<td>inherit</td>\n<td>规定应从父元素继承 box-sizing 属性的值。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"box-shadow\"><a href=\"#box-shadow\" class=\"headerlink\" title=\"box-shadow\"></a>box-shadow</h3><p>这个属性虽然在手机网页中不是很常见，但是在网页中确实比较常见的，原因是移动端的网页显示的比较小，相对来说比较简洁，但是这个效果却是极好的，自从有了这个特性以后，望门就可以将网页是的特定元素实现得更具立体感，完成以前的一些没有办法实现的效果。</p>\n<table>\n<thead>\n<tr>\n<th>默认值：</th>\n<th>none</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>继承性：</td>\n<td>no</td>\n</tr>\n<tr>\n<td>版本：</td>\n<td>CSS3</td>\n</tr>\n<tr>\n<td>JavaScript 语法：</td>\n<td><em>object</em>.style.boxShadow=”10px 10px 5px #888888”</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>box-shadow: h-shadow v-shadow blur spread color inset;</p>\n</blockquote>\n<p>注释：box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>h-shadow</em></td>\n<td>必需。水平阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td><em>v-shadow</em></td>\n<td>必需。垂直阴影的位置。允许负值。</td>\n</tr>\n<tr>\n<td><em>blur</em></td>\n<td>可选。模糊距离。</td>\n</tr>\n<tr>\n<td><em>spread</em></td>\n<td>可选。阴影的尺寸。</td>\n</tr>\n<tr>\n<td><em>color</em></td>\n<td>可选。阴影的颜色。请参阅 CSS 颜色值。</td>\n</tr>\n<tr>\n<td>inset</td>\n<td>可选。将外部阴影 (outset) 改为内部阴影。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"base64编码图片代替URL图片\"><a href=\"#base64编码图片代替URL图片\" class=\"headerlink\" title=\"base64编码图片代替URL图片\"></a>base64编码图片代替URL图片</h3><p>由于在网页加载的时候，没一张图片，都要进行HTTP资源请求，所以将图片进行编码，减小单次请求的流量，从而加快网站的加载速度，这个的实现可以使用在线的编码工具即可，地址：</p>\n<p><a href=\"http://www.fishlee.net/Tools/GetImageBase64Code#codeResult\">http://www.fishlee.net/Tools/GetImageBase64Code#codeResult</a></p>\n<h3 id=\"移动端特殊的事件\"><a href=\"#移动端特殊的事件\" class=\"headerlink\" title=\"移动端特殊的事件\"></a>移动端特殊的事件</h3><p>在HTML5出现之后，有一些新的事件</p>\n<ul>\n<li>touchstart //当手指接触屏幕时触发</li>\n<li>touchmove //当已经接触屏幕的手指开始移动后触发</li>\n<li>touchend //当手指离开屏幕时触发</li>\n<li>touchcancel//当某种touch事件非正常结束时触发</li>\n</ul>\n<p>执行事件的顺序：</p>\n<blockquote>\n<p>touchstart&gt;touchmove&gt;touchend&gt;touchcanel&gt;click</p>\n</blockquote>\n<p>从上面的顺序我们不难分析出：在点击的时候，click会发生延迟，这样的延迟一般是300ms。</p>\n<h3 id=\"手机图片和视频上传\"><a href=\"#手机图片和视频上传\" class=\"headerlink\" title=\"手机图片和视频上传\"></a>手机图片和视频上传</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- 选择照片 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"image/*\"</span>&gt;</span></div><div class=\"line\"><span class=\"comment\">&lt;!-- 选择视频 --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">file</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"video/*\"</span>&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"动画特效开启加速\"><a href=\"#动画特效开启加速\" class=\"headerlink\" title=\"动画特效开启加速\"></a>动画特效开启加速</h3><p> 默认的移动浏览器是不会开启动画效果硬件加速的，但是这样的效果在低端的安卓手机中可能会出现意想不到的反效果</p>\n<p>动画加速可以采用，下列代码</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.div</span> &#123;</div><div class=\"line\">   <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">-moz-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">-ms-transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(0, 0, 0);</div><div class=\"line\">   <span class=\"comment\">/*Other transform properties here*/</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>设置placeholder时候 focus时候文字没有隐藏</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span><span class=\"selector-pseudo\">::-webkit-input-placeholder</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>android局部滚动时隐藏原生滚动条</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">::-webkit-scrollbar</span>&#123;</div><div class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>转载：<a href=\"http://www.cnblogs.com/st-leslie/p/5196852.html\">http://www.cnblogs.com</a></p>\n<p>感谢：<a href=\"http://www.typora.io\">typora</a></p>\n</blockquote>\n"},{"title":"程序员累了怎么办？","date":"2015-10-09T16:00:00.000Z","_content":"\n程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。\n\n很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。\n\n### 倦怠发生的原因\n\n程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。\n\n+ 第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。\n+ 第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。\n+ 第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。\n+ 第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。\n\n我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。\n\n#### 先从基本的开始。\n\n+ 吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。\n+ 睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。\n+ 不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。\n+ 番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。\n+ 保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。\n\n#### 更具体化的要点\n\n+ 实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。\n+ 参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。\n+ 打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。\n+ 掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。\n+ 休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。\n+ 考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。\n+ 将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。\n\n### 结论\n\n世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。\n\n诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。\n\n所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！\n\n译文链接：[http://www.codeceo.com/article/programmer-tied.html](http://www.codeceo.com/article/programmer-tied.html)\n\n英文原文：[Preventing burnout for programmers](https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa)\n\n翻译作者：[码农网](http://www.codeceo.com/) – 小峰","source":"_posts/程序员累了怎么办？.md","raw":"---\ntitle: 程序员累了怎么办？\ntags: [其它]\ndate: 2015/10/10\n---\n\n程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。\n\n很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。\n\n### 倦怠发生的原因\n\n程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。\n\n+ 第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。\n+ 第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。\n+ 第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。\n+ 第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。\n\n我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。\n\n#### 先从基本的开始。\n\n+ 吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。\n+ 睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。\n+ 不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。\n+ 番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。\n+ 保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。\n\n#### 更具体化的要点\n\n+ 实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。\n+ 参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。\n+ 打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。\n+ 掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。\n+ 休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。\n+ 考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。\n+ 将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。\n\n### 结论\n\n世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。\n\n诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。\n\n所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！\n\n译文链接：[http://www.codeceo.com/article/programmer-tied.html](http://www.codeceo.com/article/programmer-tied.html)\n\n英文原文：[Preventing burnout for programmers](https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa)\n\n翻译作者：[码农网](http://www.codeceo.com/) – 小峰","slug":"程序员累了怎么办？","published":1,"updated":"2016-08-17T06:22:19.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmk005768ddi6yyzggs","content":"<p>程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。</p>\n<p>很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。</p>\n<h3 id=\"倦怠发生的原因\"><a href=\"#倦怠发生的原因\" class=\"headerlink\" title=\"倦怠发生的原因\"></a>倦怠发生的原因</h3><p>程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。</p>\n<ul>\n<li>第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。</li>\n<li>第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。</li>\n<li>第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。</li>\n<li>第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。</li>\n</ul>\n<p>我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。</p>\n<h4 id=\"先从基本的开始。\"><a href=\"#先从基本的开始。\" class=\"headerlink\" title=\"先从基本的开始。\"></a>先从基本的开始。</h4><ul>\n<li>吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。</li>\n<li>睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。</li>\n<li>不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。</li>\n<li>番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。</li>\n<li>保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。</li>\n</ul>\n<h4 id=\"更具体化的要点\"><a href=\"#更具体化的要点\" class=\"headerlink\" title=\"更具体化的要点\"></a>更具体化的要点</h4><ul>\n<li>实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。</li>\n<li>参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。</li>\n<li>打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。</li>\n<li>掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。</li>\n<li>休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。</li>\n<li>考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。</li>\n<li>将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。</p>\n<p>诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。</p>\n<p>所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！</p>\n<p>译文链接：<a href=\"http://www.codeceo.com/article/programmer-tied.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/programmer-tied.html</a></p>\n<p>英文原文：<a href=\"https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa\" target=\"_blank\" rel=\"external\">Preventing burnout for programmers</a></p>\n<p>翻译作者：<a href=\"http://www.codeceo.com/\" target=\"_blank\" rel=\"external\">码农网</a> – 小峰</p>\n","excerpt":"","more":"<p>程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。</p>\n<p>很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。</p>\n<h3 id=\"倦怠发生的原因\"><a href=\"#倦怠发生的原因\" class=\"headerlink\" title=\"倦怠发生的原因\"></a>倦怠发生的原因</h3><p>程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。</p>\n<ul>\n<li>第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。</li>\n<li>第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。</li>\n<li>第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。</li>\n<li>第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。</li>\n</ul>\n<p>我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。</p>\n<h4 id=\"先从基本的开始。\"><a href=\"#先从基本的开始。\" class=\"headerlink\" title=\"先从基本的开始。\"></a>先从基本的开始。</h4><ul>\n<li>吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。</li>\n<li>睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。</li>\n<li>不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。</li>\n<li>番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。</li>\n<li>保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。</li>\n</ul>\n<h4 id=\"更具体化的要点\"><a href=\"#更具体化的要点\" class=\"headerlink\" title=\"更具体化的要点\"></a>更具体化的要点</h4><ul>\n<li>实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。</li>\n<li>参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。</li>\n<li>打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。</li>\n<li>掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。</li>\n<li>休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。</li>\n<li>考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。</li>\n<li>将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。</p>\n<p>诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。</p>\n<p>所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！</p>\n<p>译文链接：<a href=\"http://www.codeceo.com/article/programmer-tied.html\">http://www.codeceo.com/article/programmer-tied.html</a></p>\n<p>英文原文：<a href=\"https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa\">Preventing burnout for programmers</a></p>\n<p>翻译作者：<a href=\"http://www.codeceo.com/\">码农网</a> – 小峰</p>\n"},{"title":"简单监听DOM事件","date":"2015-02-16T16:00:00.000Z","_content":"\n很多人还在这样做：\n\n```\nelement.addEventListener('type', obj.method.bind(obj))\nelement.addEventListener('type', function (event) {})\nelement.addEventListener('type', (event) => {})\n```\n\n上面所有的例子都创建了一个匿名事件监控句柄，且在不需要时无法删除它。这在你不需要某句柄，而它却被用户或事件冒泡偶然触发时，可能会导致性能问题或不必要的逻辑问题。\n更安全的事件处理方式如下：\n使用引用：\n\n```\nconst handler = function () {\n  console.log(\"Tada!\")\n}\nelement.addEventListener(\"click\", handler)\n```\n\n// 之后\n\n```\nelement.removeEventListener(\"click\", handler)\n```\n\n命名的函数移除它本身:\n\n```\nelement.addEventListener('click', function click(e) {\n  if (someCondition) {\n    return e.currentTarget.removeEventListener('click', click);\n  }\n});\n```\n\n更好的写法：\n\n```\nfunction handleEvent (eventName, {onElement, withCallback, useCapture = false} = {}, thisArg) {\n  const element = onElement || document.documentElement\n\n  function handler (event) {\n    if (typeof withCallback === 'function') {\n      withCallback.call(thisArg, event)\n    }\n  }\n\n  handler.destroy = function () {\n    return element.removeEventListener(eventName, handler, useCapture)\n  }\n\n  element.addEventListener(eventName, handler, useCapture)\n  return handler\n}\n```\n\n// 你需要的时候\n\n```\nconst handleClick = handleEvent('click', {\n  onElement: element,\n  withCallback: (event) => {\n    console.log('Tada!')\n  }\n})\n```\n\n// 你想删除它的时候\n\n```\nhandleClick.destroy()\n```\n","source":"_posts/简单监听DOM事件.md","raw":"---\ntitle: 简单监听DOM事件\ntags: [javascript]\ndate: 2015/02/17\n---\n\n很多人还在这样做：\n\n```\nelement.addEventListener('type', obj.method.bind(obj))\nelement.addEventListener('type', function (event) {})\nelement.addEventListener('type', (event) => {})\n```\n\n上面所有的例子都创建了一个匿名事件监控句柄，且在不需要时无法删除它。这在你不需要某句柄，而它却被用户或事件冒泡偶然触发时，可能会导致性能问题或不必要的逻辑问题。\n更安全的事件处理方式如下：\n使用引用：\n\n```\nconst handler = function () {\n  console.log(\"Tada!\")\n}\nelement.addEventListener(\"click\", handler)\n```\n\n// 之后\n\n```\nelement.removeEventListener(\"click\", handler)\n```\n\n命名的函数移除它本身:\n\n```\nelement.addEventListener('click', function click(e) {\n  if (someCondition) {\n    return e.currentTarget.removeEventListener('click', click);\n  }\n});\n```\n\n更好的写法：\n\n```\nfunction handleEvent (eventName, {onElement, withCallback, useCapture = false} = {}, thisArg) {\n  const element = onElement || document.documentElement\n\n  function handler (event) {\n    if (typeof withCallback === 'function') {\n      withCallback.call(thisArg, event)\n    }\n  }\n\n  handler.destroy = function () {\n    return element.removeEventListener(eventName, handler, useCapture)\n  }\n\n  element.addEventListener(eventName, handler, useCapture)\n  return handler\n}\n```\n\n// 你需要的时候\n\n```\nconst handleClick = handleEvent('click', {\n  onElement: element,\n  withCallback: (event) => {\n    console.log('Tada!')\n  }\n})\n```\n\n// 你想删除它的时候\n\n```\nhandleClick.destroy()\n```\n","slug":"简单监听DOM事件","published":1,"updated":"2016-08-17T06:22:19.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmm005a68ddpqvbi2fr","content":"<p>很多人还在这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.addEventListener(&apos;type&apos;, obj.method.bind(obj))</div><div class=\"line\">element.addEventListener(&apos;type&apos;, function (event) &#123;&#125;)</div><div class=\"line\">element.addEventListener(&apos;type&apos;, (event) =&gt; &#123;&#125;)</div></pre></td></tr></table></figure>\n<p>上面所有的例子都创建了一个匿名事件监控句柄，且在不需要时无法删除它。这在你不需要某句柄，而它却被用户或事件冒泡偶然触发时，可能会导致性能问题或不必要的逻辑问题。<br>更安全的事件处理方式如下：<br>使用引用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">const handler = function () &#123;</div><div class=\"line\">  console.log(&quot;Tada!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">element.addEventListener(&quot;click&quot;, handler)</div></pre></td></tr></table></figure>\n<p>// 之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.removeEventListener(&quot;click&quot;, handler)</div></pre></td></tr></table></figure>\n<p>命名的函数移除它本身:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.addEventListener(&apos;click&apos;, function click(e) &#123;</div><div class=\"line\">  if (someCondition) &#123;</div><div class=\"line\">    return e.currentTarget.removeEventListener(&apos;click&apos;, click);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>更好的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function handleEvent (eventName, &#123;onElement, withCallback, useCapture = false&#125; = &#123;&#125;, thisArg) &#123;</div><div class=\"line\">  const element = onElement || document.documentElement</div><div class=\"line\"></div><div class=\"line\">  function handler (event) &#123;</div><div class=\"line\">    if (typeof withCallback === &apos;function&apos;) &#123;</div><div class=\"line\">      withCallback.call(thisArg, event)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handler.destroy = function () &#123;</div><div class=\"line\">    return element.removeEventListener(eventName, handler, useCapture)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  element.addEventListener(eventName, handler, useCapture)</div><div class=\"line\">  return handler</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>// 你需要的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">const handleClick = handleEvent(&apos;click&apos;, &#123;</div><div class=\"line\">  onElement: element,</div><div class=\"line\">  withCallback: (event) =&gt; &#123;</div><div class=\"line\">    console.log(&apos;Tada!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>// 你想删除它的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">handleClick.destroy()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>很多人还在这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.addEventListener(&apos;type&apos;, obj.method.bind(obj))</div><div class=\"line\">element.addEventListener(&apos;type&apos;, function (event) &#123;&#125;)</div><div class=\"line\">element.addEventListener(&apos;type&apos;, (event) =&gt; &#123;&#125;)</div></pre></td></tr></table></figure>\n<p>上面所有的例子都创建了一个匿名事件监控句柄，且在不需要时无法删除它。这在你不需要某句柄，而它却被用户或事件冒泡偶然触发时，可能会导致性能问题或不必要的逻辑问题。<br>更安全的事件处理方式如下：<br>使用引用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">const handler = function () &#123;</div><div class=\"line\">  console.log(&quot;Tada!&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\">element.addEventListener(&quot;click&quot;, handler)</div></pre></td></tr></table></figure>\n<p>// 之后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.removeEventListener(&quot;click&quot;, handler)</div></pre></td></tr></table></figure>\n<p>命名的函数移除它本身:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">element.addEventListener(&apos;click&apos;, function click(e) &#123;</div><div class=\"line\">  if (someCondition) &#123;</div><div class=\"line\">    return e.currentTarget.removeEventListener(&apos;click&apos;, click);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>更好的写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function handleEvent (eventName, &#123;onElement, withCallback, useCapture = false&#125; = &#123;&#125;, thisArg) &#123;</div><div class=\"line\">  const element = onElement || document.documentElement</div><div class=\"line\"></div><div class=\"line\">  function handler (event) &#123;</div><div class=\"line\">    if (typeof withCallback === &apos;function&apos;) &#123;</div><div class=\"line\">      withCallback.call(thisArg, event)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  handler.destroy = function () &#123;</div><div class=\"line\">    return element.removeEventListener(eventName, handler, useCapture)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  element.addEventListener(eventName, handler, useCapture)</div><div class=\"line\">  return handler</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>// 你需要的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">const handleClick = handleEvent(&apos;click&apos;, &#123;</div><div class=\"line\">  onElement: element,</div><div class=\"line\">  withCallback: (event) =&gt; &#123;</div><div class=\"line\">    console.log(&apos;Tada!&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>// 你想删除它的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">handleClick.destroy()</div></pre></td></tr></table></figure>\n"},{"title":"突袭HTML5","date":"2015-01-29T16:00:00.000Z","_content":"\n[简述HTML5特性](http://www.cnblogs.com/dxy1982/archive/2012/03/23/2400291.html)\n\n[HTML5中的多线程](http://www.cnblogs.com/dxy1982/archive/2012/08/06/2359202.html)\n\n[HTML5中的地理位置API](http://www.cnblogs.com/dxy1982/archive/2012/08/07/2621387.html)\n\n[HTML5的Web Storage介绍](http://www.cnblogs.com/dxy1982/archive/2012/08/10/2625302.html)\n\n[HTML5中的拖拽操作](http://www.cnblogs.com/dxy1982/archive/2012/08/17/2626515.html)\n\n[HTML5中的离线缓存、服务端消息和桌面通知简介](http://www.cnblogs.com/dxy1982/archive/2012/08/20/2626514.html)\n\n[HTML5新增加的元素介绍](http://www.cnblogs.com/dxy1982/archive/2012/08/02/2359200.html)\n\n[HTML5中的Form表单](http://www.cnblogs.com/dxy1982/archive/2012/08/03/2611290.html)\n\n[WebGL简介](http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html)\n\n[基于WebGL类库的开发简介](http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html)\n\n[SVG概论](http://www.cnblogs.com/dxy1982/archive/2012/03/15/2381312.html)\n\n[使用SVG的图形元素](http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html)\n\n[使用SVG渲染文本和图像](http://www.cnblogs.com/dxy1982/archive/2012/04/09/2395728.html)\n\n[SVG中的笔画和填充](http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html)\n\n[SVG中的颜色表示](http://www.cnblogs.com/dxy1982/archive/2012/04/14/2447065.html)\n\n[SVG的坐标系统与变换](http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html)\n\n[SVG中元素的重用](http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html)\n\n[SVG的文档结构](http://www.cnblogs.com/dxy1982/archive/2012/05/18/2456900.html)\n\n[SVG支持的蒙板](http://www.cnblogs.com/dxy1982/archive/2012/06/01/2395742.html)\n\n[SVG的滤镜效果](http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html)\n\n[SVG中的动画](http://www.cnblogs.com/dxy1982/archive/2012/07/04/2395740.html)\n\n[SVG DOM 知识](http://www.cnblogs.com/dxy1982/archive/2012/07/20/2417379.html)\n\n[SVG对决Canvas](http://www.cnblogs.com/dxy1982/archive/2012/07/25/2409234.html)\n","source":"_posts/突袭HTML5.md","raw":"---\ntitle: 突袭HTML5\ntags: [html,html5]\ndate: 2015/01/30\n---\n\n[简述HTML5特性](http://www.cnblogs.com/dxy1982/archive/2012/03/23/2400291.html)\n\n[HTML5中的多线程](http://www.cnblogs.com/dxy1982/archive/2012/08/06/2359202.html)\n\n[HTML5中的地理位置API](http://www.cnblogs.com/dxy1982/archive/2012/08/07/2621387.html)\n\n[HTML5的Web Storage介绍](http://www.cnblogs.com/dxy1982/archive/2012/08/10/2625302.html)\n\n[HTML5中的拖拽操作](http://www.cnblogs.com/dxy1982/archive/2012/08/17/2626515.html)\n\n[HTML5中的离线缓存、服务端消息和桌面通知简介](http://www.cnblogs.com/dxy1982/archive/2012/08/20/2626514.html)\n\n[HTML5新增加的元素介绍](http://www.cnblogs.com/dxy1982/archive/2012/08/02/2359200.html)\n\n[HTML5中的Form表单](http://www.cnblogs.com/dxy1982/archive/2012/08/03/2611290.html)\n\n[WebGL简介](http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html)\n\n[基于WebGL类库的开发简介](http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html)\n\n[SVG概论](http://www.cnblogs.com/dxy1982/archive/2012/03/15/2381312.html)\n\n[使用SVG的图形元素](http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html)\n\n[使用SVG渲染文本和图像](http://www.cnblogs.com/dxy1982/archive/2012/04/09/2395728.html)\n\n[SVG中的笔画和填充](http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html)\n\n[SVG中的颜色表示](http://www.cnblogs.com/dxy1982/archive/2012/04/14/2447065.html)\n\n[SVG的坐标系统与变换](http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html)\n\n[SVG中元素的重用](http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html)\n\n[SVG的文档结构](http://www.cnblogs.com/dxy1982/archive/2012/05/18/2456900.html)\n\n[SVG支持的蒙板](http://www.cnblogs.com/dxy1982/archive/2012/06/01/2395742.html)\n\n[SVG的滤镜效果](http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html)\n\n[SVG中的动画](http://www.cnblogs.com/dxy1982/archive/2012/07/04/2395740.html)\n\n[SVG DOM 知识](http://www.cnblogs.com/dxy1982/archive/2012/07/20/2417379.html)\n\n[SVG对决Canvas](http://www.cnblogs.com/dxy1982/archive/2012/07/25/2409234.html)\n","slug":"突袭HTML5","published":1,"updated":"2016-08-17T06:22:19.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmp005c68dd0ihwchcn","content":"<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/03/23/2400291.html\" target=\"_blank\" rel=\"external\">简述HTML5特性</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/06/2359202.html\" target=\"_blank\" rel=\"external\">HTML5中的多线程</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/07/2621387.html\" target=\"_blank\" rel=\"external\">HTML5中的地理位置API</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/10/2625302.html\" target=\"_blank\" rel=\"external\">HTML5的Web Storage介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/17/2626515.html\" target=\"_blank\" rel=\"external\">HTML5中的拖拽操作</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/20/2626514.html\" target=\"_blank\" rel=\"external\">HTML5中的离线缓存、服务端消息和桌面通知简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/02/2359200.html\" target=\"_blank\" rel=\"external\">HTML5新增加的元素介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/03/2611290.html\" target=\"_blank\" rel=\"external\">HTML5中的Form表单</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html\" target=\"_blank\" rel=\"external\">WebGL简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html\" target=\"_blank\" rel=\"external\">基于WebGL类库的开发简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/03/15/2381312.html\" target=\"_blank\" rel=\"external\">SVG概论</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html\" target=\"_blank\" rel=\"external\">使用SVG的图形元素</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/09/2395728.html\" target=\"_blank\" rel=\"external\">使用SVG渲染文本和图像</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html\" target=\"_blank\" rel=\"external\">SVG中的笔画和填充</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/14/2447065.html\" target=\"_blank\" rel=\"external\">SVG中的颜色表示</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html\" target=\"_blank\" rel=\"external\">SVG的坐标系统与变换</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html\" target=\"_blank\" rel=\"external\">SVG中元素的重用</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/18/2456900.html\" target=\"_blank\" rel=\"external\">SVG的文档结构</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/06/01/2395742.html\" target=\"_blank\" rel=\"external\">SVG支持的蒙板</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html\" target=\"_blank\" rel=\"external\">SVG的滤镜效果</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/04/2395740.html\" target=\"_blank\" rel=\"external\">SVG中的动画</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/20/2417379.html\" target=\"_blank\" rel=\"external\">SVG DOM 知识</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/25/2409234.html\" target=\"_blank\" rel=\"external\">SVG对决Canvas</a></p>\n","excerpt":"","more":"<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/03/23/2400291.html\">简述HTML5特性</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/06/2359202.html\">HTML5中的多线程</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/07/2621387.html\">HTML5中的地理位置API</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/10/2625302.html\">HTML5的Web Storage介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/17/2626515.html\">HTML5中的拖拽操作</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/20/2626514.html\">HTML5中的离线缓存、服务端消息和桌面通知简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/02/2359200.html\">HTML5新增加的元素介绍</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/03/2611290.html\">HTML5中的Form表单</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html\">WebGL简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/08/01/2609582.html\">基于WebGL类库的开发简介</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/03/15/2381312.html\">SVG概论</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/06/2395729.html\">使用SVG的图形元素</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/09/2395728.html\">使用SVG渲染文本和图像</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/14/2395734.html\">SVG中的笔画和填充</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/04/14/2447065.html\">SVG中的颜色表示</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/07/2395732.html\">SVG的坐标系统与变换</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/17/2503782.html\">SVG中元素的重用</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/05/18/2456900.html\">SVG的文档结构</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/06/01/2395742.html\">SVG支持的蒙板</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/06/13/2530529.html\">SVG的滤镜效果</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/04/2395740.html\">SVG中的动画</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/20/2417379.html\">SVG DOM 知识</a></p>\n<p><a href=\"http://www.cnblogs.com/dxy1982/archive/2012/07/25/2409234.html\">SVG对决Canvas</a></p>\n"},{"title":"糟糕程序员的编程风格","date":"2016-02-16T16:00:00.000Z","_content":"\n> 有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？\n\n### 糟糕的开发人员\n\n如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。\n\n首先让我们先来了解关于糟糕的开发人员的两种主要类型：\n\n**平庸的开发人员**\n\n从本质来看，这两者是相同的，但是它们通常表现出不同的行为。\n\n**牛仔程序员**\n\n牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。\n\n那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？\n\n1、编码速度非常快\n\n通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。\n\n牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……\n\n2、凌乱、不可读的代码\n\n快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。\n\n凌乱的代码会导致……\n\n3、Bug，无处不在的bug\n\n如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。\n\n更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。\n\n总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。\n\n如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。\n\n### 自大\n\n有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。\n\n这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。\n\n只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。\n\n使得这些程序员变得糟糕的最重要的属性，是自大。\n\n糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。\n\n更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。\n\n最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。\n\n请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。\n\n### 平庸的开发者\n\n这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。\n\n不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。\n\n也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。\n\n关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。\n\n### 问题的核心\n\n促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。\n\n更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。\n\n这也是为什么在糟糕程序员的代码上经常可以发现大量复制&粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&粘贴本身并不是坏事，但只有在下面这些情况下：\n\n你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）\n\n确信复制＆粘贴的代码会有效工作\n\n只用于测试/检验\n\n糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。\n\n此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。\n\n总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。\n\n糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。\n\n每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。\n\n### 优秀的开发人员\n\n经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。\n\n有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。\n\n的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。\n\n那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。\n\n### 真正优秀的开发人员\n\n下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：\n\n> 乐于助人的开发人员\n\nMVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。\n\n由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。\n\nMVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。\n\n最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。\n\n### 总结\n\n要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。\n\n[转载自：http://www.codeceo.com/article/bad-programming-style.html](http://www.codeceo.com/article/bad-programming-style.html)\n","source":"_posts/糟糕程序员的编程风格.md","raw":"---\ntitle: 糟糕程序员的编程风格\ntags: [其它]\ndate: 2016/02/17\n---\n\n> 有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？\n\n### 糟糕的开发人员\n\n如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。\n\n首先让我们先来了解关于糟糕的开发人员的两种主要类型：\n\n**平庸的开发人员**\n\n从本质来看，这两者是相同的，但是它们通常表现出不同的行为。\n\n**牛仔程序员**\n\n牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。\n\n那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？\n\n1、编码速度非常快\n\n通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。\n\n牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……\n\n2、凌乱、不可读的代码\n\n快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。\n\n凌乱的代码会导致……\n\n3、Bug，无处不在的bug\n\n如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。\n\n更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。\n\n总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。\n\n如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。\n\n### 自大\n\n有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。\n\n这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。\n\n只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。\n\n使得这些程序员变得糟糕的最重要的属性，是自大。\n\n糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。\n\n更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。\n\n最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。\n\n请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。\n\n### 平庸的开发者\n\n这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。\n\n不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。\n\n也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。\n\n关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。\n\n### 问题的核心\n\n促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。\n\n更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。\n\n这也是为什么在糟糕程序员的代码上经常可以发现大量复制&粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&粘贴本身并不是坏事，但只有在下面这些情况下：\n\n你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）\n\n确信复制＆粘贴的代码会有效工作\n\n只用于测试/检验\n\n糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。\n\n此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。\n\n总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。\n\n糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。\n\n每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。\n\n### 优秀的开发人员\n\n经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。\n\n有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。\n\n的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。\n\n那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。\n\n### 真正优秀的开发人员\n\n下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：\n\n> 乐于助人的开发人员\n\nMVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。\n\n由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。\n\nMVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。\n\n最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。\n\n### 总结\n\n要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。\n\n[转载自：http://www.codeceo.com/article/bad-programming-style.html](http://www.codeceo.com/article/bad-programming-style.html)\n","slug":"糟糕程序员的编程风格","published":1,"updated":"2016-08-17T06:22:19.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpms005f68ddm18hpb1s","content":"<blockquote>\n<p>有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？</p>\n</blockquote>\n<h3 id=\"糟糕的开发人员\"><a href=\"#糟糕的开发人员\" class=\"headerlink\" title=\"糟糕的开发人员\"></a>糟糕的开发人员</h3><p>如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。</p>\n<p>首先让我们先来了解关于糟糕的开发人员的两种主要类型：</p>\n<p><strong>平庸的开发人员</strong></p>\n<p>从本质来看，这两者是相同的，但是它们通常表现出不同的行为。</p>\n<p><strong>牛仔程序员</strong></p>\n<p>牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。</p>\n<p>那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？</p>\n<p>1、编码速度非常快</p>\n<p>通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。</p>\n<p>牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……</p>\n<p>2、凌乱、不可读的代码</p>\n<p>快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。</p>\n<p>凌乱的代码会导致……</p>\n<p>3、Bug，无处不在的bug</p>\n<p>如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。</p>\n<p>更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。</p>\n<p>总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。</p>\n<p>如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。</p>\n<h3 id=\"自大\"><a href=\"#自大\" class=\"headerlink\" title=\"自大\"></a>自大</h3><p>有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。</p>\n<p>这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。</p>\n<p>只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。</p>\n<p>使得这些程序员变得糟糕的最重要的属性，是自大。</p>\n<p>糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。</p>\n<p>更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。</p>\n<p>最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。</p>\n<p>请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。</p>\n<h3 id=\"平庸的开发者\"><a href=\"#平庸的开发者\" class=\"headerlink\" title=\"平庸的开发者\"></a>平庸的开发者</h3><p>这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。</p>\n<p>不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。</p>\n<p>也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。</p>\n<p>关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。</p>\n<h3 id=\"问题的核心\"><a href=\"#问题的核心\" class=\"headerlink\" title=\"问题的核心\"></a>问题的核心</h3><p>促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。</p>\n<p>更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。</p>\n<p>这也是为什么在糟糕程序员的代码上经常可以发现大量复制&amp;粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&amp;粘贴本身并不是坏事，但只有在下面这些情况下：</p>\n<p>你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）</p>\n<p>确信复制＆粘贴的代码会有效工作</p>\n<p>只用于测试/检验</p>\n<p>糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。</p>\n<p>此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。</p>\n<p>总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。</p>\n<p>糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。</p>\n<p>每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。</p>\n<h3 id=\"优秀的开发人员\"><a href=\"#优秀的开发人员\" class=\"headerlink\" title=\"优秀的开发人员\"></a>优秀的开发人员</h3><p>经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。</p>\n<p>有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。</p>\n<p>的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。</p>\n<p>那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。</p>\n<h3 id=\"真正优秀的开发人员\"><a href=\"#真正优秀的开发人员\" class=\"headerlink\" title=\"真正优秀的开发人员\"></a>真正优秀的开发人员</h3><p>下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：</p>\n<blockquote>\n<p>乐于助人的开发人员</p>\n</blockquote>\n<p>MVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。</p>\n<p>由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。</p>\n<p>MVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。</p>\n<p>最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。</p>\n<p><a href=\"http://www.codeceo.com/article/bad-programming-style.html\" target=\"_blank\" rel=\"external\">转载自：http://www.codeceo.com/article/bad-programming-style.html</a></p>\n","excerpt":"","more":"<blockquote>\n<p>有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？</p>\n</blockquote>\n<h3 id=\"糟糕的开发人员\"><a href=\"#糟糕的开发人员\" class=\"headerlink\" title=\"糟糕的开发人员\"></a>糟糕的开发人员</h3><p>如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。</p>\n<p>首先让我们先来了解关于糟糕的开发人员的两种主要类型：</p>\n<p><strong>平庸的开发人员</strong></p>\n<p>从本质来看，这两者是相同的，但是它们通常表现出不同的行为。</p>\n<p><strong>牛仔程序员</strong></p>\n<p>牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。</p>\n<p>那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？</p>\n<p>1、编码速度非常快</p>\n<p>通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。</p>\n<p>牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……</p>\n<p>2、凌乱、不可读的代码</p>\n<p>快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。</p>\n<p>凌乱的代码会导致……</p>\n<p>3、Bug，无处不在的bug</p>\n<p>如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。</p>\n<p>更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。</p>\n<p>总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。</p>\n<p>如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。</p>\n<h3 id=\"自大\"><a href=\"#自大\" class=\"headerlink\" title=\"自大\"></a>自大</h3><p>有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。</p>\n<p>这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。</p>\n<p>只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。</p>\n<p>使得这些程序员变得糟糕的最重要的属性，是自大。</p>\n<p>糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。</p>\n<p>更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。</p>\n<p>最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。</p>\n<p>请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。</p>\n<h3 id=\"平庸的开发者\"><a href=\"#平庸的开发者\" class=\"headerlink\" title=\"平庸的开发者\"></a>平庸的开发者</h3><p>这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。</p>\n<p>不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。</p>\n<p>也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。</p>\n<p>关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。</p>\n<h3 id=\"问题的核心\"><a href=\"#问题的核心\" class=\"headerlink\" title=\"问题的核心\"></a>问题的核心</h3><p>促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。</p>\n<p>更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。</p>\n<p>这也是为什么在糟糕程序员的代码上经常可以发现大量复制&amp;粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&amp;粘贴本身并不是坏事，但只有在下面这些情况下：</p>\n<p>你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）</p>\n<p>确信复制＆粘贴的代码会有效工作</p>\n<p>只用于测试/检验</p>\n<p>糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。</p>\n<p>此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。</p>\n<p>总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。</p>\n<p>糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。</p>\n<p>每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。</p>\n<h3 id=\"优秀的开发人员\"><a href=\"#优秀的开发人员\" class=\"headerlink\" title=\"优秀的开发人员\"></a>优秀的开发人员</h3><p>经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。</p>\n<p>有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。</p>\n<p>的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。</p>\n<p>那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。</p>\n<h3 id=\"真正优秀的开发人员\"><a href=\"#真正优秀的开发人员\" class=\"headerlink\" title=\"真正优秀的开发人员\"></a>真正优秀的开发人员</h3><p>下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：</p>\n<blockquote>\n<p>乐于助人的开发人员</p>\n</blockquote>\n<p>MVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。</p>\n<p>由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。</p>\n<p>MVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。</p>\n<p>最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。</p>\n<p><a href=\"http://www.codeceo.com/article/bad-programming-style.html\">转载自：http://www.codeceo.com/article/bad-programming-style.html</a></p>\n"},{"title":"网页字体设置你了解吗","date":"2015-01-28T16:00:00.000Z","_content":"\n以前做项目的时候就依葫芦画瓢的设置 { font-family:arial,”microsoft yahei”,simsun,sans-self; } 等类似的字体，然而当更多的设备和系统出现后，以前这样的设置已不能满足网页在各设备上的显示需求。\n\n就拿最简单的宋体(simsun)来说吧，在Windows系统下显示是一个比较容易阅读的字体，然而在Mac上简直无法直视，如下图给出一个优化前后页面的对比效果：\n\n![字体优化前后对比图](http://77l54v.com1.z0.glb.clouddn.com/%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg)\n\n因此，出于种种原因，促使我不得不去对字体做一个相应的了解。\n\n对于网站字体设置，本文给出以下意见：\n\n移动端项目：\n\n```\nfont-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,sans-self;\n```\n\npc端(含Mac)项目：\n\n```\nfont-family:Tahoma,Arial,”Helvetica Neue“,”Hiragino Sans GB”,Simsun,sans-self;\n```\n\n移动和pc端项目：\n\n```\nfont-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,”Hiragino Sans GB”,Simsun,sans-self;\n```\n\n首先说说字体的种类，字体分为五大种类，然而各设备的支持情况也个不相同，如，\n\n各移动设备系统支持情况：\n\n| 五大类字体           | 安卓4.0 | IOS6.0 | WP8  |\n| --------------- | ----- | ------ | ---- |\n| sans-serif（无衬线） | 支持    | 支持     | 支持   |\n| serif（衬线）       | 支持    | 支持     | 支持   |\n| monospace（等宽）   | 支持    | 支持     | 支持   |\n| fantasy（梦幻）     | 不支持   | 支持     | 不支持  |\n| cuisive（草体）     | 不支持   | 不支持    | 不支持  |\n\n\n当然目前这只是移动设备各系统的支持情况，然而pc端个浏览器的支持情况也各不相同，如：\n\n| 五大类字体           | IE系列 | Chrome | Firefox |\n| --------------- | ---- | ------ | ------- |\n| sans-serif（无衬线） | 支持   | 不支持    | 不支持     |\n| serif（衬线）       | 支持   | 支持     | 支持      |\n| monospace（等宽）   | 支持   | 支持     | 支持      |\n| fantasy（梦幻）     | 支持   | 支持     | 支持      |\n| cuisive（草体）     | 不支持  | 不支持    | 不支持     |\n\n\n下面介绍下个系统的默认字体和常用字体：\n\n| 系统               | 默认西文字体         | 默认中文字体                       | 其他常用西文字体                           | 其他常用中文字体                |\n| ---------------- | -------------- | ---------------------------- | ---------------------------------- | ----------------------- |\n| Windows          | 宋体             | 宋体                           | Tahoma、Arial、Verdana、Georgia       | 微软雅黑、黑体                 |\n| Android 4.0以下    | Droid Sans     | Droid Sans Fallback          | Arial                              | 无宋体、无微软雅黑               |\n| Android 4.0及以上   | Roboto         | Roboto                       | Arial                              | 无宋体、无微软雅黑               |\n| iOS              | Helvetica Neue | Heiti SC (黑体)                | Tahoma(v7.0)、Arial、Verdana、Georgia | STHeiti(v7.0)、无宋体、无微软雅黑 |\n| Mac OS X 10.6以下  | Helvetica Neue | STHeiti (华文黑体)               | Tahoma、Arial、Verdana、Georgia       | 宋体、无微软雅黑                |\n| Mac OS X 10.6及以上 | Helvetica Neue | Hiragino Sans GB  (冬青黑体简体中文) | Tahoma、Arial、Verdana、Georgia       | 宋体、无微软雅黑                |\n\n参考资料：iOS6字体列表、iOS7字体列表、Mac OS X  10.6字体列表、Mac OS X 10.7字体列表等，在看了一些资料之后，对系统和浏览器下的字体就有了一个基本的认识。\n\n有很多同学看到上面这些表格里面的结论，可能就会想到：可以只设置西文字体不设置中文字体。\n\n只设置西文字体不设置中文字体是否可以？答案当然是不可以。因为上面这些系统和浏览器的默认字体也仅仅是是一个理想状态下的设置，这些默认字体仅限于浏览器或系统最初的默认字体。现在的手机都支持字体更换，对于浏览器而已也是如此，现在的浏览器都支持用户自己设置字体。因此，只设置西文字体而忽略中文字体设置是存在一定的危险性的。\n\n对于现在Adroid系统的各种字体app，如：字体管家、字体管理等。如果用户自己下载相关的app字体软件将字体改掉，这种情况下，我们该如何处置？\n\n如果用户将默认的系统字替换掉，那我们就只能用其他的中文字体来代替现实，然而就目前而言，移动端的中文字体非常少（几乎是唯一性），因此，本人还没有找到相应的解决办法，后期找到方法再分享出来。\n\n转载自：[http://web.jobbole.com/85073/](http://web.jobbole.com/85073/)\n","source":"_posts/网页字体设置你了解吗.md","raw":"---\ntitle: 网页字体设置你了解吗\ntags: [html]\ndate: 2015/01/29\n---\n\n以前做项目的时候就依葫芦画瓢的设置 { font-family:arial,”microsoft yahei”,simsun,sans-self; } 等类似的字体，然而当更多的设备和系统出现后，以前这样的设置已不能满足网页在各设备上的显示需求。\n\n就拿最简单的宋体(simsun)来说吧，在Windows系统下显示是一个比较容易阅读的字体，然而在Mac上简直无法直视，如下图给出一个优化前后页面的对比效果：\n\n![字体优化前后对比图](http://77l54v.com1.z0.glb.clouddn.com/%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg)\n\n因此，出于种种原因，促使我不得不去对字体做一个相应的了解。\n\n对于网站字体设置，本文给出以下意见：\n\n移动端项目：\n\n```\nfont-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,sans-self;\n```\n\npc端(含Mac)项目：\n\n```\nfont-family:Tahoma,Arial,”Helvetica Neue“,”Hiragino Sans GB”,Simsun,sans-self;\n```\n\n移动和pc端项目：\n\n```\nfont-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,”Hiragino Sans GB”,Simsun,sans-self;\n```\n\n首先说说字体的种类，字体分为五大种类，然而各设备的支持情况也个不相同，如，\n\n各移动设备系统支持情况：\n\n| 五大类字体           | 安卓4.0 | IOS6.0 | WP8  |\n| --------------- | ----- | ------ | ---- |\n| sans-serif（无衬线） | 支持    | 支持     | 支持   |\n| serif（衬线）       | 支持    | 支持     | 支持   |\n| monospace（等宽）   | 支持    | 支持     | 支持   |\n| fantasy（梦幻）     | 不支持   | 支持     | 不支持  |\n| cuisive（草体）     | 不支持   | 不支持    | 不支持  |\n\n\n当然目前这只是移动设备各系统的支持情况，然而pc端个浏览器的支持情况也各不相同，如：\n\n| 五大类字体           | IE系列 | Chrome | Firefox |\n| --------------- | ---- | ------ | ------- |\n| sans-serif（无衬线） | 支持   | 不支持    | 不支持     |\n| serif（衬线）       | 支持   | 支持     | 支持      |\n| monospace（等宽）   | 支持   | 支持     | 支持      |\n| fantasy（梦幻）     | 支持   | 支持     | 支持      |\n| cuisive（草体）     | 不支持  | 不支持    | 不支持     |\n\n\n下面介绍下个系统的默认字体和常用字体：\n\n| 系统               | 默认西文字体         | 默认中文字体                       | 其他常用西文字体                           | 其他常用中文字体                |\n| ---------------- | -------------- | ---------------------------- | ---------------------------------- | ----------------------- |\n| Windows          | 宋体             | 宋体                           | Tahoma、Arial、Verdana、Georgia       | 微软雅黑、黑体                 |\n| Android 4.0以下    | Droid Sans     | Droid Sans Fallback          | Arial                              | 无宋体、无微软雅黑               |\n| Android 4.0及以上   | Roboto         | Roboto                       | Arial                              | 无宋体、无微软雅黑               |\n| iOS              | Helvetica Neue | Heiti SC (黑体)                | Tahoma(v7.0)、Arial、Verdana、Georgia | STHeiti(v7.0)、无宋体、无微软雅黑 |\n| Mac OS X 10.6以下  | Helvetica Neue | STHeiti (华文黑体)               | Tahoma、Arial、Verdana、Georgia       | 宋体、无微软雅黑                |\n| Mac OS X 10.6及以上 | Helvetica Neue | Hiragino Sans GB  (冬青黑体简体中文) | Tahoma、Arial、Verdana、Georgia       | 宋体、无微软雅黑                |\n\n参考资料：iOS6字体列表、iOS7字体列表、Mac OS X  10.6字体列表、Mac OS X 10.7字体列表等，在看了一些资料之后，对系统和浏览器下的字体就有了一个基本的认识。\n\n有很多同学看到上面这些表格里面的结论，可能就会想到：可以只设置西文字体不设置中文字体。\n\n只设置西文字体不设置中文字体是否可以？答案当然是不可以。因为上面这些系统和浏览器的默认字体也仅仅是是一个理想状态下的设置，这些默认字体仅限于浏览器或系统最初的默认字体。现在的手机都支持字体更换，对于浏览器而已也是如此，现在的浏览器都支持用户自己设置字体。因此，只设置西文字体而忽略中文字体设置是存在一定的危险性的。\n\n对于现在Adroid系统的各种字体app，如：字体管家、字体管理等。如果用户自己下载相关的app字体软件将字体改掉，这种情况下，我们该如何处置？\n\n如果用户将默认的系统字替换掉，那我们就只能用其他的中文字体来代替现实，然而就目前而言，移动端的中文字体非常少（几乎是唯一性），因此，本人还没有找到相应的解决办法，后期找到方法再分享出来。\n\n转载自：[http://web.jobbole.com/85073/](http://web.jobbole.com/85073/)\n","slug":"网页字体设置你了解吗","published":1,"updated":"2016-08-17T06:22:19.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmu005h68ddyfjeb9q5","content":"<p>以前做项目的时候就依葫芦画瓢的设置 { font-family:arial,”microsoft yahei”,simsun,sans-self; } 等类似的字体，然而当更多的设备和系统出现后，以前这样的设置已不能满足网页在各设备上的显示需求。</p>\n<p>就拿最简单的宋体(simsun)来说吧，在Windows系统下显示是一个比较容易阅读的字体，然而在Mac上简直无法直视，如下图给出一个优化前后页面的对比效果：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg\" alt=\"字体优化前后对比图\"></p>\n<p>因此，出于种种原因，促使我不得不去对字体做一个相应的了解。</p>\n<p>对于网站字体设置，本文给出以下意见：</p>\n<p>移动端项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,sans-self;</div></pre></td></tr></table></figure>\n<p>pc端(含Mac)项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,”Helvetica Neue“,”Hiragino Sans GB”,Simsun,sans-self;</div></pre></td></tr></table></figure>\n<p>移动和pc端项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,”Hiragino Sans GB”,Simsun,sans-self;</div></pre></td></tr></table></figure>\n<p>首先说说字体的种类，字体分为五大种类，然而各设备的支持情况也个不相同，如，</p>\n<p>各移动设备系统支持情况：</p>\n<table>\n<thead>\n<tr>\n<th>五大类字体</th>\n<th>安卓4.0</th>\n<th>IOS6.0</th>\n<th>WP8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sans-serif（无衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>serif（衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>monospace（等宽）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>fantasy（梦幻）</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>cuisive（草体）</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<p>当然目前这只是移动设备各系统的支持情况，然而pc端个浏览器的支持情况也各不相同，如：</p>\n<table>\n<thead>\n<tr>\n<th>五大类字体</th>\n<th>IE系列</th>\n<th>Chrome</th>\n<th>Firefox</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sans-serif（无衬线）</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>serif（衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>monospace（等宽）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>fantasy（梦幻）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>cuisive（草体）</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<p>下面介绍下个系统的默认字体和常用字体：</p>\n<table>\n<thead>\n<tr>\n<th>系统</th>\n<th>默认西文字体</th>\n<th>默认中文字体</th>\n<th>其他常用西文字体</th>\n<th>其他常用中文字体</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Windows</td>\n<td>宋体</td>\n<td>宋体</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>微软雅黑、黑体</td>\n</tr>\n<tr>\n<td>Android 4.0以下</td>\n<td>Droid Sans</td>\n<td>Droid Sans Fallback</td>\n<td>Arial</td>\n<td>无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Android 4.0及以上</td>\n<td>Roboto</td>\n<td>Roboto</td>\n<td>Arial</td>\n<td>无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>iOS</td>\n<td>Helvetica Neue</td>\n<td>Heiti SC (黑体)</td>\n<td>Tahoma(v7.0)、Arial、Verdana、Georgia</td>\n<td>STHeiti(v7.0)、无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Mac OS X 10.6以下</td>\n<td>Helvetica Neue</td>\n<td>STHeiti (华文黑体)</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Mac OS X 10.6及以上</td>\n<td>Helvetica Neue</td>\n<td>Hiragino Sans GB  (冬青黑体简体中文)</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>宋体、无微软雅黑</td>\n</tr>\n</tbody>\n</table>\n<p>参考资料：iOS6字体列表、iOS7字体列表、Mac OS X  10.6字体列表、Mac OS X 10.7字体列表等，在看了一些资料之后，对系统和浏览器下的字体就有了一个基本的认识。</p>\n<p>有很多同学看到上面这些表格里面的结论，可能就会想到：可以只设置西文字体不设置中文字体。</p>\n<p>只设置西文字体不设置中文字体是否可以？答案当然是不可以。因为上面这些系统和浏览器的默认字体也仅仅是是一个理想状态下的设置，这些默认字体仅限于浏览器或系统最初的默认字体。现在的手机都支持字体更换，对于浏览器而已也是如此，现在的浏览器都支持用户自己设置字体。因此，只设置西文字体而忽略中文字体设置是存在一定的危险性的。</p>\n<p>对于现在Adroid系统的各种字体app，如：字体管家、字体管理等。如果用户自己下载相关的app字体软件将字体改掉，这种情况下，我们该如何处置？</p>\n<p>如果用户将默认的系统字替换掉，那我们就只能用其他的中文字体来代替现实，然而就目前而言，移动端的中文字体非常少（几乎是唯一性），因此，本人还没有找到相应的解决办法，后期找到方法再分享出来。</p>\n<p>转载自：<a href=\"http://web.jobbole.com/85073/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com/85073/</a></p>\n","excerpt":"","more":"<p>以前做项目的时候就依葫芦画瓢的设置 { font-family:arial,”microsoft yahei”,simsun,sans-self; } 等类似的字体，然而当更多的设备和系统出现后，以前这样的设置已不能满足网页在各设备上的显示需求。</p>\n<p>就拿最简单的宋体(simsun)来说吧，在Windows系统下显示是一个比较容易阅读的字体，然而在Mac上简直无法直视，如下图给出一个优化前后页面的对比效果：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/%E5%AF%B9%E6%AF%94%E5%9B%BE.jpg\" alt=\"字体优化前后对比图\"></p>\n<p>因此，出于种种原因，促使我不得不去对字体做一个相应的了解。</p>\n<p>对于网站字体设置，本文给出以下意见：</p>\n<p>移动端项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,sans-self;</div></pre></td></tr></table></figure>\n<p>pc端(含Mac)项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,”Helvetica Neue“,”Hiragino Sans GB”,Simsun,sans-self;</div></pre></td></tr></table></figure>\n<p>移动和pc端项目：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">font-family:Tahoma,Arial,Roboto,”Droid Sans”,”Helvetica Neue”,”Droid Sans Fallback”,”Heiti SC”,”Hiragino Sans GB”,Simsun,sans-self;</div></pre></td></tr></table></figure>\n<p>首先说说字体的种类，字体分为五大种类，然而各设备的支持情况也个不相同，如，</p>\n<p>各移动设备系统支持情况：</p>\n<table>\n<thead>\n<tr>\n<th>五大类字体</th>\n<th>安卓4.0</th>\n<th>IOS6.0</th>\n<th>WP8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sans-serif（无衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>serif（衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>monospace（等宽）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>fantasy（梦幻）</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>cuisive（草体）</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<p>当然目前这只是移动设备各系统的支持情况，然而pc端个浏览器的支持情况也各不相同，如：</p>\n<table>\n<thead>\n<tr>\n<th>五大类字体</th>\n<th>IE系列</th>\n<th>Chrome</th>\n<th>Firefox</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>sans-serif（无衬线）</td>\n<td>支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>serif（衬线）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>monospace（等宽）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>fantasy（梦幻）</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>cuisive（草体）</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<p>下面介绍下个系统的默认字体和常用字体：</p>\n<table>\n<thead>\n<tr>\n<th>系统</th>\n<th>默认西文字体</th>\n<th>默认中文字体</th>\n<th>其他常用西文字体</th>\n<th>其他常用中文字体</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Windows</td>\n<td>宋体</td>\n<td>宋体</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>微软雅黑、黑体</td>\n</tr>\n<tr>\n<td>Android 4.0以下</td>\n<td>Droid Sans</td>\n<td>Droid Sans Fallback</td>\n<td>Arial</td>\n<td>无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Android 4.0及以上</td>\n<td>Roboto</td>\n<td>Roboto</td>\n<td>Arial</td>\n<td>无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>iOS</td>\n<td>Helvetica Neue</td>\n<td>Heiti SC (黑体)</td>\n<td>Tahoma(v7.0)、Arial、Verdana、Georgia</td>\n<td>STHeiti(v7.0)、无宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Mac OS X 10.6以下</td>\n<td>Helvetica Neue</td>\n<td>STHeiti (华文黑体)</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>宋体、无微软雅黑</td>\n</tr>\n<tr>\n<td>Mac OS X 10.6及以上</td>\n<td>Helvetica Neue</td>\n<td>Hiragino Sans GB  (冬青黑体简体中文)</td>\n<td>Tahoma、Arial、Verdana、Georgia</td>\n<td>宋体、无微软雅黑</td>\n</tr>\n</tbody>\n</table>\n<p>参考资料：iOS6字体列表、iOS7字体列表、Mac OS X  10.6字体列表、Mac OS X 10.7字体列表等，在看了一些资料之后，对系统和浏览器下的字体就有了一个基本的认识。</p>\n<p>有很多同学看到上面这些表格里面的结论，可能就会想到：可以只设置西文字体不设置中文字体。</p>\n<p>只设置西文字体不设置中文字体是否可以？答案当然是不可以。因为上面这些系统和浏览器的默认字体也仅仅是是一个理想状态下的设置，这些默认字体仅限于浏览器或系统最初的默认字体。现在的手机都支持字体更换，对于浏览器而已也是如此，现在的浏览器都支持用户自己设置字体。因此，只设置西文字体而忽略中文字体设置是存在一定的危险性的。</p>\n<p>对于现在Adroid系统的各种字体app，如：字体管家、字体管理等。如果用户自己下载相关的app字体软件将字体改掉，这种情况下，我们该如何处置？</p>\n<p>如果用户将默认的系统字替换掉，那我们就只能用其他的中文字体来代替现实，然而就目前而言，移动端的中文字体非常少（几乎是唯一性），因此，本人还没有找到相应的解决办法，后期找到方法再分享出来。</p>\n<p>转载自：<a href=\"http://web.jobbole.com/85073/\">http://web.jobbole.com/85073/</a></p>\n"},{"title":"解决IE下a标签点击有虚线边框的问题","date":"2015-02-15T16:00:00.000Z","_content":"\n```\na:focus{outline:none;}\n```\n\n其它浏览器可以加入\n\n```\n*{outline:none;}\n```\n","source":"_posts/解决IE下a标签点击有虚线边框的问题.md","raw":"---\ntitle: 解决IE下a标签点击有虚线边框的问题\ntags: [html,css]\ndate: 2015/02/16\n---\n\n```\na:focus{outline:none;}\n```\n\n其它浏览器可以加入\n\n```\n*{outline:none;}\n```\n","slug":"解决IE下a标签点击有虚线边框的问题","published":1,"updated":"2016-08-17T06:22:19.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmv005k68ddjctycwnm","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a:focus&#123;outline:none;&#125;</div></pre></td></tr></table></figure>\n<p>其它浏览器可以加入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">*&#123;outline:none;&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">a:focus&#123;outline:none;&#125;</div></pre></td></tr></table></figure>\n<p>其它浏览器可以加入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">*&#123;outline:none;&#125;</div></pre></td></tr></table></figure>\n"},{"title":"让ubuntu 终端显示英文提示，而桌面环境显示中文的方法","date":"2014-01-01T16:00:00.000Z","_content":"\n让ubuntu 终端显示英文提示，而桌面环境显示中文的方法，打开终端：\n\n```\n$ vi .bashrc\n```\n\n在最后面加入如下代码：\n\n```\nif [ \"$TERM\"=\"linux\" ] ;then\n\nexport LANG=C\n\nfi\n```\n\n关闭当前终端，重新打开终端后命令中的提示就显示英文提示了。\n","source":"_posts/让ubuntu 终端显示英文提示，而桌面环境显示中文的方法.md","raw":"---\ntitle: 让ubuntu 终端显示英文提示，而桌面环境显示中文的方法\ntags: [linux,ubuntu]\ndate: 2014/01/02\n---\n\n让ubuntu 终端显示英文提示，而桌面环境显示中文的方法，打开终端：\n\n```\n$ vi .bashrc\n```\n\n在最后面加入如下代码：\n\n```\nif [ \"$TERM\"=\"linux\" ] ;then\n\nexport LANG=C\n\nfi\n```\n\n关闭当前终端，重新打开终端后命令中的提示就显示英文提示了。\n","slug":"让ubuntu 终端显示英文提示，而桌面环境显示中文的方法","published":1,"updated":"2016-08-17T06:22:19.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmx005m68ddz2pitjdt","content":"<p>让ubuntu 终端显示英文提示，而桌面环境显示中文的方法，打开终端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vi .bashrc</div></pre></td></tr></table></figure>\n<p>在最后面加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if [ &quot;$TERM&quot;=&quot;linux&quot; ] ;then</div><div class=\"line\"></div><div class=\"line\">export LANG=C</div><div class=\"line\"></div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>关闭当前终端，重新打开终端后命令中的提示就显示英文提示了。</p>\n","excerpt":"","more":"<p>让ubuntu 终端显示英文提示，而桌面环境显示中文的方法，打开终端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ vi .bashrc</div></pre></td></tr></table></figure>\n<p>在最后面加入如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if [ &quot;$TERM&quot;=&quot;linux&quot; ] ;then</div><div class=\"line\"></div><div class=\"line\">export LANG=C</div><div class=\"line\"></div><div class=\"line\">fi</div></pre></td></tr></table></figure>\n<p>关闭当前终端，重新打开终端后命令中的提示就显示英文提示了。</p>\n"},{"title":"解决g++command not found","date":"2013-10-10T16:00:00.000Z","_content":"\n在安装一些包的时候，遇到g++:command not found error,这是由于系统缺失相对应的包\n\n1-在发现该错误时，先在系统中确认是否缺失相对应的包：\nrpm -qa | grep \"g++\"\n\n2-在确认系统未安装之后，查询可安装的相对应的功能的包：\nyum whatprovides \"*/g++\"\n\n3-根据提供的包，选择适合系统的进行安装：\nyum install gcc-c++-4.4.7-4.el6.x86_64\n\n4-安装结束之后，新开terminal，重新继续初始操作；\n\n***一定要选择与系统相匹配的包进行安装***\n","source":"_posts/解决g++command not found.md","raw":"---\ntitle: 解决g++command not found\ntags: [linux]\ndate: 2013/10/11\n---\n\n在安装一些包的时候，遇到g++:command not found error,这是由于系统缺失相对应的包\n\n1-在发现该错误时，先在系统中确认是否缺失相对应的包：\nrpm -qa | grep \"g++\"\n\n2-在确认系统未安装之后，查询可安装的相对应的功能的包：\nyum whatprovides \"*/g++\"\n\n3-根据提供的包，选择适合系统的进行安装：\nyum install gcc-c++-4.4.7-4.el6.x86_64\n\n4-安装结束之后，新开terminal，重新继续初始操作；\n\n***一定要选择与系统相匹配的包进行安装***\n","slug":"解决g++command not found","published":1,"updated":"2016-08-23T07:18:49.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpmz005o68dd4iv6m4fa","content":"<p>在安装一些包的时候，遇到g++:command not found error,这是由于系统缺失相对应的包</p>\n<p>1-在发现该错误时，先在系统中确认是否缺失相对应的包：<br>rpm -qa | grep “g++”</p>\n<p>2-在确认系统未安装之后，查询可安装的相对应的功能的包：<br>yum whatprovides “*/g++”</p>\n<p>3-根据提供的包，选择适合系统的进行安装：<br>yum install gcc-c++-4.4.7-4.el6.x86_64</p>\n<p>4-安装结束之后，新开terminal，重新继续初始操作；</p>\n<p><strong><em>一定要选择与系统相匹配的包进行安装</em></strong></p>\n","excerpt":"","more":"<p>在安装一些包的时候，遇到g++:command not found error,这是由于系统缺失相对应的包</p>\n<p>1-在发现该错误时，先在系统中确认是否缺失相对应的包：<br>rpm -qa | grep “g++”</p>\n<p>2-在确认系统未安装之后，查询可安装的相对应的功能的包：<br>yum whatprovides “*/g++”</p>\n<p>3-根据提供的包，选择适合系统的进行安装：<br>yum install gcc-c++-4.4.7-4.el6.x86_64</p>\n<p>4-安装结束之后，新开terminal，重新继续初始操作；</p>\n<p><strong><em>一定要选择与系统相匹配的包进行安装</em></strong></p>\n"},{"title":"记一次淘宝首页奇葩的渲染问题","date":"2015-08-10T16:00:00.000Z","_content":"\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题1.jpg)\n\n或许你曾经在 Chrome 浏览器上碰到过这样让人瞠目结舌的问题：\n\n+ hover 触发一个层展示，hover 离开后，这个层还遗留残影\n+ 浏览器没有清理一个元素渲染的上一个状态，导致页面多出一个错位的跟该元素一模一样的影子\n+ 交互时突然出现一个方形色块，覆盖在元素上\n+ 或者还有更奇葩的……\n\n以上列举到的三个问题，我在维护淘宝首页的时候都遇到过。这些都是浏览器渲染页面时，因为渲染引擎的 bug 导致的问题，不常见，更加难以写 demo 演示，它们只在特定的复杂场景下，程序计算存在误差或者漏洞的时候出现，尤其是涉及到边界判断的时候。\n\n***问题复现***\n\n很难得有机会让我碰到一个可以复现的，我把它记录下来了。如下图所示，hover 到学习模块的边界位置时：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题2.gif)\n\n手动 hover 和模拟 hover 都有一样的问题，没有多想，立马加上了一句话修复了这个问题:\n\n```\n.channel2 .channel-item {\n    transform: translateZ(0);\n}\n\n.channel2 .channel-item {\n    transform: translateZ(0);\n}\n```\n\n这个不是直觉，多次遇到这种奇葩问题，我第一想到的便是使用 3D 加速将这个渲染层隔离渲染，80% 以上的概率能够解决问题，而解决问题的关键在于找准加这句代码的 DOM 元素。\n\n***探索 bug***\n\n这个层在我的代码中肯定是不存在的，我们只能用 bug 来形容这个问题。因为元素刚好贴在 .channel2 的边界，猜测应该跟层渲染有关，于是打开了控制台 ESC -> Rendering -> Show layer borders，看到了这个:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题3.gif)\n\n仔细观察，可以看到，这个粉色块在瓦片边界和父元素边界之中，可以断定，这几个瓦片在渲染的时候存在问题。\n\n这里需要补充下关于瓦片的知识。瓦片，英文里头称之为 tile，它是 webkit/blink 渲染页面时的中间过程，将整个页面分成多个大小一样的瓦片，并发渲染每个瓦片的内容。一个元素开启 3D 硬件加速之后，会变成一个独立的层，这个层的渲染也会被分割成瓦片，可以想象成一个子页面。\n\n瓦片和瓦片之间的边界计算是处理的难点，因为渲染的内容不能错位。\n\n其实让我找到问题根本原因的是，rendering 块的颜色，平时在网页上开启 show layer borders 看到的是半透明的绿色块，而这里显示的是粉色块，搜索了下不同色块代表的含义，没找到具体的文档说明，但是找到了 代码:\n\n```\n// Missing resize invalidations are in salmon pink.\nSkColor DebugColors::MissingResizeInvalidations() {\n  return SkColorSetARGB(255, 255, 155, 170);\n}\n\n// Missing resize invalidations are in salmon pink.\nSkColor DebugColors::MissingResizeInvalidations() {\n  return SkColorSetARGB(255, 255, 155, 170);\n}\n```\n\n对应的就是这个颜色，“缺失调整验证”，在 chromium 的源码仓库中搜了上面的代码，找到了 具体说明:\n\n```\nif (!deflated_content_rect.Contains(canvas_playback_rect)) {\n  if (clear_canvas_with_debug_color) {\n    // Any non-painted areas outside of the content bounds are left in\n    // this color.  If this is seen then it means that cc neglected to\n    // rerasterize a tile that used to intersect with the content rect\n    // after the content bounds grew.\n    canvas->save();\n    canvas->translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());\n    canvas->clipRect(gfx::RectToSkRect(content_rect),\n                     SkRegion::kDifference_Op);\n    canvas->drawColor(DebugColors::MissingResizeInvalidations(),\n                      SkXfermode::kSrc_Mode);\n    canvas->restore();\n  }\n}\n\nif (!deflated_content_rect.Contains(canvas_playback_rect)) {\n  if (clear_canvas_with_debug_color) {\n    // Any non-painted areas outside of the content bounds are left in\n    // this color.  If this is seen then it means that cc neglected to\n    // rerasterize a tile that used to intersect with the content rect\n    // after the content bounds grew.\n    canvas->save();\n    canvas->translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());\n    canvas->clipRect(gfx::RectToSkRect(content_rect),\n                     SkRegion::kDifference_Op);\n    canvas->drawColor(DebugColors::MissingResizeInvalidations(),\n                      SkXfermode::kSrc_Mode);\n    canvas->restore();\n  }\n}\n```\n\n这里能看的肯定就是注释啦，没有太多上下文，看的挺头痛！大致翻译了下上下几段注释:\n\n>1. 即使完全覆盖，对于触碰到渲染层边界的栅格化处理，我们依然需要，在上次记录没有覆盖到的纹理下方和纹理化线性过滤的上方，栅格化处理背景颜色。\n>2. 内容的最后的纹理可能只有部分被栅格覆盖\n>3. 在内容边界外没有被渲染到的部分将使用 MissingResizeInvalidations 颜色，如果这个块能够被看见，那就意味着程序忽视处理了内边边界增长之后栅格化与内容相交的瓦片。\n\n从第三句大致可以了解到，因为元素的边界增长导致了这个渲染 bug，回头看了下元素的边界状态，果然…\n\n***直接原因***\n\n我们看看 hover 上去之后，层边界的变化:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题4.gif)\n\n很明显，这里的高度溢出了，但是没有处理，看了下这个元素的 css，确实高度上没有做处理，在元素上添加\n\n```\n.channel-item {\n  overflow: hidden；\n}\n\n.channel-item {\n  overflow: hidden；\n}\n```\n\n同样可以解决问题。\n\n最后的解决手段:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题5.gif)\n\n层渲染的问题我还是比较喜欢使用 3d 硬件加速来处理，而 overflow:hidden 这样的 css 布局处理上，我是不太推荐的，搞不好就把哪个重要的内容隐藏掉了。\n\n***类似问题处理方案***\n\n如果以后大家遇到类似的问题，可以打开 chrome 的层和瓦片分析工具，看看渲染出来的块有没有异常色块，尤其是粉色块。也可以观察交互过程中，元素的边界有没有变化。\n\nCSS 在浏览器中的渲染是我们触及比较少的知识，如果想迅速找到问题，必须对浏览器的渲染原理有所了解，并且能够熟练的使用 chrome 提供的调试工具，这是基础。\n","source":"_posts/记一次淘宝首页奇葩的渲染问题.md","raw":"---\ntitle: 记一次淘宝首页奇葩的渲染问题\ntags: [html,css]\ndate: 2015/08/11\n---\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题1.jpg)\n\n或许你曾经在 Chrome 浏览器上碰到过这样让人瞠目结舌的问题：\n\n+ hover 触发一个层展示，hover 离开后，这个层还遗留残影\n+ 浏览器没有清理一个元素渲染的上一个状态，导致页面多出一个错位的跟该元素一模一样的影子\n+ 交互时突然出现一个方形色块，覆盖在元素上\n+ 或者还有更奇葩的……\n\n以上列举到的三个问题，我在维护淘宝首页的时候都遇到过。这些都是浏览器渲染页面时，因为渲染引擎的 bug 导致的问题，不常见，更加难以写 demo 演示，它们只在特定的复杂场景下，程序计算存在误差或者漏洞的时候出现，尤其是涉及到边界判断的时候。\n\n***问题复现***\n\n很难得有机会让我碰到一个可以复现的，我把它记录下来了。如下图所示，hover 到学习模块的边界位置时：\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题2.gif)\n\n手动 hover 和模拟 hover 都有一样的问题，没有多想，立马加上了一句话修复了这个问题:\n\n```\n.channel2 .channel-item {\n    transform: translateZ(0);\n}\n\n.channel2 .channel-item {\n    transform: translateZ(0);\n}\n```\n\n这个不是直觉，多次遇到这种奇葩问题，我第一想到的便是使用 3D 加速将这个渲染层隔离渲染，80% 以上的概率能够解决问题，而解决问题的关键在于找准加这句代码的 DOM 元素。\n\n***探索 bug***\n\n这个层在我的代码中肯定是不存在的，我们只能用 bug 来形容这个问题。因为元素刚好贴在 .channel2 的边界，猜测应该跟层渲染有关，于是打开了控制台 ESC -> Rendering -> Show layer borders，看到了这个:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题3.gif)\n\n仔细观察，可以看到，这个粉色块在瓦片边界和父元素边界之中，可以断定，这几个瓦片在渲染的时候存在问题。\n\n这里需要补充下关于瓦片的知识。瓦片，英文里头称之为 tile，它是 webkit/blink 渲染页面时的中间过程，将整个页面分成多个大小一样的瓦片，并发渲染每个瓦片的内容。一个元素开启 3D 硬件加速之后，会变成一个独立的层，这个层的渲染也会被分割成瓦片，可以想象成一个子页面。\n\n瓦片和瓦片之间的边界计算是处理的难点，因为渲染的内容不能错位。\n\n其实让我找到问题根本原因的是，rendering 块的颜色，平时在网页上开启 show layer borders 看到的是半透明的绿色块，而这里显示的是粉色块，搜索了下不同色块代表的含义，没找到具体的文档说明，但是找到了 代码:\n\n```\n// Missing resize invalidations are in salmon pink.\nSkColor DebugColors::MissingResizeInvalidations() {\n  return SkColorSetARGB(255, 255, 155, 170);\n}\n\n// Missing resize invalidations are in salmon pink.\nSkColor DebugColors::MissingResizeInvalidations() {\n  return SkColorSetARGB(255, 255, 155, 170);\n}\n```\n\n对应的就是这个颜色，“缺失调整验证”，在 chromium 的源码仓库中搜了上面的代码，找到了 具体说明:\n\n```\nif (!deflated_content_rect.Contains(canvas_playback_rect)) {\n  if (clear_canvas_with_debug_color) {\n    // Any non-painted areas outside of the content bounds are left in\n    // this color.  If this is seen then it means that cc neglected to\n    // rerasterize a tile that used to intersect with the content rect\n    // after the content bounds grew.\n    canvas->save();\n    canvas->translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());\n    canvas->clipRect(gfx::RectToSkRect(content_rect),\n                     SkRegion::kDifference_Op);\n    canvas->drawColor(DebugColors::MissingResizeInvalidations(),\n                      SkXfermode::kSrc_Mode);\n    canvas->restore();\n  }\n}\n\nif (!deflated_content_rect.Contains(canvas_playback_rect)) {\n  if (clear_canvas_with_debug_color) {\n    // Any non-painted areas outside of the content bounds are left in\n    // this color.  If this is seen then it means that cc neglected to\n    // rerasterize a tile that used to intersect with the content rect\n    // after the content bounds grew.\n    canvas->save();\n    canvas->translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());\n    canvas->clipRect(gfx::RectToSkRect(content_rect),\n                     SkRegion::kDifference_Op);\n    canvas->drawColor(DebugColors::MissingResizeInvalidations(),\n                      SkXfermode::kSrc_Mode);\n    canvas->restore();\n  }\n}\n```\n\n这里能看的肯定就是注释啦，没有太多上下文，看的挺头痛！大致翻译了下上下几段注释:\n\n>1. 即使完全覆盖，对于触碰到渲染层边界的栅格化处理，我们依然需要，在上次记录没有覆盖到的纹理下方和纹理化线性过滤的上方，栅格化处理背景颜色。\n>2. 内容的最后的纹理可能只有部分被栅格覆盖\n>3. 在内容边界外没有被渲染到的部分将使用 MissingResizeInvalidations 颜色，如果这个块能够被看见，那就意味着程序忽视处理了内边边界增长之后栅格化与内容相交的瓦片。\n\n从第三句大致可以了解到，因为元素的边界增长导致了这个渲染 bug，回头看了下元素的边界状态，果然…\n\n***直接原因***\n\n我们看看 hover 上去之后，层边界的变化:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题4.gif)\n\n很明显，这里的高度溢出了，但是没有处理，看了下这个元素的 css，确实高度上没有做处理，在元素上添加\n\n```\n.channel-item {\n  overflow: hidden；\n}\n\n.channel-item {\n  overflow: hidden；\n}\n```\n\n同样可以解决问题。\n\n最后的解决手段:\n\n![图片](http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题5.gif)\n\n层渲染的问题我还是比较喜欢使用 3d 硬件加速来处理，而 overflow:hidden 这样的 css 布局处理上，我是不太推荐的，搞不好就把哪个重要的内容隐藏掉了。\n\n***类似问题处理方案***\n\n如果以后大家遇到类似的问题，可以打开 chrome 的层和瓦片分析工具，看看渲染出来的块有没有异常色块，尤其是粉色块。也可以观察交互过程中，元素的边界有没有变化。\n\nCSS 在浏览器中的渲染是我们触及比较少的知识，如果想迅速找到问题，必须对浏览器的渲染原理有所了解，并且能够熟练的使用 chrome 提供的调试工具，这是基础。\n","slug":"记一次淘宝首页奇葩的渲染问题","published":1,"updated":"2016-08-17T06:22:19.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpn1005r68ddb20284jf","content":"<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题1.jpg\" alt=\"图片\"></p>\n<p>或许你曾经在 Chrome 浏览器上碰到过这样让人瞠目结舌的问题：</p>\n<ul>\n<li>hover 触发一个层展示，hover 离开后，这个层还遗留残影</li>\n<li>浏览器没有清理一个元素渲染的上一个状态，导致页面多出一个错位的跟该元素一模一样的影子</li>\n<li>交互时突然出现一个方形色块，覆盖在元素上</li>\n<li>或者还有更奇葩的……</li>\n</ul>\n<p>以上列举到的三个问题，我在维护淘宝首页的时候都遇到过。这些都是浏览器渲染页面时，因为渲染引擎的 bug 导致的问题，不常见，更加难以写 demo 演示，它们只在特定的复杂场景下，程序计算存在误差或者漏洞的时候出现，尤其是涉及到边界判断的时候。</p>\n<p><strong><em>问题复现</em></strong></p>\n<p>很难得有机会让我碰到一个可以复现的，我把它记录下来了。如下图所示，hover 到学习模块的边界位置时：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题2.gif\" alt=\"图片\"></p>\n<p>手动 hover 和模拟 hover 都有一样的问题，没有多想，立马加上了一句话修复了这个问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.channel2 .channel-item &#123;</div><div class=\"line\">    transform: translateZ(0);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.channel2 .channel-item &#123;</div><div class=\"line\">    transform: translateZ(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个不是直觉，多次遇到这种奇葩问题，我第一想到的便是使用 3D 加速将这个渲染层隔离渲染，80% 以上的概率能够解决问题，而解决问题的关键在于找准加这句代码的 DOM 元素。</p>\n<p><strong><em>探索 bug</em></strong></p>\n<p>这个层在我的代码中肯定是不存在的，我们只能用 bug 来形容这个问题。因为元素刚好贴在 .channel2 的边界，猜测应该跟层渲染有关，于是打开了控制台 ESC -&gt; Rendering -&gt; Show layer borders，看到了这个:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题3.gif\" alt=\"图片\"></p>\n<p>仔细观察，可以看到，这个粉色块在瓦片边界和父元素边界之中，可以断定，这几个瓦片在渲染的时候存在问题。</p>\n<p>这里需要补充下关于瓦片的知识。瓦片，英文里头称之为 tile，它是 webkit/blink 渲染页面时的中间过程，将整个页面分成多个大小一样的瓦片，并发渲染每个瓦片的内容。一个元素开启 3D 硬件加速之后，会变成一个独立的层，这个层的渲染也会被分割成瓦片，可以想象成一个子页面。</p>\n<p>瓦片和瓦片之间的边界计算是处理的难点，因为渲染的内容不能错位。</p>\n<p>其实让我找到问题根本原因的是，rendering 块的颜色，平时在网页上开启 show layer borders 看到的是半透明的绿色块，而这里显示的是粉色块，搜索了下不同色块代表的含义，没找到具体的文档说明，但是找到了 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Missing resize invalidations are in salmon pink.</div><div class=\"line\">SkColor DebugColors::MissingResizeInvalidations() &#123;</div><div class=\"line\">  return SkColorSetARGB(255, 255, 155, 170);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Missing resize invalidations are in salmon pink.</div><div class=\"line\">SkColor DebugColors::MissingResizeInvalidations() &#123;</div><div class=\"line\">  return SkColorSetARGB(255, 255, 155, 170);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对应的就是这个颜色，“缺失调整验证”，在 chromium 的源码仓库中搜了上面的代码，找到了 具体说明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!deflated_content_rect.Contains(canvas_playback_rect)) &#123;</div><div class=\"line\">  if (clear_canvas_with_debug_color) &#123;</div><div class=\"line\">    // Any non-painted areas outside of the content bounds are left in</div><div class=\"line\">    // this color.  If this is seen then it means that cc neglected to</div><div class=\"line\">    // rerasterize a tile that used to intersect with the content rect</div><div class=\"line\">    // after the content bounds grew.</div><div class=\"line\">    canvas-&gt;save();</div><div class=\"line\">    canvas-&gt;translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());</div><div class=\"line\">    canvas-&gt;clipRect(gfx::RectToSkRect(content_rect),</div><div class=\"line\">                     SkRegion::kDifference_Op);</div><div class=\"line\">    canvas-&gt;drawColor(DebugColors::MissingResizeInvalidations(),</div><div class=\"line\">                      SkXfermode::kSrc_Mode);</div><div class=\"line\">    canvas-&gt;restore();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!deflated_content_rect.Contains(canvas_playback_rect)) &#123;</div><div class=\"line\">  if (clear_canvas_with_debug_color) &#123;</div><div class=\"line\">    // Any non-painted areas outside of the content bounds are left in</div><div class=\"line\">    // this color.  If this is seen then it means that cc neglected to</div><div class=\"line\">    // rerasterize a tile that used to intersect with the content rect</div><div class=\"line\">    // after the content bounds grew.</div><div class=\"line\">    canvas-&gt;save();</div><div class=\"line\">    canvas-&gt;translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());</div><div class=\"line\">    canvas-&gt;clipRect(gfx::RectToSkRect(content_rect),</div><div class=\"line\">                     SkRegion::kDifference_Op);</div><div class=\"line\">    canvas-&gt;drawColor(DebugColors::MissingResizeInvalidations(),</div><div class=\"line\">                      SkXfermode::kSrc_Mode);</div><div class=\"line\">    canvas-&gt;restore();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里能看的肯定就是注释啦，没有太多上下文，看的挺头痛！大致翻译了下上下几段注释:</p>\n<blockquote>\n<ol>\n<li>即使完全覆盖，对于触碰到渲染层边界的栅格化处理，我们依然需要，在上次记录没有覆盖到的纹理下方和纹理化线性过滤的上方，栅格化处理背景颜色。</li>\n<li>内容的最后的纹理可能只有部分被栅格覆盖</li>\n<li>在内容边界外没有被渲染到的部分将使用 MissingResizeInvalidations 颜色，如果这个块能够被看见，那就意味着程序忽视处理了内边边界增长之后栅格化与内容相交的瓦片。</li>\n</ol>\n</blockquote>\n<p>从第三句大致可以了解到，因为元素的边界增长导致了这个渲染 bug，回头看了下元素的边界状态，果然…</p>\n<p><strong><em>直接原因</em></strong></p>\n<p>我们看看 hover 上去之后，层边界的变化:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题4.gif\" alt=\"图片\"></p>\n<p>很明显，这里的高度溢出了，但是没有处理，看了下这个元素的 css，确实高度上没有做处理，在元素上添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.channel-item &#123;</div><div class=\"line\">  overflow: hidden；</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.channel-item &#123;</div><div class=\"line\">  overflow: hidden；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样可以解决问题。</p>\n<p>最后的解决手段:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题5.gif\" alt=\"图片\"></p>\n<p>层渲染的问题我还是比较喜欢使用 3d 硬件加速来处理，而 overflow:hidden 这样的 css 布局处理上，我是不太推荐的，搞不好就把哪个重要的内容隐藏掉了。</p>\n<p><strong><em>类似问题处理方案</em></strong></p>\n<p>如果以后大家遇到类似的问题，可以打开 chrome 的层和瓦片分析工具，看看渲染出来的块有没有异常色块，尤其是粉色块。也可以观察交互过程中，元素的边界有没有变化。</p>\n<p>CSS 在浏览器中的渲染是我们触及比较少的知识，如果想迅速找到问题，必须对浏览器的渲染原理有所了解，并且能够熟练的使用 chrome 提供的调试工具，这是基础。</p>\n","excerpt":"","more":"<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题1.jpg\" alt=\"图片\"></p>\n<p>或许你曾经在 Chrome 浏览器上碰到过这样让人瞠目结舌的问题：</p>\n<ul>\n<li>hover 触发一个层展示，hover 离开后，这个层还遗留残影</li>\n<li>浏览器没有清理一个元素渲染的上一个状态，导致页面多出一个错位的跟该元素一模一样的影子</li>\n<li>交互时突然出现一个方形色块，覆盖在元素上</li>\n<li>或者还有更奇葩的……</li>\n</ul>\n<p>以上列举到的三个问题，我在维护淘宝首页的时候都遇到过。这些都是浏览器渲染页面时，因为渲染引擎的 bug 导致的问题，不常见，更加难以写 demo 演示，它们只在特定的复杂场景下，程序计算存在误差或者漏洞的时候出现，尤其是涉及到边界判断的时候。</p>\n<p><strong><em>问题复现</em></strong></p>\n<p>很难得有机会让我碰到一个可以复现的，我把它记录下来了。如下图所示，hover 到学习模块的边界位置时：</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题2.gif\" alt=\"图片\"></p>\n<p>手动 hover 和模拟 hover 都有一样的问题，没有多想，立马加上了一句话修复了这个问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.channel2 .channel-item &#123;</div><div class=\"line\">    transform: translateZ(0);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.channel2 .channel-item &#123;</div><div class=\"line\">    transform: translateZ(0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个不是直觉，多次遇到这种奇葩问题，我第一想到的便是使用 3D 加速将这个渲染层隔离渲染，80% 以上的概率能够解决问题，而解决问题的关键在于找准加这句代码的 DOM 元素。</p>\n<p><strong><em>探索 bug</em></strong></p>\n<p>这个层在我的代码中肯定是不存在的，我们只能用 bug 来形容这个问题。因为元素刚好贴在 .channel2 的边界，猜测应该跟层渲染有关，于是打开了控制台 ESC -&gt; Rendering -&gt; Show layer borders，看到了这个:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题3.gif\" alt=\"图片\"></p>\n<p>仔细观察，可以看到，这个粉色块在瓦片边界和父元素边界之中，可以断定，这几个瓦片在渲染的时候存在问题。</p>\n<p>这里需要补充下关于瓦片的知识。瓦片，英文里头称之为 tile，它是 webkit/blink 渲染页面时的中间过程，将整个页面分成多个大小一样的瓦片，并发渲染每个瓦片的内容。一个元素开启 3D 硬件加速之后，会变成一个独立的层，这个层的渲染也会被分割成瓦片，可以想象成一个子页面。</p>\n<p>瓦片和瓦片之间的边界计算是处理的难点，因为渲染的内容不能错位。</p>\n<p>其实让我找到问题根本原因的是，rendering 块的颜色，平时在网页上开启 show layer borders 看到的是半透明的绿色块，而这里显示的是粉色块，搜索了下不同色块代表的含义，没找到具体的文档说明，但是找到了 代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">// Missing resize invalidations are in salmon pink.</div><div class=\"line\">SkColor DebugColors::MissingResizeInvalidations() &#123;</div><div class=\"line\">  return SkColorSetARGB(255, 255, 155, 170);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// Missing resize invalidations are in salmon pink.</div><div class=\"line\">SkColor DebugColors::MissingResizeInvalidations() &#123;</div><div class=\"line\">  return SkColorSetARGB(255, 255, 155, 170);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对应的就是这个颜色，“缺失调整验证”，在 chromium 的源码仓库中搜了上面的代码，找到了 具体说明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (!deflated_content_rect.Contains(canvas_playback_rect)) &#123;</div><div class=\"line\">  if (clear_canvas_with_debug_color) &#123;</div><div class=\"line\">    // Any non-painted areas outside of the content bounds are left in</div><div class=\"line\">    // this color.  If this is seen then it means that cc neglected to</div><div class=\"line\">    // rerasterize a tile that used to intersect with the content rect</div><div class=\"line\">    // after the content bounds grew.</div><div class=\"line\">    canvas-&gt;save();</div><div class=\"line\">    canvas-&gt;translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());</div><div class=\"line\">    canvas-&gt;clipRect(gfx::RectToSkRect(content_rect),</div><div class=\"line\">                     SkRegion::kDifference_Op);</div><div class=\"line\">    canvas-&gt;drawColor(DebugColors::MissingResizeInvalidations(),</div><div class=\"line\">                      SkXfermode::kSrc_Mode);</div><div class=\"line\">    canvas-&gt;restore();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">if (!deflated_content_rect.Contains(canvas_playback_rect)) &#123;</div><div class=\"line\">  if (clear_canvas_with_debug_color) &#123;</div><div class=\"line\">    // Any non-painted areas outside of the content bounds are left in</div><div class=\"line\">    // this color.  If this is seen then it means that cc neglected to</div><div class=\"line\">    // rerasterize a tile that used to intersect with the content rect</div><div class=\"line\">    // after the content bounds grew.</div><div class=\"line\">    canvas-&gt;save();</div><div class=\"line\">    canvas-&gt;translate(-canvas_bitmap_rect.x(), -canvas_bitmap_rect.y());</div><div class=\"line\">    canvas-&gt;clipRect(gfx::RectToSkRect(content_rect),</div><div class=\"line\">                     SkRegion::kDifference_Op);</div><div class=\"line\">    canvas-&gt;drawColor(DebugColors::MissingResizeInvalidations(),</div><div class=\"line\">                      SkXfermode::kSrc_Mode);</div><div class=\"line\">    canvas-&gt;restore();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里能看的肯定就是注释啦，没有太多上下文，看的挺头痛！大致翻译了下上下几段注释:</p>\n<blockquote>\n<ol>\n<li>即使完全覆盖，对于触碰到渲染层边界的栅格化处理，我们依然需要，在上次记录没有覆盖到的纹理下方和纹理化线性过滤的上方，栅格化处理背景颜色。</li>\n<li>内容的最后的纹理可能只有部分被栅格覆盖</li>\n<li>在内容边界外没有被渲染到的部分将使用 MissingResizeInvalidations 颜色，如果这个块能够被看见，那就意味着程序忽视处理了内边边界增长之后栅格化与内容相交的瓦片。</li>\n</ol>\n</blockquote>\n<p>从第三句大致可以了解到，因为元素的边界增长导致了这个渲染 bug，回头看了下元素的边界状态，果然…</p>\n<p><strong><em>直接原因</em></strong></p>\n<p>我们看看 hover 上去之后，层边界的变化:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题4.gif\" alt=\"图片\"></p>\n<p>很明显，这里的高度溢出了，但是没有处理，看了下这个元素的 css，确实高度上没有做处理，在元素上添加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">.channel-item &#123;</div><div class=\"line\">  overflow: hidden；</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">.channel-item &#123;</div><div class=\"line\">  overflow: hidden；</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>同样可以解决问题。</p>\n<p>最后的解决手段:</p>\n<p><img src=\"http://77l54v.com1.z0.glb.clouddn.com/记一次淘宝首页奇葩的渲染问题5.gif\" alt=\"图片\"></p>\n<p>层渲染的问题我还是比较喜欢使用 3d 硬件加速来处理，而 overflow:hidden 这样的 css 布局处理上，我是不太推荐的，搞不好就把哪个重要的内容隐藏掉了。</p>\n<p><strong><em>类似问题处理方案</em></strong></p>\n<p>如果以后大家遇到类似的问题，可以打开 chrome 的层和瓦片分析工具，看看渲染出来的块有没有异常色块，尤其是粉色块。也可以观察交互过程中，元素的边界有没有变化。</p>\n<p>CSS 在浏览器中的渲染是我们触及比较少的知识，如果想迅速找到问题，必须对浏览器的渲染原理有所了解，并且能够熟练的使用 chrome 提供的调试工具，这是基础。</p>\n"},{"title":"重写js中的window.alert函数","date":"2015-01-23T16:00:00.000Z","_content":"\n使用了bootstrap框架，所以要引入bootstrap框架。\n\n```\n/**\n * msg string 消息内容\n * title string 对话框标题\n * callback function 返回函数。在隐藏并且CSS动画结束后触发\n **/\nwindow.alert = function (msg, title, callback) {\n    if (!title) {\n        title = '对话框';\n    }\n    var dialogHTML = '<div id=\"selfAlert\" class=\"modal fade\">';\n    dialogHTML += '<div class=\"modal-dialog\">';\n    dialogHTML += '<div class=\"modal-content\">';\n    dialogHTML += '<div class=\"modal-header\">';\n    dialogHTML += '<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">';\n    dialogHTML += '<span aria-hidden=\"true\">&times;</span>';\n    dialogHTML += '</button>';\n    dialogHTML += '<h4 class=\"modal-title\">' + title + '</h4>';\n    dialogHTML += '</div>';\n    dialogHTML += '<div class=\"modal-body\">';\n    dialogHTML += msg;\n    dialogHTML += '</div>';\n    dialogHTML += '<div class=\"modal-footer\">';\n    dialogHTML += '<button type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\">确定</button>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n\n    if ($('#selfAlert').length <= 0) {\n        $('body').append(dialogHTML);\n    }\n\n    $('#selfAlert').on('hidden.bs.modal', function () {\n        $('#selfAlert').remove();\n        if (typeof callback == 'function') {\n            callback();\n        }\n    }).modal('show');\n}\n```\n","source":"_posts/重写js中的window.alert函数.md","raw":"---\ntitle: 重写js中的window.alert函数\ntags: [javascript]\ndate: 2015/01/24\n---\n\n使用了bootstrap框架，所以要引入bootstrap框架。\n\n```\n/**\n * msg string 消息内容\n * title string 对话框标题\n * callback function 返回函数。在隐藏并且CSS动画结束后触发\n **/\nwindow.alert = function (msg, title, callback) {\n    if (!title) {\n        title = '对话框';\n    }\n    var dialogHTML = '<div id=\"selfAlert\" class=\"modal fade\">';\n    dialogHTML += '<div class=\"modal-dialog\">';\n    dialogHTML += '<div class=\"modal-content\">';\n    dialogHTML += '<div class=\"modal-header\">';\n    dialogHTML += '<button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">';\n    dialogHTML += '<span aria-hidden=\"true\">&times;</span>';\n    dialogHTML += '</button>';\n    dialogHTML += '<h4 class=\"modal-title\">' + title + '</h4>';\n    dialogHTML += '</div>';\n    dialogHTML += '<div class=\"modal-body\">';\n    dialogHTML += msg;\n    dialogHTML += '</div>';\n    dialogHTML += '<div class=\"modal-footer\">';\n    dialogHTML += '<button type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\">确定</button>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n    dialogHTML += '</div>';\n\n    if ($('#selfAlert').length <= 0) {\n        $('body').append(dialogHTML);\n    }\n\n    $('#selfAlert').on('hidden.bs.modal', function () {\n        $('#selfAlert').remove();\n        if (typeof callback == 'function') {\n            callback();\n        }\n    }).modal('show');\n}\n```\n","slug":"重写js中的window.alert函数","published":1,"updated":"2016-08-17T06:22:19.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpnt007g68dd8qfc7xj0","content":"<p>使用了bootstrap框架，所以要引入bootstrap框架。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * msg string 消息内容</div><div class=\"line\"> * title string 对话框标题</div><div class=\"line\"> * callback function 返回函数。在隐藏并且CSS动画结束后触发</div><div class=\"line\"> **/</div><div class=\"line\">window.alert = function (msg, title, callback) &#123;</div><div class=\"line\">    if (!title) &#123;</div><div class=\"line\">        title = &apos;对话框&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var dialogHTML = &apos;&lt;div id=&quot;selfAlert&quot; class=&quot;modal fade&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-dialog&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-content&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-header&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/button&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;h4 class=&quot;modal-title&quot;&gt;&apos; + title + &apos;&lt;/h4&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-body&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += msg;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-footer&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot;&gt;确定&lt;/button&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\"></div><div class=\"line\">    if ($(&apos;#selfAlert&apos;).length &lt;= 0) &#123;</div><div class=\"line\">        $(&apos;body&apos;).append(dialogHTML);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    $(&apos;#selfAlert&apos;).on(&apos;hidden.bs.modal&apos;, function () &#123;</div><div class=\"line\">        $(&apos;#selfAlert&apos;).remove();</div><div class=\"line\">        if (typeof callback == &apos;function&apos;) &#123;</div><div class=\"line\">            callback();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).modal(&apos;show&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>使用了bootstrap框架，所以要引入bootstrap框架。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * msg string 消息内容</div><div class=\"line\"> * title string 对话框标题</div><div class=\"line\"> * callback function 返回函数。在隐藏并且CSS动画结束后触发</div><div class=\"line\"> **/</div><div class=\"line\">window.alert = function (msg, title, callback) &#123;</div><div class=\"line\">    if (!title) &#123;</div><div class=\"line\">        title = &apos;对话框&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var dialogHTML = &apos;&lt;div id=&quot;selfAlert&quot; class=&quot;modal fade&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-dialog&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-content&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-header&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/button&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;h4 class=&quot;modal-title&quot;&gt;&apos; + title + &apos;&lt;/h4&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-body&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += msg;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;div class=&quot;modal-footer&quot;&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-dismiss=&quot;modal&quot;&gt;确定&lt;/button&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\">    dialogHTML += &apos;&lt;/div&gt;&apos;;</div><div class=\"line\"></div><div class=\"line\">    if ($(&apos;#selfAlert&apos;).length &lt;= 0) &#123;</div><div class=\"line\">        $(&apos;body&apos;).append(dialogHTML);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    $(&apos;#selfAlert&apos;).on(&apos;hidden.bs.modal&apos;, function () &#123;</div><div class=\"line\">        $(&apos;#selfAlert&apos;).remove();</div><div class=\"line\">        if (typeof callback == &apos;function&apos;) &#123;</div><div class=\"line\">            callback();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).modal(&apos;show&apos;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"详解Javascript的继承实现","date":"2015-01-27T16:00:00.000Z","_content":"\n我最早掌握的在js中实现继承的方法是在w3school学到的混合原型链和对象冒充的方法，在工作中，只要用到继承的时候，我都是用这个方法实现。它的实现简单，思路清晰：用对象冒充继承父类构造函数的属性，用原型链继承父类prototype 对象的方法，满足我遇到过的所有继承的场景。正因如此，我从没想过下次写继承的时候，我要换一种方式来写，直到今天晚上看了三生石上关于javascript继承系列的博客（出的很早，现在才看，真有点可惜），才发现在js里面，继承机制也可以写的如此贴近java这种后端语言的实现，确实很妙！所以我想在充分理解他博客的思路下，实现一个自己今后用得到的一个继承库。\n\n### 1. 混合方式实现及问题\n\n了解问题之前，先看看它的具体实现：\n\n```\n//父类构造函数\nfunction Employee(name, salary) {\n    //实例属性：姓名\n    this.name = name;\n    //实例属性：薪资\n    this.salary = salary;\n}\n\n//通过字面量对象设置父类的原型，给父类添加实例方法\nEmployee.prototype = {\n    //由于此处添加实例方法时也是通过修改父类原型处理的，\n    //所以必须修改父类原型的constructor指向，避免父类实例的constructor属性指向Object函数\n    constructor: Employee,\n    getName: function () {\n        return this.name;\n    },\n    getSalary: function () {\n        return this.salary;\n    },\n    toString: function () {\n        return this.name + ''s salary is ' + this.getSalary() + '.';\n    }\n}\n\n//子类构造函数\nfunction Manager(name, salary, percentage) {\n    //对象冒充，实现属性继承（name, salary）\n    Employee.apply(this, [name, salary]);\n    //实例属性：提成\n    this.percentage = percentage;\n}\n\n//将父类的一个实例设置为子类的原型，实现方法继承\nManager.prototype = new Employee();\n//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数\nManager.prototype.constructor = Manager;\n//给子类添加新的实例方法\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n}\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //true\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n从结果上来说，这种继承实现方式没有问题，Manager的实例同时继承到了Employee类的实例属性和实例方法，并且通过instanceOf运算的结果也都正确。但是从代码组织和实现细节层面，这种方法还有以下几个问题：\n\n1）代码组织不够优雅，继承实现的关键部分的逻辑是通用的，都是如下结构：\n\n```\n//将父类的一个实例设置为子类的原型，实现方法继承\nSubClass.prototype = new SuperClass();\n//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数\nSubClass.prototype.constructor = SubClass;\n//给子类添加新的实例方法\nSubClass.prototype.method1 = function() {\n}\nSubClass.prototype.method2 = function() {\n}\nSubClass.prototype.method3 = function() {\n}\n```\n\n这段代码缺乏封装。另外在添加子类的实例方法时，不能通过SubClass.prototype = { method1: function() {} }这种方式去设置，否则就把子类的原型整个又修改了，继承就无法实现了，这样每次都得按SubClass.prototype.method1 = function() {} 的结构去写，代码看起来很不连续。\n\n**解决方式：**利用模块化的方式，将通用的逻辑封装起来，对外提供简单的接口，只要按照约定的接口调用，就能够简化类的构建与类的继承。具体实现请看后面的内容介绍，暂时只能提供理论的说明。\n\n2）在给子类的原型设置成父类的实例时，调用的是new SuperClass()，这是对父类构造函数的无参调用，那么就要求父类必须有无参的构造函数。可是在javascript中，函数无法重载，所以父类不可能提供多个构造函数，在实际业务中，大部分场景下父类构造函数又不可能没有参数，为了在唯一的一个构造函数中模拟函数重载，只能借助判断arguments.length来处理。问题就是，有时候很难保证每次写父类构造函数的时候都会添加arguments.length的判断逻辑。这样的话，这个处理方式就是有风险的。要是能把构造函数里的逻辑抽离出来，让类的构造函数全部是无参函数的话，这个问题就很好解决了。\n\n**解决方式：**把父类跟子类的构造函数全部无参化，并且在构造函数内不写任何逻辑，把构造函数的逻辑都迁移到init这个实例方法，比如前面给出的Employee和Manager的例子就能改造成下面这个样子：\n\n```\n//无参无逻辑的父类构造函数\nfunction Employee() {}\n\nEmployee.prototype = {\n    constructor: Employee,\n    //把构造逻辑搬到init方法中来\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\n//无参无逻辑的子类构造函数\nfunction Manager() {}\n\nManager.prototype = new Employee();\nManager.prototype.constructor = Manager;\n//把构造逻辑搬到init方法中来\nManager.prototype.init = function (name, salary, percentage) {\n    //借用父类的init方法，实现属性继承（name, salary）\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n```\n\n用init方法来完成构造功能，就可以保证在设置子类原型时（Manager.prototype = new Employee()），父类的实例化操作一定不会出错，唯一不好的是在调用类的构造函数来初始化实例的时候，必须在调用构造函数后手动调用init方法来完成实际的构造逻辑：\n\n```\nvar e = new Employee();\ne.init('jason', 5000);\nvar m = new Manager();\nm.init('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //true\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n要是能把这个init的逻辑放在构造函数内部就好了，可是这样的话就会违背前面说的构造函数无参无逻辑的原则。换一种方式来考虑，这个原则的目的是为了保证在实例化父类作为子类原型的时候，调用父类的构造函数不会出错，那么就可以稍微打破一下这个原则，在类的构造函数里添加少量的并且一定不会有问题的逻辑来解决：\n\n```\n//添加一个全局标识initializing，表示是否正在进行子类的构建和类的继承\nvar initializing = false;\n//可自动调用init方法的父类构造函数\nfunction Employee() {\n    if (!initializing) {\n        this.init.apply(this, arguments);\n    }\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    //把构造逻辑搬到init方法中来\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\n//可自动调用init方法的子类构造函数\nfunction Manager() {\n    if (!initializing) {\n        this.init.apply(this, arguments);\n    }\n}\n\n//表示开始子类的构建和类的继承\ninitializing = true;\n//此时调用new Emplyee()，并不会调用Employee.prototype.init方法\nManager.prototype = new Employee();\nManager.prototype.constructor = Manager;\n//表示结束子类的构建和类的继承，之后调用new Employee或new Manager都会自动调用init实例方法\ninitializing = false;\n\n//把构造逻辑搬到init方法中来\nManager.prototype.init = function (name, salary, percentage) {\n    //借用父类的init方法，实现属性继承（name, salary）\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n```\n\n调用结果仍然和前面的例子一样。但是这个实现还有一个小问题，它引入了一个全局变量initializing，要是能把引入这个全局变量就好了，这个其实很好解决，只要我们把关于类的构建跟继承，封装成一个模块，然后把这个变量放在模块的内部，就没有问题了。\n\n3）在构造子类的时候，是把子类的原型设置成了父类的一个实例，这个是不符合语义的，继承应该发生在类与类之间，而不是类与实例之间。之所以要用父类的一个实例来作为子类的原型：\n\n```\nSubClass.prototype = new SuperClass();\n```\n\n完全是因为父类的这个实例，指向父类的原型，而子类的实例又会指向子类的原型，所以最终子类的实例就能通过原型链访问到父类原型上的方法。这个做法虽然能实现实例方法的继承，但是它不符合语义，而且它还有一个很大的问题就是会增加原型链的长度，导致子类在调用父类方法时，必须通过原型链的查找到父类的方法才行。要是继承层次较深，会对js的执行性能有些影响。\n\n**解决方式：**在解决这个问题之前，先想想继承能帮我们解决什么问题：从父类复用已有的实例属性和实例方法。在javascript面向对象编程中，一直有一个原则就是，实例属性都写在构造函数或者实例方法里面，实例方法写在原型上面，也就是说类的原型，按照这个原则来说，就是用来写实例方法的，而且是只用来写实例方法，那么我们完全可以在构建子类时，通过复制的方式将父类原型的所有方法全部添加到子类的原型上，不一定要把父类的一个实例设置成子类的原型，这样就能将原型链的长度大大地缩短，借助一个简短的copy函数，我们就能轻松对前面的代码进行改造：\n\n```\n//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n}\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    this.init.apply(this, arguments);\n}\n//将父类的原型方法复制到子类的原型上\nManager.prototype = copy(Employee.prototype);\n//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = function (name, salary, percentage) {\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n这么做了以后，当调用m.toString的时候其实调用的是Manager类自身原型上的方法，而不是Employee类的实例方法，缩短了在原型链上查找方法的距离。这个做法在性能上有很大的优点，但不好的是通过原型链维持的继承关系其实已经断了，子类的原型和子类的实例都无法再通过js原生的属性访问到父类的原型，所以这个调用console.log(m instanceof Employee)输出的是false。不过跟性能比起来，这个都可以不算问题：一是instanceOf的运算，几乎在javascript的开发里面用不到，至少我是没碰到过；二是通过复制方式完全能够把父类的实例方法继承下来，这就已经达到了继承的最大目的。\n\n这个方法还有一个额外的好处是，解决了第2个问题最后提到的引入initializing全局变量的问题，如果是复制的话，就不需要在构建继承关系时，去调用父类的构造函数，那么也就没有必要在构造函数内先判断initializing才能去调用init方法，上面的代码中就已经去掉了initializing这个变量的处理。\n\n4）在子类的构造函数和实例方法内如果想要调用父类的构造函数或者方法，显得比较繁琐：\n\n```\nfunction SuperClass() {}\n\nSuperClass.prototype = {\n    constructor: SuperClass,\n    method1: function () {}\n}\n\nfunction SubClass() {\n    //调用父类构造函数\n    SuperClass.apply(this);\n}\n\nSubClass.prototype = new SuperClass();\nSubClass.prototype.constructor = SubClass;\nSubClass.prototype.method1 = function () {\n    //调用父类的实例方法\n    SuperClass.prototype.method1.apply(this, arguments);\n}\nSubClass.prototype.method2 = function () {}\nSubClass.prototype.method3 = function () {}\n```\n\n每次都得靠apply借用方法来处理。要是能改成如下的调用就好用多了：\n\n```\nfunction SubClass() {\n//调用父类构造函数\n        this.base();\n}\n\nSubClass.prototype = new SuperClass();\nSubClass.prototype.constructor = SubClass;\nSubClass.prototype.method1 = function() {\n//调用父类的实例方法\n        this.base();\n}\n```\n\n**解决方式：**如果要在每个实例方法里，都能通过this.base()调用父类原型上相应的方法，那么this.base就一定不是一个固定的方法，需要在每个实例方法执行期间动态地将this.base指定为父类原型的同名方法，能够做到这个实现的方式，就只有通过方法代理了，前面的Employee和Manager的例子可以改造如下：\n\n```\n//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n};\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    //必须在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n    this.baseProto = Employee.prototype;\n    this.init.apply(this, arguments);\n}\n\nManager.prototype = copy(Employee.prototype);\n//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = (function (name, func) {\n    return function () {\n        //记录实例原有的this.base的值\n        var old = this.base;\n        //将实例的this.base指向父类的原型的同名方法\n        this.base = this.baseProto[name];\n        //调用子类自身定义的init方法，也就是func参数传递进来的函数\n        var ret = func.apply(this, arguments);\n        //还原实例原有的this.base的值\n        this.base = old;\n        return ret;\n    }\n})('init', function (name, salary, percentage) {\n    //通过this.base调用父类的init方法\n    //这个函数真实的调用位置是var ret = func.apply(this, arguments);\n    //当调用Manager实例的init方法时，其实不是调用的这个函数\n    //而是调用上面那个匿名函数里面return的匿名函数\n    //在return的匿名函数里，先把this.base指向为了父类原型的同名函数，然后在调用func\n    //func内部再通过调用this.base时，就能调用父类的原型方法。\n    this.base(name, salary);\n    this.percentage = percentage;\n});\n\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n通过代理的方式，就解决了在在实例方法内部通过this.base调用父类原型同名方法的问题。可是在实际情况中，每个实例方法都有可能需要调用父类的实例，那么每个实例方法都要添加同样的代码，显然这会增加很多麻烦，好在这部分的逻辑也是同样的，我们可以把它抽象一下，最后都放到模块化的内部去，这样就能简化代理的工作。\n\n5）未考虑静态属性和静态方法。尽管静态成员是不需要继承的，但在有些场景下，我们还是需要静态成员，所以得考虑静态成员应该添加在哪里。\n\n**解决方式：**由于js原生并不支持静态成员，所以只能借助一些公共的位置来处理。最佳的位置是添加到构造函数上：\n\n```\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n};\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\n//添加一个静态属性\nEmployee.idCounter = 1;\n//添加一个静态方法\nEmployee.getId = function () {\n    return Employee.idCounter++;\n};\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n            //调用静态方法\n            this.id = Employee.getId();\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    this.baseProto = Employee.prototype;\n    this.init.apply(this, arguments);\n}\n\nManager.prototype = copy(Employee.prototype);\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = (function (name, func) {\n    return function () {\n        var old = this.base;\n        this.base = this.baseProto[name];\n        var ret = func.apply(this, arguments);\n        this.base = old;\n        return ret;\n    }\n})('init', function (name, salary, percentage) {\n    this.base(name, salary);\n    this.percentage = percentage;\n});\n\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\nconsole.log(m.id); //2\nconsole.log(e.id); //1\n```\n\n最后的两行输出了正确的实例id，而这个id是通过Employee类的静态方法生成的。在java的面向对象编程中，子类跟父类都可以定义静态成员，在调用的时候还存在覆盖的问题，在js里面，因为受语言的限制，自定义的静态成员不可能实现全面的面向对象功能，就像上面这种，能够给类提供一些公共的属性和公共方法，就已经足够了。\n\n### 2. 期望的调用方式\n\n从第1部分的分析可以看出，在js里面，类的构建与继承，有很多通用的逻辑，完全可以把这些逻辑封装成一个单独的模块，形成一个通用的类库，以便在工作中有需要的时候，都可以直接拿来使用。这个类库要求能完成我们需要的功能（类的构建与继承和静态成员的添加），同时在使用时要足够简洁方便。在利用bootstrap的modal组件自定义alert，confirm和modal对话框这篇文章里，我曾说过一些从组件期望的调用方式，去反推组件实现的一些观点，当你明确你需要什么东西时，你才知道这个东西你该怎么去创造。本文要编写的这个继承组件也会采取这个方法来实现，我先用前面Employee和Manager的例子来模拟调用这个继承库的场景，通过预设的一些组件名称或者接口名称以及调用方式，来尝试走通真实使用这个继承库的流程，有了这个东西，下一步我只需要根据这个要求去实现即可，模拟如下：\n\n```\n//通过调用Class函数构造一个类\nvar Employee = Class({\n    //通过instanceMembers指定这个类的实例成员\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    //通过staticMembers指定这个类的静态成员\n    //静态方法内部可通过this访问其它静态成员\n    //在外部可通过Employee.getId这种方式访问到静态成员\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                this.base(name, salary);\n                this.percentage = percentage;\n                Manager.count++;\n            },\n            getSalary: function () {\n                return this.salary + this.salary * this.percentage;\n            }\n    },\n    //通过extend指定要继承的类\n    extend: Employee\n});\n```\n\n从模拟的结果来看，我想要的继承库对外提供的名称只有Class, instanceMembers, staticMembers和extend而已，调用方式也很简单，只要传递参数给Class函数即可。接下来就按照这个目标，看看如何一步步根据第一部分罗列的那些问题和解决方式，把这个库给写出来。\n\n### 3. 继承库的详细实现\n\n根据API名称和接口以及前面第1部分提出的问题，这个继承库要完成的功能有：\n\n1）类的构建（关键：init方法）和静态成员处理；\n\n2）继承关系的构建（关键：父类原型的复制）；\n\n3）父类方法的简化调用（关键：父类原型上同名方法的代理）。\n\n所以这个库的实现，可以按照这三点分成三版来开发。\n\n1）第一版\n\n在第一版里面，仅需要实现类的构架和静态成员添加的功能即可，细节如下：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        TargetClass.prototype = instanceMembers;\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n这一版核心代码在于类的构建和静态成员添加的部分，其它代码仅仅提供一些提前可以想到的赋值函数和变量（isObject, isFunction)，并做一些参数合法性校验的处理。添加静态成员的代码一定要在设置原型的代码之前，否则就有原型被覆盖的风险。有了这个版本，就可以直接构建带静态成员的Employee类了：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar e = new Employee('jason', 5000);\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(e.id); //1\nconsole.log(e.constructor === Employee); //true\n```\n\n在getId方法中之所以直接使用this就能访问到构造函数Employee，是因为getId这个方法是添加到构造函数上的，所以当调用Employee.getId()时，getId方法里面的this指向的就是Employee这个函数对象。\n\n第二版在第一版的基础上，实现继承关系的构建部分：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    //简单复制\n    function copy(source) {\n        var target = {};\n        for (var i in source) {\n            if (hasOwn.call(source, i)) {\n                target[i] = source[i];\n            }\n        }\n        return target;\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (extend) {\n                //如果有要继承的父类\n                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n                this.baseProto = extend.prototype;\n            }\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        //如果有要继承的父类，先把父类的实例方法都复制过来\n        extend & (TargetClass.prototype = copy(extend.prototype));\n\n        //添加实例方法\n        for (prop in instanceMembers) {\n            if (hasOwn.call(instanceMembers, prop)) {\n                TargetClass.prototype[prop] = instanceMembers[prop];\n            }\n        }\n\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n这一版关键的部分在于：\n\n```\nif(extend){\n    //如果有要继承的父类\n    //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n    this.baseProto = extend.prototype;\n}\n```\n\n```\n//如果有要继承的父类，先把父类的实例方法都复制过来\nextend && (TargetClass.prototype = copy(extend.prototype));\n```\n\nthis.baseProto主要目的就是为了让子类的实例能够有一个属性可以访问到父类的原型，因为后面的继承方式是复制方式，会导致原型链断裂。有了这一版之后，就可以加入Manager类来演示效果了：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //借用父类的init方法，实现属性继承（name, salary）\n                Employee.prototype.init.apply(this, [name, salary]);\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.salary + this.salary * this.percentage;\n            }\n    },\n    extend: Employee\n});\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\nconsole.log(e.constructor === Employee); //true\nconsole.log(m.constructor === Manager); //true\nconsole.log(e.id); //1\nconsole.log(m.id); //2\n```\n\n不过在Manager内部，调用父类的方法时还是apply借用的方式，所以在最后一版里面，需要把它变成我们期望的this.base的方式，反正原理前面也已经了解了，无非是在方法同名的时候，对实例方法加一个代理而已，实现如下：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    //简单复制\n    function copy(source) {\n        var target = {};\n        for (var i in source) {\n            if (hasOwn.call(source, i)) {\n                target[i] = source[i];\n            }\n        }\n        return target;\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (extend) {\n                //如果有要继承的父类\n                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n                this.baseProto = extend.prototype;\n            }\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        //如果有要继承的父类，先把父类的实例方法都复制过来\n        extend & (TargetClass.prototype = copy(extend.prototype));\n\n        //添加实例方法\n        for (prop in instanceMembers) {\n\n            if (hasOwn.call(instanceMembers, prop)) {\n\n                //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法\n                if (extend & isFunction(instanceMembers[prop]) && isFunction(extend.prototype[prop])) {\n                    TargetClass.prototype[prop] = (function (name, func) {\n                        return function () {\n                            //记录实例原有的this.base的值\n                            var old = this.base;\n                            //将实例的this.base指向父类的原型的同名方法\n                            this.base = extend.prototype[name];\n                            //调用子类自身定义的实例方法，也就是func参数传递进来的函数\n                            var ret = func.apply(this, arguments);\n                            //还原实例原有的this.base的值\n                            this.base = old;\n                            return ret;\n                        }\n                    })(prop, instanceMembers[prop]);\n                } else {\n                    TargetClass.prototype[prop] = instanceMembers[prop];\n                }\n            }\n        }\n\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n核心部分是：\n\n```\nif (hasOwn.call(instanceMembers, prop)) {\n\n    //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法\n    if (extend & isFunction(instanceMembers[prop]) && isFunction(extend.prototype[prop])) {\n        TargetClass.prototype[prop] = (function (name, func) {\n            return function () {\n                //记录实例原有的this.base的值\n                var old = this.base;\n                //将实例的this.base指向父类的原型的同名方法\n                this.base = extend.prototype[name];\n                //调用子类自身定义的实例方法，也就是func参数传递进来的函数\n                var ret = func.apply(this, arguments);\n                //还原实例原有的this.base的值\n                this.base = old;\n                return ret;\n            }\n        })(prop, instanceMembers[prop]);\n    } else {\n        TargetClass.prototype[prop] = instanceMembers[prop];\n    }\n}\n```\n\n只有当需要继承父类，且父类原型中有方法与当前的实例方法同名时，才会去对当前的实例方法添加代理。更详细的原理可以回到文章第1部分回顾相关内容。至此，我们在Manager类内部调用父类的方法时，就很简单了，只要通过this.base即可：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //通过this.base调用父类的构造方法\n                this.base(name, salary);\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.base() + this.salary * this.percentage;\n            }\n    },\n    extend: Employee\n});\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\nconsole.log(e.constructor === Employee); //true\nconsole.log(m.constructor === Manager); //true\nconsole.log(e.id); //1\nconsole.log(m.id); //2\n```\n\n注意这两处调用：\n\n```\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //通过this.base调用父类的构造方法\n                this.base(name, salary);//要注意的第一处\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.base() + this.salary * this.percentage;//要注意的第二处this.base()\n            }\n    },\n    extend: Employee\n});\n```\n\n以上就是本文要实现的继承库的全部细节，其实它所做的事就是把本文第1部分提到的那些问题的解决方式和第二部分模拟的调用场景结合起来，封装到一个模块内部而已，各个细节的原理只要理解了第1部分总结的那些解决方式就很掌握了。在最后一版的演示中，也能看到，本文实现的这个继承库，已经完全满足了模拟场景中的需求，今后有任何需要用到继承的场景，完全可以拿最后一版的实现去开发。\n\n### 4. 总结\n\n本文在三生石上关于javascript继承系列博客的思路指引下，实现了一个易用的继承库，使用它可以更像java语言构建面向对象的类和类之间的继承关系，我可以预见在将来的工作，这个库对我的代码质量和功能实现会起到很重要的作用，因为在开发中，继承的编码思想还是应用的非常多，尤其是当我们做项目做得多的时候，一方面肯定想把一些公共的东西写成可重用的组件，另一方面又必须得满足各个项目的个性要求，所以在写组件的时候不能写的太死，多写接口，等到具体项目的时候再通过继承等方式来扩展该项目独有的功能，这样写出的组件才会更灵活稳定。总之有了这个继承库，感觉以后写的代码都会开心好多~所以希望本文的内容也能对你有同样的一些帮助。如果确实有帮助，求点推荐：）\n\n谢谢阅读！\n\n文章转载：[http://www.cnblogs.com](http://www.cnblogs.com/lyzg/p/5313752.html)\n","source":"_posts/详解Javascript的继承实现.md","raw":"---\ntitle: 详解Javascript的继承实现\ntags: [javascript]\ndate: 2015/01/28\n---\n\n我最早掌握的在js中实现继承的方法是在w3school学到的混合原型链和对象冒充的方法，在工作中，只要用到继承的时候，我都是用这个方法实现。它的实现简单，思路清晰：用对象冒充继承父类构造函数的属性，用原型链继承父类prototype 对象的方法，满足我遇到过的所有继承的场景。正因如此，我从没想过下次写继承的时候，我要换一种方式来写，直到今天晚上看了三生石上关于javascript继承系列的博客（出的很早，现在才看，真有点可惜），才发现在js里面，继承机制也可以写的如此贴近java这种后端语言的实现，确实很妙！所以我想在充分理解他博客的思路下，实现一个自己今后用得到的一个继承库。\n\n### 1. 混合方式实现及问题\n\n了解问题之前，先看看它的具体实现：\n\n```\n//父类构造函数\nfunction Employee(name, salary) {\n    //实例属性：姓名\n    this.name = name;\n    //实例属性：薪资\n    this.salary = salary;\n}\n\n//通过字面量对象设置父类的原型，给父类添加实例方法\nEmployee.prototype = {\n    //由于此处添加实例方法时也是通过修改父类原型处理的，\n    //所以必须修改父类原型的constructor指向，避免父类实例的constructor属性指向Object函数\n    constructor: Employee,\n    getName: function () {\n        return this.name;\n    },\n    getSalary: function () {\n        return this.salary;\n    },\n    toString: function () {\n        return this.name + ''s salary is ' + this.getSalary() + '.';\n    }\n}\n\n//子类构造函数\nfunction Manager(name, salary, percentage) {\n    //对象冒充，实现属性继承（name, salary）\n    Employee.apply(this, [name, salary]);\n    //实例属性：提成\n    this.percentage = percentage;\n}\n\n//将父类的一个实例设置为子类的原型，实现方法继承\nManager.prototype = new Employee();\n//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数\nManager.prototype.constructor = Manager;\n//给子类添加新的实例方法\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n}\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //true\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n从结果上来说，这种继承实现方式没有问题，Manager的实例同时继承到了Employee类的实例属性和实例方法，并且通过instanceOf运算的结果也都正确。但是从代码组织和实现细节层面，这种方法还有以下几个问题：\n\n1）代码组织不够优雅，继承实现的关键部分的逻辑是通用的，都是如下结构：\n\n```\n//将父类的一个实例设置为子类的原型，实现方法继承\nSubClass.prototype = new SuperClass();\n//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数\nSubClass.prototype.constructor = SubClass;\n//给子类添加新的实例方法\nSubClass.prototype.method1 = function() {\n}\nSubClass.prototype.method2 = function() {\n}\nSubClass.prototype.method3 = function() {\n}\n```\n\n这段代码缺乏封装。另外在添加子类的实例方法时，不能通过SubClass.prototype = { method1: function() {} }这种方式去设置，否则就把子类的原型整个又修改了，继承就无法实现了，这样每次都得按SubClass.prototype.method1 = function() {} 的结构去写，代码看起来很不连续。\n\n**解决方式：**利用模块化的方式，将通用的逻辑封装起来，对外提供简单的接口，只要按照约定的接口调用，就能够简化类的构建与类的继承。具体实现请看后面的内容介绍，暂时只能提供理论的说明。\n\n2）在给子类的原型设置成父类的实例时，调用的是new SuperClass()，这是对父类构造函数的无参调用，那么就要求父类必须有无参的构造函数。可是在javascript中，函数无法重载，所以父类不可能提供多个构造函数，在实际业务中，大部分场景下父类构造函数又不可能没有参数，为了在唯一的一个构造函数中模拟函数重载，只能借助判断arguments.length来处理。问题就是，有时候很难保证每次写父类构造函数的时候都会添加arguments.length的判断逻辑。这样的话，这个处理方式就是有风险的。要是能把构造函数里的逻辑抽离出来，让类的构造函数全部是无参函数的话，这个问题就很好解决了。\n\n**解决方式：**把父类跟子类的构造函数全部无参化，并且在构造函数内不写任何逻辑，把构造函数的逻辑都迁移到init这个实例方法，比如前面给出的Employee和Manager的例子就能改造成下面这个样子：\n\n```\n//无参无逻辑的父类构造函数\nfunction Employee() {}\n\nEmployee.prototype = {\n    constructor: Employee,\n    //把构造逻辑搬到init方法中来\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\n//无参无逻辑的子类构造函数\nfunction Manager() {}\n\nManager.prototype = new Employee();\nManager.prototype.constructor = Manager;\n//把构造逻辑搬到init方法中来\nManager.prototype.init = function (name, salary, percentage) {\n    //借用父类的init方法，实现属性继承（name, salary）\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n```\n\n用init方法来完成构造功能，就可以保证在设置子类原型时（Manager.prototype = new Employee()），父类的实例化操作一定不会出错，唯一不好的是在调用类的构造函数来初始化实例的时候，必须在调用构造函数后手动调用init方法来完成实际的构造逻辑：\n\n```\nvar e = new Employee();\ne.init('jason', 5000);\nvar m = new Manager();\nm.init('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //true\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n要是能把这个init的逻辑放在构造函数内部就好了，可是这样的话就会违背前面说的构造函数无参无逻辑的原则。换一种方式来考虑，这个原则的目的是为了保证在实例化父类作为子类原型的时候，调用父类的构造函数不会出错，那么就可以稍微打破一下这个原则，在类的构造函数里添加少量的并且一定不会有问题的逻辑来解决：\n\n```\n//添加一个全局标识initializing，表示是否正在进行子类的构建和类的继承\nvar initializing = false;\n//可自动调用init方法的父类构造函数\nfunction Employee() {\n    if (!initializing) {\n        this.init.apply(this, arguments);\n    }\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    //把构造逻辑搬到init方法中来\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\n//可自动调用init方法的子类构造函数\nfunction Manager() {\n    if (!initializing) {\n        this.init.apply(this, arguments);\n    }\n}\n\n//表示开始子类的构建和类的继承\ninitializing = true;\n//此时调用new Emplyee()，并不会调用Employee.prototype.init方法\nManager.prototype = new Employee();\nManager.prototype.constructor = Manager;\n//表示结束子类的构建和类的继承，之后调用new Employee或new Manager都会自动调用init实例方法\ninitializing = false;\n\n//把构造逻辑搬到init方法中来\nManager.prototype.init = function (name, salary, percentage) {\n    //借用父类的init方法，实现属性继承（name, salary）\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n```\n\n调用结果仍然和前面的例子一样。但是这个实现还有一个小问题，它引入了一个全局变量initializing，要是能把引入这个全局变量就好了，这个其实很好解决，只要我们把关于类的构建跟继承，封装成一个模块，然后把这个变量放在模块的内部，就没有问题了。\n\n3）在构造子类的时候，是把子类的原型设置成了父类的一个实例，这个是不符合语义的，继承应该发生在类与类之间，而不是类与实例之间。之所以要用父类的一个实例来作为子类的原型：\n\n```\nSubClass.prototype = new SuperClass();\n```\n\n完全是因为父类的这个实例，指向父类的原型，而子类的实例又会指向子类的原型，所以最终子类的实例就能通过原型链访问到父类原型上的方法。这个做法虽然能实现实例方法的继承，但是它不符合语义，而且它还有一个很大的问题就是会增加原型链的长度，导致子类在调用父类方法时，必须通过原型链的查找到父类的方法才行。要是继承层次较深，会对js的执行性能有些影响。\n\n**解决方式：**在解决这个问题之前，先想想继承能帮我们解决什么问题：从父类复用已有的实例属性和实例方法。在javascript面向对象编程中，一直有一个原则就是，实例属性都写在构造函数或者实例方法里面，实例方法写在原型上面，也就是说类的原型，按照这个原则来说，就是用来写实例方法的，而且是只用来写实例方法，那么我们完全可以在构建子类时，通过复制的方式将父类原型的所有方法全部添加到子类的原型上，不一定要把父类的一个实例设置成子类的原型，这样就能将原型链的长度大大地缩短，借助一个简短的copy函数，我们就能轻松对前面的代码进行改造：\n\n```\n//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n}\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    this.init.apply(this, arguments);\n}\n//将父类的原型方法复制到子类的原型上\nManager.prototype = copy(Employee.prototype);\n//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = function (name, salary, percentage) {\n    Employee.prototype.init.apply(this, [name, salary]);\n    this.percentage = percentage;\n};\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n这么做了以后，当调用m.toString的时候其实调用的是Manager类自身原型上的方法，而不是Employee类的实例方法，缩短了在原型链上查找方法的距离。这个做法在性能上有很大的优点，但不好的是通过原型链维持的继承关系其实已经断了，子类的原型和子类的实例都无法再通过js原生的属性访问到父类的原型，所以这个调用console.log(m instanceof Employee)输出的是false。不过跟性能比起来，这个都可以不算问题：一是instanceOf的运算，几乎在javascript的开发里面用不到，至少我是没碰到过；二是通过复制方式完全能够把父类的实例方法继承下来，这就已经达到了继承的最大目的。\n\n这个方法还有一个额外的好处是，解决了第2个问题最后提到的引入initializing全局变量的问题，如果是复制的话，就不需要在构建继承关系时，去调用父类的构造函数，那么也就没有必要在构造函数内先判断initializing才能去调用init方法，上面的代码中就已经去掉了initializing这个变量的处理。\n\n4）在子类的构造函数和实例方法内如果想要调用父类的构造函数或者方法，显得比较繁琐：\n\n```\nfunction SuperClass() {}\n\nSuperClass.prototype = {\n    constructor: SuperClass,\n    method1: function () {}\n}\n\nfunction SubClass() {\n    //调用父类构造函数\n    SuperClass.apply(this);\n}\n\nSubClass.prototype = new SuperClass();\nSubClass.prototype.constructor = SubClass;\nSubClass.prototype.method1 = function () {\n    //调用父类的实例方法\n    SuperClass.prototype.method1.apply(this, arguments);\n}\nSubClass.prototype.method2 = function () {}\nSubClass.prototype.method3 = function () {}\n```\n\n每次都得靠apply借用方法来处理。要是能改成如下的调用就好用多了：\n\n```\nfunction SubClass() {\n//调用父类构造函数\n        this.base();\n}\n\nSubClass.prototype = new SuperClass();\nSubClass.prototype.constructor = SubClass;\nSubClass.prototype.method1 = function() {\n//调用父类的实例方法\n        this.base();\n}\n```\n\n**解决方式：**如果要在每个实例方法里，都能通过this.base()调用父类原型上相应的方法，那么this.base就一定不是一个固定的方法，需要在每个实例方法执行期间动态地将this.base指定为父类原型的同名方法，能够做到这个实现的方式，就只有通过方法代理了，前面的Employee和Manager的例子可以改造如下：\n\n```\n//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n};\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    //必须在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n    this.baseProto = Employee.prototype;\n    this.init.apply(this, arguments);\n}\n\nManager.prototype = copy(Employee.prototype);\n//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = (function (name, func) {\n    return function () {\n        //记录实例原有的this.base的值\n        var old = this.base;\n        //将实例的this.base指向父类的原型的同名方法\n        this.base = this.baseProto[name];\n        //调用子类自身定义的init方法，也就是func参数传递进来的函数\n        var ret = func.apply(this, arguments);\n        //还原实例原有的this.base的值\n        this.base = old;\n        return ret;\n    }\n})('init', function (name, salary, percentage) {\n    //通过this.base调用父类的init方法\n    //这个函数真实的调用位置是var ret = func.apply(this, arguments);\n    //当调用Manager实例的init方法时，其实不是调用的这个函数\n    //而是调用上面那个匿名函数里面return的匿名函数\n    //在return的匿名函数里，先把this.base指向为了父类原型的同名函数，然后在调用func\n    //func内部再通过调用this.base时，就能调用父类的原型方法。\n    this.base(name, salary);\n    this.percentage = percentage;\n});\n\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\n```\n\n通过代理的方式，就解决了在在实例方法内部通过this.base调用父类原型同名方法的问题。可是在实际情况中，每个实例方法都有可能需要调用父类的实例，那么每个实例方法都要添加同样的代码，显然这会增加很多麻烦，好在这部分的逻辑也是同样的，我们可以把它抽象一下，最后都放到模块化的内部去，这样就能简化代理的工作。\n\n5）未考虑静态属性和静态方法。尽管静态成员是不需要继承的，但在有些场景下，我们还是需要静态成员，所以得考虑静态成员应该添加在哪里。\n\n**解决方式：**由于js原生并不支持静态成员，所以只能借助一些公共的位置来处理。最佳的位置是添加到构造函数上：\n\n```\nvar copy = function (source) {\n    var target = {};\n    for (var i in source) {\n        if (source.hasOwnProperty(i)) {\n            target[i] = source[i];\n        }\n    }\n    return target;\n};\n\nfunction Employee() {\n    this.init.apply(this, arguments);\n}\n\n//添加一个静态属性\nEmployee.idCounter = 1;\n//添加一个静态方法\nEmployee.getId = function () {\n    return Employee.idCounter++;\n};\n\nEmployee.prototype = {\n    constructor: Employee,\n    init: function (name, salary) {\n            this.name = name;\n            this.salary = salary;\n            //调用静态方法\n            this.id = Employee.getId();\n        },\n        getName: function () {\n            return this.name;\n        },\n        getSalary: function () {\n            return this.salary;\n        },\n        toString: function () {\n            return this.name + ''s salary is ' + this.getSalary() + '.';\n        }\n};\n\nfunction Manager() {\n    this.baseProto = Employee.prototype;\n    this.init.apply(this, arguments);\n}\n\nManager.prototype = copy(Employee.prototype);\nManager.prototype.constructor = Manager;\n\nManager.prototype.init = (function (name, func) {\n    return function () {\n        var old = this.base;\n        this.base = this.baseProto[name];\n        var ret = func.apply(this, arguments);\n        this.base = old;\n        return ret;\n    }\n})('init', function (name, salary, percentage) {\n    this.base(name, salary);\n    this.percentage = percentage;\n});\n\nManager.prototype.getSalary = function () {\n    return this.salary + this.salary * this.percentage;\n};\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\n\nconsole.log(m instanceof Manager); //true\nconsole.log(m instanceof Employee); //false\nconsole.log(e instanceof Employee); //true\nconsole.log(e instanceof Manager); //false\nconsole.log(m.id); //2\nconsole.log(e.id); //1\n```\n\n最后的两行输出了正确的实例id，而这个id是通过Employee类的静态方法生成的。在java的面向对象编程中，子类跟父类都可以定义静态成员，在调用的时候还存在覆盖的问题，在js里面，因为受语言的限制，自定义的静态成员不可能实现全面的面向对象功能，就像上面这种，能够给类提供一些公共的属性和公共方法，就已经足够了。\n\n### 2. 期望的调用方式\n\n从第1部分的分析可以看出，在js里面，类的构建与继承，有很多通用的逻辑，完全可以把这些逻辑封装成一个单独的模块，形成一个通用的类库，以便在工作中有需要的时候，都可以直接拿来使用。这个类库要求能完成我们需要的功能（类的构建与继承和静态成员的添加），同时在使用时要足够简洁方便。在利用bootstrap的modal组件自定义alert，confirm和modal对话框这篇文章里，我曾说过一些从组件期望的调用方式，去反推组件实现的一些观点，当你明确你需要什么东西时，你才知道这个东西你该怎么去创造。本文要编写的这个继承组件也会采取这个方法来实现，我先用前面Employee和Manager的例子来模拟调用这个继承库的场景，通过预设的一些组件名称或者接口名称以及调用方式，来尝试走通真实使用这个继承库的流程，有了这个东西，下一步我只需要根据这个要求去实现即可，模拟如下：\n\n```\n//通过调用Class函数构造一个类\nvar Employee = Class({\n    //通过instanceMembers指定这个类的实例成员\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    //通过staticMembers指定这个类的静态成员\n    //静态方法内部可通过this访问其它静态成员\n    //在外部可通过Employee.getId这种方式访问到静态成员\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                this.base(name, salary);\n                this.percentage = percentage;\n                Manager.count++;\n            },\n            getSalary: function () {\n                return this.salary + this.salary * this.percentage;\n            }\n    },\n    //通过extend指定要继承的类\n    extend: Employee\n});\n```\n\n从模拟的结果来看，我想要的继承库对外提供的名称只有Class, instanceMembers, staticMembers和extend而已，调用方式也很简单，只要传递参数给Class函数即可。接下来就按照这个目标，看看如何一步步根据第一部分罗列的那些问题和解决方式，把这个库给写出来。\n\n### 3. 继承库的详细实现\n\n根据API名称和接口以及前面第1部分提出的问题，这个继承库要完成的功能有：\n\n1）类的构建（关键：init方法）和静态成员处理；\n\n2）继承关系的构建（关键：父类原型的复制）；\n\n3）父类方法的简化调用（关键：父类原型上同名方法的代理）。\n\n所以这个库的实现，可以按照这三点分成三版来开发。\n\n1）第一版\n\n在第一版里面，仅需要实现类的构架和静态成员添加的功能即可，细节如下：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        TargetClass.prototype = instanceMembers;\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n这一版核心代码在于类的构建和静态成员添加的部分，其它代码仅仅提供一些提前可以想到的赋值函数和变量（isObject, isFunction)，并做一些参数合法性校验的处理。添加静态成员的代码一定要在设置原型的代码之前，否则就有原型被覆盖的风险。有了这个版本，就可以直接构建带静态成员的Employee类了：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar e = new Employee('jason', 5000);\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(e.id); //1\nconsole.log(e.constructor === Employee); //true\n```\n\n在getId方法中之所以直接使用this就能访问到构造函数Employee，是因为getId这个方法是添加到构造函数上的，所以当调用Employee.getId()时，getId方法里面的this指向的就是Employee这个函数对象。\n\n第二版在第一版的基础上，实现继承关系的构建部分：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    //简单复制\n    function copy(source) {\n        var target = {};\n        for (var i in source) {\n            if (hasOwn.call(source, i)) {\n                target[i] = source[i];\n            }\n        }\n        return target;\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (extend) {\n                //如果有要继承的父类\n                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n                this.baseProto = extend.prototype;\n            }\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        //如果有要继承的父类，先把父类的实例方法都复制过来\n        extend & (TargetClass.prototype = copy(extend.prototype));\n\n        //添加实例方法\n        for (prop in instanceMembers) {\n            if (hasOwn.call(instanceMembers, prop)) {\n                TargetClass.prototype[prop] = instanceMembers[prop];\n            }\n        }\n\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n这一版关键的部分在于：\n\n```\nif(extend){\n    //如果有要继承的父类\n    //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n    this.baseProto = extend.prototype;\n}\n```\n\n```\n//如果有要继承的父类，先把父类的实例方法都复制过来\nextend && (TargetClass.prototype = copy(extend.prototype));\n```\n\nthis.baseProto主要目的就是为了让子类的实例能够有一个属性可以访问到父类的原型，因为后面的继承方式是复制方式，会导致原型链断裂。有了这一版之后，就可以加入Manager类来演示效果了：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //借用父类的init方法，实现属性继承（name, salary）\n                Employee.prototype.init.apply(this, [name, salary]);\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.salary + this.salary * this.percentage;\n            }\n    },\n    extend: Employee\n});\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\nconsole.log(e.constructor === Employee); //true\nconsole.log(m.constructor === Manager); //true\nconsole.log(e.id); //1\nconsole.log(m.id); //2\n```\n\n不过在Manager内部，调用父类的方法时还是apply借用的方式，所以在最后一版里面，需要把它变成我们期望的this.base的方式，反正原理前面也已经了解了，无非是在方法同名的时候，对实例方法加一个代理而已，实现如下：\n\n```\nvar Class = (function () {\n    var hasOwn = Object.prototype.hasOwnProperty;\n\n    //用来判断是否为Object的实例\n    function isObject(o) {\n        return typeof (o) === 'object';\n    }\n\n    //用来判断是否为Function的实例\n    function isFunction(f) {\n        return typeof (f) === 'function';\n    }\n\n    //简单复制\n    function copy(source) {\n        var target = {};\n        for (var i in source) {\n            if (hasOwn.call(source, i)) {\n                target[i] = source[i];\n            }\n        }\n        return target;\n    }\n\n    function ClassBuilder(options) {\n        if (!isObject(options)) {\n            throw new Error('Class options must be an valid object instance!');\n        }\n\n        var instanceMembers = isObject(options) & options.instanceMembers || {},\n            staticMembers = isObject(options) && options.staticMembers || {},\n            extend = isObject(options) && isFunction(options.extend) && options.extend,\n            prop;\n\n        //表示要构建的类的构造函数\n        function TargetClass() {\n            if (extend) {\n                //如果有要继承的父类\n                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型\n                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型\n                this.baseProto = extend.prototype;\n            }\n            if (isFunction(this.init)) {\n                this.init.apply(this, arguments);\n            }\n        }\n\n        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型\n        for (prop in staticMembers) {\n            if (hasOwn.call(staticMembers, prop)) {\n                TargetClass[prop] = staticMembers[prop];\n            }\n        }\n\n        //如果有要继承的父类，先把父类的实例方法都复制过来\n        extend & (TargetClass.prototype = copy(extend.prototype));\n\n        //添加实例方法\n        for (prop in instanceMembers) {\n\n            if (hasOwn.call(instanceMembers, prop)) {\n\n                //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法\n                if (extend & isFunction(instanceMembers[prop]) && isFunction(extend.prototype[prop])) {\n                    TargetClass.prototype[prop] = (function (name, func) {\n                        return function () {\n                            //记录实例原有的this.base的值\n                            var old = this.base;\n                            //将实例的this.base指向父类的原型的同名方法\n                            this.base = extend.prototype[name];\n                            //调用子类自身定义的实例方法，也就是func参数传递进来的函数\n                            var ret = func.apply(this, arguments);\n                            //还原实例原有的this.base的值\n                            this.base = old;\n                            return ret;\n                        }\n                    })(prop, instanceMembers[prop]);\n                } else {\n                    TargetClass.prototype[prop] = instanceMembers[prop];\n                }\n            }\n        }\n\n        TargetClass.prototype.constructor = TargetClass;\n\n        return TargetClass;\n    }\n\n    return ClassBuilder\n})();\n```\n\n核心部分是：\n\n```\nif (hasOwn.call(instanceMembers, prop)) {\n\n    //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法\n    if (extend & isFunction(instanceMembers[prop]) && isFunction(extend.prototype[prop])) {\n        TargetClass.prototype[prop] = (function (name, func) {\n            return function () {\n                //记录实例原有的this.base的值\n                var old = this.base;\n                //将实例的this.base指向父类的原型的同名方法\n                this.base = extend.prototype[name];\n                //调用子类自身定义的实例方法，也就是func参数传递进来的函数\n                var ret = func.apply(this, arguments);\n                //还原实例原有的this.base的值\n                this.base = old;\n                return ret;\n            }\n        })(prop, instanceMembers[prop]);\n    } else {\n        TargetClass.prototype[prop] = instanceMembers[prop];\n    }\n}\n```\n\n只有当需要继承父类，且父类原型中有方法与当前的实例方法同名时，才会去对当前的实例方法添加代理。更详细的原理可以回到文章第1部分回顾相关内容。至此，我们在Manager类内部调用父类的方法时，就很简单了，只要通过this.base即可：\n\n```\nvar Employee = Class({\n    instanceMembers: {\n        init: function (name, salary) {\n                this.name = name;\n                this.salary = salary;\n                //调用静态方法\n                this.id = Employee.getId();\n            },\n            getName: function () {\n                return this.name;\n            },\n            getSalary: function () {\n                return this.salary;\n            },\n            toString: function () {\n                return this.name + ''s salary is ' + this.getSalary() + '.';\n            }\n    },\n    staticMembers: {\n        idCounter: 1,\n        getId: function () {\n            return this.idCounter++;\n        }\n    }\n});\n\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //通过this.base调用父类的构造方法\n                this.base(name, salary);\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.base() + this.salary * this.percentage;\n            }\n    },\n    extend: Employee\n});\n\nvar e = new Employee('jason', 5000);\nvar m = new Manager('tom', 8000, 0.15);\n\nconsole.log(e.toString()); //jason's salary is 5000.\nconsole.log(m.toString()); //tom's salary is 9200.\nconsole.log(e.constructor === Employee); //true\nconsole.log(m.constructor === Manager); //true\nconsole.log(e.id); //1\nconsole.log(m.id); //2\n```\n\n注意这两处调用：\n\n```\nvar Manager = Class({\n    instanceMembers: {\n        init: function (name, salary, percentage) {\n                //通过this.base调用父类的构造方法\n                this.base(name, salary);//要注意的第一处\n                this.percentage = percentage;\n            },\n            getSalary: function () {\n                return this.base() + this.salary * this.percentage;//要注意的第二处this.base()\n            }\n    },\n    extend: Employee\n});\n```\n\n以上就是本文要实现的继承库的全部细节，其实它所做的事就是把本文第1部分提到的那些问题的解决方式和第二部分模拟的调用场景结合起来，封装到一个模块内部而已，各个细节的原理只要理解了第1部分总结的那些解决方式就很掌握了。在最后一版的演示中，也能看到，本文实现的这个继承库，已经完全满足了模拟场景中的需求，今后有任何需要用到继承的场景，完全可以拿最后一版的实现去开发。\n\n### 4. 总结\n\n本文在三生石上关于javascript继承系列博客的思路指引下，实现了一个易用的继承库，使用它可以更像java语言构建面向对象的类和类之间的继承关系，我可以预见在将来的工作，这个库对我的代码质量和功能实现会起到很重要的作用，因为在开发中，继承的编码思想还是应用的非常多，尤其是当我们做项目做得多的时候，一方面肯定想把一些公共的东西写成可重用的组件，另一方面又必须得满足各个项目的个性要求，所以在写组件的时候不能写的太死，多写接口，等到具体项目的时候再通过继承等方式来扩展该项目独有的功能，这样写出的组件才会更灵活稳定。总之有了这个继承库，感觉以后写的代码都会开心好多~所以希望本文的内容也能对你有同样的一些帮助。如果确实有帮助，求点推荐：）\n\n谢谢阅读！\n\n文章转载：[http://www.cnblogs.com](http://www.cnblogs.com/lyzg/p/5313752.html)\n","slug":"详解Javascript的继承实现","published":1,"updated":"2016-08-17T06:22:19.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpnu007h68dd6vml29bx","content":"<p>我最早掌握的在js中实现继承的方法是在w3school学到的混合原型链和对象冒充的方法，在工作中，只要用到继承的时候，我都是用这个方法实现。它的实现简单，思路清晰：用对象冒充继承父类构造函数的属性，用原型链继承父类prototype 对象的方法，满足我遇到过的所有继承的场景。正因如此，我从没想过下次写继承的时候，我要换一种方式来写，直到今天晚上看了三生石上关于javascript继承系列的博客（出的很早，现在才看，真有点可惜），才发现在js里面，继承机制也可以写的如此贴近java这种后端语言的实现，确实很妙！所以我想在充分理解他博客的思路下，实现一个自己今后用得到的一个继承库。</p>\n<h3 id=\"1-混合方式实现及问题\"><a href=\"#1-混合方式实现及问题\" class=\"headerlink\" title=\"1. 混合方式实现及问题\"></a>1. 混合方式实现及问题</h3><p>了解问题之前，先看看它的具体实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//父类构造函数</div><div class=\"line\">function Employee(name, salary) &#123;</div><div class=\"line\">    //实例属性：姓名</div><div class=\"line\">    this.name = name;</div><div class=\"line\">    //实例属性：薪资</div><div class=\"line\">    this.salary = salary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//通过字面量对象设置父类的原型，给父类添加实例方法</div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    //由于此处添加实例方法时也是通过修改父类原型处理的，</div><div class=\"line\">    //所以必须修改父类原型的constructor指向，避免父类实例的constructor属性指向Object函数</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    getName: function () &#123;</div><div class=\"line\">        return this.name;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getSalary: function () &#123;</div><div class=\"line\">        return this.salary;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    toString: function () &#123;</div><div class=\"line\">        return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//子类构造函数</div><div class=\"line\">function Manager(name, salary, percentage) &#123;</div><div class=\"line\">    //对象冒充，实现属性继承（name, salary）</div><div class=\"line\">    Employee.apply(this, [name, salary]);</div><div class=\"line\">    //实例属性：提成</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//将父类的一个实例设置为子类的原型，实现方法继承</div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//给子类添加新的实例方法</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>从结果上来说，这种继承实现方式没有问题，Manager的实例同时继承到了Employee类的实例属性和实例方法，并且通过instanceOf运算的结果也都正确。但是从代码组织和实现细节层面，这种方法还有以下几个问题：</p>\n<p>1）代码组织不够优雅，继承实现的关键部分的逻辑是通用的，都是如下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//将父类的一个实例设置为子类的原型，实现方法继承</div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">//给子类添加新的实例方法</div><div class=\"line\">SubClass.prototype.method1 = function() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method2 = function() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method3 = function() &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码缺乏封装。另外在添加子类的实例方法时，不能通过SubClass.prototype = { method1: function() {} }这种方式去设置，否则就把子类的原型整个又修改了，继承就无法实现了，这样每次都得按SubClass.prototype.method1 = function() {} 的结构去写，代码看起来很不连续。</p>\n<p><strong>解决方式：</strong>利用模块化的方式，将通用的逻辑封装起来，对外提供简单的接口，只要按照约定的接口调用，就能够简化类的构建与类的继承。具体实现请看后面的内容介绍，暂时只能提供理论的说明。</p>\n<p>2）在给子类的原型设置成父类的实例时，调用的是new SuperClass()，这是对父类构造函数的无参调用，那么就要求父类必须有无参的构造函数。可是在javascript中，函数无法重载，所以父类不可能提供多个构造函数，在实际业务中，大部分场景下父类构造函数又不可能没有参数，为了在唯一的一个构造函数中模拟函数重载，只能借助判断arguments.length来处理。问题就是，有时候很难保证每次写父类构造函数的时候都会添加arguments.length的判断逻辑。这样的话，这个处理方式就是有风险的。要是能把构造函数里的逻辑抽离出来，让类的构造函数全部是无参函数的话，这个问题就很好解决了。</p>\n<p><strong>解决方式：</strong>把父类跟子类的构造函数全部无参化，并且在构造函数内不写任何逻辑，把构造函数的逻辑都迁移到init这个实例方法，比如前面给出的Employee和Manager的例子就能改造成下面这个样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//无参无逻辑的父类构造函数</div><div class=\"line\">function Employee() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    //把构造逻辑搬到init方法中来</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//无参无逻辑的子类构造函数</div><div class=\"line\">function Manager() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//把构造逻辑搬到init方法中来</div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>用init方法来完成构造功能，就可以保证在设置子类原型时（Manager.prototype = new Employee()），父类的实例化操作一定不会出错，唯一不好的是在调用类的构造函数来初始化实例的时候，必须在调用构造函数后手动调用init方法来完成实际的构造逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var e = new Employee();</div><div class=\"line\">e.init(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager();</div><div class=\"line\">m.init(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>要是能把这个init的逻辑放在构造函数内部就好了，可是这样的话就会违背前面说的构造函数无参无逻辑的原则。换一种方式来考虑，这个原则的目的是为了保证在实例化父类作为子类原型的时候，调用父类的构造函数不会出错，那么就可以稍微打破一下这个原则，在类的构造函数里添加少量的并且一定不会有问题的逻辑来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//添加一个全局标识initializing，表示是否正在进行子类的构建和类的继承</div><div class=\"line\">var initializing = false;</div><div class=\"line\">//可自动调用init方法的父类构造函数</div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    if (!initializing) &#123;</div><div class=\"line\">        this.init.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    //把构造逻辑搬到init方法中来</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//可自动调用init方法的子类构造函数</div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    if (!initializing) &#123;</div><div class=\"line\">        this.init.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//表示开始子类的构建和类的继承</div><div class=\"line\">initializing = true;</div><div class=\"line\">//此时调用new Emplyee()，并不会调用Employee.prototype.init方法</div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//表示结束子类的构建和类的继承，之后调用new Employee或new Manager都会自动调用init实例方法</div><div class=\"line\">initializing = false;</div><div class=\"line\"></div><div class=\"line\">//把构造逻辑搬到init方法中来</div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用结果仍然和前面的例子一样。但是这个实现还有一个小问题，它引入了一个全局变量initializing，要是能把引入这个全局变量就好了，这个其实很好解决，只要我们把关于类的构建跟继承，封装成一个模块，然后把这个变量放在模块的内部，就没有问题了。</p>\n<p>3）在构造子类的时候，是把子类的原型设置成了父类的一个实例，这个是不符合语义的，继承应该发生在类与类之间，而不是类与实例之间。之所以要用父类的一个实例来作为子类的原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">SubClass.prototype = new SuperClass();</div></pre></td></tr></table></figure>\n<p>完全是因为父类的这个实例，指向父类的原型，而子类的实例又会指向子类的原型，所以最终子类的实例就能通过原型链访问到父类原型上的方法。这个做法虽然能实现实例方法的继承，但是它不符合语义，而且它还有一个很大的问题就是会增加原型链的长度，导致子类在调用父类方法时，必须通过原型链的查找到父类的方法才行。要是继承层次较深，会对js的执行性能有些影响。</p>\n<p><strong>解决方式：</strong>在解决这个问题之前，先想想继承能帮我们解决什么问题：从父类复用已有的实例属性和实例方法。在javascript面向对象编程中，一直有一个原则就是，实例属性都写在构造函数或者实例方法里面，实例方法写在原型上面，也就是说类的原型，按照这个原则来说，就是用来写实例方法的，而且是只用来写实例方法，那么我们完全可以在构建子类时，通过复制的方式将父类原型的所有方法全部添加到子类的原型上，不一定要把父类的一个实例设置成子类的原型，这样就能将原型链的长度大大地缩短，借助一个简短的copy函数，我们就能轻松对前面的代码进行改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题</div><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\">//将父类的原型方法复制到子类的原型上</div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>这么做了以后，当调用m.toString的时候其实调用的是Manager类自身原型上的方法，而不是Employee类的实例方法，缩短了在原型链上查找方法的距离。这个做法在性能上有很大的优点，但不好的是通过原型链维持的继承关系其实已经断了，子类的原型和子类的实例都无法再通过js原生的属性访问到父类的原型，所以这个调用console.log(m instanceof Employee)输出的是false。不过跟性能比起来，这个都可以不算问题：一是instanceOf的运算，几乎在javascript的开发里面用不到，至少我是没碰到过；二是通过复制方式完全能够把父类的实例方法继承下来，这就已经达到了继承的最大目的。</p>\n<p>这个方法还有一个额外的好处是，解决了第2个问题最后提到的引入initializing全局变量的问题，如果是复制的话，就不需要在构建继承关系时，去调用父类的构造函数，那么也就没有必要在构造函数内先判断initializing才能去调用init方法，上面的代码中就已经去掉了initializing这个变量的处理。</p>\n<p>4）在子类的构造函数和实例方法内如果想要调用父类的构造函数或者方法，显得比较繁琐：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function SuperClass() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">    constructor: SuperClass,</div><div class=\"line\">    method1: function () &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function SubClass() &#123;</div><div class=\"line\">    //调用父类构造函数</div><div class=\"line\">    SuperClass.apply(this);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">SubClass.prototype.method1 = function () &#123;</div><div class=\"line\">    //调用父类的实例方法</div><div class=\"line\">    SuperClass.prototype.method1.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method2 = function () &#123;&#125;</div><div class=\"line\">SubClass.prototype.method3 = function () &#123;&#125;</div></pre></td></tr></table></figure>\n<p>每次都得靠apply借用方法来处理。要是能改成如下的调用就好用多了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function SubClass() &#123;</div><div class=\"line\">//调用父类构造函数</div><div class=\"line\">        this.base();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">SubClass.prototype.method1 = function() &#123;</div><div class=\"line\">//调用父类的实例方法</div><div class=\"line\">        this.base();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方式：</strong>如果要在每个实例方法里，都能通过this.base()调用父类原型上相应的方法，那么this.base就一定不是一个固定的方法，需要在每个实例方法执行期间动态地将this.base指定为父类原型的同名方法，能够做到这个实现的方式，就只有通过方法代理了，前面的Employee和Manager的例子可以改造如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题</div><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    //必须在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">    this.baseProto = Employee.prototype;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = (function (name, func) &#123;</div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        //记录实例原有的this.base的值</div><div class=\"line\">        var old = this.base;</div><div class=\"line\">        //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">        this.base = this.baseProto[name];</div><div class=\"line\">        //调用子类自身定义的init方法，也就是func参数传递进来的函数</div><div class=\"line\">        var ret = func.apply(this, arguments);</div><div class=\"line\">        //还原实例原有的this.base的值</div><div class=\"line\">        this.base = old;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(&apos;init&apos;, function (name, salary, percentage) &#123;</div><div class=\"line\">    //通过this.base调用父类的init方法</div><div class=\"line\">    //这个函数真实的调用位置是var ret = func.apply(this, arguments);</div><div class=\"line\">    //当调用Manager实例的init方法时，其实不是调用的这个函数</div><div class=\"line\">    //而是调用上面那个匿名函数里面return的匿名函数</div><div class=\"line\">    //在return的匿名函数里，先把this.base指向为了父类原型的同名函数，然后在调用func</div><div class=\"line\">    //func内部再通过调用this.base时，就能调用父类的原型方法。</div><div class=\"line\">    this.base(name, salary);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>通过代理的方式，就解决了在在实例方法内部通过this.base调用父类原型同名方法的问题。可是在实际情况中，每个实例方法都有可能需要调用父类的实例，那么每个实例方法都要添加同样的代码，显然这会增加很多麻烦，好在这部分的逻辑也是同样的，我们可以把它抽象一下，最后都放到模块化的内部去，这样就能简化代理的工作。</p>\n<p>5）未考虑静态属性和静态方法。尽管静态成员是不需要继承的，但在有些场景下，我们还是需要静态成员，所以得考虑静态成员应该添加在哪里。</p>\n<p><strong>解决方式：</strong>由于js原生并不支持静态成员，所以只能借助一些公共的位置来处理。最佳的位置是添加到构造函数上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//添加一个静态属性</div><div class=\"line\">Employee.idCounter = 1;</div><div class=\"line\">//添加一个静态方法</div><div class=\"line\">Employee.getId = function () &#123;</div><div class=\"line\">    return Employee.idCounter++;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">            //调用静态方法</div><div class=\"line\">            this.id = Employee.getId();</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    this.baseProto = Employee.prototype;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = (function (name, func) &#123;</div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        var old = this.base;</div><div class=\"line\">        this.base = this.baseProto[name];</div><div class=\"line\">        var ret = func.apply(this, arguments);</div><div class=\"line\">        this.base = old;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(&apos;init&apos;, function (name, salary, percentage) &#123;</div><div class=\"line\">    this.base(name, salary);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div><div class=\"line\">console.log(m.id); //2</div><div class=\"line\">console.log(e.id); //1</div></pre></td></tr></table></figure>\n<p>最后的两行输出了正确的实例id，而这个id是通过Employee类的静态方法生成的。在java的面向对象编程中，子类跟父类都可以定义静态成员，在调用的时候还存在覆盖的问题，在js里面，因为受语言的限制，自定义的静态成员不可能实现全面的面向对象功能，就像上面这种，能够给类提供一些公共的属性和公共方法，就已经足够了。</p>\n<h3 id=\"2-期望的调用方式\"><a href=\"#2-期望的调用方式\" class=\"headerlink\" title=\"2. 期望的调用方式\"></a>2. 期望的调用方式</h3><p>从第1部分的分析可以看出，在js里面，类的构建与继承，有很多通用的逻辑，完全可以把这些逻辑封装成一个单独的模块，形成一个通用的类库，以便在工作中有需要的时候，都可以直接拿来使用。这个类库要求能完成我们需要的功能（类的构建与继承和静态成员的添加），同时在使用时要足够简洁方便。在利用bootstrap的modal组件自定义alert，confirm和modal对话框这篇文章里，我曾说过一些从组件期望的调用方式，去反推组件实现的一些观点，当你明确你需要什么东西时，你才知道这个东西你该怎么去创造。本文要编写的这个继承组件也会采取这个方法来实现，我先用前面Employee和Manager的例子来模拟调用这个继承库的场景，通过预设的一些组件名称或者接口名称以及调用方式，来尝试走通真实使用这个继承库的流程，有了这个东西，下一步我只需要根据这个要求去实现即可，模拟如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//通过调用Class函数构造一个类</div><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    //通过instanceMembers指定这个类的实例成员</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    //通过staticMembers指定这个类的静态成员</div><div class=\"line\">    //静态方法内部可通过this访问其它静态成员</div><div class=\"line\">    //在外部可通过Employee.getId这种方式访问到静态成员</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                this.base(name, salary);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">                Manager.count++;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    //通过extend指定要继承的类</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>从模拟的结果来看，我想要的继承库对外提供的名称只有Class, instanceMembers, staticMembers和extend而已，调用方式也很简单，只要传递参数给Class函数即可。接下来就按照这个目标，看看如何一步步根据第一部分罗列的那些问题和解决方式，把这个库给写出来。</p>\n<h3 id=\"3-继承库的详细实现\"><a href=\"#3-继承库的详细实现\" class=\"headerlink\" title=\"3. 继承库的详细实现\"></a>3. 继承库的详细实现</h3><p>根据API名称和接口以及前面第1部分提出的问题，这个继承库要完成的功能有：</p>\n<p>1）类的构建（关键：init方法）和静态成员处理；</p>\n<p>2）继承关系的构建（关键：父类原型的复制）；</p>\n<p>3）父类方法的简化调用（关键：父类原型上同名方法的代理）。</p>\n<p>所以这个库的实现，可以按照这三点分成三版来开发。</p>\n<p>1）第一版</p>\n<p>在第一版里面，仅需要实现类的构架和静态成员添加的功能即可，细节如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype = instanceMembers;</div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这一版核心代码在于类的构建和静态成员添加的部分，其它代码仅仅提供一些提前可以想到的赋值函数和变量（isObject, isFunction)，并做一些参数合法性校验的处理。添加静态成员的代码一定要在设置原型的代码之前，否则就有原型被覆盖的风险。有了这个版本，就可以直接构建带静态成员的Employee类了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(e.constructor === Employee); //true</div></pre></td></tr></table></figure>\n<p>在getId方法中之所以直接使用this就能访问到构造函数Employee，是因为getId这个方法是添加到构造函数上的，所以当调用Employee.getId()时，getId方法里面的this指向的就是Employee这个函数对象。</p>\n<p>第二版在第一版的基础上，实现继承关系的构建部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //简单复制</div><div class=\"line\">    function copy(source) &#123;</div><div class=\"line\">        var target = &#123;&#125;;</div><div class=\"line\">        for (var i in source) &#123;</div><div class=\"line\">            if (hasOwn.call(source, i)) &#123;</div><div class=\"line\">                target[i] = source[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return target;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (extend) &#123;</div><div class=\"line\">                //如果有要继承的父类</div><div class=\"line\">                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">                this.baseProto = extend.prototype;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">        extend &amp; (TargetClass.prototype = copy(extend.prototype));</div><div class=\"line\"></div><div class=\"line\">        //添加实例方法</div><div class=\"line\">        for (prop in instanceMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\">                TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这一版关键的部分在于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if(extend)&#123;</div><div class=\"line\">    //如果有要继承的父类</div><div class=\"line\">    //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">    this.baseProto = extend.prototype;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">extend &amp;&amp; (TargetClass.prototype = copy(extend.prototype));</div></pre></td></tr></table></figure>\n<p>this.baseProto主要目的就是为了让子类的实例能够有一个属性可以访问到父类的原型，因为后面的继承方式是复制方式，会导致原型链断裂。有了这一版之后，就可以加入Manager类来演示效果了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">                Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\">console.log(e.constructor === Employee); //true</div><div class=\"line\">console.log(m.constructor === Manager); //true</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(m.id); //2</div></pre></td></tr></table></figure>\n<p>不过在Manager内部，调用父类的方法时还是apply借用的方式，所以在最后一版里面，需要把它变成我们期望的this.base的方式，反正原理前面也已经了解了，无非是在方法同名的时候，对实例方法加一个代理而已，实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //简单复制</div><div class=\"line\">    function copy(source) &#123;</div><div class=\"line\">        var target = &#123;&#125;;</div><div class=\"line\">        for (var i in source) &#123;</div><div class=\"line\">            if (hasOwn.call(source, i)) &#123;</div><div class=\"line\">                target[i] = source[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return target;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (extend) &#123;</div><div class=\"line\">                //如果有要继承的父类</div><div class=\"line\">                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">                this.baseProto = extend.prototype;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">        extend &amp; (TargetClass.prototype = copy(extend.prototype));</div><div class=\"line\"></div><div class=\"line\">        //添加实例方法</div><div class=\"line\">        for (prop in instanceMembers) &#123;</div><div class=\"line\"></div><div class=\"line\">            if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\"></div><div class=\"line\">                //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法</div><div class=\"line\">                if (extend &amp; isFunction(instanceMembers[prop]) &amp;&amp; isFunction(extend.prototype[prop])) &#123;</div><div class=\"line\">                    TargetClass.prototype[prop] = (function (name, func) &#123;</div><div class=\"line\">                        return function () &#123;</div><div class=\"line\">                            //记录实例原有的this.base的值</div><div class=\"line\">                            var old = this.base;</div><div class=\"line\">                            //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">                            this.base = extend.prototype[name];</div><div class=\"line\">                            //调用子类自身定义的实例方法，也就是func参数传递进来的函数</div><div class=\"line\">                            var ret = func.apply(this, arguments);</div><div class=\"line\">                            //还原实例原有的this.base的值</div><div class=\"line\">                            this.base = old;</div><div class=\"line\">                            return ret;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;)(prop, instanceMembers[prop]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>核心部分是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\"></div><div class=\"line\">    //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法</div><div class=\"line\">    if (extend &amp; isFunction(instanceMembers[prop]) &amp;&amp; isFunction(extend.prototype[prop])) &#123;</div><div class=\"line\">        TargetClass.prototype[prop] = (function (name, func) &#123;</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                //记录实例原有的this.base的值</div><div class=\"line\">                var old = this.base;</div><div class=\"line\">                //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">                this.base = extend.prototype[name];</div><div class=\"line\">                //调用子类自身定义的实例方法，也就是func参数传递进来的函数</div><div class=\"line\">                var ret = func.apply(this, arguments);</div><div class=\"line\">                //还原实例原有的this.base的值</div><div class=\"line\">                this.base = old;</div><div class=\"line\">                return ret;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(prop, instanceMembers[prop]);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有当需要继承父类，且父类原型中有方法与当前的实例方法同名时，才会去对当前的实例方法添加代理。更详细的原理可以回到文章第1部分回顾相关内容。至此，我们在Manager类内部调用父类的方法时，就很简单了，只要通过this.base即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //通过this.base调用父类的构造方法</div><div class=\"line\">                this.base(name, salary);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.base() + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\">console.log(e.constructor === Employee); //true</div><div class=\"line\">console.log(m.constructor === Manager); //true</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(m.id); //2</div></pre></td></tr></table></figure>\n<p>注意这两处调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //通过this.base调用父类的构造方法</div><div class=\"line\">                this.base(name, salary);//要注意的第一处</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.base() + this.salary * this.percentage;//要注意的第二处this.base()</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上就是本文要实现的继承库的全部细节，其实它所做的事就是把本文第1部分提到的那些问题的解决方式和第二部分模拟的调用场景结合起来，封装到一个模块内部而已，各个细节的原理只要理解了第1部分总结的那些解决方式就很掌握了。在最后一版的演示中，也能看到，本文实现的这个继承库，已经完全满足了模拟场景中的需求，今后有任何需要用到继承的场景，完全可以拿最后一版的实现去开发。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>本文在三生石上关于javascript继承系列博客的思路指引下，实现了一个易用的继承库，使用它可以更像java语言构建面向对象的类和类之间的继承关系，我可以预见在将来的工作，这个库对我的代码质量和功能实现会起到很重要的作用，因为在开发中，继承的编码思想还是应用的非常多，尤其是当我们做项目做得多的时候，一方面肯定想把一些公共的东西写成可重用的组件，另一方面又必须得满足各个项目的个性要求，所以在写组件的时候不能写的太死，多写接口，等到具体项目的时候再通过继承等方式来扩展该项目独有的功能，这样写出的组件才会更灵活稳定。总之有了这个继承库，感觉以后写的代码都会开心好多~所以希望本文的内容也能对你有同样的一些帮助。如果确实有帮助，求点推荐：）</p>\n<p>谢谢阅读！</p>\n<p>文章转载：<a href=\"http://www.cnblogs.com/lyzg/p/5313752.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com</a></p>\n","excerpt":"","more":"<p>我最早掌握的在js中实现继承的方法是在w3school学到的混合原型链和对象冒充的方法，在工作中，只要用到继承的时候，我都是用这个方法实现。它的实现简单，思路清晰：用对象冒充继承父类构造函数的属性，用原型链继承父类prototype 对象的方法，满足我遇到过的所有继承的场景。正因如此，我从没想过下次写继承的时候，我要换一种方式来写，直到今天晚上看了三生石上关于javascript继承系列的博客（出的很早，现在才看，真有点可惜），才发现在js里面，继承机制也可以写的如此贴近java这种后端语言的实现，确实很妙！所以我想在充分理解他博客的思路下，实现一个自己今后用得到的一个继承库。</p>\n<h3 id=\"1-混合方式实现及问题\"><a href=\"#1-混合方式实现及问题\" class=\"headerlink\" title=\"1. 混合方式实现及问题\"></a>1. 混合方式实现及问题</h3><p>了解问题之前，先看看它的具体实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//父类构造函数</div><div class=\"line\">function Employee(name, salary) &#123;</div><div class=\"line\">    //实例属性：姓名</div><div class=\"line\">    this.name = name;</div><div class=\"line\">    //实例属性：薪资</div><div class=\"line\">    this.salary = salary;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//通过字面量对象设置父类的原型，给父类添加实例方法</div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    //由于此处添加实例方法时也是通过修改父类原型处理的，</div><div class=\"line\">    //所以必须修改父类原型的constructor指向，避免父类实例的constructor属性指向Object函数</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    getName: function () &#123;</div><div class=\"line\">        return this.name;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getSalary: function () &#123;</div><div class=\"line\">        return this.salary;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    toString: function () &#123;</div><div class=\"line\">        return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//子类构造函数</div><div class=\"line\">function Manager(name, salary, percentage) &#123;</div><div class=\"line\">    //对象冒充，实现属性继承（name, salary）</div><div class=\"line\">    Employee.apply(this, [name, salary]);</div><div class=\"line\">    //实例属性：提成</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//将父类的一个实例设置为子类的原型，实现方法继承</div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//给子类添加新的实例方法</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>从结果上来说，这种继承实现方式没有问题，Manager的实例同时继承到了Employee类的实例属性和实例方法，并且通过instanceOf运算的结果也都正确。但是从代码组织和实现细节层面，这种方法还有以下几个问题：</p>\n<p>1）代码组织不够优雅，继承实现的关键部分的逻辑是通用的，都是如下结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//将父类的一个实例设置为子类的原型，实现方法继承</div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">//修改子类原型的constructor指向，避免子类实例的constructor属性指向父类的构造函数</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">//给子类添加新的实例方法</div><div class=\"line\">SubClass.prototype.method1 = function() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method2 = function() &#123;</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method3 = function() &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码缺乏封装。另外在添加子类的实例方法时，不能通过SubClass.prototype = { method1: function() {} }这种方式去设置，否则就把子类的原型整个又修改了，继承就无法实现了，这样每次都得按SubClass.prototype.method1 = function() {} 的结构去写，代码看起来很不连续。</p>\n<p><strong>解决方式：</strong>利用模块化的方式，将通用的逻辑封装起来，对外提供简单的接口，只要按照约定的接口调用，就能够简化类的构建与类的继承。具体实现请看后面的内容介绍，暂时只能提供理论的说明。</p>\n<p>2）在给子类的原型设置成父类的实例时，调用的是new SuperClass()，这是对父类构造函数的无参调用，那么就要求父类必须有无参的构造函数。可是在javascript中，函数无法重载，所以父类不可能提供多个构造函数，在实际业务中，大部分场景下父类构造函数又不可能没有参数，为了在唯一的一个构造函数中模拟函数重载，只能借助判断arguments.length来处理。问题就是，有时候很难保证每次写父类构造函数的时候都会添加arguments.length的判断逻辑。这样的话，这个处理方式就是有风险的。要是能把构造函数里的逻辑抽离出来，让类的构造函数全部是无参函数的话，这个问题就很好解决了。</p>\n<p><strong>解决方式：</strong>把父类跟子类的构造函数全部无参化，并且在构造函数内不写任何逻辑，把构造函数的逻辑都迁移到init这个实例方法，比如前面给出的Employee和Manager的例子就能改造成下面这个样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//无参无逻辑的父类构造函数</div><div class=\"line\">function Employee() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    //把构造逻辑搬到init方法中来</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//无参无逻辑的子类构造函数</div><div class=\"line\">function Manager() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//把构造逻辑搬到init方法中来</div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>用init方法来完成构造功能，就可以保证在设置子类原型时（Manager.prototype = new Employee()），父类的实例化操作一定不会出错，唯一不好的是在调用类的构造函数来初始化实例的时候，必须在调用构造函数后手动调用init方法来完成实际的构造逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var e = new Employee();</div><div class=\"line\">e.init(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager();</div><div class=\"line\">m.init(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>要是能把这个init的逻辑放在构造函数内部就好了，可是这样的话就会违背前面说的构造函数无参无逻辑的原则。换一种方式来考虑，这个原则的目的是为了保证在实例化父类作为子类原型的时候，调用父类的构造函数不会出错，那么就可以稍微打破一下这个原则，在类的构造函数里添加少量的并且一定不会有问题的逻辑来解决：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//添加一个全局标识initializing，表示是否正在进行子类的构建和类的继承</div><div class=\"line\">var initializing = false;</div><div class=\"line\">//可自动调用init方法的父类构造函数</div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    if (!initializing) &#123;</div><div class=\"line\">        this.init.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    //把构造逻辑搬到init方法中来</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//可自动调用init方法的子类构造函数</div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    if (!initializing) &#123;</div><div class=\"line\">        this.init.apply(this, arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//表示开始子类的构建和类的继承</div><div class=\"line\">initializing = true;</div><div class=\"line\">//此时调用new Emplyee()，并不会调用Employee.prototype.init方法</div><div class=\"line\">Manager.prototype = new Employee();</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\">//表示结束子类的构建和类的继承，之后调用new Employee或new Manager都会自动调用init实例方法</div><div class=\"line\">initializing = false;</div><div class=\"line\"></div><div class=\"line\">//把构造逻辑搬到init方法中来</div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>调用结果仍然和前面的例子一样。但是这个实现还有一个小问题，它引入了一个全局变量initializing，要是能把引入这个全局变量就好了，这个其实很好解决，只要我们把关于类的构建跟继承，封装成一个模块，然后把这个变量放在模块的内部，就没有问题了。</p>\n<p>3）在构造子类的时候，是把子类的原型设置成了父类的一个实例，这个是不符合语义的，继承应该发生在类与类之间，而不是类与实例之间。之所以要用父类的一个实例来作为子类的原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">SubClass.prototype = new SuperClass();</div></pre></td></tr></table></figure>\n<p>完全是因为父类的这个实例，指向父类的原型，而子类的实例又会指向子类的原型，所以最终子类的实例就能通过原型链访问到父类原型上的方法。这个做法虽然能实现实例方法的继承，但是它不符合语义，而且它还有一个很大的问题就是会增加原型链的长度，导致子类在调用父类方法时，必须通过原型链的查找到父类的方法才行。要是继承层次较深，会对js的执行性能有些影响。</p>\n<p><strong>解决方式：</strong>在解决这个问题之前，先想想继承能帮我们解决什么问题：从父类复用已有的实例属性和实例方法。在javascript面向对象编程中，一直有一个原则就是，实例属性都写在构造函数或者实例方法里面，实例方法写在原型上面，也就是说类的原型，按照这个原则来说，就是用来写实例方法的，而且是只用来写实例方法，那么我们完全可以在构建子类时，通过复制的方式将父类原型的所有方法全部添加到子类的原型上，不一定要把父类的一个实例设置成子类的原型，这样就能将原型链的长度大大地缩短，借助一个简短的copy函数，我们就能轻松对前面的代码进行改造：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题</div><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\">//将父类的原型方法复制到子类的原型上</div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = function (name, salary, percentage) &#123;</div><div class=\"line\">    Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>这么做了以后，当调用m.toString的时候其实调用的是Manager类自身原型上的方法，而不是Employee类的实例方法，缩短了在原型链上查找方法的距离。这个做法在性能上有很大的优点，但不好的是通过原型链维持的继承关系其实已经断了，子类的原型和子类的实例都无法再通过js原生的属性访问到父类的原型，所以这个调用console.log(m instanceof Employee)输出的是false。不过跟性能比起来，这个都可以不算问题：一是instanceOf的运算，几乎在javascript的开发里面用不到，至少我是没碰到过；二是通过复制方式完全能够把父类的实例方法继承下来，这就已经达到了继承的最大目的。</p>\n<p>这个方法还有一个额外的好处是，解决了第2个问题最后提到的引入initializing全局变量的问题，如果是复制的话，就不需要在构建继承关系时，去调用父类的构造函数，那么也就没有必要在构造函数内先判断initializing才能去调用init方法，上面的代码中就已经去掉了initializing这个变量的处理。</p>\n<p>4）在子类的构造函数和实例方法内如果想要调用父类的构造函数或者方法，显得比较繁琐：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function SuperClass() &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">SuperClass.prototype = &#123;</div><div class=\"line\">    constructor: SuperClass,</div><div class=\"line\">    method1: function () &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function SubClass() &#123;</div><div class=\"line\">    //调用父类构造函数</div><div class=\"line\">    SuperClass.apply(this);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">SubClass.prototype.method1 = function () &#123;</div><div class=\"line\">    //调用父类的实例方法</div><div class=\"line\">    SuperClass.prototype.method1.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\">SubClass.prototype.method2 = function () &#123;&#125;</div><div class=\"line\">SubClass.prototype.method3 = function () &#123;&#125;</div></pre></td></tr></table></figure>\n<p>每次都得靠apply借用方法来处理。要是能改成如下的调用就好用多了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">function SubClass() &#123;</div><div class=\"line\">//调用父类构造函数</div><div class=\"line\">        this.base();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">SubClass.prototype = new SuperClass();</div><div class=\"line\">SubClass.prototype.constructor = SubClass;</div><div class=\"line\">SubClass.prototype.method1 = function() &#123;</div><div class=\"line\">//调用父类的实例方法</div><div class=\"line\">        this.base();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><strong>解决方式：</strong>如果要在每个实例方法里，都能通过this.base()调用父类原型上相应的方法，那么this.base就一定不是一个固定的方法，需要在每个实例方法执行期间动态地将this.base指定为父类原型的同名方法，能够做到这个实现的方式，就只有通过方法代理了，前面的Employee和Manager的例子可以改造如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//用来复制父类原型，由于父类原型上约定只写实例方法，所以复制的时候不必担心引用的问题</div><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    //必须在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">    this.baseProto = Employee.prototype;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">//子类还是需要修改constructor指向，因为从父类原型复制出来的对象的constructor还是指向父类的构造函数</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = (function (name, func) &#123;</div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        //记录实例原有的this.base的值</div><div class=\"line\">        var old = this.base;</div><div class=\"line\">        //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">        this.base = this.baseProto[name];</div><div class=\"line\">        //调用子类自身定义的init方法，也就是func参数传递进来的函数</div><div class=\"line\">        var ret = func.apply(this, arguments);</div><div class=\"line\">        //还原实例原有的this.base的值</div><div class=\"line\">        this.base = old;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(&apos;init&apos;, function (name, salary, percentage) &#123;</div><div class=\"line\">    //通过this.base调用父类的init方法</div><div class=\"line\">    //这个函数真实的调用位置是var ret = func.apply(this, arguments);</div><div class=\"line\">    //当调用Manager实例的init方法时，其实不是调用的这个函数</div><div class=\"line\">    //而是调用上面那个匿名函数里面return的匿名函数</div><div class=\"line\">    //在return的匿名函数里，先把this.base指向为了父类原型的同名函数，然后在调用func</div><div class=\"line\">    //func内部再通过调用this.base时，就能调用父类的原型方法。</div><div class=\"line\">    this.base(name, salary);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div></pre></td></tr></table></figure>\n<p>通过代理的方式，就解决了在在实例方法内部通过this.base调用父类原型同名方法的问题。可是在实际情况中，每个实例方法都有可能需要调用父类的实例，那么每个实例方法都要添加同样的代码，显然这会增加很多麻烦，好在这部分的逻辑也是同样的，我们可以把它抽象一下，最后都放到模块化的内部去，这样就能简化代理的工作。</p>\n<p>5）未考虑静态属性和静态方法。尽管静态成员是不需要继承的，但在有些场景下，我们还是需要静态成员，所以得考虑静态成员应该添加在哪里。</p>\n<p><strong>解决方式：</strong>由于js原生并不支持静态成员，所以只能借助一些公共的位置来处理。最佳的位置是添加到构造函数上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var copy = function (source) &#123;</div><div class=\"line\">    var target = &#123;&#125;;</div><div class=\"line\">    for (var i in source) &#123;</div><div class=\"line\">        if (source.hasOwnProperty(i)) &#123;</div><div class=\"line\">            target[i] = source[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return target;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Employee() &#123;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//添加一个静态属性</div><div class=\"line\">Employee.idCounter = 1;</div><div class=\"line\">//添加一个静态方法</div><div class=\"line\">Employee.getId = function () &#123;</div><div class=\"line\">    return Employee.idCounter++;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Employee.prototype = &#123;</div><div class=\"line\">    constructor: Employee,</div><div class=\"line\">    init: function (name, salary) &#123;</div><div class=\"line\">            this.name = name;</div><div class=\"line\">            this.salary = salary;</div><div class=\"line\">            //调用静态方法</div><div class=\"line\">            this.id = Employee.getId();</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getName: function () &#123;</div><div class=\"line\">            return this.name;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        getSalary: function () &#123;</div><div class=\"line\">            return this.salary;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        toString: function () &#123;</div><div class=\"line\">            return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">function Manager() &#123;</div><div class=\"line\">    this.baseProto = Employee.prototype;</div><div class=\"line\">    this.init.apply(this, arguments);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype = copy(Employee.prototype);</div><div class=\"line\">Manager.prototype.constructor = Manager;</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.init = (function (name, func) &#123;</div><div class=\"line\">    return function () &#123;</div><div class=\"line\">        var old = this.base;</div><div class=\"line\">        this.base = this.baseProto[name];</div><div class=\"line\">        var ret = func.apply(this, arguments);</div><div class=\"line\">        this.base = old;</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)(&apos;init&apos;, function (name, salary, percentage) &#123;</div><div class=\"line\">    this.base(name, salary);</div><div class=\"line\">    this.percentage = percentage;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Manager.prototype.getSalary = function () &#123;</div><div class=\"line\">    return this.salary + this.salary * this.percentage;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\"></div><div class=\"line\">console.log(m instanceof Manager); //true</div><div class=\"line\">console.log(m instanceof Employee); //false</div><div class=\"line\">console.log(e instanceof Employee); //true</div><div class=\"line\">console.log(e instanceof Manager); //false</div><div class=\"line\">console.log(m.id); //2</div><div class=\"line\">console.log(e.id); //1</div></pre></td></tr></table></figure>\n<p>最后的两行输出了正确的实例id，而这个id是通过Employee类的静态方法生成的。在java的面向对象编程中，子类跟父类都可以定义静态成员，在调用的时候还存在覆盖的问题，在js里面，因为受语言的限制，自定义的静态成员不可能实现全面的面向对象功能，就像上面这种，能够给类提供一些公共的属性和公共方法，就已经足够了。</p>\n<h3 id=\"2-期望的调用方式\"><a href=\"#2-期望的调用方式\" class=\"headerlink\" title=\"2. 期望的调用方式\"></a>2. 期望的调用方式</h3><p>从第1部分的分析可以看出，在js里面，类的构建与继承，有很多通用的逻辑，完全可以把这些逻辑封装成一个单独的模块，形成一个通用的类库，以便在工作中有需要的时候，都可以直接拿来使用。这个类库要求能完成我们需要的功能（类的构建与继承和静态成员的添加），同时在使用时要足够简洁方便。在利用bootstrap的modal组件自定义alert，confirm和modal对话框这篇文章里，我曾说过一些从组件期望的调用方式，去反推组件实现的一些观点，当你明确你需要什么东西时，你才知道这个东西你该怎么去创造。本文要编写的这个继承组件也会采取这个方法来实现，我先用前面Employee和Manager的例子来模拟调用这个继承库的场景，通过预设的一些组件名称或者接口名称以及调用方式，来尝试走通真实使用这个继承库的流程，有了这个东西，下一步我只需要根据这个要求去实现即可，模拟如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//通过调用Class函数构造一个类</div><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    //通过instanceMembers指定这个类的实例成员</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    //通过staticMembers指定这个类的静态成员</div><div class=\"line\">    //静态方法内部可通过this访问其它静态成员</div><div class=\"line\">    //在外部可通过Employee.getId这种方式访问到静态成员</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                this.base(name, salary);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">                Manager.count++;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    //通过extend指定要继承的类</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>从模拟的结果来看，我想要的继承库对外提供的名称只有Class, instanceMembers, staticMembers和extend而已，调用方式也很简单，只要传递参数给Class函数即可。接下来就按照这个目标，看看如何一步步根据第一部分罗列的那些问题和解决方式，把这个库给写出来。</p>\n<h3 id=\"3-继承库的详细实现\"><a href=\"#3-继承库的详细实现\" class=\"headerlink\" title=\"3. 继承库的详细实现\"></a>3. 继承库的详细实现</h3><p>根据API名称和接口以及前面第1部分提出的问题，这个继承库要完成的功能有：</p>\n<p>1）类的构建（关键：init方法）和静态成员处理；</p>\n<p>2）继承关系的构建（关键：父类原型的复制）；</p>\n<p>3）父类方法的简化调用（关键：父类原型上同名方法的代理）。</p>\n<p>所以这个库的实现，可以按照这三点分成三版来开发。</p>\n<p>1）第一版</p>\n<p>在第一版里面，仅需要实现类的构架和静态成员添加的功能即可，细节如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype = instanceMembers;</div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这一版核心代码在于类的构建和静态成员添加的部分，其它代码仅仅提供一些提前可以想到的赋值函数和变量（isObject, isFunction)，并做一些参数合法性校验的处理。添加静态成员的代码一定要在设置原型的代码之前，否则就有原型被覆盖的风险。有了这个版本，就可以直接构建带静态成员的Employee类了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(e.constructor === Employee); //true</div></pre></td></tr></table></figure>\n<p>在getId方法中之所以直接使用this就能访问到构造函数Employee，是因为getId这个方法是添加到构造函数上的，所以当调用Employee.getId()时，getId方法里面的this指向的就是Employee这个函数对象。</p>\n<p>第二版在第一版的基础上，实现继承关系的构建部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //简单复制</div><div class=\"line\">    function copy(source) &#123;</div><div class=\"line\">        var target = &#123;&#125;;</div><div class=\"line\">        for (var i in source) &#123;</div><div class=\"line\">            if (hasOwn.call(source, i)) &#123;</div><div class=\"line\">                target[i] = source[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return target;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (extend) &#123;</div><div class=\"line\">                //如果有要继承的父类</div><div class=\"line\">                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">                this.baseProto = extend.prototype;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">        extend &amp; (TargetClass.prototype = copy(extend.prototype));</div><div class=\"line\"></div><div class=\"line\">        //添加实例方法</div><div class=\"line\">        for (prop in instanceMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\">                TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>这一版关键的部分在于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if(extend)&#123;</div><div class=\"line\">    //如果有要继承的父类</div><div class=\"line\">    //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">    //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">    this.baseProto = extend.prototype;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">//如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">extend &amp;&amp; (TargetClass.prototype = copy(extend.prototype));</div></pre></td></tr></table></figure>\n<p>this.baseProto主要目的就是为了让子类的实例能够有一个属性可以访问到父类的原型，因为后面的继承方式是复制方式，会导致原型链断裂。有了这一版之后，就可以加入Manager类来演示效果了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //借用父类的init方法，实现属性继承（name, salary）</div><div class=\"line\">                Employee.prototype.init.apply(this, [name, salary]);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\">console.log(e.constructor === Employee); //true</div><div class=\"line\">console.log(m.constructor === Manager); //true</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(m.id); //2</div></pre></td></tr></table></figure>\n<p>不过在Manager内部，调用父类的方法时还是apply借用的方式，所以在最后一版里面，需要把它变成我们期望的this.base的方式，反正原理前面也已经了解了，无非是在方法同名的时候，对实例方法加一个代理而已，实现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Class = (function () &#123;</div><div class=\"line\">    var hasOwn = Object.prototype.hasOwnProperty;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Object的实例</div><div class=\"line\">    function isObject(o) &#123;</div><div class=\"line\">        return typeof (o) === &apos;object&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //用来判断是否为Function的实例</div><div class=\"line\">    function isFunction(f) &#123;</div><div class=\"line\">        return typeof (f) === &apos;function&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //简单复制</div><div class=\"line\">    function copy(source) &#123;</div><div class=\"line\">        var target = &#123;&#125;;</div><div class=\"line\">        for (var i in source) &#123;</div><div class=\"line\">            if (hasOwn.call(source, i)) &#123;</div><div class=\"line\">                target[i] = source[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return target;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    function ClassBuilder(options) &#123;</div><div class=\"line\">        if (!isObject(options)) &#123;</div><div class=\"line\">            throw new Error(&apos;Class options must be an valid object instance!&apos;);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        var instanceMembers = isObject(options) &amp; options.instanceMembers || &#123;&#125;,</div><div class=\"line\">            staticMembers = isObject(options) &amp;&amp; options.staticMembers || &#123;&#125;,</div><div class=\"line\">            extend = isObject(options) &amp;&amp; isFunction(options.extend) &amp;&amp; options.extend,</div><div class=\"line\">            prop;</div><div class=\"line\"></div><div class=\"line\">        //表示要构建的类的构造函数</div><div class=\"line\">        function TargetClass() &#123;</div><div class=\"line\">            if (extend) &#123;</div><div class=\"line\">                //如果有要继承的父类</div><div class=\"line\">                //就在每个实例中添加baseProto属性，以便实例内部可以通过这个属性访问到父类的原型</div><div class=\"line\">                //因为copy函数导致原型链断裂，无法通过原型链访问到父类的原型</div><div class=\"line\">                this.baseProto = extend.prototype;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isFunction(this.init)) &#123;</div><div class=\"line\">                this.init.apply(this, arguments);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //添加静态成员，这段代码需在原型设置的前面执行，避免staticMembers中包含prototype属性，覆盖类的原型</div><div class=\"line\">        for (prop in staticMembers) &#123;</div><div class=\"line\">            if (hasOwn.call(staticMembers, prop)) &#123;</div><div class=\"line\">                TargetClass[prop] = staticMembers[prop];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //如果有要继承的父类，先把父类的实例方法都复制过来</div><div class=\"line\">        extend &amp; (TargetClass.prototype = copy(extend.prototype));</div><div class=\"line\"></div><div class=\"line\">        //添加实例方法</div><div class=\"line\">        for (prop in instanceMembers) &#123;</div><div class=\"line\"></div><div class=\"line\">            if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\"></div><div class=\"line\">                //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法</div><div class=\"line\">                if (extend &amp; isFunction(instanceMembers[prop]) &amp;&amp; isFunction(extend.prototype[prop])) &#123;</div><div class=\"line\">                    TargetClass.prototype[prop] = (function (name, func) &#123;</div><div class=\"line\">                        return function () &#123;</div><div class=\"line\">                            //记录实例原有的this.base的值</div><div class=\"line\">                            var old = this.base;</div><div class=\"line\">                            //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">                            this.base = extend.prototype[name];</div><div class=\"line\">                            //调用子类自身定义的实例方法，也就是func参数传递进来的函数</div><div class=\"line\">                            var ret = func.apply(this, arguments);</div><div class=\"line\">                            //还原实例原有的this.base的值</div><div class=\"line\">                            this.base = old;</div><div class=\"line\">                            return ret;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;)(prop, instanceMembers[prop]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        TargetClass.prototype.constructor = TargetClass;</div><div class=\"line\"></div><div class=\"line\">        return TargetClass;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return ClassBuilder</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>核心部分是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">if (hasOwn.call(instanceMembers, prop)) &#123;</div><div class=\"line\"></div><div class=\"line\">    //如果有要继承的父类，且在父类的原型上存在当前实例方法同名的方法</div><div class=\"line\">    if (extend &amp; isFunction(instanceMembers[prop]) &amp;&amp; isFunction(extend.prototype[prop])) &#123;</div><div class=\"line\">        TargetClass.prototype[prop] = (function (name, func) &#123;</div><div class=\"line\">            return function () &#123;</div><div class=\"line\">                //记录实例原有的this.base的值</div><div class=\"line\">                var old = this.base;</div><div class=\"line\">                //将实例的this.base指向父类的原型的同名方法</div><div class=\"line\">                this.base = extend.prototype[name];</div><div class=\"line\">                //调用子类自身定义的实例方法，也就是func参数传递进来的函数</div><div class=\"line\">                var ret = func.apply(this, arguments);</div><div class=\"line\">                //还原实例原有的this.base的值</div><div class=\"line\">                this.base = old;</div><div class=\"line\">                return ret;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)(prop, instanceMembers[prop]);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        TargetClass.prototype[prop] = instanceMembers[prop];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>只有当需要继承父类，且父类原型中有方法与当前的实例方法同名时，才会去对当前的实例方法添加代理。更详细的原理可以回到文章第1部分回顾相关内容。至此，我们在Manager类内部调用父类的方法时，就很简单了，只要通过this.base即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Employee = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary) &#123;</div><div class=\"line\">                this.name = name;</div><div class=\"line\">                this.salary = salary;</div><div class=\"line\">                //调用静态方法</div><div class=\"line\">                this.id = Employee.getId();</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getName: function () &#123;</div><div class=\"line\">                return this.name;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.salary;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            toString: function () &#123;</div><div class=\"line\">                return this.name + &apos;&apos;s salary is &apos; + this.getSalary() + &apos;.&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    staticMembers: &#123;</div><div class=\"line\">        idCounter: 1,</div><div class=\"line\">        getId: function () &#123;</div><div class=\"line\">            return this.idCounter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //通过this.base调用父类的构造方法</div><div class=\"line\">                this.base(name, salary);</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.base() + this.salary * this.percentage;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">var e = new Employee(&apos;jason&apos;, 5000);</div><div class=\"line\">var m = new Manager(&apos;tom&apos;, 8000, 0.15);</div><div class=\"line\"></div><div class=\"line\">console.log(e.toString()); //jason&apos;s salary is 5000.</div><div class=\"line\">console.log(m.toString()); //tom&apos;s salary is 9200.</div><div class=\"line\">console.log(e.constructor === Employee); //true</div><div class=\"line\">console.log(m.constructor === Manager); //true</div><div class=\"line\">console.log(e.id); //1</div><div class=\"line\">console.log(m.id); //2</div></pre></td></tr></table></figure>\n<p>注意这两处调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">var Manager = Class(&#123;</div><div class=\"line\">    instanceMembers: &#123;</div><div class=\"line\">        init: function (name, salary, percentage) &#123;</div><div class=\"line\">                //通过this.base调用父类的构造方法</div><div class=\"line\">                this.base(name, salary);//要注意的第一处</div><div class=\"line\">                this.percentage = percentage;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            getSalary: function () &#123;</div><div class=\"line\">                return this.base() + this.salary * this.percentage;//要注意的第二处this.base()</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    extend: Employee</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>以上就是本文要实现的继承库的全部细节，其实它所做的事就是把本文第1部分提到的那些问题的解决方式和第二部分模拟的调用场景结合起来，封装到一个模块内部而已，各个细节的原理只要理解了第1部分总结的那些解决方式就很掌握了。在最后一版的演示中，也能看到，本文实现的这个继承库，已经完全满足了模拟场景中的需求，今后有任何需要用到继承的场景，完全可以拿最后一版的实现去开发。</p>\n<h3 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4. 总结\"></a>4. 总结</h3><p>本文在三生石上关于javascript继承系列博客的思路指引下，实现了一个易用的继承库，使用它可以更像java语言构建面向对象的类和类之间的继承关系，我可以预见在将来的工作，这个库对我的代码质量和功能实现会起到很重要的作用，因为在开发中，继承的编码思想还是应用的非常多，尤其是当我们做项目做得多的时候，一方面肯定想把一些公共的东西写成可重用的组件，另一方面又必须得满足各个项目的个性要求，所以在写组件的时候不能写的太死，多写接口，等到具体项目的时候再通过继承等方式来扩展该项目独有的功能，这样写出的组件才会更灵活稳定。总之有了这个继承库，感觉以后写的代码都会开心好多~所以希望本文的内容也能对你有同样的一些帮助。如果确实有帮助，求点推荐：）</p>\n<p>谢谢阅读！</p>\n<p>文章转载：<a href=\"http://www.cnblogs.com/lyzg/p/5313752.html\">http://www.cnblogs.com</a></p>\n"},{"title":"轻量级Modal模态框插件cta.js","date":"2015-02-08T16:00:00.000Z","_content":"\n项目地址：[https://github.com/chinchang/cta.js](https://github.com/chinchang/cta.js)\n\n演示地址：[http://kushagragour.in/lab/ctajs/](http://kushagragour.in/lab/ctajs/)\n\n>360会警告说是虚假招聘网站，不知道为什么\n","source":"_posts/轻量级Modal模态框插件cta.js.md","raw":"---\ntitle: 轻量级Modal模态框插件cta.js\ntags: [javascript]\ndate: 2015/02/09\n---\n\n项目地址：[https://github.com/chinchang/cta.js](https://github.com/chinchang/cta.js)\n\n演示地址：[http://kushagragour.in/lab/ctajs/](http://kushagragour.in/lab/ctajs/)\n\n>360会警告说是虚假招聘网站，不知道为什么\n","slug":"轻量级Modal模态框插件cta.js","published":1,"updated":"2016-08-17T06:22:19.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpnx007k68ddlk24k6hq","content":"<p>项目地址：<a href=\"https://github.com/chinchang/cta.js\" target=\"_blank\" rel=\"external\">https://github.com/chinchang/cta.js</a></p>\n<p>演示地址：<a href=\"http://kushagragour.in/lab/ctajs/\" target=\"_blank\" rel=\"external\">http://kushagragour.in/lab/ctajs/</a></p>\n<blockquote>\n<p>360会警告说是虚假招聘网站，不知道为什么</p>\n</blockquote>\n","excerpt":"","more":"<p>项目地址：<a href=\"https://github.com/chinchang/cta.js\">https://github.com/chinchang/cta.js</a></p>\n<p>演示地址：<a href=\"http://kushagragour.in/lab/ctajs/\">http://kushagragour.in/lab/ctajs/</a></p>\n<blockquote>\n<p>360会警告说是虚假招聘网站，不知道为什么</p>\n</blockquote>\n"},{"title":"使用ES6写更好的JavaScript","date":"2016-05-29T16:00:00.000Z","_content":"\n## 使用 ES6 写更好的 JavaScript part I：广受欢迎新特性\n\n### 介绍\n\n在ES2015规范敲定并且Node.js增添了大量的函数式子集的背景下，我们终于可以拍着胸脯说：未来就在眼前。\n\n… 我早就想这样说了\n\n但这是真的。V8引擎将很快实现规范，而且Node已经添加了大量可用于生产环境的ES2015特性。下面要列出的是一些我认为很有必要的特性，而且这些特性是不使用需要像Babel或者Traceur这样的翻译器就可以直接使用的。\n\n这篇文章将会讲到三个相当流行的ES2015特性，并且已经在Node中支持了了：\n\n+ 用let和const声明块级作用域；\n+ 箭头函数；\n+ 简写属性和方法。\n\n让我们马上开始。\n\n### let和const声明块级作用域\n\n作用域是你程序中变量可见的区域。换句话说就是一系列的规则，它们决定了你声明的变量在哪里是可以使用的。\n\n大家应该都听过 ，在JavaScript中只有在函数内部才会创造新的作用域。然而你创建的98%的作用域事实上都是函数作用域，其实在JavaScript中有三种创建新作用域的方法。你可以这样：\n\n1. 创建一个函数。你应该已经知道这种方式。\n2. 创建一个catch块。 我绝对没哟开玩笑.\n3. 创建一个代码块。如果你用的是ES2015，在一段代码块中用let或者const声明的变量会限制它们只在这个块中可见。这叫做块级作用域。\n\n一个代码块就是你用花括号包起来的部分。 { 像这样 }。在if/else声明和try/catch/finally块中经常出现。如果你想利用块作用域的优势，你可以用花括号包裹任意的代码来创建一个代码块\n\n考虑下面的代码片段。\n\n```javascript\n// 在 Node 中你需要使用 strict 模式尝试这个\n\"use strict\";\n\nvar foo = \"foo\";\nfunction baz() {\n    if (foo) {\n        var bar = \"bar\";\n        let foobar = foo + bar;\n    }\n    // foo 和 bar 这里都可见 \n    console.log(\"This situation is \" + foo + bar + \". I'm going home.\");\n    try {\n        console.log(\"This log statement is \" + foobar + \"! It threw a ReferenceError at me!\");\n    } catch (err) {\n        console.log(\"You got a \" + err + \"; no dice.\");\n    }\n    try {\n        console.log(\"Just to prove to you that \" + err + \" doesn't exit outside of the above `catch` block.\");\n    } catch (err) {\n        console.log(\"Told you so.\");\n    }\n}\n\nbaz();\n\ntry {\n    console.log(invisible);\n} catch (err) {\n    console.log(\"invisible hasn't been declared, yet, so we get a \" + err);\n}\nlet invisible = \"You can't see me, yet\"; // let 声明的变量在声明前是不可访问的\n```\n\n还有些要强调的\n\n+ 注意foobar在if块之外是不可见的，因为我们没有用let声明；\n+ 我们可以在任何地方使用foo ，因为我们用var定义它为全局作用域可见；\n+ 我们可以在baz内部任何地方使用bar， 因为var-声明的变量是在定义的整个作用域内都可见。\n+ 用let or const声明的变量不能在定义前调用。换句话说，它不会像var变量一样被编译器提升到作用域的开始处。\n\nconst 与 let 类似，但有两点不同。\n\n1. 必须给声明为const的变量在声明时赋值。不可以先声明后赋值。\n2. 不能改变const变量的值，只有在创建它时可以给它赋值。如果你试图改变它的值，会得到一个TyepError。\n\n### let & const: Who Cares?\n\n我们已经用var将就了二十多年了，你可能在想我们真的需要新的类型声明关键字吗？（这里作者应该是想表达这个意思）\n\n问的好，简单的回答就是–不， 并不真正需要。但在可以用let和const的地方使用它们很有好处的。\n\n+ let和const声明变量时都不会被提升到作用域开始的地方，这样可以使代码可读性更强，制造尽可能少的迷惑。\n+ 它会尽可能的约束变量的作用域，有助于减少令人迷惑的命名冲突。\n+ 这样可以让程序只有在必须重新分配变量的情况下重新分配变量。 const 可以加强常量的引用。\n\n另一个例子就是 let 在 for 循环中的使用：\n\n```javascript\n\"use strict\";\n\nvar languages = ['Danish', 'Norwegian', 'Swedish'];\n\n//会污染全局变量!\nfor (var i = 0; i &lt; languages.length; i += 1) {\n    console.log(`${languages[i]} is a Scandinavian language.`);\n}\n\nconsole.log(i); // 4\n\nfor (let j = 0; j &lt; languages.length; j += 1) {\n    console.log(`${languages[j]} is a Scandinavian language.`);\n}\n\ntry {\n    console.log(j); // Reference error\n} catch (err) {\n    console.log(`You got a ${err}; no dice.`);\n}\n```\n\n在for循环中使用var声明的计数器并不会真正把计数器的值限制在本次循环中。 而let可以。\n\nlet在每次迭代时重新绑定循环变量有很大的优势，这样每个循环中拷贝自身 , 而不是共享全局范围内的变量。\n\n```javascript\n\"use strict\";\n\n// 简洁明了\nfor (let i = 1; i &lt; 6; i += 1) {\n    setTimeout(function() {\n        console.log(\"I've waited \" + i + \" seconds!\");\n    }, 1000 * i);\n}\n\n// 功能完全混乱\nfor (var j = 0; j &lt; 6; j += 1) {\n        setTimeout(function() {\n        console.log(\"I've waited \" + j + \" seconds for this!\");\n    }, 1000 * j);\n}\n```\n\n第一层循环会和你想象的一样工作。而下面的会每秒输出 “I’ve waited 6 seconds!”。\n\n好吧，我选择狗带。\n\n### 动态this关键字的怪异\n\nJavaScript的this关键字因为总是不按套路出牌而臭名昭著。\n\n事实上，它的规则相当简单。不管怎么说，this在有些情形下会导致奇怪的用法\n\n```javascript\n\"use strict\";\n\nconst polyglot = {\n    name : \"Michel Thomas\",\n    languages : [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"],\n    introduce : function () {\n        // this.name is \"Michel Thomas\"\n        const self = this;\n        this.languages.forEach(function(language) {\n            // this.name is undefined, so we have to use our saved \"self\" variable \n            console.log(\"My name is \" + self.name + \", and I speak \" + language + \".\");\n        });\n    }\n}\n\npolyglot.introduce();\n```\n\n在introduce里, this.name是undefined。在回调函数外面，也就是forEach中， 它指向了polyglot对象。在这种情形下我们总是希望在函数内部this和函数外部的this指向同一个对象。\n\n问题是在JavaScript中函数会根据确定性四原则在调用时定义自己的this变量。这就是著名的动态this 机制。\n\n这些规则中没有一个是关于查找this所描述的“附近作用域”的；也就是说并没有一个确切的方法可以让JavaScript引擎能够基于包裹作用域来定义this的含义。\n\n这就意味着当引擎查找this的值时，可以找到值，但却和回调函数之外的不是同一个值。有两种传统的方案可以解决这个问题。\n\n+ 在函数外面把this保存到一个变量中，通常取名self，并在内部函数中使用；\n+ 或者在内部函数中调用bind阻止对this的赋值。\n\n以上两种办法均可生效，但会产生副作用。\n\n另一方面，如果内部函数没有设置它自己的this值，JavaScript会像查找其它变量那样查找this的值：通过遍历父作用域直到找到同名的变量。这样会让我们使用附近作用域代码中的this值，这就是著名的词法this。\n\n如果有样的特性，我们的代码将会更加的清晰，不是吗?\n\n### 箭头函数中的词法this\n\n在 ES2015 中，我们有了这一特性。箭头函数不会绑定this值，允许我们利用词法绑定this关键字。这样我们就可以像这样重构上面的代码了：\n\n```javascript\n\"use strict\";\n\nlet polyglot = {\n    name : \"Michel Thomas\",\n    languages : [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"],\n    introduce : function () {\n        this.languages.forEach((language) =&gt; {\n            console.log(\"My name is \" + this.name + \", and I speak \" + language + \".\");\n        });\n    }\n}\n```\n\n… 这样就会按照我们想的那样工作了。\n\n箭头函数有一些新的语法。\n\n```javascript\n\"use strict\";\n\nlet languages = [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"];\n\n// 多行箭头函数必须使用花括号， \n// 必须明确包含返回值语句\n    let languages_lower = languages.map((language) =&gt; {\n    return language.toLowerCase()\n});\n\n// 单行箭头函数，花括号是可省的，\n// 函数默认返回最后一个表达式的值\n// 你可以指明返回语句，这是可选的。\nlet languages_lower = languages.map((language) =&gt; language.toLowerCase());\n\n// 如果你的箭头函数只有一个参数，可以省略括号\nlet languages_lower = languages.map(language =&gt; language.toLowerCase());\n\n// 如果箭头函数有多个参数，必须用圆括号包裹\nlet languages_lower = languages.map((language, unused_param) =&gt; language.toLowerCase());\n\nconsole.log(languages_lower); // [\"spanish\", \"french\", \"italian\", \"german\", \"polish\"]\n\n// 最后，如果你的函数没有参数，你必须在箭头前加上空的括号。\n(() =&gt; alert(\"Hello!\"))();\n```\n\nMDN关于箭头函数的文档解释的很好。\n\n### 简写属性和方法\n\nES2015提供了在对象上定义属性和方法的一些新方式。\n\n### 简写方法\n\n在 JavaScript 中， method 是对象的一个有函数值的属性：\n\n```javascript\n\"use strict\";\n\nconst myObject = {\n    const foo = function () {\n        console.log('bar');\n    },\n}\n```\n\n在ES2015中，我们可以这样简写：\n\n```javascript\n\"use strict\";\n\nconst myObject = {\n    foo () {\n        console.log('bar');\n    },\n    * range (from, to) {\n        while (from &lt; to) {\n            if (from === to)\n                return ++from;\n            else\n                yield from ++;\n        }\n    }\n}\n```\n\n注意你也可以使用生成器去定义方法。只需要在函数名前面加一个星号(*)。\n\n这些叫做 方法定义 。和传统的函数作为属性很像，但有一些不同：\n\n+ 只能在方法定义处调用super；\n+ 不允许用new调用方法定义。\n\n我会在随后的几篇文章中讲到super关键字。如果你等不及了， Exploring ES6中有关于它的干货。\n\n### 简写和推导属性\n\nES6还引入了简写和推导属性 。\n\n如果对象的键值和变量名是一致的，那么你可以仅用变量名来初始化你的对象，而不是定义冗余的键值对。\n\n```javascript\n\"use strict\";\n\nconst foo = 'foo';\nconst bar = 'bar';\n\n// 旧语法\nconst myObject = {\n    foo : foo,\n    bar : bar\n};\n\n// 新语法\nconst myObject = { foo, bar }\n```\n\n两中语法都以foo和bar键值指向foo and bar变量。后面的方式语义上更加一致；这只是个语法糖。\n\n当用揭示模块模式来定义一些简洁的公共 API 的定义，我常常利用简写属性的优势。\n\n```javascript\n\"use strict\";\n\nfunction Module () {\n    function foo () {\n        return 'foo';\n    }\n    \n    function bar () {\n        return 'bar';\n    }\n    \n    // 这样写:\n    const publicAPI = { foo, bar }\n    \n    /* 不要这样写:\n    const publicAPI =  {\n       foo : foo,\n       bar : bar\n    } */ \n    \n    return publicAPI;\n};\n```\n\n这里我们创建并返回了一个publicAPI对象，键值foo指向foo方法，键值bar指向bar方法。\n\n### 推导属性名\n\n这是不常见的例子，但ES6允许你用表达式做属性名。\n\n```javascript\n\"use strict\";\n\nconst myObj = {\n  // 设置属性名为 foo 函数的返回值\n    [foo ()] () {\n      return 'foo';\n    }\n};\n\nfunction foo () {\n    return 'foo';\n}\n\nconsole.log(myObj.foo() ); // 'foo'\n```\n\n根据Dr. Raushmayer在Exploring ES6中讲的，这种特性最主要的用途是设置属性名与Symbol值一样。\n\n### Getter 和 Setter 方法\n\n最后，我想提一下get和set方法，它们在ES5中就已经支持了。\n\n```javascript\n\"use strict\";\n\n// 例子采用的是 MDN's 上关于 getter 的内容\n//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\nconst speakingObj = {\n    // 记录 “speak” 方法调用过多少次\n    words : [],\n    \n    speak (word) {\n        this.words.push(word);\n        console.log('speakingObj says ' + word + '!');\n    },\n    \n    get called () {\n        // 返回最新的单词\n        const words = this.words;\n        if (!words.length)\n            return 'speakingObj hasn\\'t spoken, yet.';\n        else\n            return words[words.length - 1];\n    }\n};\n\nconsole.log(speakingObj.called); // 'speakingObj hasn't spoken, yet.'\n\nspeakingObj.speak('blargh'); // 'speakingObj says blargh!'\n\nconsole.log(speakingObj.called); // 'blargh'\n```\n\n使用getters时要记得下面这些:\n\n+ Getters不接受参数；\n+ 属性名不可以和getter函数重名；\n+ 可以用Object.defineProperty(OBJECT, \"property name\", { get : function () { . . . } }) 动态创建 getter\n\n作为最后这点的例子，我们可以这样定义上面的 getter 方法：\n\n```javascript\n\"use strict\";\n\nconst speakingObj = {\n    // 记录 “speak” 方法调用过多少次\n    words : [],\n    \n    speak (word) {\n        this.words.push(word);\n        console.log('speakingObj says ' + word + '!');\n    }\n};\n\n// 这只是为了证明观点。我是绝对不会这样写的\nfunction called () {\n    // 返回新的单词\n    const words = this.words;\n    if (!words.length)\n        return 'speakingObj hasn\\'t spoken, yet.';\n    else\n        return words[words.length - 1];\n};\n\nObject.defineProperty(speakingObj, \"called\", get : getCalled ) \n除了 getters，还有 setters。像平常一样，它们通过自定义的逻辑给对象设置属性。\n\n\"use strict\";\n\n// 创建一个新的 globetrotter（环球者）！\nconst globetrotter = {\n    // globetrotter 现在所处国家所说的语言 \n    const current_lang = undefined,\n    \n    // globetrotter 已近环游过的国家\n    let countries = 0,\n    \n    // 查看环游过哪些国家了\n    get countryCount () {\n        return this.countries;\n    }, \n    \n    // 不论 globe trotter 飞到哪里，都重新设置他的语言\n    set languages (language) {\n        // 增加环游过的城市数\n        countries += 1;\n    \n        // 重置当前语言\n        this.current_lang = language; \n    };\n};\n\nglobetrotter.language = 'Japanese';\nglobetrotter.countryCount(); // 1\n\nglobetrotter.language = 'Spanish';\nglobetrotter.countryCount(); // 2\n```\n\n上面讲的关于getters的也同样适用于setters，但有一点不同：\n\n+ getter不接受参数，setters必须接受正好一个参数。\n\n破坏这些规则中的任意一个都会抛出一个错误。\n\n既然 Angular 2 正在引入TypeCript并且把class带到了台前，我希望get and set能够流行起来… 但还有点希望它们不要流行起来。\n\n### 结论\n\n未来的JavaScript正在变成现实，是时候把它提供的东西都用起来了。这篇文章里，我们浏览了 ES2015的三个很流行的特性：\n\n+ let和const带来的块级作用域；\n+ 箭头函数带来的this的词法作用域；\n+ 简写属性和方法，以及getter和setter函数的回顾。\n\n## 使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]\n\n### 辞旧迎新\n\n在本文的开始，我们要说明一件事：\n\n从本质上说，ES6的classes主要是给创建老式构造函数提供了一种更加方便的语法，并不是什么新魔法 —— Axel Rauschmayer，Exploring ES6作者\n\n从功能上来讲，class声明就是一个语法糖，它只是比我们之前一直使用的基于原型的行为委托功能更强大一点。本文将从新语法与原型的关系入手，仔细研究ES2015的class关键字。文中将提及以下内容：\n\n+ 定义与实例化类；\n+ 使用extends创建子类；\n+ 子类中super语句的调用；\n+ 以及重要的标记方法（symbol method）的例子。\n\n在此过程中，我们将特别注意 class 声明语法从本质上是如何映射到基于原型代码的。\n\n让我们从头开始说起。\n\n### 退一步说：Classes不是什么\n\nJavaScript的『类』与Java、Python或者其他你可能用过的面向对象语言中的类不同。其实后者可能称作面向『类』的语言更为准确一些。\n\n在传统的面向类的语言中，我们创建的类是对象的模板。需要一个新对象时，我们实例化这个类，这一步操作告诉语言引擎将这个类的方法和属性复制到一个新实体上，这个实体称作实例。实例是我们自己的对象，且在实例化之后与父类毫无内在联系。\n\n而JavaScript没有这样的复制机制。在JavaScript中『实例化』一个类创建了一个新对象，但这个新对象却不独立于它的父类。\n\n正相反，它创建了一个与原型相连接的对象。即使是在实例化之后，对于原型的修改也会传递到实例化的新对象去。\n\n原型本身就是一个无比强大的设计模式。有许多使用了原型的技术模仿了传统类的机制，class便为这些技术提供了简洁的语法。\n\n总而言之：\n\n+ JavaScript不存在Java和其他面向对象语言中的类概念；\n+ JavaScript 的class很大程度上只是原型继承的语法糖，与传统的类继承有很大的不同。\n\n搞清楚这些之后，让我们先看一下class。\n\n### 类基础：声明与表达式\n\n我们使用class 关键字创建类，关键字之后是变量标识符，最后是一个称作类主体的代码块。这种写法称作类的声明。没有使用extends关键字的类声明被称作基类：\n\n```javascript\n\"use strict\";\n\n// Food 是一个基类\nclass Food {\n\n    constructor (name, protein, carbs, fat) {\n        this.name = name;\n        this.protein = protein;\n        this.carbs = carbs;\n        this.fat = fat;\n    }\n\n    toString () {\n        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`\n    }\n\n    print () {\n        console.log( this.toString() );\n    }\n}\n\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\n\nchicken_breast.print(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'\nconsole.log(chicken_breast.protein); // 26 (LINE A)\n```\n\n需要注意到以下事情：\n\n+ 类只能包含方法定义，不能有数据属性；\n+ 定义方法时，可以使用简写方法定义；\n+ 与创建对象不同，我们不能在类主体中使用逗号分隔方法定义；\n+ 我们可以在实例化对象上直接引用类的属性（如 LINE A）。\n\n类有一个独有的特性，就是 contructor 构造方法。在构造方法中我们可以初始化对象的属性。\n\n构造方法的定义并不是必须的。如果不写构造方法，引擎会为我们插入一个空的构造方法：\n\n```javascript\n\"use strict\";\n\nclass NoConstructor {\n    /* JavaScript 会插入这样的代码：\n     constructor () { }\n    */\n}\n\nconst nemo = new NoConstructor(); // 能工作，但没啥意思\n```\n\n将一个类赋值给一个变量的形式叫类表达式，这种写法可以替代上面的语法形式：\n\n```javascript\n\"use strict\";\n\n// 这是一个匿名类表达式，在类主体中我们不能通过名称引用它\nconst Food = class {\n    // 和上面一样的类定义……\n}\n\n// 这是一个命名类表达式，在类主体中我们可以通过名称引用它\nconst Food = class FoodClass {\n    // 和上面一样的类定义……\n\n    //  添加一个新方法，证明我们可以通过内部名称引用 FoodClass……        \n    printMacronutrients () {\n        console.log(`${FoodClass.name} | ${FoodClass.protein} g P :: ${FoodClass.carbs} g C :: ${FoodClass.fat} g F`)\n    }\n}\n\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\nchicken_breast.printMacronutrients(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'\n\n// 但是不能在外部引用\ntry {\n    console.log(FoodClass.protein); // 引用错误\n} catch (err) {\n    // pass\n}\n```\n\n这一行为与匿名函数与命名函数表达式很类似。\n\n### 使用extends创建子类以及使用super调用\n\n使用extends创建的类被称作子类，或派生类。这一用法简单明了，我们直接在上面的例子中构建：\n\n```javascript\n\"use strict\";\n\n// FatFreeFood 是一个派生类\nclass FatFreeFood extends Food {\n\n    constructor (name, protein, carbs) {\n        super(name, protein, carbs, 0);\n    }\n\n    print () {\n        super.print();\n        console.log(`Would you look at that -- ${this.name} has no fat!`);\n    }\n\n}\n\nconst fat_free_yogurt = new FatFreeFood('Greek Yogurt', 16, 12);\nfat_free_yogurt.print(); // 'Greek Yogurt | 26g P :: 16g C :: 0g F  /  Would you look at that -- Greek Yogurt has no fat!'\n```\n\n派生类拥有我们上文讨论的一切有关基类的特性，另外还有如下几点新特点：\n\n+ 子类使用class关键字声明，之后紧跟一个标识符，然后使用extend关键字，最后写一个任意表达式。这个表达式通常来讲就是个标识符，但理论上也可以是函数。\n+ 如果你的派生类需要引用它的父类，可以使用super关键字。\n+ 一个派生类不能有一个空的构造函数。即使这个构造函数就是调用了一下super()，你也得把它显式的写出来。但派生类却可以没有构造函数。\n+ 在派生类的构造函数中，必须先调用super，才能使用this关键字（译者注：仅在构造函数中是这样，在其他方法中可以直接使用this）。\n\n在JavaScript中仅有两个super关键字的使用场景：\n\n1. 在子类构造函数中调用。如果初始化派生类是需要使用父类的构造函数，我们可以在子类的构造函数中调用super(parentConstructorParams)，传递任意需要的参数。\n2. 引用父类的方法。在常规方法定义中，派生类可以使用点运算符来引用父类的方法：super.methodName。\n\n我们的 FatFreeFood 演示了这两种情况：\n\n1. 在构造函数中，我们简单的调用了super，并将脂肪的量传入为0。\n2. 在我们的print方法中，我们先调用了super.print，之后才添加了其他的逻辑。\n\n不管你信不信，我反正是信了以上说的已涵盖了有关class的基础语法，这就是你开始实验需要掌握的全部内容。\n\n### 深入学习原型\n\n现在我们开始关注class是怎么映射到JavaScript内部的原型机制的。我们会关注以下几点：\n\n+ 使用构造调用创建对象；\n+ 原型连接的本质；\n+ 属性和方法委托；\n+ 使用原型模拟类。\n+ 使用构造调用创建对象\n\n构造函数不是什么新鲜玩意儿。使用new关键字调用任意函数会使其返回一个对象 —— 这一步称作创建了一个构造调用，这种函数通常被称作构造器：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\n// 使用 'new' 关键字调用 Food 方法，就是构造调用，该操作会返回一个对象\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\nconsole.log(chicken_breast.protein) // 26\n\n// 不用 'new' 调用 Food 方法，会返回 'undefined'\nconst fish = Food('Halibut', 26, 0, 2);\nconsole.log(fish); // 'undefined'\n```\n\n当我们使用new关键字调用函数时，JS内部执行了下面四个步骤：\n\n1. 创建一个新对象（这里称它为O）；\n2. 给O赋予一个连接到其他对象的链接，称为原型；\n3. 将函数的this引用指向O；\n4. 函数隐式返回O。\n\n在第三步和第四步之间，引擎会执行你函数中的具体逻辑。\n\n知道了这一点，我们就可以重写Food方法，使之不用new关键字也能工作：\n\n```javascript\n\"use strict\";\n\n// 演示示例：消除对 'new' 关键字的依赖\nfunction Food (name, protein, carbs, fat) {\n    // 第一步：创建新对象\n    const obj = { };\n\n    // 第二步：链接原型——我们在下文会更加具体地探究原型的概念\n    Object.setPrototypeOf(obj, Food.prototype);\n\n    // 第三步：设置 'this' 指向我们的新对象\n    // 尽然我们不能再运行的执行上下文中重置 `this`\n    // 我们在使用 'obj' 取代 'this' 来模拟第三步\n    obj.name    = name;\n    obj.protein = protein;\n    obj.carbs   = carbs;\n    obj.fat     = fat;\n\n    // 第四步：返回新创建的对象\n    return obj;\n}\n\nconst fish = Food('Halibut', 26, 0, 2);\nconsole.log(fish.protein); // 26\n```\n\n四步中的三步都是简单明了的。创建一个对象、赋值属性、然后写一个return声明，这些操作对大多数开发者来说没有理解上的问题——然而这就是难倒众人的黑魔法原型。\n\n### 直观理解原型链\n\n在通常情况下，JavaScript中的包括函数在内的所有对象都会链接到另一个对象上，这就是原型。\n\n如果我们访问一个对象本身没有的属性，JavaScript就会在对象的原型上检查该属性。换句话说，如果你对一个对象请求它没有的属性，它会对你说：『这个我不知道，问我的原型吧』。\n\n在另一个对象上查找不存在属性的过程称作委托。\n\n```javascript\n\"use strict\";\n\n// joe 没有 toString 方法……\nconst joe    = { name : 'Joe' },\n    sara   = { name : 'Sara' };\n\nObject.hasOwnProperty(joe, toString); // false\nObject.hasOwnProperty(sara, toString); // false\n\n// ……但我们还是可以调用它！\njoe.toString(); // '[object Object]'，而不是引用错误！\nsara.toString(); // '[object Object]'，而不是引用错误！\n```\n\n尽管我们的 toString 的输出完全没啥用，但请注意：这段代码没有引起任何的ReferenceError！这是因为尽管joe和sara没有toString的属性，但他们的原型有啊。\n\n当我们寻找sara.toString()方法时，sara说：『我没有toString属性，找我的原型吧』。正如上文所说，JavaScript会亲切的询问Object.prototype 是否含有toString属性。由于原型上有这一属性，JS 就会把Object.prototype上的toString返回给我们程序并执行。\n\nsara本身没有属性没关系——我们会把查找操作委托到原型上。\n\n换言之，我们就可以访问到对象上并不存在的属性，只要其的原型上有这些属性。我们可以利用这一点将属性和方法赋值到对象的原型上，然后我们就可以调用这些属性，好像它们真的存在在那个对象上一样。\n\n更给力的是，如果几个对象共享相同的原型——正如上面的joe和sara的例子一样——当我们给原型赋值属性之后，它们就都可以访问了，无需将这些属性单独拷贝到每一个对象上。\n\n这就是为何大家把它称作原型继承——如果我的对象没有，但对象的原型有，那我的对象也能继承这个属性。\n\n事实上，这里并没有发生什么『继承』。在面向类的语言里，继承指从父类复制属性到子类的行为。在JavaScript里，没发生这种复制的操作，事实上这就是原型继承与类继承相比的一个主要优势。\n\n在我们探究原型究竟是怎么来的之前，我们先做一个简要回顾：\n\n+ joe和sara没有『继承』一个toString的属性；\n+ joe和sara实际上根本没有从Object.prototype上『继承』；\n+ joe和sara是链接到了Object.prototype上；\n+ joe和sara链接到了同一个Object.prototype上。\n+ 如果想找到一个对象的（我们称它作O）原型，我们可以使用 Object.getPrototypeof(O)。\n\n然后我们再强调一遍：对象没有『继承自』他们的原型。他们只是委托到原型上。\n\n以上。\n\n接下来让我们深入一下。\n\n### 设置对象的原型\n\n我们已了解到基本上每个对象（下文以O指代）都有原型（下文以P指代），然后当我们查找O上没有的属性，JavaScript引擎就会在P上寻找这个属性。\n\n至此我们有两个问题：\n\n+ 以上情况函数怎么玩？\n+ 这些原型是从哪里来的？\n\n名为Object的函数\n\n在JavaScript引擎执行程序之前，它会创建一个环境让程序在内部执行，在执行环境中会创建一个函数，叫做Object, 以及一个关联对象，叫做Object.prototype。\n\n换句话说，Object和Object.prototype在任意执行中的JavaScript程序中永远存在。\n\n这个Object乍一看好像和其他函数没什么区别，但特别之处在于它是一个构造器——在调用它时返回一个新对象：\n\n```javascript\n\"use strict\";\n\ntypeof new Object(); // \"object\"\ntypeof Object();     // 这个 Object 函数的特点是不需要使用 new 关键字调用\n```\n\n这个Object.prototype对象是个……对象。正如其他对象一样，它有属性。\n\n![https://i.imgsafe.org/ebbd5e3.png](https://i.imgsafe.org/ebbd5e3.png)\n\n关于Object和Object.prototype你需要知道以下几点：\n\n1. Object函数有一个叫做.prototype的属性，指向一个对象（Object.prototype）；\n2. Object.prototype对象有一个叫做.constructor的属性，指向一个函数（Object）。\n\n实际上，这个总体方案对于JavaScript中的所有函数都是适用的。当我们创建一个函数——下文称作 someFunction——这个函数就会有一个属性.prototype，指向一个叫做someFunction.prototype 的对象。\n\n与之相反，someFunction.prototype对象会有一个叫做.contructor的属性，它的引用指回函数someFunction。\n\n```javascript\n\"use strict\";\n\nfunction foo () {  console.log('Foo!');  }\n\nconsole.log(foo.prototype); // 指向一个叫 'foo' 的对象\nconsole.log(foo.prototype.constructor); // 指向 'foo' 函数\n\nfoo.prototype.constructor(); // 输出 'Foo!' —— 仅为证明确实有 'foo.prototype.constructor' 这么个方法且指向原函数\n```\n\n需要记住以下几个要点：\n\n1. 所有的函数都有一个属性，叫做 .prototype，它指向这个函数的关联对象。\n2. 所有函数的原型都有一个属性，叫做 .constructor，它指向这个函数本身。\n3. 一个函数原型的 .constructor 并非必须指向创建这个函数原型的函数……有点绕，我们等下会深入探讨一下。\n\n设置函数的原型有一些规则，在开始之前，我们先概括设置对象原型的三个规则：\n\n1. 『默认』规则；\n2. 使用new隐式设置原型；\n3. 使用Object.create显式设置原型。\n\n### 默认规则\n\n考虑下这段代码：\n\n```javascript\n\"use strict\";\n\nconst foo = { status : 'foobar' };\n```\n\n十分简单，我们做的事儿就是创建一个叫foo的对象，然后给他一个叫status的属性。\n\n然后JavaScript在幕后多做了点工作。当我们在字面上创建一个对象时，JavaScript将对象的原型指向Object.prototype并设置其原型的.constructor指向Object：\n\n```javascript\n\"use strict\";\n\nconst foo = { status : 'foobar' };\n\nObject.getPrototypeOf(foo) === Object.prototype; // true\nfoo.constructor === Object; // true\n```\n\n### 使用new隐式设置原型\n\n让我们再看下之前调整过的 Food 例子。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n```\n\n现在我们知道函数Food将会与一个叫做Food.prototype的对象关联。\n\n当我们使用new关键字创建一个对象，JavaScript将会：\n\n1. 设置这个对象的原型指向我们使用new调用的函数的.prototype属性；\n2. 设置这个对象的.constructor指向我们使用new调用到的构造函数。\n\n```javascript\nconst tootsie_roll = new Food('Tootsie Roll', 0, 26, 0);\n\nObject.getPrototypeOf(tootsie_roll) === Food.prototype; // true\ntootsie_roll.constructor === Food; // true\n```\n\n这就可以让我们搞出下面这样的黑魔法：\n\n```javascript\n\"use strict\";\n\nFood.prototype.cook = function cook () {\n    console.log(`${this.name} is cooking!`);\n};\n\nconst dinner = new Food('Lamb Chops', 52, 8, 32);\ndinner.cook(); // 'Lamb Chops are cooking!'\n```\n\n### 使用Object.create显式设置原型\n\n最后我们可以使用Object.create方法手工设置对象的原型引用。\n\n```javascript\n\"use strict\";\n\nconst foo = {\n    speak () {\n        console.log('Foo!');\n    }\n};\n\nconst bar = Object.create(foo);\n\nbar.speak(); // 'Foo!'\nObject.getPrototypeOf(bar) === foo; // true\n```\n\n还记得使用new调用函数的时候，JavaScript在幕后干了哪四件事儿吗？Object.create就干了这三件事儿：\n\n1. 创建一个新对象；\n2. 设置它的原型引用；\n3. 返回这个新对象。\n\n[你可以自己去看下MDN上写的那个polyfill。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) \n（译者注：polyfill就是给老代码实现现有新功能的补丁代码，这里就是指老版本JS没有Object.create函数，MDN上有手工撸的一个替代方案）\n\n### 模拟 class 行为\n\n直接使用原型来模拟面向类的行为需要一些技巧。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nFood.prototype.toString = function () {\n    return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n};\n\nfunction FatFreeFood (name, protein, carbs) {\n    Food.call(this, name, protein, carbs, 0);\n}\n\n// 设置 \"subclass\" 关系\n// =====================\n// LINE A :: 使用 Object.create 手动设置 FatFreeFood's 『父类』.\nFatFreeFood.prototype = Object.create(Food.prototype);\n\n// LINE B :: 手工重置 constructor 的引用\nObject.defineProperty(FatFreeFood.constructor, \"constructor\", {\n    enumerable : false,\n    writeable  : true,\n    value      : FatFreeFood\n});\n```\n\n在Line A，我们需要设置FatFreeFood.prototype使之等于一个新对象，这个新对象的原型引用是Food.prototype。如果没这么搞，我们的子类就不能访问『超类』的方法。\n\n不幸的是，这个导致了相当诡异的结果：FatFreeFood.constructor是Function，而不是FatFreeFood。为了保证一切正常，我们需要在Line B手工设置FatFreeFood.constructor。\n\n让开发者从使用原型对类行为笨拙的模仿中脱离苦海是class关键字的产生动机之一。它确实也提供了避免原型语法常见陷阱的解决方案。\n\n现在我们已经探究了太多关于JavaScript的原型机制，你应该更容易理解class关键字让一切变得多么简单了吧！\n\n### 深入探究下方法\n\n现在我们已了解到JavaScript原型系统的必要性，我们将深入探究一下类支持的三种方法，以及一种特殊情况，以结束本文的讨论。\n\n+ 构造器；\n+ 静态方法；\n+ 原型方法；\n+ 一种原型方法的特殊情况：『标记方法』。\n\n并非我提出的这三组方法，这要归功于Rauschmayer博士在探索ES6一书中的定义。\n\n### 类构造器\n\n一个类的constructor方法用于关注我们的初始化逻辑，constructor方法有以下几个特殊点：\n\n1. 只有在构造方法里，我们才可以调用父类的构造器；\n2. 它在背后处理了所有设置原型链的工作；\n3. 它被用作类的定义。\n\n第二点就是在JavaScript中使用class的一个主要好处，我们来引用一下《探索 ES6》书里的15.2.3.1 的标题：\n\n> 子类的原型就是超类\n\n正如我们所见，手工设置非常繁琐且容易出错。如果我们使用class关键字，JavaScript在内部会负责搞定这些设置，这一点也是使用class的优势。\n\n第三点有点意思。在JavaScript中类仅仅是个函数——它等同于与类中的constructor方法。\n\n```javascript\n\"use strict\";\n\nclass Food {\n    // 和之前一样的类定义……\n}\n\ntypeof Food; // 'function'\n```\n\n与一般把函数作为构造器的方式不同，我们不能不用new关键字而直接调用类构造器：\n\n```javascript\nconst burrito = Food('Heaven', 100, 100, 25); // 类型错误\n```\n\n这就引发了另一个问题：当我们不用new调用函数构造器的时候发生了什么？\n\n简短的回答是：对于任何没有显式返回的函数来说都是返回undefined。我们只需要相信用我们构造函数的用户都会使用构造调用。这就是社区为何约定构造方法的首字母大写：提醒使用者要用new来调用。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nconst fish = Food('Halibut', 26, 0, 2); // D'oh . . .\nconsole.log(fish); // 'undefined'\n```\n\n长一点的回答是：返回undefined，除非你手工检测是否使用被new调用，然后进行自己的处理。\n\nES2015引入了一个属性使得这种检测变得简单: [new.target](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target).\n\nnew.target是一个定义在所有使用new调用的函数上的属性，包括类构造器。 当我们使用new关键字调用函数时，函数体内的new.target的值就是这个函数本身。如果函数没有被new调用，这个值就是undefined。\n\n```javascript\n\"use strict\";\n\n// 强行构造调用\nfunction Food (name, protein, carbs, fat) {\n    // 如果用户忘了手工调用一下\n    if (!new.target)\n        return new Food(name, protein, carbs, fat);\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nconst fish = Food('Halibut', 26, 0, 2); // 糟了，不过没关系！\nfish; // 'Food {name: \"Halibut\", protein: 20, carbs: 5, fat: 0}'\n```\n\n在ES5里用起来也还行：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n\n    if (!(this instanceof Food))\n        return new Food(name, protein, carbs, fat);\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n```\n\nMDN文档讲述了new.target的更多细节，而且给有兴趣者配上了ES2015规范作为参考。规范里有关 [[Construct]] 的描述很有启发性。\n\n### 静态方法\n\n静态方法是构造方法自己的方法，不能被类的实例化对象调用。我们使用static关键字定义静态方法。\n\n```javascript\n\"use strict\";\n\nclass Food {\n     // 和之前一样……\n\n     // 添加静态方法\n     static describe () {\n         console.log('\"Food\" 是一种存储了营养信息的数据类型');\n     }\n}\n\nFood.describe(); // '\"Food\" 是一种存储了营养信息的数据类型'\n```\n\n静态方法与老式构造函数中直接属性赋值相似：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    Food.count += 1;\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nFood.count = 0;\nFood.describe = function count () {\n    console.log(`你创建了 ${Food.count} 个 food`);\n};\n\nconst dummy = new Food();\nFood.describe(); // \"你创建了 1 个 food\"\n```\n\n### 原型方法\n\n任何不是构造方法和静态方法的方法都是原型方法。之所以叫原型方法，是因为我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。\n\n```javascript\n\"use strict\";\n\n// 使用 ES6：\nclass Food {\n\n    constructor (name, protein, carbs, fat) {\n        this.name = name;\n        this.protein = protein;\n        this.carbs = carbs;\n        this.fat = fat;\n    }\n\n    toString () {  \n        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n    }\n\n    print () {  \n        console.log( this.toString() );  \n    }\n}\n\n// 在 ES5 里：\nfunction Food  (name, protein, carbs, fat) {\n    this.name = name;\n    this.protein = protein;\n    this.carbs = carbs;\n    this.fat = fat;\n}\n\n// 『原型方法』的命名大概来自我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。\nFood.prototype.toString = function toString () {\n    return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n};\n\nFood.prototype.print = function print () {\n    console.log( this.toString() );\n};\n```\n\n应该说明，在方法定义时完全可以使用生成器。\n\n```javascript\n\"use strict\";\n\nclass Range {\n\n    constructor(from, to) {\n        this.from = from;\n        this.to   = to;\n    }\n\n    * generate () {\n        let counter = this.from,\n            to      = this.to;\n\n        while (counter &lt; to) {\n            if (counter == to)\n                return counter++;\n            else\n                yield counter++;\n        }\n    }\n}\n\nconst range = new Range(0, 3);\nconst gen = range.generate();\nfor (let val of range.generate()) {\n    console.log(`Generator 的值是 ${ val }. `);\n    //  Prints:\n    //    Generator 的值是 0.\n    //    Generator 的值是 1.\n    //    Generator 的值是 2.\n}\n```\n\n### 标志方法\n\n最后我们说说标志方法。这是一些名为Symbol值的方法，当我们在自定义对象中使用内置构造器时，JavaScript引擎可以识别并使用这些方法。\n\nMDN文档提供了一个Symbol是什么的简要概览：\n\nSymbol是一个唯一且不变的数据类型，可以作为一个对象的属性标示符。\n\n创建一个新的symbol，会给我们提供一个被认为是程序里的唯一标识的值。这一点对于命名对象的属性十分有用：我们可以确保不会不小心覆盖任何属性。使用Symbol做键值也不是无数的，所以他们很大程度上对外界是不可见的（也不完全是，可以通过Reflect.ownKeys获得）\n\n```javascript\n\"use strict\";\n\nconst secureObject = {\n    // 这个键可以看作是唯一的\n    [new Symbol(\"name\")] : 'Dr. Secure A. F.'\n};\n\nconsole.log( Object.getKeys(superSecureObject) ); // [] -- 标志属性不太好获取    \nconsole.log( Reflect.ownKeys(secureObject) ); // [Symbol(\"name\")] -- 但也不是完全隐藏的\n```\n\n对我们来讲更有意思的是，这给我们提供了一种方式来告诉 JavaScript 引擎使用特定方法来达到特定的目的。\n\n所谓的『众所周知的Symbol』是一些特定对象的键，当你在定义对象中使用时他们时，JavaScript引擎会触发一些特定方法。\n\n这对于JavaScript来说有点怪异，我们还是看个例子吧：\n\n```javascript\n\"use strict\";\n\n// 继承 Array 可以让我们直观的使用 'length'\n// 同时可以让我们访问到内置方法，如\n// map、filter、reduce、push、pop 等\nclass FoodSet extends Array {\n\n    // foods 把传递的任意参数收集为一个数组\n    // 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\n    constructor(...foods) {\n        super();\n        this.foods = [];\n        foods.forEach((food) =&gt; this.foods.push(food))\n    }\n\n     // 自定义迭代器行为，请注意，这不是多么好用的迭代器，但是个不错的例子\n     // 键名前必须写星号\n     * [Symbol.iterator] () {\n        let position = 0;\n        while (position &lt; this.foods.length) {\n          if (position === this.foods.length) {\n              return \"Done!\"\n          } else {\n              yield `${this.foods[ position++ ]} is the food item at position ${position}`;\n          }\n         }\n     }\n\n     // 当我们的用户使用内置的数组方法，返回一个数组类型对象\n     // 而不是 FoodSet 类型的。这使得我们的 FoodSet 可以被一些\n     // 期望操作数组的代码操作\n     static get [Symbol.species] () {\n         return Array;\n     }\n}\n\nconst foodset = new FoodSet(new Food('Fish', 26, 0, 16), new Food('Hamburger', 26, 48, 24));\n\n// 当我们使用 for ... of 操作 FoodSet 时，JavaScript 将会使用\n// 我们之前用 [Symbol.iterator] 做键值的方法\nfor (let food of foodset) {\n    // 打印全部 food\n    console.log( food );\n}\n\n// 当我们执行数组的 `filter` 方法时，JavaScript 创建并返回一个新对象\n// 我们在什么对象上执行 `filter` 方法，新对象就使用这个对象作为默认构造器来创建\n// 然而大部分代码都希望 filter 返回一个数组，于是我们通过重写 [Symbol.species]\n// 的方式告诉 JavaScript 使用数组的构造器\nconst healthy_foods = foodset.filter((food) =&gt; food.name !== 'Hamburger');\n\nconsole.log( healthy_foods instanceof FoodSet ); //\nconsole.log( healthy_foods instanceof Array );\n```\n\n当你使用for...of遍历一个对象时，JavaScript将会尝试执行对象的迭代器方法，这一方法就是该对象 Symbol.iterator属性上关联的方法。如果我们提供了自己的方法定义，JavaScript就会使用我们自定义的。如果没有自己制定的话，如果有默认的实现就用默认的，没有的话就不执行。\n\nSymbo.species更奇异了。在自定义的类中，默认的Symbol.species函数就是类的构造函数。当我们的子类有内置的集合（例如Array和Set）时，我们通常希望在使用父类的实例时也能使用子类。\n\n通过方法返回父类的实例而不是派生类的实例，使我们更能确保我们子类在大多数代码里的可用性。而Symbol.species可以实现这一功能。\n\n如果不怎么需要这个功能就别费力去搞了。Symbol的这种用法——或者说有关Symbol的全部用法——都还比较罕见。这些例子只是为了演示：\n\n1. 我们可以在自定义类中使用JavaScript内置的特定构造器；\n2. 用两个普通的例子展示了怎么实现这一点。\n\n### 结论\n\nES2015的class关键字没有带给我们 Java 里或是SmallTalk里那种『真正的类』。宁可说它只是提供了一种更加方便的语法来创建通过原型关联的对象，本质上没有什么新东西。\n\n## 使用ES6写更好的JavaScript part III：好用的集合和反引号\n\n### 简介\n\nES2015发生了一些重大变革，像promises和generators. 但并非新标准的一切都高不可攀。 – 相当一部分新特性可以快速上手。\n\n在这篇文章里，我们来看下新特性带来的好处:\n\n+ 新的集合: map，weakmap，set， weakset\n+ 大部分的new String methods\n+ 模板字符串。\n\n我们开始这个系列的最后一章吧。\n\n### 模板字符串\n\n模板字符串 解决了三个痛点，允许你做如下操作:\n\n1. 定义在字符串内部的表达式，称为 字符串插值。\n2. 写多行字符串无须用换行符 (\\n) 拼接。\n3. 使用“raw”字符串 – 在反斜杠内的字符串不会被转义，视为常量。\n\n```javascript\n“use strict”;\n\n/* 三个模板字符串的例子:\n\n字符串插值，多行字符串，raw 字符串。\n================================= */\n// ================================== \n// 1. 字符串插值 :: 解析任何一个字符串中的表达式。 \nconsole.log(1 + 1 = ${1 + 1});\n\n// ================================== \n// 2. 多行字符串 :: 这样写: \nlet childe_roland = \nI saw them and I knew them all. And yet <br> Dauntless the slug-horn to my lips I set, <br> And blew “Childe Roland to the Dark Tower came.”\n\n// … 代替下面的写法: \nchild_roland = \n‘I saw them and I knew them all. And yet\\n’ + \n‘Dauntless the slug-horn to my lips I set,\\n’ + \n‘And blew “Childe Roland to the Dark Tower came.”’;\n\n// ================================== \n// 3. raw 字符串 :: 在字符串前加 raw 前缀，javascript 会忽略转义字符。 \n// 依然会解析包在 ${} 的表达式 \nconst unescaped = String.rawThis ${string()} doesn't contain a newline!\\n\n\nfunction string () { return “string”; }\n\nconsole.log(unescaped); // ‘This string doesn’t contain a newline!\\n’ – 注意 \\n 会被原样输出\n\n// 你可以像 React 使用 JSX 一样，用模板字符串创建 HTML 模板 \nconst template = \n`\n\nExample\n\nI’m a pure JS & HTML template!\n\n`\n\nfunction getClass () { \n// Check application state, calculate a class based on that state \nreturn “some-stateful-class”; \n}\n\nconsole.log(template); // 这样使用略显笨，自己试试吧！\n\n// 另一个常用的例子是打印变量名: \nconst user = { name : ‘Joe’ };\n\nconsole.log(“User’s name is ” + user.name + “.”); // 有点冗长 \nconsole.log(User's name is ${user.name}.); // 这样稍好一些\n```\n\n1. 使用字符串插值，用反引号代替引号包裹字符串，并把我们想要的表达式嵌入在${}中。\n\n2. 对于多行字符串，只需要把你要写的字符串包裹在反引号里，在要换行的地方直接换行。 JavaScript 会在换行处插入新行。\n3. 使用原生字符串，在模板字符串前加前缀String.raw，仍然使用反引号包裹字符串。\n\n模板字符串或许只不过是一种语法糖 … 但它比语法糖略胜一筹。\n\n### 新的字符串方法\n\nES2015也给String新增了一些方法。他们主要归为两类:\n\n1. 通用的便捷方法\n2. 扩充 Unicode 支持的方法。\n\n在本文里我们只讲第一类，同时unicode特定方法也有相当好的用例 。如果你感兴趣的话，这是地址在MDN的文档里，有一个关于字符串新方法的完整列表。\n\n### startsWith & endsWith\n\n对新手而言，我们有String.prototype.startsWith。 它对任何字符串都有效，它需要两个参数:\n\n1. 一个是 search string 还有\n2. 整形的位置参数 n。这是可选的。\n\nString.prototype.startsWith方法会检查以nth位起的字符串是否以search string开始。如果没有位置参数，则默认从头开始。\n\n如果字符串以要搜索的字符串开头返回 true，否则返回 false。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\n// 这个字符串是以 \"This is one\" 开头吗?\nconsole.log(contrived_example.startsWith(\"This is one\")); // true\n\n// 这个字符串的第四个字符以 \"is\" 开头?\nconsole.log(contrived_example.startsWith(\"is\", 4)); // false\n\n// 这个字符串的第五个字符以 \"is\" 开始?\nconsole.log(contrived_example.startsWith(\"is\", 5)); // true\n```\n\n### endsWith\n\nString.prototype.endsWith和startswith相似: 它也需要两个参数：一个是要搜索的字符串，一个是位置。\n\n然而String.prototype.endsWith位置参数会告诉函数要搜索的字符串在原始字符串中被当做结尾处理。\n\n换句话说，它会切掉nth后的所有字符串，并检查是否以要搜索的字符结尾。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\nconsole.log(contrived_example.endsWith(\"contrived example!\")); // true\n\nconsole.log(contrived_example.slice(0, 11)); // \"This is one\"\nconsole.log(contrived_example.endsWith(\"one\", 11)); // true\n\n// 通常情况下，传一个位置参数向下面这样:\nfunction substringEndsWith (string, search_string, position) {\n    // Chop off the end of the string\n    const substring = string.slice(0, position);\n\n    // 检查被截取的字符串是否已 search_string 结尾\n    return substring.endsWith(search_string);\n}\n```\n\n### includes\n\nES2015也添加了String.prototype.includes。 你需要用字符串调用它，并且要传递一个搜索项。如果字符串包含搜索项会返回true，反之返回false。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\n// 这个字符串是否包含单词 impressively ?\ncontrived_example.includes(\"impressively\"); // true\n```\n\nES2015之前，我们只能这样:\n\n```javascript\n\"use strict\";\ncontrived_example.indexOf(\"impressively\") !== -1 // true\n```\n\n不算太坏。但是，String.prototype.includes是 一个改善，它屏蔽了任意整数返回值为true的漏洞。\n\n### repeat\n\n还有String.prototype.repeat。可以对任意字符串使用，像includes一样，它会或多或少地完成函数名指示的工作。\n\n它只需要一个参数: 一个整型的count。使用案例说明一切，上代码:\n\n```javascript\nconst na = \"na\";\n\nconsole.log(na.repeat(5) + \", Batman!\"); // 'nanananana, Batman!'\n```\n\n### raw\n\n最后，我们有String.raw，我们在上面简单介绍过。\n\n一个模板字符串以 String.raw 为前缀，它将不会在字符串中转义:\n\n```javascript\n/* 单右斜线要转义，我们需要双右斜线才能打印一个右斜线，\\n 在普通字符串里会被解析为换行\n  *   */\nconsole.log('This string \\\\ has fewer \\\\ backslashes \\\\ and \\n breaks the line.');\n\n// 不想这样写的话用 raw 字符串\nString.raw`This string \\\\ has too many \\\\ backslashes \\\\ and \\n doesn't break the line.`\n```\n\n### Unicode方法\n\n虽然我们不涉及剩余的 string 方法，但是如果我不告诉你去这个主题的必读部分就会显得我疏忽。\n\n* Dr Rauschmayer对于Unicode in JavaScript的介绍 \n* 他关于ES2015’s Unicode Support in Exploring ES6和The Absolute Minimum Every Software Developer Needs to Know About Unicode 的讨论。\n\n无论如何我不得不跳过它的最后一部分。虽然有些老但是还是有优点的。\n\n这里是文档中缺失的字符串方法，这样你会知道缺哪些东西了。\n\n+ String.fromCodePoint & String.prototype.codePointAt;\n+ String.prototype.normalize;\n+ Unicode point escapes.\n\n### 集合\n\nES2015新增了一些集合类型:\n\n1. Map和WeakMap\n2. Set和WeakSet。\n\n合适的Map和Set类型十分方便使用，还有弱变量是一个令人兴奋的改动，虽然它对Javascript来说像舶来品一样。\n\n### Map\n\nmap就是简单的键值对。最简单的理解方式就是和object类似，一个键对应一个值。\n\n```javascript\n\"use strict\";\n\n// 我们可以把 foo 当键，bar 当值\nconst obj = { foo : 'bar' };\n\n// 对象键为 foo 的值为 bar\nobj.foo === 'bar'; // true\n```\n\n新的Map类型在概念上是相似的，但是可以使用任意的数据类型作为键 – 不止strings和symbols–还有除了pitfalls associated with trying to use an objects a map的一些东西。\n\n下面的片段例举了 Map 的 API.\n\n```javascript\n\"use strict\";\n\n// 构造器\nlet scotch_inventory = new Map();\n\n// BASIC API METHODS\n// Map.prototype.set (K, V) :: 创建一个键 K，并设置它的值为 V。\nscotch_inventory.set('Lagavulin 18', 2);\nscotch_inventory.set('The Dalmore', 1);\n\n// 你可以创建一个 map 里面包含一个有两个元素的数组\nscotch_inventory = new Map([['Lagavulin 18', 2], ['The Dalmore', 1]]);\n\n// 所有的 map 都有 size 属性，这个属性会告诉你 map 里有多少个键值对。\n// 用 Map 或 Set 的时候，一定要使用 size ，不能使用 length\nconsole.log(scotch_inventory.size); // 2\n\n// Map.prototype.get(K) :: 返回键相关的值。如果键不存在返回 undefined\nconsole.log(scotch_inventory.get('The Dalmore')); // 1\nconsole.log(scotch_inventory.get('Glenfiddich 18')); // undefined\n\n// Map.prototype.has(K) :: 如果 map 里包含键 K 返回true，否则返回 false\nconsole.log(scotch_inventory.has('The Dalmore')); // true\nconsole.log(scotch_inventory.has('Glenfiddich 18')); // false\n\n// Map.prototype.delete(K) :: 从 map 里删除键 K。成功返回true，不存在返回 false\nconsole.log(scotch_inventory.delete('The Dalmore')); // true -- breaks my heart\n\n// Map.prototype.clear() :: 清楚 map 中的所有键值对\nscotch_inventory.clear();\nconsole.log( scotch_inventory ); // Map {} -- long night\n\n// 遍历方法\n// Map 提供了多种方法遍历键值。 \n//  重置值，继续探索\nscotch_inventory.set('Lagavulin 18', 1);\nscotch_inventory.set('Glenfiddich 18', 1);\n\n/* Map.prototype.forEach(callback[, thisArg]) :: 对 map 里的每个键值对执行一个回调函数 \n  *   你可以在回调函数内部设置 'this' 的值，通过传递一个 thisArg 参数，那是可选的而且没有太大必要那样做\n  *   最后，注意回调函数已经被传了键和值 */\nscotch_inventory.forEach(function (quantity, scotch) {\n    console.log(`Excuse me while I sip this ${scotch}.`);\n});\n\n// Map.prototype.keys() :: 返回一个 map 中的所有键\nconst scotch_names = scotch_inventory.keys();\nfor (let name of scotch_names) {\n    console.log(`We've got ${name} in the cellar.`);\n}\n\n// Map.prototype.values() :: 返回 map 中的所有值\nconst quantities = scotch_inventory.values();\nfor (let quantity of quantities) {\n    console.log(`I just drank ${quantity} of . . . Uh . . . I forget`);\n}\n\n// Map.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 \n//   以后会经常看到 map 里的键值对和 \"entries\" 关联 \nconst entries = scotch_inventory.entries();\nfor (let entry of entries) {\n    console.log(`I remember! I drank ${entry[1]} bottle of ${entry[0]}!`);\n}\n```\n\n但是Object在保存键值对的时候仍然有用。 如果符合下面的全部条件，你可能还是想用Object:\n\n1. 当你写代码的时候，你知道你的键值对。\n2. 你知道你可能不会去增加或删除你的键值对。\n3. 你使用的键全都是 string 或 symbol。\n\n另一方面，如果符合以下任意条件，你可能会想使用一个 map。\n\n1. 你需要遍历整个map – 然而这对 object 来说是难以置信的.\n2. 当你写代码的时候不需要知道键的名字或数量。\n3. 你需要复杂的键，像 Object 或 别的 Map (!).\n\n像遍历一个map一样遍历一个object是可行的，但奇妙的是–还会有一些坑潜伏在暗处。 Map更容易使用，并且增加了一些可集成的优势。然而object是以随机顺序遍历的，map是以插入的顺序遍历的。\n\n添加随意动态键名的键值对给一个object是可行的。但奇妙的是: 比如说如果你曾经遍历过一个伪 map，你需要记住手动更新条目数。\n\n最后一条，如果你要设置的键名不是string或symbol，你除了选择Map别无选择。\n\n上面的这些只是一些指导性的意见，并不是最好的规则。\n\n### WeakMap\n\n你可能听说过一个特别棒的特性垃圾回收器，它会定期地检查不再使用的对象并清除。\n\nTo quote Dr Rauschmayer:\n\n> WeakMap 不会阻止它的键值被垃圾回收。那意味着你可以把数据和对象关联起来不用担心内存泄漏。\n\n换句换说，就是你的程序丢掉了WeakMap键的所有外部引用，他能自动垃圾回收他们的值。\n\n尽管大大简化了用例，考虑到SPA(单页面应用) 就是用来展示用户希望展示的东西，像一些物品描述和一张图片，我们可以理解为API返回的JSON。\n\n理论上来说我们可以通过缓存响应结果来减少请求服务器的次数。我们可以这样用Map :\n\n```javascript\n\"use strict\";\n\nconst cache = new Map();\n\nfunction put (element, result) {\n    cache.set(element, result);\n}\n\nfunction retrieve (element) {\n    return cache.get(element);\n}\n```\n\n… 这是行得通的，但是有内存泄漏的危险。\n\n因为这是一个SPA，用户或许想离开这个视图，这样的话我们的 “视图”object就会失效，会被垃圾回收。\n\n不幸的是，如果你使用的是正常的Map ,当这些object不使用时，你必须自行清除。\n\n使用WeakMap替代就可以解决上面的问题:\n\n```javascript\n\"use strict\";\n\nconst cache = new WeakMap(); // 不会再有内存泄露了\n\n// 剩下的都一样\n```\n\n这样当应用失去不需要的元素的引用时，垃圾回收系统可以自动重用那些元素。\n\nWeakMap的API和Map相似，但有如下几点不同:\n\n1. 在WeakMap里你可以使用object作为键。 这意味着不能以String和Symbol做键。\n2. WeakMap只有set，get，has，和delete方法 – 那意味着你不能遍历weak map.\n3. WeakMaps没有size属性。\n\n不能遍历或检查WeakMap的长度的原因是，在遍历过程中可能会遇到垃圾回收系统的运行: 这一瞬间是满的，下一秒就没了。\n\n这种不可预测的行为需要谨慎对待，TC39(ECMA第39届技术委员会)曾试图避免禁止WeakMap的遍历和长度检测。\n\n其他的案例，可以在这里找到Use Cases for WeakMap，来自Exploring ES6.\n\n### Set\n\nSet就是只包含一个值的集合。换句换说，每个set的元素只会出现一次。\n\n这是一个有用的数据类型，如果你要追踪唯一并且固定的object ,比如说聊天室的当前用户。\n\nSet和Map有完全相同的API。主要的不同是Set没有set方法，因为它不能存储键值对。剩下的几乎相同。\n\n```javascript\n\"use strict\";\n\n// 构造器\nlet scotch_collection = new Set();\n\n// 基本的 API 方法\n// Set.prototype.add (O) :: 和 set 一样，添加一个对象\nscotch_collection.add('Lagavulin 18');\nscotch_collection.add('The Dalmore');\n\n// 你也可以用数组构造一个 set\nscotch_collection = new Set(['Lagavulin 18', 'The Dalmore']);\n\n// 所有的 set 都有一个 length 属性。这个属性会告诉你 set 里有多少对象\n//   用 set 或 map 的时候，一定记住用 size，不用 length\nconsole.log(scotch_collection.size); // 2\n\n// Set.prototype.has(O) :: 包含对象 O 返回 true 否则返回 false\nconsole.log(scotch_collection.has('The Dalmore')); // true\nconsole.log(scotch_collection.has('Glenfiddich 18')); // false\n\n// Set.prototype.delete(O) :: 删除 set 中的 O 对象，成功返回 true，不存在返回 false\nscotch_collection.delete('The Dalmore'); // true -- break my heart\n\n// Set.prototype.clear() :: 删除 set 中的所有对象\nscotch_collection.clear();\nconsole.log( scotch_collection ); // Set {} -- long night.\n\n/* 迭代方法\n * Set 提供了多种方法遍历\n *  重新设置值，继续探索 */\nscotch_collection.add('Lagavulin 18');\nscotch_collection.add('Glenfiddich 18');\n\n/* Set.prototype.forEach(callback[, thisArg]) :: 执行一个函数，回调函数\n *  set 里在每个的键值对。 You can set the value of 'this' inside \n *  the callback by passing a thisArg, but that's optional and seldom necessary. */\nscotch_collection.forEach(function (scotch) {\n    console.log(`Excuse me while I sip this ${scotch}.`);\n});\n\n// Set.prototype.values() :: 返回 set 中的所有值\nlet scotch_names = scotch_collection.values();\nfor (let name of scotch_names) {\n    console.log(`I just drank ${name} . . . I think.`);\n}\n\n// Set.prototype.keys() ::  对 set 来说，和 Set.prototype.values() 方法一致\nscotch_names = scotch_collection.keys();\nfor (let name of scotch_names) {\n    console.log(`I just drank ${name} . . . I think.`);\n}\n\n/* Set.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 \n *   这有点多余，但是这种方法可以保留 map API 的可操作性\n *    */\nconst entries = scotch_collection.entries();\nfor (let entry of entries) {\n    console.log(`I got some ${entry[0]} in my cup and more ${entry[1]} in my flask!`);\n}\n```\n\n### WeakSet\n\nWeakSet相对于Set就像WeakMap相对于 Map :\n\n1. 在WeakSet里object的引用是弱类型的。\n2. WeakSet没有property属性。\n3. 不能遍历WeakSet。\n\nWeak set的用例并不多，但是这儿有一些Domenic Denicola称呼它们为“perfect for branding” – 意思就是标记一个对象以满足其他需求。\n\n这儿是他给的例子:\n\n```javascript\n/* 下面这个例子来自 Weakset 使用案例的邮件讨论 \n  *    邮件的内容和讨论的其余部分在这儿:\n  *      https://mail.mozilla.org/pipermail/es-discuss/2015-June/043027.html\n  */\n\nconst foos = new WeakSet();\n\nclass Foo {\n  constructor() {\n    foos.add(this);\n  }\n\n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError(\"Foo.prototype.method called on an incompatible object!\");\n    }\n  }\n}\n```\n\n这是一个轻量科学的方法防止大家在一个没有被Foo构造出的object上使用method。\n\n使用的WeakSet的优势是允许foo里的object使用完后被垃圾回收。\n\n### 总结\n\n这篇文章里，我们已经了解了ES2015带来的一些好处，从string的便捷方法和模板变量到适当的Map和Set实现。\n\nString方法和模板字符串易于上手。同时你很快也就不用到处用weak set了，我认为你很快就会喜欢上Set和Map。\n\n整理转载：[https://github.com/xitu/gold-miner](https://github.com/xitu/gold-miner)","source":"_posts/使用ES6写更好的JavaScript.md","raw":"---\ntitle: 使用ES6写更好的JavaScript\ntags: [javascript,es6]\ndate: 2016/05/30\n---\n\n## 使用 ES6 写更好的 JavaScript part I：广受欢迎新特性\n\n### 介绍\n\n在ES2015规范敲定并且Node.js增添了大量的函数式子集的背景下，我们终于可以拍着胸脯说：未来就在眼前。\n\n… 我早就想这样说了\n\n但这是真的。V8引擎将很快实现规范，而且Node已经添加了大量可用于生产环境的ES2015特性。下面要列出的是一些我认为很有必要的特性，而且这些特性是不使用需要像Babel或者Traceur这样的翻译器就可以直接使用的。\n\n这篇文章将会讲到三个相当流行的ES2015特性，并且已经在Node中支持了了：\n\n+ 用let和const声明块级作用域；\n+ 箭头函数；\n+ 简写属性和方法。\n\n让我们马上开始。\n\n### let和const声明块级作用域\n\n作用域是你程序中变量可见的区域。换句话说就是一系列的规则，它们决定了你声明的变量在哪里是可以使用的。\n\n大家应该都听过 ，在JavaScript中只有在函数内部才会创造新的作用域。然而你创建的98%的作用域事实上都是函数作用域，其实在JavaScript中有三种创建新作用域的方法。你可以这样：\n\n1. 创建一个函数。你应该已经知道这种方式。\n2. 创建一个catch块。 我绝对没哟开玩笑.\n3. 创建一个代码块。如果你用的是ES2015，在一段代码块中用let或者const声明的变量会限制它们只在这个块中可见。这叫做块级作用域。\n\n一个代码块就是你用花括号包起来的部分。 { 像这样 }。在if/else声明和try/catch/finally块中经常出现。如果你想利用块作用域的优势，你可以用花括号包裹任意的代码来创建一个代码块\n\n考虑下面的代码片段。\n\n```javascript\n// 在 Node 中你需要使用 strict 模式尝试这个\n\"use strict\";\n\nvar foo = \"foo\";\nfunction baz() {\n    if (foo) {\n        var bar = \"bar\";\n        let foobar = foo + bar;\n    }\n    // foo 和 bar 这里都可见 \n    console.log(\"This situation is \" + foo + bar + \". I'm going home.\");\n    try {\n        console.log(\"This log statement is \" + foobar + \"! It threw a ReferenceError at me!\");\n    } catch (err) {\n        console.log(\"You got a \" + err + \"; no dice.\");\n    }\n    try {\n        console.log(\"Just to prove to you that \" + err + \" doesn't exit outside of the above `catch` block.\");\n    } catch (err) {\n        console.log(\"Told you so.\");\n    }\n}\n\nbaz();\n\ntry {\n    console.log(invisible);\n} catch (err) {\n    console.log(\"invisible hasn't been declared, yet, so we get a \" + err);\n}\nlet invisible = \"You can't see me, yet\"; // let 声明的变量在声明前是不可访问的\n```\n\n还有些要强调的\n\n+ 注意foobar在if块之外是不可见的，因为我们没有用let声明；\n+ 我们可以在任何地方使用foo ，因为我们用var定义它为全局作用域可见；\n+ 我们可以在baz内部任何地方使用bar， 因为var-声明的变量是在定义的整个作用域内都可见。\n+ 用let or const声明的变量不能在定义前调用。换句话说，它不会像var变量一样被编译器提升到作用域的开始处。\n\nconst 与 let 类似，但有两点不同。\n\n1. 必须给声明为const的变量在声明时赋值。不可以先声明后赋值。\n2. 不能改变const变量的值，只有在创建它时可以给它赋值。如果你试图改变它的值，会得到一个TyepError。\n\n### let & const: Who Cares?\n\n我们已经用var将就了二十多年了，你可能在想我们真的需要新的类型声明关键字吗？（这里作者应该是想表达这个意思）\n\n问的好，简单的回答就是–不， 并不真正需要。但在可以用let和const的地方使用它们很有好处的。\n\n+ let和const声明变量时都不会被提升到作用域开始的地方，这样可以使代码可读性更强，制造尽可能少的迷惑。\n+ 它会尽可能的约束变量的作用域，有助于减少令人迷惑的命名冲突。\n+ 这样可以让程序只有在必须重新分配变量的情况下重新分配变量。 const 可以加强常量的引用。\n\n另一个例子就是 let 在 for 循环中的使用：\n\n```javascript\n\"use strict\";\n\nvar languages = ['Danish', 'Norwegian', 'Swedish'];\n\n//会污染全局变量!\nfor (var i = 0; i &lt; languages.length; i += 1) {\n    console.log(`${languages[i]} is a Scandinavian language.`);\n}\n\nconsole.log(i); // 4\n\nfor (let j = 0; j &lt; languages.length; j += 1) {\n    console.log(`${languages[j]} is a Scandinavian language.`);\n}\n\ntry {\n    console.log(j); // Reference error\n} catch (err) {\n    console.log(`You got a ${err}; no dice.`);\n}\n```\n\n在for循环中使用var声明的计数器并不会真正把计数器的值限制在本次循环中。 而let可以。\n\nlet在每次迭代时重新绑定循环变量有很大的优势，这样每个循环中拷贝自身 , 而不是共享全局范围内的变量。\n\n```javascript\n\"use strict\";\n\n// 简洁明了\nfor (let i = 1; i &lt; 6; i += 1) {\n    setTimeout(function() {\n        console.log(\"I've waited \" + i + \" seconds!\");\n    }, 1000 * i);\n}\n\n// 功能完全混乱\nfor (var j = 0; j &lt; 6; j += 1) {\n        setTimeout(function() {\n        console.log(\"I've waited \" + j + \" seconds for this!\");\n    }, 1000 * j);\n}\n```\n\n第一层循环会和你想象的一样工作。而下面的会每秒输出 “I’ve waited 6 seconds!”。\n\n好吧，我选择狗带。\n\n### 动态this关键字的怪异\n\nJavaScript的this关键字因为总是不按套路出牌而臭名昭著。\n\n事实上，它的规则相当简单。不管怎么说，this在有些情形下会导致奇怪的用法\n\n```javascript\n\"use strict\";\n\nconst polyglot = {\n    name : \"Michel Thomas\",\n    languages : [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"],\n    introduce : function () {\n        // this.name is \"Michel Thomas\"\n        const self = this;\n        this.languages.forEach(function(language) {\n            // this.name is undefined, so we have to use our saved \"self\" variable \n            console.log(\"My name is \" + self.name + \", and I speak \" + language + \".\");\n        });\n    }\n}\n\npolyglot.introduce();\n```\n\n在introduce里, this.name是undefined。在回调函数外面，也就是forEach中， 它指向了polyglot对象。在这种情形下我们总是希望在函数内部this和函数外部的this指向同一个对象。\n\n问题是在JavaScript中函数会根据确定性四原则在调用时定义自己的this变量。这就是著名的动态this 机制。\n\n这些规则中没有一个是关于查找this所描述的“附近作用域”的；也就是说并没有一个确切的方法可以让JavaScript引擎能够基于包裹作用域来定义this的含义。\n\n这就意味着当引擎查找this的值时，可以找到值，但却和回调函数之外的不是同一个值。有两种传统的方案可以解决这个问题。\n\n+ 在函数外面把this保存到一个变量中，通常取名self，并在内部函数中使用；\n+ 或者在内部函数中调用bind阻止对this的赋值。\n\n以上两种办法均可生效，但会产生副作用。\n\n另一方面，如果内部函数没有设置它自己的this值，JavaScript会像查找其它变量那样查找this的值：通过遍历父作用域直到找到同名的变量。这样会让我们使用附近作用域代码中的this值，这就是著名的词法this。\n\n如果有样的特性，我们的代码将会更加的清晰，不是吗?\n\n### 箭头函数中的词法this\n\n在 ES2015 中，我们有了这一特性。箭头函数不会绑定this值，允许我们利用词法绑定this关键字。这样我们就可以像这样重构上面的代码了：\n\n```javascript\n\"use strict\";\n\nlet polyglot = {\n    name : \"Michel Thomas\",\n    languages : [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"],\n    introduce : function () {\n        this.languages.forEach((language) =&gt; {\n            console.log(\"My name is \" + this.name + \", and I speak \" + language + \".\");\n        });\n    }\n}\n```\n\n… 这样就会按照我们想的那样工作了。\n\n箭头函数有一些新的语法。\n\n```javascript\n\"use strict\";\n\nlet languages = [\"Spanish\", \"French\", \"Italian\", \"German\", \"Polish\"];\n\n// 多行箭头函数必须使用花括号， \n// 必须明确包含返回值语句\n    let languages_lower = languages.map((language) =&gt; {\n    return language.toLowerCase()\n});\n\n// 单行箭头函数，花括号是可省的，\n// 函数默认返回最后一个表达式的值\n// 你可以指明返回语句，这是可选的。\nlet languages_lower = languages.map((language) =&gt; language.toLowerCase());\n\n// 如果你的箭头函数只有一个参数，可以省略括号\nlet languages_lower = languages.map(language =&gt; language.toLowerCase());\n\n// 如果箭头函数有多个参数，必须用圆括号包裹\nlet languages_lower = languages.map((language, unused_param) =&gt; language.toLowerCase());\n\nconsole.log(languages_lower); // [\"spanish\", \"french\", \"italian\", \"german\", \"polish\"]\n\n// 最后，如果你的函数没有参数，你必须在箭头前加上空的括号。\n(() =&gt; alert(\"Hello!\"))();\n```\n\nMDN关于箭头函数的文档解释的很好。\n\n### 简写属性和方法\n\nES2015提供了在对象上定义属性和方法的一些新方式。\n\n### 简写方法\n\n在 JavaScript 中， method 是对象的一个有函数值的属性：\n\n```javascript\n\"use strict\";\n\nconst myObject = {\n    const foo = function () {\n        console.log('bar');\n    },\n}\n```\n\n在ES2015中，我们可以这样简写：\n\n```javascript\n\"use strict\";\n\nconst myObject = {\n    foo () {\n        console.log('bar');\n    },\n    * range (from, to) {\n        while (from &lt; to) {\n            if (from === to)\n                return ++from;\n            else\n                yield from ++;\n        }\n    }\n}\n```\n\n注意你也可以使用生成器去定义方法。只需要在函数名前面加一个星号(*)。\n\n这些叫做 方法定义 。和传统的函数作为属性很像，但有一些不同：\n\n+ 只能在方法定义处调用super；\n+ 不允许用new调用方法定义。\n\n我会在随后的几篇文章中讲到super关键字。如果你等不及了， Exploring ES6中有关于它的干货。\n\n### 简写和推导属性\n\nES6还引入了简写和推导属性 。\n\n如果对象的键值和变量名是一致的，那么你可以仅用变量名来初始化你的对象，而不是定义冗余的键值对。\n\n```javascript\n\"use strict\";\n\nconst foo = 'foo';\nconst bar = 'bar';\n\n// 旧语法\nconst myObject = {\n    foo : foo,\n    bar : bar\n};\n\n// 新语法\nconst myObject = { foo, bar }\n```\n\n两中语法都以foo和bar键值指向foo and bar变量。后面的方式语义上更加一致；这只是个语法糖。\n\n当用揭示模块模式来定义一些简洁的公共 API 的定义，我常常利用简写属性的优势。\n\n```javascript\n\"use strict\";\n\nfunction Module () {\n    function foo () {\n        return 'foo';\n    }\n    \n    function bar () {\n        return 'bar';\n    }\n    \n    // 这样写:\n    const publicAPI = { foo, bar }\n    \n    /* 不要这样写:\n    const publicAPI =  {\n       foo : foo,\n       bar : bar\n    } */ \n    \n    return publicAPI;\n};\n```\n\n这里我们创建并返回了一个publicAPI对象，键值foo指向foo方法，键值bar指向bar方法。\n\n### 推导属性名\n\n这是不常见的例子，但ES6允许你用表达式做属性名。\n\n```javascript\n\"use strict\";\n\nconst myObj = {\n  // 设置属性名为 foo 函数的返回值\n    [foo ()] () {\n      return 'foo';\n    }\n};\n\nfunction foo () {\n    return 'foo';\n}\n\nconsole.log(myObj.foo() ); // 'foo'\n```\n\n根据Dr. Raushmayer在Exploring ES6中讲的，这种特性最主要的用途是设置属性名与Symbol值一样。\n\n### Getter 和 Setter 方法\n\n最后，我想提一下get和set方法，它们在ES5中就已经支持了。\n\n```javascript\n\"use strict\";\n\n// 例子采用的是 MDN's 上关于 getter 的内容\n//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get\nconst speakingObj = {\n    // 记录 “speak” 方法调用过多少次\n    words : [],\n    \n    speak (word) {\n        this.words.push(word);\n        console.log('speakingObj says ' + word + '!');\n    },\n    \n    get called () {\n        // 返回最新的单词\n        const words = this.words;\n        if (!words.length)\n            return 'speakingObj hasn\\'t spoken, yet.';\n        else\n            return words[words.length - 1];\n    }\n};\n\nconsole.log(speakingObj.called); // 'speakingObj hasn't spoken, yet.'\n\nspeakingObj.speak('blargh'); // 'speakingObj says blargh!'\n\nconsole.log(speakingObj.called); // 'blargh'\n```\n\n使用getters时要记得下面这些:\n\n+ Getters不接受参数；\n+ 属性名不可以和getter函数重名；\n+ 可以用Object.defineProperty(OBJECT, \"property name\", { get : function () { . . . } }) 动态创建 getter\n\n作为最后这点的例子，我们可以这样定义上面的 getter 方法：\n\n```javascript\n\"use strict\";\n\nconst speakingObj = {\n    // 记录 “speak” 方法调用过多少次\n    words : [],\n    \n    speak (word) {\n        this.words.push(word);\n        console.log('speakingObj says ' + word + '!');\n    }\n};\n\n// 这只是为了证明观点。我是绝对不会这样写的\nfunction called () {\n    // 返回新的单词\n    const words = this.words;\n    if (!words.length)\n        return 'speakingObj hasn\\'t spoken, yet.';\n    else\n        return words[words.length - 1];\n};\n\nObject.defineProperty(speakingObj, \"called\", get : getCalled ) \n除了 getters，还有 setters。像平常一样，它们通过自定义的逻辑给对象设置属性。\n\n\"use strict\";\n\n// 创建一个新的 globetrotter（环球者）！\nconst globetrotter = {\n    // globetrotter 现在所处国家所说的语言 \n    const current_lang = undefined,\n    \n    // globetrotter 已近环游过的国家\n    let countries = 0,\n    \n    // 查看环游过哪些国家了\n    get countryCount () {\n        return this.countries;\n    }, \n    \n    // 不论 globe trotter 飞到哪里，都重新设置他的语言\n    set languages (language) {\n        // 增加环游过的城市数\n        countries += 1;\n    \n        // 重置当前语言\n        this.current_lang = language; \n    };\n};\n\nglobetrotter.language = 'Japanese';\nglobetrotter.countryCount(); // 1\n\nglobetrotter.language = 'Spanish';\nglobetrotter.countryCount(); // 2\n```\n\n上面讲的关于getters的也同样适用于setters，但有一点不同：\n\n+ getter不接受参数，setters必须接受正好一个参数。\n\n破坏这些规则中的任意一个都会抛出一个错误。\n\n既然 Angular 2 正在引入TypeCript并且把class带到了台前，我希望get and set能够流行起来… 但还有点希望它们不要流行起来。\n\n### 结论\n\n未来的JavaScript正在变成现实，是时候把它提供的东西都用起来了。这篇文章里，我们浏览了 ES2015的三个很流行的特性：\n\n+ let和const带来的块级作用域；\n+ 箭头函数带来的this的词法作用域；\n+ 简写属性和方法，以及getter和setter函数的回顾。\n\n## 使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]\n\n### 辞旧迎新\n\n在本文的开始，我们要说明一件事：\n\n从本质上说，ES6的classes主要是给创建老式构造函数提供了一种更加方便的语法，并不是什么新魔法 —— Axel Rauschmayer，Exploring ES6作者\n\n从功能上来讲，class声明就是一个语法糖，它只是比我们之前一直使用的基于原型的行为委托功能更强大一点。本文将从新语法与原型的关系入手，仔细研究ES2015的class关键字。文中将提及以下内容：\n\n+ 定义与实例化类；\n+ 使用extends创建子类；\n+ 子类中super语句的调用；\n+ 以及重要的标记方法（symbol method）的例子。\n\n在此过程中，我们将特别注意 class 声明语法从本质上是如何映射到基于原型代码的。\n\n让我们从头开始说起。\n\n### 退一步说：Classes不是什么\n\nJavaScript的『类』与Java、Python或者其他你可能用过的面向对象语言中的类不同。其实后者可能称作面向『类』的语言更为准确一些。\n\n在传统的面向类的语言中，我们创建的类是对象的模板。需要一个新对象时，我们实例化这个类，这一步操作告诉语言引擎将这个类的方法和属性复制到一个新实体上，这个实体称作实例。实例是我们自己的对象，且在实例化之后与父类毫无内在联系。\n\n而JavaScript没有这样的复制机制。在JavaScript中『实例化』一个类创建了一个新对象，但这个新对象却不独立于它的父类。\n\n正相反，它创建了一个与原型相连接的对象。即使是在实例化之后，对于原型的修改也会传递到实例化的新对象去。\n\n原型本身就是一个无比强大的设计模式。有许多使用了原型的技术模仿了传统类的机制，class便为这些技术提供了简洁的语法。\n\n总而言之：\n\n+ JavaScript不存在Java和其他面向对象语言中的类概念；\n+ JavaScript 的class很大程度上只是原型继承的语法糖，与传统的类继承有很大的不同。\n\n搞清楚这些之后，让我们先看一下class。\n\n### 类基础：声明与表达式\n\n我们使用class 关键字创建类，关键字之后是变量标识符，最后是一个称作类主体的代码块。这种写法称作类的声明。没有使用extends关键字的类声明被称作基类：\n\n```javascript\n\"use strict\";\n\n// Food 是一个基类\nclass Food {\n\n    constructor (name, protein, carbs, fat) {\n        this.name = name;\n        this.protein = protein;\n        this.carbs = carbs;\n        this.fat = fat;\n    }\n\n    toString () {\n        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`\n    }\n\n    print () {\n        console.log( this.toString() );\n    }\n}\n\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\n\nchicken_breast.print(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'\nconsole.log(chicken_breast.protein); // 26 (LINE A)\n```\n\n需要注意到以下事情：\n\n+ 类只能包含方法定义，不能有数据属性；\n+ 定义方法时，可以使用简写方法定义；\n+ 与创建对象不同，我们不能在类主体中使用逗号分隔方法定义；\n+ 我们可以在实例化对象上直接引用类的属性（如 LINE A）。\n\n类有一个独有的特性，就是 contructor 构造方法。在构造方法中我们可以初始化对象的属性。\n\n构造方法的定义并不是必须的。如果不写构造方法，引擎会为我们插入一个空的构造方法：\n\n```javascript\n\"use strict\";\n\nclass NoConstructor {\n    /* JavaScript 会插入这样的代码：\n     constructor () { }\n    */\n}\n\nconst nemo = new NoConstructor(); // 能工作，但没啥意思\n```\n\n将一个类赋值给一个变量的形式叫类表达式，这种写法可以替代上面的语法形式：\n\n```javascript\n\"use strict\";\n\n// 这是一个匿名类表达式，在类主体中我们不能通过名称引用它\nconst Food = class {\n    // 和上面一样的类定义……\n}\n\n// 这是一个命名类表达式，在类主体中我们可以通过名称引用它\nconst Food = class FoodClass {\n    // 和上面一样的类定义……\n\n    //  添加一个新方法，证明我们可以通过内部名称引用 FoodClass……        \n    printMacronutrients () {\n        console.log(`${FoodClass.name} | ${FoodClass.protein} g P :: ${FoodClass.carbs} g C :: ${FoodClass.fat} g F`)\n    }\n}\n\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\nchicken_breast.printMacronutrients(); // 'Chicken Breast | 26g P :: 0g C :: 3.5g F'\n\n// 但是不能在外部引用\ntry {\n    console.log(FoodClass.protein); // 引用错误\n} catch (err) {\n    // pass\n}\n```\n\n这一行为与匿名函数与命名函数表达式很类似。\n\n### 使用extends创建子类以及使用super调用\n\n使用extends创建的类被称作子类，或派生类。这一用法简单明了，我们直接在上面的例子中构建：\n\n```javascript\n\"use strict\";\n\n// FatFreeFood 是一个派生类\nclass FatFreeFood extends Food {\n\n    constructor (name, protein, carbs) {\n        super(name, protein, carbs, 0);\n    }\n\n    print () {\n        super.print();\n        console.log(`Would you look at that -- ${this.name} has no fat!`);\n    }\n\n}\n\nconst fat_free_yogurt = new FatFreeFood('Greek Yogurt', 16, 12);\nfat_free_yogurt.print(); // 'Greek Yogurt | 26g P :: 16g C :: 0g F  /  Would you look at that -- Greek Yogurt has no fat!'\n```\n\n派生类拥有我们上文讨论的一切有关基类的特性，另外还有如下几点新特点：\n\n+ 子类使用class关键字声明，之后紧跟一个标识符，然后使用extend关键字，最后写一个任意表达式。这个表达式通常来讲就是个标识符，但理论上也可以是函数。\n+ 如果你的派生类需要引用它的父类，可以使用super关键字。\n+ 一个派生类不能有一个空的构造函数。即使这个构造函数就是调用了一下super()，你也得把它显式的写出来。但派生类却可以没有构造函数。\n+ 在派生类的构造函数中，必须先调用super，才能使用this关键字（译者注：仅在构造函数中是这样，在其他方法中可以直接使用this）。\n\n在JavaScript中仅有两个super关键字的使用场景：\n\n1. 在子类构造函数中调用。如果初始化派生类是需要使用父类的构造函数，我们可以在子类的构造函数中调用super(parentConstructorParams)，传递任意需要的参数。\n2. 引用父类的方法。在常规方法定义中，派生类可以使用点运算符来引用父类的方法：super.methodName。\n\n我们的 FatFreeFood 演示了这两种情况：\n\n1. 在构造函数中，我们简单的调用了super，并将脂肪的量传入为0。\n2. 在我们的print方法中，我们先调用了super.print，之后才添加了其他的逻辑。\n\n不管你信不信，我反正是信了以上说的已涵盖了有关class的基础语法，这就是你开始实验需要掌握的全部内容。\n\n### 深入学习原型\n\n现在我们开始关注class是怎么映射到JavaScript内部的原型机制的。我们会关注以下几点：\n\n+ 使用构造调用创建对象；\n+ 原型连接的本质；\n+ 属性和方法委托；\n+ 使用原型模拟类。\n+ 使用构造调用创建对象\n\n构造函数不是什么新鲜玩意儿。使用new关键字调用任意函数会使其返回一个对象 —— 这一步称作创建了一个构造调用，这种函数通常被称作构造器：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\n// 使用 'new' 关键字调用 Food 方法，就是构造调用，该操作会返回一个对象\nconst chicken_breast = new Food('Chicken Breast', 26, 0, 3.5);\nconsole.log(chicken_breast.protein) // 26\n\n// 不用 'new' 调用 Food 方法，会返回 'undefined'\nconst fish = Food('Halibut', 26, 0, 2);\nconsole.log(fish); // 'undefined'\n```\n\n当我们使用new关键字调用函数时，JS内部执行了下面四个步骤：\n\n1. 创建一个新对象（这里称它为O）；\n2. 给O赋予一个连接到其他对象的链接，称为原型；\n3. 将函数的this引用指向O；\n4. 函数隐式返回O。\n\n在第三步和第四步之间，引擎会执行你函数中的具体逻辑。\n\n知道了这一点，我们就可以重写Food方法，使之不用new关键字也能工作：\n\n```javascript\n\"use strict\";\n\n// 演示示例：消除对 'new' 关键字的依赖\nfunction Food (name, protein, carbs, fat) {\n    // 第一步：创建新对象\n    const obj = { };\n\n    // 第二步：链接原型——我们在下文会更加具体地探究原型的概念\n    Object.setPrototypeOf(obj, Food.prototype);\n\n    // 第三步：设置 'this' 指向我们的新对象\n    // 尽然我们不能再运行的执行上下文中重置 `this`\n    // 我们在使用 'obj' 取代 'this' 来模拟第三步\n    obj.name    = name;\n    obj.protein = protein;\n    obj.carbs   = carbs;\n    obj.fat     = fat;\n\n    // 第四步：返回新创建的对象\n    return obj;\n}\n\nconst fish = Food('Halibut', 26, 0, 2);\nconsole.log(fish.protein); // 26\n```\n\n四步中的三步都是简单明了的。创建一个对象、赋值属性、然后写一个return声明，这些操作对大多数开发者来说没有理解上的问题——然而这就是难倒众人的黑魔法原型。\n\n### 直观理解原型链\n\n在通常情况下，JavaScript中的包括函数在内的所有对象都会链接到另一个对象上，这就是原型。\n\n如果我们访问一个对象本身没有的属性，JavaScript就会在对象的原型上检查该属性。换句话说，如果你对一个对象请求它没有的属性，它会对你说：『这个我不知道，问我的原型吧』。\n\n在另一个对象上查找不存在属性的过程称作委托。\n\n```javascript\n\"use strict\";\n\n// joe 没有 toString 方法……\nconst joe    = { name : 'Joe' },\n    sara   = { name : 'Sara' };\n\nObject.hasOwnProperty(joe, toString); // false\nObject.hasOwnProperty(sara, toString); // false\n\n// ……但我们还是可以调用它！\njoe.toString(); // '[object Object]'，而不是引用错误！\nsara.toString(); // '[object Object]'，而不是引用错误！\n```\n\n尽管我们的 toString 的输出完全没啥用，但请注意：这段代码没有引起任何的ReferenceError！这是因为尽管joe和sara没有toString的属性，但他们的原型有啊。\n\n当我们寻找sara.toString()方法时，sara说：『我没有toString属性，找我的原型吧』。正如上文所说，JavaScript会亲切的询问Object.prototype 是否含有toString属性。由于原型上有这一属性，JS 就会把Object.prototype上的toString返回给我们程序并执行。\n\nsara本身没有属性没关系——我们会把查找操作委托到原型上。\n\n换言之，我们就可以访问到对象上并不存在的属性，只要其的原型上有这些属性。我们可以利用这一点将属性和方法赋值到对象的原型上，然后我们就可以调用这些属性，好像它们真的存在在那个对象上一样。\n\n更给力的是，如果几个对象共享相同的原型——正如上面的joe和sara的例子一样——当我们给原型赋值属性之后，它们就都可以访问了，无需将这些属性单独拷贝到每一个对象上。\n\n这就是为何大家把它称作原型继承——如果我的对象没有，但对象的原型有，那我的对象也能继承这个属性。\n\n事实上，这里并没有发生什么『继承』。在面向类的语言里，继承指从父类复制属性到子类的行为。在JavaScript里，没发生这种复制的操作，事实上这就是原型继承与类继承相比的一个主要优势。\n\n在我们探究原型究竟是怎么来的之前，我们先做一个简要回顾：\n\n+ joe和sara没有『继承』一个toString的属性；\n+ joe和sara实际上根本没有从Object.prototype上『继承』；\n+ joe和sara是链接到了Object.prototype上；\n+ joe和sara链接到了同一个Object.prototype上。\n+ 如果想找到一个对象的（我们称它作O）原型，我们可以使用 Object.getPrototypeof(O)。\n\n然后我们再强调一遍：对象没有『继承自』他们的原型。他们只是委托到原型上。\n\n以上。\n\n接下来让我们深入一下。\n\n### 设置对象的原型\n\n我们已了解到基本上每个对象（下文以O指代）都有原型（下文以P指代），然后当我们查找O上没有的属性，JavaScript引擎就会在P上寻找这个属性。\n\n至此我们有两个问题：\n\n+ 以上情况函数怎么玩？\n+ 这些原型是从哪里来的？\n\n名为Object的函数\n\n在JavaScript引擎执行程序之前，它会创建一个环境让程序在内部执行，在执行环境中会创建一个函数，叫做Object, 以及一个关联对象，叫做Object.prototype。\n\n换句话说，Object和Object.prototype在任意执行中的JavaScript程序中永远存在。\n\n这个Object乍一看好像和其他函数没什么区别，但特别之处在于它是一个构造器——在调用它时返回一个新对象：\n\n```javascript\n\"use strict\";\n\ntypeof new Object(); // \"object\"\ntypeof Object();     // 这个 Object 函数的特点是不需要使用 new 关键字调用\n```\n\n这个Object.prototype对象是个……对象。正如其他对象一样，它有属性。\n\n![https://i.imgsafe.org/ebbd5e3.png](https://i.imgsafe.org/ebbd5e3.png)\n\n关于Object和Object.prototype你需要知道以下几点：\n\n1. Object函数有一个叫做.prototype的属性，指向一个对象（Object.prototype）；\n2. Object.prototype对象有一个叫做.constructor的属性，指向一个函数（Object）。\n\n实际上，这个总体方案对于JavaScript中的所有函数都是适用的。当我们创建一个函数——下文称作 someFunction——这个函数就会有一个属性.prototype，指向一个叫做someFunction.prototype 的对象。\n\n与之相反，someFunction.prototype对象会有一个叫做.contructor的属性，它的引用指回函数someFunction。\n\n```javascript\n\"use strict\";\n\nfunction foo () {  console.log('Foo!');  }\n\nconsole.log(foo.prototype); // 指向一个叫 'foo' 的对象\nconsole.log(foo.prototype.constructor); // 指向 'foo' 函数\n\nfoo.prototype.constructor(); // 输出 'Foo!' —— 仅为证明确实有 'foo.prototype.constructor' 这么个方法且指向原函数\n```\n\n需要记住以下几个要点：\n\n1. 所有的函数都有一个属性，叫做 .prototype，它指向这个函数的关联对象。\n2. 所有函数的原型都有一个属性，叫做 .constructor，它指向这个函数本身。\n3. 一个函数原型的 .constructor 并非必须指向创建这个函数原型的函数……有点绕，我们等下会深入探讨一下。\n\n设置函数的原型有一些规则，在开始之前，我们先概括设置对象原型的三个规则：\n\n1. 『默认』规则；\n2. 使用new隐式设置原型；\n3. 使用Object.create显式设置原型。\n\n### 默认规则\n\n考虑下这段代码：\n\n```javascript\n\"use strict\";\n\nconst foo = { status : 'foobar' };\n```\n\n十分简单，我们做的事儿就是创建一个叫foo的对象，然后给他一个叫status的属性。\n\n然后JavaScript在幕后多做了点工作。当我们在字面上创建一个对象时，JavaScript将对象的原型指向Object.prototype并设置其原型的.constructor指向Object：\n\n```javascript\n\"use strict\";\n\nconst foo = { status : 'foobar' };\n\nObject.getPrototypeOf(foo) === Object.prototype; // true\nfoo.constructor === Object; // true\n```\n\n### 使用new隐式设置原型\n\n让我们再看下之前调整过的 Food 例子。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n```\n\n现在我们知道函数Food将会与一个叫做Food.prototype的对象关联。\n\n当我们使用new关键字创建一个对象，JavaScript将会：\n\n1. 设置这个对象的原型指向我们使用new调用的函数的.prototype属性；\n2. 设置这个对象的.constructor指向我们使用new调用到的构造函数。\n\n```javascript\nconst tootsie_roll = new Food('Tootsie Roll', 0, 26, 0);\n\nObject.getPrototypeOf(tootsie_roll) === Food.prototype; // true\ntootsie_roll.constructor === Food; // true\n```\n\n这就可以让我们搞出下面这样的黑魔法：\n\n```javascript\n\"use strict\";\n\nFood.prototype.cook = function cook () {\n    console.log(`${this.name} is cooking!`);\n};\n\nconst dinner = new Food('Lamb Chops', 52, 8, 32);\ndinner.cook(); // 'Lamb Chops are cooking!'\n```\n\n### 使用Object.create显式设置原型\n\n最后我们可以使用Object.create方法手工设置对象的原型引用。\n\n```javascript\n\"use strict\";\n\nconst foo = {\n    speak () {\n        console.log('Foo!');\n    }\n};\n\nconst bar = Object.create(foo);\n\nbar.speak(); // 'Foo!'\nObject.getPrototypeOf(bar) === foo; // true\n```\n\n还记得使用new调用函数的时候，JavaScript在幕后干了哪四件事儿吗？Object.create就干了这三件事儿：\n\n1. 创建一个新对象；\n2. 设置它的原型引用；\n3. 返回这个新对象。\n\n[你可以自己去看下MDN上写的那个polyfill。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) \n（译者注：polyfill就是给老代码实现现有新功能的补丁代码，这里就是指老版本JS没有Object.create函数，MDN上有手工撸的一个替代方案）\n\n### 模拟 class 行为\n\n直接使用原型来模拟面向类的行为需要一些技巧。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nFood.prototype.toString = function () {\n    return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n};\n\nfunction FatFreeFood (name, protein, carbs) {\n    Food.call(this, name, protein, carbs, 0);\n}\n\n// 设置 \"subclass\" 关系\n// =====================\n// LINE A :: 使用 Object.create 手动设置 FatFreeFood's 『父类』.\nFatFreeFood.prototype = Object.create(Food.prototype);\n\n// LINE B :: 手工重置 constructor 的引用\nObject.defineProperty(FatFreeFood.constructor, \"constructor\", {\n    enumerable : false,\n    writeable  : true,\n    value      : FatFreeFood\n});\n```\n\n在Line A，我们需要设置FatFreeFood.prototype使之等于一个新对象，这个新对象的原型引用是Food.prototype。如果没这么搞，我们的子类就不能访问『超类』的方法。\n\n不幸的是，这个导致了相当诡异的结果：FatFreeFood.constructor是Function，而不是FatFreeFood。为了保证一切正常，我们需要在Line B手工设置FatFreeFood.constructor。\n\n让开发者从使用原型对类行为笨拙的模仿中脱离苦海是class关键字的产生动机之一。它确实也提供了避免原型语法常见陷阱的解决方案。\n\n现在我们已经探究了太多关于JavaScript的原型机制，你应该更容易理解class关键字让一切变得多么简单了吧！\n\n### 深入探究下方法\n\n现在我们已了解到JavaScript原型系统的必要性，我们将深入探究一下类支持的三种方法，以及一种特殊情况，以结束本文的讨论。\n\n+ 构造器；\n+ 静态方法；\n+ 原型方法；\n+ 一种原型方法的特殊情况：『标记方法』。\n\n并非我提出的这三组方法，这要归功于Rauschmayer博士在探索ES6一书中的定义。\n\n### 类构造器\n\n一个类的constructor方法用于关注我们的初始化逻辑，constructor方法有以下几个特殊点：\n\n1. 只有在构造方法里，我们才可以调用父类的构造器；\n2. 它在背后处理了所有设置原型链的工作；\n3. 它被用作类的定义。\n\n第二点就是在JavaScript中使用class的一个主要好处，我们来引用一下《探索 ES6》书里的15.2.3.1 的标题：\n\n> 子类的原型就是超类\n\n正如我们所见，手工设置非常繁琐且容易出错。如果我们使用class关键字，JavaScript在内部会负责搞定这些设置，这一点也是使用class的优势。\n\n第三点有点意思。在JavaScript中类仅仅是个函数——它等同于与类中的constructor方法。\n\n```javascript\n\"use strict\";\n\nclass Food {\n    // 和之前一样的类定义……\n}\n\ntypeof Food; // 'function'\n```\n\n与一般把函数作为构造器的方式不同，我们不能不用new关键字而直接调用类构造器：\n\n```javascript\nconst burrito = Food('Heaven', 100, 100, 25); // 类型错误\n```\n\n这就引发了另一个问题：当我们不用new调用函数构造器的时候发生了什么？\n\n简短的回答是：对于任何没有显式返回的函数来说都是返回undefined。我们只需要相信用我们构造函数的用户都会使用构造调用。这就是社区为何约定构造方法的首字母大写：提醒使用者要用new来调用。\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nconst fish = Food('Halibut', 26, 0, 2); // D'oh . . .\nconsole.log(fish); // 'undefined'\n```\n\n长一点的回答是：返回undefined，除非你手工检测是否使用被new调用，然后进行自己的处理。\n\nES2015引入了一个属性使得这种检测变得简单: [new.target](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target).\n\nnew.target是一个定义在所有使用new调用的函数上的属性，包括类构造器。 当我们使用new关键字调用函数时，函数体内的new.target的值就是这个函数本身。如果函数没有被new调用，这个值就是undefined。\n\n```javascript\n\"use strict\";\n\n// 强行构造调用\nfunction Food (name, protein, carbs, fat) {\n    // 如果用户忘了手工调用一下\n    if (!new.target)\n        return new Food(name, protein, carbs, fat);\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nconst fish = Food('Halibut', 26, 0, 2); // 糟了，不过没关系！\nfish; // 'Food {name: \"Halibut\", protein: 20, carbs: 5, fat: 0}'\n```\n\n在ES5里用起来也还行：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n\n    if (!(this instanceof Food))\n        return new Food(name, protein, carbs, fat);\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n```\n\nMDN文档讲述了new.target的更多细节，而且给有兴趣者配上了ES2015规范作为参考。规范里有关 [[Construct]] 的描述很有启发性。\n\n### 静态方法\n\n静态方法是构造方法自己的方法，不能被类的实例化对象调用。我们使用static关键字定义静态方法。\n\n```javascript\n\"use strict\";\n\nclass Food {\n     // 和之前一样……\n\n     // 添加静态方法\n     static describe () {\n         console.log('\"Food\" 是一种存储了营养信息的数据类型');\n     }\n}\n\nFood.describe(); // '\"Food\" 是一种存储了营养信息的数据类型'\n```\n\n静态方法与老式构造函数中直接属性赋值相似：\n\n```javascript\n\"use strict\";\n\nfunction Food (name, protein, carbs, fat) {\n    Food.count += 1;\n\n    this.name    = name;\n    this.protein = protein;\n    this.carbs   = carbs;\n    this.fat     = fat;\n}\n\nFood.count = 0;\nFood.describe = function count () {\n    console.log(`你创建了 ${Food.count} 个 food`);\n};\n\nconst dummy = new Food();\nFood.describe(); // \"你创建了 1 个 food\"\n```\n\n### 原型方法\n\n任何不是构造方法和静态方法的方法都是原型方法。之所以叫原型方法，是因为我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。\n\n```javascript\n\"use strict\";\n\n// 使用 ES6：\nclass Food {\n\n    constructor (name, protein, carbs, fat) {\n        this.name = name;\n        this.protein = protein;\n        this.carbs = carbs;\n        this.fat = fat;\n    }\n\n    toString () {  \n        return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n    }\n\n    print () {  \n        console.log( this.toString() );  \n    }\n}\n\n// 在 ES5 里：\nfunction Food  (name, protein, carbs, fat) {\n    this.name = name;\n    this.protein = protein;\n    this.carbs = carbs;\n    this.fat = fat;\n}\n\n// 『原型方法』的命名大概来自我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。\nFood.prototype.toString = function toString () {\n    return `${this.name} | ${this.protein}g P :: ${this.carbs}g C :: ${this.fat}g F`;\n};\n\nFood.prototype.print = function print () {\n    console.log( this.toString() );\n};\n```\n\n应该说明，在方法定义时完全可以使用生成器。\n\n```javascript\n\"use strict\";\n\nclass Range {\n\n    constructor(from, to) {\n        this.from = from;\n        this.to   = to;\n    }\n\n    * generate () {\n        let counter = this.from,\n            to      = this.to;\n\n        while (counter &lt; to) {\n            if (counter == to)\n                return counter++;\n            else\n                yield counter++;\n        }\n    }\n}\n\nconst range = new Range(0, 3);\nconst gen = range.generate();\nfor (let val of range.generate()) {\n    console.log(`Generator 的值是 ${ val }. `);\n    //  Prints:\n    //    Generator 的值是 0.\n    //    Generator 的值是 1.\n    //    Generator 的值是 2.\n}\n```\n\n### 标志方法\n\n最后我们说说标志方法。这是一些名为Symbol值的方法，当我们在自定义对象中使用内置构造器时，JavaScript引擎可以识别并使用这些方法。\n\nMDN文档提供了一个Symbol是什么的简要概览：\n\nSymbol是一个唯一且不变的数据类型，可以作为一个对象的属性标示符。\n\n创建一个新的symbol，会给我们提供一个被认为是程序里的唯一标识的值。这一点对于命名对象的属性十分有用：我们可以确保不会不小心覆盖任何属性。使用Symbol做键值也不是无数的，所以他们很大程度上对外界是不可见的（也不完全是，可以通过Reflect.ownKeys获得）\n\n```javascript\n\"use strict\";\n\nconst secureObject = {\n    // 这个键可以看作是唯一的\n    [new Symbol(\"name\")] : 'Dr. Secure A. F.'\n};\n\nconsole.log( Object.getKeys(superSecureObject) ); // [] -- 标志属性不太好获取    \nconsole.log( Reflect.ownKeys(secureObject) ); // [Symbol(\"name\")] -- 但也不是完全隐藏的\n```\n\n对我们来讲更有意思的是，这给我们提供了一种方式来告诉 JavaScript 引擎使用特定方法来达到特定的目的。\n\n所谓的『众所周知的Symbol』是一些特定对象的键，当你在定义对象中使用时他们时，JavaScript引擎会触发一些特定方法。\n\n这对于JavaScript来说有点怪异，我们还是看个例子吧：\n\n```javascript\n\"use strict\";\n\n// 继承 Array 可以让我们直观的使用 'length'\n// 同时可以让我们访问到内置方法，如\n// map、filter、reduce、push、pop 等\nclass FoodSet extends Array {\n\n    // foods 把传递的任意参数收集为一个数组\n    // 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\n    constructor(...foods) {\n        super();\n        this.foods = [];\n        foods.forEach((food) =&gt; this.foods.push(food))\n    }\n\n     // 自定义迭代器行为，请注意，这不是多么好用的迭代器，但是个不错的例子\n     // 键名前必须写星号\n     * [Symbol.iterator] () {\n        let position = 0;\n        while (position &lt; this.foods.length) {\n          if (position === this.foods.length) {\n              return \"Done!\"\n          } else {\n              yield `${this.foods[ position++ ]} is the food item at position ${position}`;\n          }\n         }\n     }\n\n     // 当我们的用户使用内置的数组方法，返回一个数组类型对象\n     // 而不是 FoodSet 类型的。这使得我们的 FoodSet 可以被一些\n     // 期望操作数组的代码操作\n     static get [Symbol.species] () {\n         return Array;\n     }\n}\n\nconst foodset = new FoodSet(new Food('Fish', 26, 0, 16), new Food('Hamburger', 26, 48, 24));\n\n// 当我们使用 for ... of 操作 FoodSet 时，JavaScript 将会使用\n// 我们之前用 [Symbol.iterator] 做键值的方法\nfor (let food of foodset) {\n    // 打印全部 food\n    console.log( food );\n}\n\n// 当我们执行数组的 `filter` 方法时，JavaScript 创建并返回一个新对象\n// 我们在什么对象上执行 `filter` 方法，新对象就使用这个对象作为默认构造器来创建\n// 然而大部分代码都希望 filter 返回一个数组，于是我们通过重写 [Symbol.species]\n// 的方式告诉 JavaScript 使用数组的构造器\nconst healthy_foods = foodset.filter((food) =&gt; food.name !== 'Hamburger');\n\nconsole.log( healthy_foods instanceof FoodSet ); //\nconsole.log( healthy_foods instanceof Array );\n```\n\n当你使用for...of遍历一个对象时，JavaScript将会尝试执行对象的迭代器方法，这一方法就是该对象 Symbol.iterator属性上关联的方法。如果我们提供了自己的方法定义，JavaScript就会使用我们自定义的。如果没有自己制定的话，如果有默认的实现就用默认的，没有的话就不执行。\n\nSymbo.species更奇异了。在自定义的类中，默认的Symbol.species函数就是类的构造函数。当我们的子类有内置的集合（例如Array和Set）时，我们通常希望在使用父类的实例时也能使用子类。\n\n通过方法返回父类的实例而不是派生类的实例，使我们更能确保我们子类在大多数代码里的可用性。而Symbol.species可以实现这一功能。\n\n如果不怎么需要这个功能就别费力去搞了。Symbol的这种用法——或者说有关Symbol的全部用法——都还比较罕见。这些例子只是为了演示：\n\n1. 我们可以在自定义类中使用JavaScript内置的特定构造器；\n2. 用两个普通的例子展示了怎么实现这一点。\n\n### 结论\n\nES2015的class关键字没有带给我们 Java 里或是SmallTalk里那种『真正的类』。宁可说它只是提供了一种更加方便的语法来创建通过原型关联的对象，本质上没有什么新东西。\n\n## 使用ES6写更好的JavaScript part III：好用的集合和反引号\n\n### 简介\n\nES2015发生了一些重大变革，像promises和generators. 但并非新标准的一切都高不可攀。 – 相当一部分新特性可以快速上手。\n\n在这篇文章里，我们来看下新特性带来的好处:\n\n+ 新的集合: map，weakmap，set， weakset\n+ 大部分的new String methods\n+ 模板字符串。\n\n我们开始这个系列的最后一章吧。\n\n### 模板字符串\n\n模板字符串 解决了三个痛点，允许你做如下操作:\n\n1. 定义在字符串内部的表达式，称为 字符串插值。\n2. 写多行字符串无须用换行符 (\\n) 拼接。\n3. 使用“raw”字符串 – 在反斜杠内的字符串不会被转义，视为常量。\n\n```javascript\n“use strict”;\n\n/* 三个模板字符串的例子:\n\n字符串插值，多行字符串，raw 字符串。\n================================= */\n// ================================== \n// 1. 字符串插值 :: 解析任何一个字符串中的表达式。 \nconsole.log(1 + 1 = ${1 + 1});\n\n// ================================== \n// 2. 多行字符串 :: 这样写: \nlet childe_roland = \nI saw them and I knew them all. And yet <br> Dauntless the slug-horn to my lips I set, <br> And blew “Childe Roland to the Dark Tower came.”\n\n// … 代替下面的写法: \nchild_roland = \n‘I saw them and I knew them all. And yet\\n’ + \n‘Dauntless the slug-horn to my lips I set,\\n’ + \n‘And blew “Childe Roland to the Dark Tower came.”’;\n\n// ================================== \n// 3. raw 字符串 :: 在字符串前加 raw 前缀，javascript 会忽略转义字符。 \n// 依然会解析包在 ${} 的表达式 \nconst unescaped = String.rawThis ${string()} doesn't contain a newline!\\n\n\nfunction string () { return “string”; }\n\nconsole.log(unescaped); // ‘This string doesn’t contain a newline!\\n’ – 注意 \\n 会被原样输出\n\n// 你可以像 React 使用 JSX 一样，用模板字符串创建 HTML 模板 \nconst template = \n`\n\nExample\n\nI’m a pure JS & HTML template!\n\n`\n\nfunction getClass () { \n// Check application state, calculate a class based on that state \nreturn “some-stateful-class”; \n}\n\nconsole.log(template); // 这样使用略显笨，自己试试吧！\n\n// 另一个常用的例子是打印变量名: \nconst user = { name : ‘Joe’ };\n\nconsole.log(“User’s name is ” + user.name + “.”); // 有点冗长 \nconsole.log(User's name is ${user.name}.); // 这样稍好一些\n```\n\n1. 使用字符串插值，用反引号代替引号包裹字符串，并把我们想要的表达式嵌入在${}中。\n\n2. 对于多行字符串，只需要把你要写的字符串包裹在反引号里，在要换行的地方直接换行。 JavaScript 会在换行处插入新行。\n3. 使用原生字符串，在模板字符串前加前缀String.raw，仍然使用反引号包裹字符串。\n\n模板字符串或许只不过是一种语法糖 … 但它比语法糖略胜一筹。\n\n### 新的字符串方法\n\nES2015也给String新增了一些方法。他们主要归为两类:\n\n1. 通用的便捷方法\n2. 扩充 Unicode 支持的方法。\n\n在本文里我们只讲第一类，同时unicode特定方法也有相当好的用例 。如果你感兴趣的话，这是地址在MDN的文档里，有一个关于字符串新方法的完整列表。\n\n### startsWith & endsWith\n\n对新手而言，我们有String.prototype.startsWith。 它对任何字符串都有效，它需要两个参数:\n\n1. 一个是 search string 还有\n2. 整形的位置参数 n。这是可选的。\n\nString.prototype.startsWith方法会检查以nth位起的字符串是否以search string开始。如果没有位置参数，则默认从头开始。\n\n如果字符串以要搜索的字符串开头返回 true，否则返回 false。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\n// 这个字符串是以 \"This is one\" 开头吗?\nconsole.log(contrived_example.startsWith(\"This is one\")); // true\n\n// 这个字符串的第四个字符以 \"is\" 开头?\nconsole.log(contrived_example.startsWith(\"is\", 4)); // false\n\n// 这个字符串的第五个字符以 \"is\" 开始?\nconsole.log(contrived_example.startsWith(\"is\", 5)); // true\n```\n\n### endsWith\n\nString.prototype.endsWith和startswith相似: 它也需要两个参数：一个是要搜索的字符串，一个是位置。\n\n然而String.prototype.endsWith位置参数会告诉函数要搜索的字符串在原始字符串中被当做结尾处理。\n\n换句话说，它会切掉nth后的所有字符串，并检查是否以要搜索的字符结尾。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\nconsole.log(contrived_example.endsWith(\"contrived example!\")); // true\n\nconsole.log(contrived_example.slice(0, 11)); // \"This is one\"\nconsole.log(contrived_example.endsWith(\"one\", 11)); // true\n\n// 通常情况下，传一个位置参数向下面这样:\nfunction substringEndsWith (string, search_string, position) {\n    // Chop off the end of the string\n    const substring = string.slice(0, position);\n\n    // 检查被截取的字符串是否已 search_string 结尾\n    return substring.endsWith(search_string);\n}\n```\n\n### includes\n\nES2015也添加了String.prototype.includes。 你需要用字符串调用它，并且要传递一个搜索项。如果字符串包含搜索项会返回true，反之返回false。\n\n```javascript\n\"use strict\";\n\nconst contrived_example = \"This is one impressively contrived example!\";\n\n// 这个字符串是否包含单词 impressively ?\ncontrived_example.includes(\"impressively\"); // true\n```\n\nES2015之前，我们只能这样:\n\n```javascript\n\"use strict\";\ncontrived_example.indexOf(\"impressively\") !== -1 // true\n```\n\n不算太坏。但是，String.prototype.includes是 一个改善，它屏蔽了任意整数返回值为true的漏洞。\n\n### repeat\n\n还有String.prototype.repeat。可以对任意字符串使用，像includes一样，它会或多或少地完成函数名指示的工作。\n\n它只需要一个参数: 一个整型的count。使用案例说明一切，上代码:\n\n```javascript\nconst na = \"na\";\n\nconsole.log(na.repeat(5) + \", Batman!\"); // 'nanananana, Batman!'\n```\n\n### raw\n\n最后，我们有String.raw，我们在上面简单介绍过。\n\n一个模板字符串以 String.raw 为前缀，它将不会在字符串中转义:\n\n```javascript\n/* 单右斜线要转义，我们需要双右斜线才能打印一个右斜线，\\n 在普通字符串里会被解析为换行\n  *   */\nconsole.log('This string \\\\ has fewer \\\\ backslashes \\\\ and \\n breaks the line.');\n\n// 不想这样写的话用 raw 字符串\nString.raw`This string \\\\ has too many \\\\ backslashes \\\\ and \\n doesn't break the line.`\n```\n\n### Unicode方法\n\n虽然我们不涉及剩余的 string 方法，但是如果我不告诉你去这个主题的必读部分就会显得我疏忽。\n\n* Dr Rauschmayer对于Unicode in JavaScript的介绍 \n* 他关于ES2015’s Unicode Support in Exploring ES6和The Absolute Minimum Every Software Developer Needs to Know About Unicode 的讨论。\n\n无论如何我不得不跳过它的最后一部分。虽然有些老但是还是有优点的。\n\n这里是文档中缺失的字符串方法，这样你会知道缺哪些东西了。\n\n+ String.fromCodePoint & String.prototype.codePointAt;\n+ String.prototype.normalize;\n+ Unicode point escapes.\n\n### 集合\n\nES2015新增了一些集合类型:\n\n1. Map和WeakMap\n2. Set和WeakSet。\n\n合适的Map和Set类型十分方便使用，还有弱变量是一个令人兴奋的改动，虽然它对Javascript来说像舶来品一样。\n\n### Map\n\nmap就是简单的键值对。最简单的理解方式就是和object类似，一个键对应一个值。\n\n```javascript\n\"use strict\";\n\n// 我们可以把 foo 当键，bar 当值\nconst obj = { foo : 'bar' };\n\n// 对象键为 foo 的值为 bar\nobj.foo === 'bar'; // true\n```\n\n新的Map类型在概念上是相似的，但是可以使用任意的数据类型作为键 – 不止strings和symbols–还有除了pitfalls associated with trying to use an objects a map的一些东西。\n\n下面的片段例举了 Map 的 API.\n\n```javascript\n\"use strict\";\n\n// 构造器\nlet scotch_inventory = new Map();\n\n// BASIC API METHODS\n// Map.prototype.set (K, V) :: 创建一个键 K，并设置它的值为 V。\nscotch_inventory.set('Lagavulin 18', 2);\nscotch_inventory.set('The Dalmore', 1);\n\n// 你可以创建一个 map 里面包含一个有两个元素的数组\nscotch_inventory = new Map([['Lagavulin 18', 2], ['The Dalmore', 1]]);\n\n// 所有的 map 都有 size 属性，这个属性会告诉你 map 里有多少个键值对。\n// 用 Map 或 Set 的时候，一定要使用 size ，不能使用 length\nconsole.log(scotch_inventory.size); // 2\n\n// Map.prototype.get(K) :: 返回键相关的值。如果键不存在返回 undefined\nconsole.log(scotch_inventory.get('The Dalmore')); // 1\nconsole.log(scotch_inventory.get('Glenfiddich 18')); // undefined\n\n// Map.prototype.has(K) :: 如果 map 里包含键 K 返回true，否则返回 false\nconsole.log(scotch_inventory.has('The Dalmore')); // true\nconsole.log(scotch_inventory.has('Glenfiddich 18')); // false\n\n// Map.prototype.delete(K) :: 从 map 里删除键 K。成功返回true，不存在返回 false\nconsole.log(scotch_inventory.delete('The Dalmore')); // true -- breaks my heart\n\n// Map.prototype.clear() :: 清楚 map 中的所有键值对\nscotch_inventory.clear();\nconsole.log( scotch_inventory ); // Map {} -- long night\n\n// 遍历方法\n// Map 提供了多种方法遍历键值。 \n//  重置值，继续探索\nscotch_inventory.set('Lagavulin 18', 1);\nscotch_inventory.set('Glenfiddich 18', 1);\n\n/* Map.prototype.forEach(callback[, thisArg]) :: 对 map 里的每个键值对执行一个回调函数 \n  *   你可以在回调函数内部设置 'this' 的值，通过传递一个 thisArg 参数，那是可选的而且没有太大必要那样做\n  *   最后，注意回调函数已经被传了键和值 */\nscotch_inventory.forEach(function (quantity, scotch) {\n    console.log(`Excuse me while I sip this ${scotch}.`);\n});\n\n// Map.prototype.keys() :: 返回一个 map 中的所有键\nconst scotch_names = scotch_inventory.keys();\nfor (let name of scotch_names) {\n    console.log(`We've got ${name} in the cellar.`);\n}\n\n// Map.prototype.values() :: 返回 map 中的所有值\nconst quantities = scotch_inventory.values();\nfor (let quantity of quantities) {\n    console.log(`I just drank ${quantity} of . . . Uh . . . I forget`);\n}\n\n// Map.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 \n//   以后会经常看到 map 里的键值对和 \"entries\" 关联 \nconst entries = scotch_inventory.entries();\nfor (let entry of entries) {\n    console.log(`I remember! I drank ${entry[1]} bottle of ${entry[0]}!`);\n}\n```\n\n但是Object在保存键值对的时候仍然有用。 如果符合下面的全部条件，你可能还是想用Object:\n\n1. 当你写代码的时候，你知道你的键值对。\n2. 你知道你可能不会去增加或删除你的键值对。\n3. 你使用的键全都是 string 或 symbol。\n\n另一方面，如果符合以下任意条件，你可能会想使用一个 map。\n\n1. 你需要遍历整个map – 然而这对 object 来说是难以置信的.\n2. 当你写代码的时候不需要知道键的名字或数量。\n3. 你需要复杂的键，像 Object 或 别的 Map (!).\n\n像遍历一个map一样遍历一个object是可行的，但奇妙的是–还会有一些坑潜伏在暗处。 Map更容易使用，并且增加了一些可集成的优势。然而object是以随机顺序遍历的，map是以插入的顺序遍历的。\n\n添加随意动态键名的键值对给一个object是可行的。但奇妙的是: 比如说如果你曾经遍历过一个伪 map，你需要记住手动更新条目数。\n\n最后一条，如果你要设置的键名不是string或symbol，你除了选择Map别无选择。\n\n上面的这些只是一些指导性的意见，并不是最好的规则。\n\n### WeakMap\n\n你可能听说过一个特别棒的特性垃圾回收器，它会定期地检查不再使用的对象并清除。\n\nTo quote Dr Rauschmayer:\n\n> WeakMap 不会阻止它的键值被垃圾回收。那意味着你可以把数据和对象关联起来不用担心内存泄漏。\n\n换句换说，就是你的程序丢掉了WeakMap键的所有外部引用，他能自动垃圾回收他们的值。\n\n尽管大大简化了用例，考虑到SPA(单页面应用) 就是用来展示用户希望展示的东西，像一些物品描述和一张图片，我们可以理解为API返回的JSON。\n\n理论上来说我们可以通过缓存响应结果来减少请求服务器的次数。我们可以这样用Map :\n\n```javascript\n\"use strict\";\n\nconst cache = new Map();\n\nfunction put (element, result) {\n    cache.set(element, result);\n}\n\nfunction retrieve (element) {\n    return cache.get(element);\n}\n```\n\n… 这是行得通的，但是有内存泄漏的危险。\n\n因为这是一个SPA，用户或许想离开这个视图，这样的话我们的 “视图”object就会失效，会被垃圾回收。\n\n不幸的是，如果你使用的是正常的Map ,当这些object不使用时，你必须自行清除。\n\n使用WeakMap替代就可以解决上面的问题:\n\n```javascript\n\"use strict\";\n\nconst cache = new WeakMap(); // 不会再有内存泄露了\n\n// 剩下的都一样\n```\n\n这样当应用失去不需要的元素的引用时，垃圾回收系统可以自动重用那些元素。\n\nWeakMap的API和Map相似，但有如下几点不同:\n\n1. 在WeakMap里你可以使用object作为键。 这意味着不能以String和Symbol做键。\n2. WeakMap只有set，get，has，和delete方法 – 那意味着你不能遍历weak map.\n3. WeakMaps没有size属性。\n\n不能遍历或检查WeakMap的长度的原因是，在遍历过程中可能会遇到垃圾回收系统的运行: 这一瞬间是满的，下一秒就没了。\n\n这种不可预测的行为需要谨慎对待，TC39(ECMA第39届技术委员会)曾试图避免禁止WeakMap的遍历和长度检测。\n\n其他的案例，可以在这里找到Use Cases for WeakMap，来自Exploring ES6.\n\n### Set\n\nSet就是只包含一个值的集合。换句换说，每个set的元素只会出现一次。\n\n这是一个有用的数据类型，如果你要追踪唯一并且固定的object ,比如说聊天室的当前用户。\n\nSet和Map有完全相同的API。主要的不同是Set没有set方法，因为它不能存储键值对。剩下的几乎相同。\n\n```javascript\n\"use strict\";\n\n// 构造器\nlet scotch_collection = new Set();\n\n// 基本的 API 方法\n// Set.prototype.add (O) :: 和 set 一样，添加一个对象\nscotch_collection.add('Lagavulin 18');\nscotch_collection.add('The Dalmore');\n\n// 你也可以用数组构造一个 set\nscotch_collection = new Set(['Lagavulin 18', 'The Dalmore']);\n\n// 所有的 set 都有一个 length 属性。这个属性会告诉你 set 里有多少对象\n//   用 set 或 map 的时候，一定记住用 size，不用 length\nconsole.log(scotch_collection.size); // 2\n\n// Set.prototype.has(O) :: 包含对象 O 返回 true 否则返回 false\nconsole.log(scotch_collection.has('The Dalmore')); // true\nconsole.log(scotch_collection.has('Glenfiddich 18')); // false\n\n// Set.prototype.delete(O) :: 删除 set 中的 O 对象，成功返回 true，不存在返回 false\nscotch_collection.delete('The Dalmore'); // true -- break my heart\n\n// Set.prototype.clear() :: 删除 set 中的所有对象\nscotch_collection.clear();\nconsole.log( scotch_collection ); // Set {} -- long night.\n\n/* 迭代方法\n * Set 提供了多种方法遍历\n *  重新设置值，继续探索 */\nscotch_collection.add('Lagavulin 18');\nscotch_collection.add('Glenfiddich 18');\n\n/* Set.prototype.forEach(callback[, thisArg]) :: 执行一个函数，回调函数\n *  set 里在每个的键值对。 You can set the value of 'this' inside \n *  the callback by passing a thisArg, but that's optional and seldom necessary. */\nscotch_collection.forEach(function (scotch) {\n    console.log(`Excuse me while I sip this ${scotch}.`);\n});\n\n// Set.prototype.values() :: 返回 set 中的所有值\nlet scotch_names = scotch_collection.values();\nfor (let name of scotch_names) {\n    console.log(`I just drank ${name} . . . I think.`);\n}\n\n// Set.prototype.keys() ::  对 set 来说，和 Set.prototype.values() 方法一致\nscotch_names = scotch_collection.keys();\nfor (let name of scotch_names) {\n    console.log(`I just drank ${name} . . . I think.`);\n}\n\n/* Set.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 \n *   这有点多余，但是这种方法可以保留 map API 的可操作性\n *    */\nconst entries = scotch_collection.entries();\nfor (let entry of entries) {\n    console.log(`I got some ${entry[0]} in my cup and more ${entry[1]} in my flask!`);\n}\n```\n\n### WeakSet\n\nWeakSet相对于Set就像WeakMap相对于 Map :\n\n1. 在WeakSet里object的引用是弱类型的。\n2. WeakSet没有property属性。\n3. 不能遍历WeakSet。\n\nWeak set的用例并不多，但是这儿有一些Domenic Denicola称呼它们为“perfect for branding” – 意思就是标记一个对象以满足其他需求。\n\n这儿是他给的例子:\n\n```javascript\n/* 下面这个例子来自 Weakset 使用案例的邮件讨论 \n  *    邮件的内容和讨论的其余部分在这儿:\n  *      https://mail.mozilla.org/pipermail/es-discuss/2015-June/043027.html\n  */\n\nconst foos = new WeakSet();\n\nclass Foo {\n  constructor() {\n    foos.add(this);\n  }\n\n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError(\"Foo.prototype.method called on an incompatible object!\");\n    }\n  }\n}\n```\n\n这是一个轻量科学的方法防止大家在一个没有被Foo构造出的object上使用method。\n\n使用的WeakSet的优势是允许foo里的object使用完后被垃圾回收。\n\n### 总结\n\n这篇文章里，我们已经了解了ES2015带来的一些好处，从string的便捷方法和模板变量到适当的Map和Set实现。\n\nString方法和模板字符串易于上手。同时你很快也就不用到处用weak set了，我认为你很快就会喜欢上Set和Map。\n\n整理转载：[https://github.com/xitu/gold-miner](https://github.com/xitu/gold-miner)","slug":"使用ES6写更好的JavaScript","published":1,"updated":"2016-08-23T07:24:54.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cis75cpny007l68dd3lm39ii0","content":"<h2 id=\"使用-ES6-写更好的-JavaScript-part-I：广受欢迎新特性\"><a href=\"#使用-ES6-写更好的-JavaScript-part-I：广受欢迎新特性\" class=\"headerlink\" title=\"使用 ES6 写更好的 JavaScript part I：广受欢迎新特性\"></a>使用 ES6 写更好的 JavaScript part I：广受欢迎新特性</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>在ES2015规范敲定并且Node.js增添了大量的函数式子集的背景下，我们终于可以拍着胸脯说：未来就在眼前。</p>\n<p>… 我早就想这样说了</p>\n<p>但这是真的。V8引擎将很快实现规范，而且Node已经添加了大量可用于生产环境的ES2015特性。下面要列出的是一些我认为很有必要的特性，而且这些特性是不使用需要像Babel或者Traceur这样的翻译器就可以直接使用的。</p>\n<p>这篇文章将会讲到三个相当流行的ES2015特性，并且已经在Node中支持了了：</p>\n<ul>\n<li>用let和const声明块级作用域；</li>\n<li>箭头函数；</li>\n<li>简写属性和方法。</li>\n</ul>\n<p>让我们马上开始。</p>\n<h3 id=\"let和const声明块级作用域\"><a href=\"#let和const声明块级作用域\" class=\"headerlink\" title=\"let和const声明块级作用域\"></a>let和const声明块级作用域</h3><p>作用域是你程序中变量可见的区域。换句话说就是一系列的规则，它们决定了你声明的变量在哪里是可以使用的。</p>\n<p>大家应该都听过 ，在JavaScript中只有在函数内部才会创造新的作用域。然而你创建的98%的作用域事实上都是函数作用域，其实在JavaScript中有三种创建新作用域的方法。你可以这样：</p>\n<ol>\n<li>创建一个函数。你应该已经知道这种方式。</li>\n<li>创建一个catch块。 我绝对没哟开玩笑.</li>\n<li>创建一个代码块。如果你用的是ES2015，在一段代码块中用let或者const声明的变量会限制它们只在这个块中可见。这叫做块级作用域。</li>\n</ol>\n<p>一个代码块就是你用花括号包起来的部分。 { 像这样 }。在if/else声明和try/catch/finally块中经常出现。如果你想利用块作用域的优势，你可以用花括号包裹任意的代码来创建一个代码块</p>\n<p>考虑下面的代码片段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 Node 中你需要使用 strict 模式尝试这个</span></div><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">\"foo\"</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (foo) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> bar = <span class=\"string\">\"bar\"</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> foobar = foo + bar;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// foo 和 bar 这里都可见 </span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This situation is \"</span> + foo + bar + <span class=\"string\">\". I'm going home.\"</span>);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This log statement is \"</span> + foobar + <span class=\"string\">\"! It threw a ReferenceError at me!\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"You got a \"</span> + err + <span class=\"string\">\"; no dice.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Just to prove to you that \"</span> + err + <span class=\"string\">\" doesn't exit outside of the above `catch` block.\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Told you so.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">baz();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(invisible);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"invisible hasn't been declared, yet, so we get a \"</span> + err);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> invisible = <span class=\"string\">\"You can't see me, yet\"</span>; <span class=\"comment\">// let 声明的变量在声明前是不可访问的</span></div></pre></td></tr></table></figure>\n<p>还有些要强调的</p>\n<ul>\n<li>注意foobar在if块之外是不可见的，因为我们没有用let声明；</li>\n<li>我们可以在任何地方使用foo ，因为我们用var定义它为全局作用域可见；</li>\n<li>我们可以在baz内部任何地方使用bar， 因为var-声明的变量是在定义的整个作用域内都可见。</li>\n<li>用let or const声明的变量不能在定义前调用。换句话说，它不会像var变量一样被编译器提升到作用域的开始处。</li>\n</ul>\n<p>const 与 let 类似，但有两点不同。</p>\n<ol>\n<li>必须给声明为const的变量在声明时赋值。不可以先声明后赋值。</li>\n<li>不能改变const变量的值，只有在创建它时可以给它赋值。如果你试图改变它的值，会得到一个TyepError。</li>\n</ol>\n<h3 id=\"let-amp-const-Who-Cares\"><a href=\"#let-amp-const-Who-Cares\" class=\"headerlink\" title=\"let &amp; const: Who Cares?\"></a>let &amp; const: Who Cares?</h3><p>我们已经用var将就了二十多年了，你可能在想我们真的需要新的类型声明关键字吗？（这里作者应该是想表达这个意思）</p>\n<p>问的好，简单的回答就是–不， 并不真正需要。但在可以用let和const的地方使用它们很有好处的。</p>\n<ul>\n<li>let和const声明变量时都不会被提升到作用域开始的地方，这样可以使代码可读性更强，制造尽可能少的迷惑。</li>\n<li>它会尽可能的约束变量的作用域，有助于减少令人迷惑的命名冲突。</li>\n<li>这样可以让程序只有在必须重新分配变量的情况下重新分配变量。 const 可以加强常量的引用。</li>\n</ul>\n<p>另一个例子就是 let 在 for 循环中的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> languages = [<span class=\"string\">'Danish'</span>, <span class=\"string\">'Norwegian'</span>, <span class=\"string\">'Swedish'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//会污染全局变量!</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; languages.length; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;languages[i]&#125;</span> is a Scandinavian language.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 4</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &amp;lt; languages.length; j += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;languages[j]&#125;</span> is a Scandinavian language.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(j); <span class=\"comment\">// Reference error</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`You got a <span class=\"subst\">$&#123;err&#125;</span>; no dice.`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在for循环中使用var声明的计数器并不会真正把计数器的值限制在本次循环中。 而let可以。</p>\n<p>let在每次迭代时重新绑定循环变量有很大的优势，这样每个循环中拷贝自身 , 而不是共享全局范围内的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 简洁明了</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &amp;lt; <span class=\"number\">6</span>; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I've waited \"</span> + i + <span class=\"string\">\" seconds!\"</span>);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span> * i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 功能完全混乱</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &amp;lt; <span class=\"number\">6</span>; j += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I've waited \"</span> + j + <span class=\"string\">\" seconds for this!\"</span>);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span> * j);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一层循环会和你想象的一样工作。而下面的会每秒输出 “I’ve waited 6 seconds!”。</p>\n<p>好吧，我选择狗带。</p>\n<h3 id=\"动态this关键字的怪异\"><a href=\"#动态this关键字的怪异\" class=\"headerlink\" title=\"动态this关键字的怪异\"></a>动态this关键字的怪异</h3><p>JavaScript的this关键字因为总是不按套路出牌而臭名昭著。</p>\n<p>事实上，它的规则相当简单。不管怎么说，this在有些情形下会导致奇怪的用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> polyglot = &#123;</div><div class=\"line\">    name : <span class=\"string\">\"Michel Thomas\"</span>,</div><div class=\"line\">    languages : [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>],</div><div class=\"line\">    introduce : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// this.name is \"Michel Thomas\"</span></div><div class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">this</span>.languages.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">language</span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// this.name is undefined, so we have to use our saved \"self\" variable </span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"My name is \"</span> + self.name + <span class=\"string\">\", and I speak \"</span> + language + <span class=\"string\">\".\"</span>);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">polyglot.introduce();</div></pre></td></tr></table></figure>\n<p>在introduce里, this.name是undefined。在回调函数外面，也就是forEach中， 它指向了polyglot对象。在这种情形下我们总是希望在函数内部this和函数外部的this指向同一个对象。</p>\n<p>问题是在JavaScript中函数会根据确定性四原则在调用时定义自己的this变量。这就是著名的动态this 机制。</p>\n<p>这些规则中没有一个是关于查找this所描述的“附近作用域”的；也就是说并没有一个确切的方法可以让JavaScript引擎能够基于包裹作用域来定义this的含义。</p>\n<p>这就意味着当引擎查找this的值时，可以找到值，但却和回调函数之外的不是同一个值。有两种传统的方案可以解决这个问题。</p>\n<ul>\n<li>在函数外面把this保存到一个变量中，通常取名self，并在内部函数中使用；</li>\n<li>或者在内部函数中调用bind阻止对this的赋值。</li>\n</ul>\n<p>以上两种办法均可生效，但会产生副作用。</p>\n<p>另一方面，如果内部函数没有设置它自己的this值，JavaScript会像查找其它变量那样查找this的值：通过遍历父作用域直到找到同名的变量。这样会让我们使用附近作用域代码中的this值，这就是著名的词法this。</p>\n<p>如果有样的特性，我们的代码将会更加的清晰，不是吗?</p>\n<h3 id=\"箭头函数中的词法this\"><a href=\"#箭头函数中的词法this\" class=\"headerlink\" title=\"箭头函数中的词法this\"></a>箭头函数中的词法this</h3><p>在 ES2015 中，我们有了这一特性。箭头函数不会绑定this值，允许我们利用词法绑定this关键字。这样我们就可以像这样重构上面的代码了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> polyglot = &#123;</div><div class=\"line\">    name : <span class=\"string\">\"Michel Thomas\"</span>,</div><div class=\"line\">    languages : [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>],</div><div class=\"line\">    introduce : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.languages.forEach((language) =&amp;gt; &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"My name is \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\", and I speak \"</span> + language + <span class=\"string\">\".\"</span>);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>… 这样就会按照我们想的那样工作了。</p>\n<p>箭头函数有一些新的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> languages = [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多行箭头函数必须使用花括号， </span></div><div class=\"line\"><span class=\"comment\">// 必须明确包含返回值语句</span></div><div class=\"line\">    <span class=\"keyword\">let</span> languages_lower = languages.map((language) =&amp;gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> language.toLowerCase()</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 单行箭头函数，花括号是可省的，</span></div><div class=\"line\"><span class=\"comment\">// 函数默认返回最后一个表达式的值</span></div><div class=\"line\"><span class=\"comment\">// 你可以指明返回语句，这是可选的。</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map((language) =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果你的箭头函数只有一个参数，可以省略括号</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map(language =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果箭头函数有多个参数，必须用圆括号包裹</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map((language, unused_param) =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(languages_lower); <span class=\"comment\">// [\"spanish\", \"french\", \"italian\", \"german\", \"polish\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最后，如果你的函数没有参数，你必须在箭头前加上空的括号。</span></div><div class=\"line\">(() =&amp;gt; alert(<span class=\"string\">\"Hello!\"</span>))();</div></pre></td></tr></table></figure>\n<p>MDN关于箭头函数的文档解释的很好。</p>\n<h3 id=\"简写属性和方法\"><a href=\"#简写属性和方法\" class=\"headerlink\" title=\"简写属性和方法\"></a>简写属性和方法</h3><p>ES2015提供了在对象上定义属性和方法的一些新方式。</p>\n<h3 id=\"简写方法\"><a href=\"#简写方法\" class=\"headerlink\" title=\"简写方法\"></a>简写方法</h3><p>在 JavaScript 中， method 是对象的一个有函数值的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在ES2015中，我们可以这样简写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    foo () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    * range (<span class=\"keyword\">from</span>, to) &#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">from</span> &amp;lt; to) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">from</span> === to)</div><div class=\"line\">                <span class=\"keyword\">return</span> ++<span class=\"keyword\">from</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> ++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意你也可以使用生成器去定义方法。只需要在函数名前面加一个星号(*)。</p>\n<p>这些叫做 方法定义 。和传统的函数作为属性很像，但有一些不同：</p>\n<ul>\n<li>只能在方法定义处调用super；</li>\n<li>不允许用new调用方法定义。</li>\n</ul>\n<p>我会在随后的几篇文章中讲到super关键字。如果你等不及了， Exploring ES6中有关于它的干货。</p>\n<h3 id=\"简写和推导属性\"><a href=\"#简写和推导属性\" class=\"headerlink\" title=\"简写和推导属性\"></a>简写和推导属性</h3><p>ES6还引入了简写和推导属性 。</p>\n<p>如果对象的键值和变量名是一致的，那么你可以仅用变量名来初始化你的对象，而不是定义冗余的键值对。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'foo'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"string\">'bar'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 旧语法</span></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    foo : foo,</div><div class=\"line\">    bar : bar</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 新语法</span></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123; foo, bar &#125;</div></pre></td></tr></table></figure>\n<p>两中语法都以foo和bar键值指向foo and bar变量。后面的方式语义上更加一致；这只是个语法糖。</p>\n<p>当用揭示模块模式来定义一些简洁的公共 API 的定义，我常常利用简写属性的优势。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'bar'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 这样写:</span></div><div class=\"line\">    <span class=\"keyword\">const</span> publicAPI = &#123; foo, bar &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 不要这样写:</span></div><div class=\"line\">    const publicAPI =  &#123;</div><div class=\"line\">       foo : foo,</div><div class=\"line\">       bar : bar</div><div class=\"line\">    &#125; */ </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> publicAPI;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里我们创建并返回了一个publicAPI对象，键值foo指向foo方法，键值bar指向bar方法。</p>\n<h3 id=\"推导属性名\"><a href=\"#推导属性名\" class=\"headerlink\" title=\"推导属性名\"></a>推导属性名</h3><p>这是不常见的例子，但ES6允许你用表达式做属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObj = &#123;</div><div class=\"line\">  <span class=\"comment\">// 设置属性名为 foo 函数的返回值</span></div><div class=\"line\">    [foo ()] () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObj.foo() ); <span class=\"comment\">// 'foo'</span></div></pre></td></tr></table></figure>\n<p>根据Dr. Raushmayer在Exploring ES6中讲的，这种特性最主要的用途是设置属性名与Symbol值一样。</p>\n<h3 id=\"Getter-和-Setter-方法\"><a href=\"#Getter-和-Setter-方法\" class=\"headerlink\" title=\"Getter 和 Setter 方法\"></a>Getter 和 Setter 方法</h3><p>最后，我想提一下get和set方法，它们在ES5中就已经支持了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例子采用的是 MDN's 上关于 getter 的内容</span></div><div class=\"line\"><span class=\"comment\">//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get</span></div><div class=\"line\"><span class=\"keyword\">const</span> speakingObj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 记录 “speak” 方法调用过多少次</span></div><div class=\"line\">    words : [],</div><div class=\"line\">    </div><div class=\"line\">    speak (word) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.words.push(word);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakingObj says '</span> + word + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    get called () &#123;</div><div class=\"line\">        <span class=\"comment\">// 返回最新的单词</span></div><div class=\"line\">        <span class=\"keyword\">const</span> words = <span class=\"keyword\">this</span>.words;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!words.length)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'speakingObj hasn\\'t spoken, yet.'</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> words[words.length - <span class=\"number\">1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(speakingObj.called); <span class=\"comment\">// 'speakingObj hasn't spoken, yet.'</span></div><div class=\"line\"></div><div class=\"line\">speakingObj.speak(<span class=\"string\">'blargh'</span>); <span class=\"comment\">// 'speakingObj says blargh!'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(speakingObj.called); <span class=\"comment\">// 'blargh'</span></div></pre></td></tr></table></figure>\n<p>使用getters时要记得下面这些:</p>\n<ul>\n<li>Getters不接受参数；</li>\n<li>属性名不可以和getter函数重名；</li>\n<li>可以用Object.defineProperty(OBJECT, “property name”, { get : function () { . . . } }) 动态创建 getter</li>\n</ul>\n<p>作为最后这点的例子，我们可以这样定义上面的 getter 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> speakingObj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 记录 “speak” 方法调用过多少次</span></div><div class=\"line\">    words : [],</div><div class=\"line\">    </div><div class=\"line\">    speak (word) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.words.push(word);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakingObj says '</span> + word + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这只是为了证明观点。我是绝对不会这样写的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">called</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 返回新的单词</span></div><div class=\"line\">    <span class=\"keyword\">const</span> words = <span class=\"keyword\">this</span>.words;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!words.length)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'speakingObj hasn\\'t spoken, yet.'</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> words[words.length - <span class=\"number\">1</span>];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(speakingObj, <span class=\"string\">\"called\"</span>, get : getCalled ) </div><div class=\"line\">除了 getters，还有 setters。像平常一样，它们通过自定义的逻辑给对象设置属性。</div><div class=\"line\"><span class=\"meta\"></span></div><div class=\"line\">\"use strict\";</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个新的 globetrotter（环球者）！</span></div><div class=\"line\"><span class=\"keyword\">const</span> globetrotter = &#123;</div><div class=\"line\">    <span class=\"comment\">// globetrotter 现在所处国家所说的语言 </span></div><div class=\"line\">    <span class=\"keyword\">const</span> current_lang = <span class=\"literal\">undefined</span>,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// globetrotter 已近环游过的国家</span></div><div class=\"line\">    <span class=\"keyword\">let</span> countries = <span class=\"number\">0</span>,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 查看环游过哪些国家了</span></div><div class=\"line\">    get countryCount () &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.countries;</div><div class=\"line\">    &#125;, </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 不论 globe trotter 飞到哪里，都重新设置他的语言</span></div><div class=\"line\">    set languages (language) &#123;</div><div class=\"line\">        <span class=\"comment\">// 增加环游过的城市数</span></div><div class=\"line\">        countries += <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">        <span class=\"comment\">// 重置当前语言</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.current_lang = language; </div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">globetrotter.language = <span class=\"string\">'Japanese'</span>;</div><div class=\"line\">globetrotter.countryCount(); <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">globetrotter.language = <span class=\"string\">'Spanish'</span>;</div><div class=\"line\">globetrotter.countryCount(); <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面讲的关于getters的也同样适用于setters，但有一点不同：</p>\n<ul>\n<li>getter不接受参数，setters必须接受正好一个参数。</li>\n</ul>\n<p>破坏这些规则中的任意一个都会抛出一个错误。</p>\n<p>既然 Angular 2 正在引入TypeCript并且把class带到了台前，我希望get and set能够流行起来… 但还有点希望它们不要流行起来。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>未来的JavaScript正在变成现实，是时候把它提供的东西都用起来了。这篇文章里，我们浏览了 ES2015的三个很流行的特性：</p>\n<ul>\n<li>let和const带来的块级作用域；</li>\n<li>箭头函数带来的this的词法作用域；</li>\n<li>简写属性和方法，以及getter和setter函数的回顾。</li>\n</ul>\n<h2 id=\"使用-ES6-编写更好的-JavaScript-Part-II：深入探究-类\"><a href=\"#使用-ES6-编写更好的-JavaScript-Part-II：深入探究-类\" class=\"headerlink\" title=\"使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]\"></a>使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]</h2><h3 id=\"辞旧迎新\"><a href=\"#辞旧迎新\" class=\"headerlink\" title=\"辞旧迎新\"></a>辞旧迎新</h3><p>在本文的开始，我们要说明一件事：</p>\n<p>从本质上说，ES6的classes主要是给创建老式构造函数提供了一种更加方便的语法，并不是什么新魔法 —— Axel Rauschmayer，Exploring ES6作者</p>\n<p>从功能上来讲，class声明就是一个语法糖，它只是比我们之前一直使用的基于原型的行为委托功能更强大一点。本文将从新语法与原型的关系入手，仔细研究ES2015的class关键字。文中将提及以下内容：</p>\n<ul>\n<li>定义与实例化类；</li>\n<li>使用extends创建子类；</li>\n<li>子类中super语句的调用；</li>\n<li>以及重要的标记方法（symbol method）的例子。</li>\n</ul>\n<p>在此过程中，我们将特别注意 class 声明语法从本质上是如何映射到基于原型代码的。</p>\n<p>让我们从头开始说起。</p>\n<h3 id=\"退一步说：Classes不是什么\"><a href=\"#退一步说：Classes不是什么\" class=\"headerlink\" title=\"退一步说：Classes不是什么\"></a>退一步说：Classes不是什么</h3><p>JavaScript的『类』与Java、Python或者其他你可能用过的面向对象语言中的类不同。其实后者可能称作面向『类』的语言更为准确一些。</p>\n<p>在传统的面向类的语言中，我们创建的类是对象的模板。需要一个新对象时，我们实例化这个类，这一步操作告诉语言引擎将这个类的方法和属性复制到一个新实体上，这个实体称作实例。实例是我们自己的对象，且在实例化之后与父类毫无内在联系。</p>\n<p>而JavaScript没有这样的复制机制。在JavaScript中『实例化』一个类创建了一个新对象，但这个新对象却不独立于它的父类。</p>\n<p>正相反，它创建了一个与原型相连接的对象。即使是在实例化之后，对于原型的修改也会传递到实例化的新对象去。</p>\n<p>原型本身就是一个无比强大的设计模式。有许多使用了原型的技术模仿了传统类的机制，class便为这些技术提供了简洁的语法。</p>\n<p>总而言之：</p>\n<ul>\n<li>JavaScript不存在Java和其他面向对象语言中的类概念；</li>\n<li>JavaScript 的class很大程度上只是原型继承的语法糖，与传统的类继承有很大的不同。</li>\n</ul>\n<p>搞清楚这些之后，让我们先看一下class。</p>\n<h3 id=\"类基础：声明与表达式\"><a href=\"#类基础：声明与表达式\" class=\"headerlink\" title=\"类基础：声明与表达式\"></a>类基础：声明与表达式</h3><p>我们使用class 关键字创建类，关键字之后是变量标识符，最后是一个称作类主体的代码块。这种写法称作类的声明。没有使用extends关键字的类声明被称作基类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Food 是一个基类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs, fat) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    toString () &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\"></div><div class=\"line\">chicken_breast.print(); <span class=\"comment\">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(chicken_breast.protein); <span class=\"comment\">// 26 (LINE A)</span></div></pre></td></tr></table></figure>\n<p>需要注意到以下事情：</p>\n<ul>\n<li>类只能包含方法定义，不能有数据属性；</li>\n<li>定义方法时，可以使用简写方法定义；</li>\n<li>与创建对象不同，我们不能在类主体中使用逗号分隔方法定义；</li>\n<li>我们可以在实例化对象上直接引用类的属性（如 LINE A）。</li>\n</ul>\n<p>类有一个独有的特性，就是 contructor 构造方法。在构造方法中我们可以初始化对象的属性。</p>\n<p>构造方法的定义并不是必须的。如果不写构造方法，引擎会为我们插入一个空的构造方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoConstructor</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/* JavaScript 会插入这样的代码：</span></div><div class=\"line\">     constructor () &#123; &#125;</div><div class=\"line\">    */</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> nemo = <span class=\"keyword\">new</span> NoConstructor(); <span class=\"comment\">// 能工作，但没啥意思</span></div></pre></td></tr></table></figure>\n<p>将一个类赋值给一个变量的形式叫类表达式，这种写法可以替代上面的语法形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这是一个匿名类表达式，在类主体中我们不能通过名称引用它</span></div><div class=\"line\"><span class=\"keyword\">const</span> Food = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和上面一样的类定义……</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这是一个命名类表达式，在类主体中我们可以通过名称引用它</span></div><div class=\"line\"><span class=\"keyword\">const</span> Food = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FoodClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和上面一样的类定义……</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//  添加一个新方法，证明我们可以通过内部名称引用 FoodClass……        </span></div><div class=\"line\">    printMacronutrients () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;FoodClass.name&#125;</span> | <span class=\"subst\">$&#123;FoodClass.protein&#125;</span> g P :: <span class=\"subst\">$&#123;FoodClass.carbs&#125;</span> g C :: <span class=\"subst\">$&#123;FoodClass.fat&#125;</span> g F`</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\">chicken_breast.printMacronutrients(); <span class=\"comment\">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 但是不能在外部引用</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(FoodClass.protein); <span class=\"comment\">// 引用错误</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"comment\">// pass</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一行为与匿名函数与命名函数表达式很类似。</p>\n<h3 id=\"使用extends创建子类以及使用super调用\"><a href=\"#使用extends创建子类以及使用super调用\" class=\"headerlink\" title=\"使用extends创建子类以及使用super调用\"></a>使用extends创建子类以及使用super调用</h3><p>使用extends创建的类被称作子类，或派生类。这一用法简单明了，我们直接在上面的例子中构建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FatFreeFood 是一个派生类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FatFreeFood</span> <span class=\"keyword\">extends</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name, protein, carbs, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.print();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Would you look at that -- <span class=\"subst\">$&#123;this.name&#125;</span> has no fat!`</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fat_free_yogurt = <span class=\"keyword\">new</span> FatFreeFood(<span class=\"string\">'Greek Yogurt'</span>, <span class=\"number\">16</span>, <span class=\"number\">12</span>);</div><div class=\"line\">fat_free_yogurt.print(); <span class=\"comment\">// 'Greek Yogurt | 26g P :: 16g C :: 0g F  /  Would you look at that -- Greek Yogurt has no fat!'</span></div></pre></td></tr></table></figure>\n<p>派生类拥有我们上文讨论的一切有关基类的特性，另外还有如下几点新特点：</p>\n<ul>\n<li>子类使用class关键字声明，之后紧跟一个标识符，然后使用extend关键字，最后写一个任意表达式。这个表达式通常来讲就是个标识符，但理论上也可以是函数。</li>\n<li>如果你的派生类需要引用它的父类，可以使用super关键字。</li>\n<li>一个派生类不能有一个空的构造函数。即使这个构造函数就是调用了一下super()，你也得把它显式的写出来。但派生类却可以没有构造函数。</li>\n<li>在派生类的构造函数中，必须先调用super，才能使用this关键字（译者注：仅在构造函数中是这样，在其他方法中可以直接使用this）。</li>\n</ul>\n<p>在JavaScript中仅有两个super关键字的使用场景：</p>\n<ol>\n<li>在子类构造函数中调用。如果初始化派生类是需要使用父类的构造函数，我们可以在子类的构造函数中调用super(parentConstructorParams)，传递任意需要的参数。</li>\n<li>引用父类的方法。在常规方法定义中，派生类可以使用点运算符来引用父类的方法：super.methodName。</li>\n</ol>\n<p>我们的 FatFreeFood 演示了这两种情况：</p>\n<ol>\n<li>在构造函数中，我们简单的调用了super，并将脂肪的量传入为0。</li>\n<li>在我们的print方法中，我们先调用了super.print，之后才添加了其他的逻辑。</li>\n</ol>\n<p>不管你信不信，我反正是信了以上说的已涵盖了有关class的基础语法，这就是你开始实验需要掌握的全部内容。</p>\n<h3 id=\"深入学习原型\"><a href=\"#深入学习原型\" class=\"headerlink\" title=\"深入学习原型\"></a>深入学习原型</h3><p>现在我们开始关注class是怎么映射到JavaScript内部的原型机制的。我们会关注以下几点：</p>\n<ul>\n<li>使用构造调用创建对象；</li>\n<li>原型连接的本质；</li>\n<li>属性和方法委托；</li>\n<li>使用原型模拟类。</li>\n<li>使用构造调用创建对象</li>\n</ul>\n<p>构造函数不是什么新鲜玩意儿。使用new关键字调用任意函数会使其返回一个对象 —— 这一步称作创建了一个构造调用，这种函数通常被称作构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 'new' 关键字调用 Food 方法，就是构造调用，该操作会返回一个对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(chicken_breast.protein) <span class=\"comment\">// 26</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不用 'new' 调用 Food 方法，会返回 'undefined'</span></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish); <span class=\"comment\">// 'undefined'</span></div></pre></td></tr></table></figure>\n<p>当我们使用new关键字调用函数时，JS内部执行了下面四个步骤：</p>\n<ol>\n<li>创建一个新对象（这里称它为O）；</li>\n<li>给O赋予一个连接到其他对象的链接，称为原型；</li>\n<li>将函数的this引用指向O；</li>\n<li>函数隐式返回O。</li>\n</ol>\n<p>在第三步和第四步之间，引擎会执行你函数中的具体逻辑。</p>\n<p>知道了这一点，我们就可以重写Food方法，使之不用new关键字也能工作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 演示示例：消除对 'new' 关键字的依赖</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 第一步：创建新对象</span></div><div class=\"line\">    <span class=\"keyword\">const</span> obj = &#123; &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第二步：链接原型——我们在下文会更加具体地探究原型的概念</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Food.prototype);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第三步：设置 'this' 指向我们的新对象</span></div><div class=\"line\">    <span class=\"comment\">// 尽然我们不能再运行的执行上下文中重置 `this`</span></div><div class=\"line\">    <span class=\"comment\">// 我们在使用 'obj' 取代 'this' 来模拟第三步</span></div><div class=\"line\">    obj.name    = name;</div><div class=\"line\">    obj.protein = protein;</div><div class=\"line\">    obj.carbs   = carbs;</div><div class=\"line\">    obj.fat     = fat;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第四步：返回新创建的对象</span></div><div class=\"line\">    <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish.protein); <span class=\"comment\">// 26</span></div></pre></td></tr></table></figure>\n<p>四步中的三步都是简单明了的。创建一个对象、赋值属性、然后写一个return声明，这些操作对大多数开发者来说没有理解上的问题——然而这就是难倒众人的黑魔法原型。</p>\n<h3 id=\"直观理解原型链\"><a href=\"#直观理解原型链\" class=\"headerlink\" title=\"直观理解原型链\"></a>直观理解原型链</h3><p>在通常情况下，JavaScript中的包括函数在内的所有对象都会链接到另一个对象上，这就是原型。</p>\n<p>如果我们访问一个对象本身没有的属性，JavaScript就会在对象的原型上检查该属性。换句话说，如果你对一个对象请求它没有的属性，它会对你说：『这个我不知道，问我的原型吧』。</p>\n<p>在另一个对象上查找不存在属性的过程称作委托。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// joe 没有 toString 方法……</span></div><div class=\"line\"><span class=\"keyword\">const</span> joe    = &#123; name : <span class=\"string\">'Joe'</span> &#125;,</div><div class=\"line\">    sara   = &#123; name : <span class=\"string\">'Sara'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.hasOwnProperty(joe, toString); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.hasOwnProperty(sara, toString); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ……但我们还是可以调用它！</span></div><div class=\"line\">joe.toString(); <span class=\"comment\">// '[object Object]'，而不是引用错误！</span></div><div class=\"line\">sara.toString(); <span class=\"comment\">// '[object Object]'，而不是引用错误！</span></div></pre></td></tr></table></figure>\n<p>尽管我们的 toString 的输出完全没啥用，但请注意：这段代码没有引起任何的ReferenceError！这是因为尽管joe和sara没有toString的属性，但他们的原型有啊。</p>\n<p>当我们寻找sara.toString()方法时，sara说：『我没有toString属性，找我的原型吧』。正如上文所说，JavaScript会亲切的询问Object.prototype 是否含有toString属性。由于原型上有这一属性，JS 就会把Object.prototype上的toString返回给我们程序并执行。</p>\n<p>sara本身没有属性没关系——我们会把查找操作委托到原型上。</p>\n<p>换言之，我们就可以访问到对象上并不存在的属性，只要其的原型上有这些属性。我们可以利用这一点将属性和方法赋值到对象的原型上，然后我们就可以调用这些属性，好像它们真的存在在那个对象上一样。</p>\n<p>更给力的是，如果几个对象共享相同的原型——正如上面的joe和sara的例子一样——当我们给原型赋值属性之后，它们就都可以访问了，无需将这些属性单独拷贝到每一个对象上。</p>\n<p>这就是为何大家把它称作原型继承——如果我的对象没有，但对象的原型有，那我的对象也能继承这个属性。</p>\n<p>事实上，这里并没有发生什么『继承』。在面向类的语言里，继承指从父类复制属性到子类的行为。在JavaScript里，没发生这种复制的操作，事实上这就是原型继承与类继承相比的一个主要优势。</p>\n<p>在我们探究原型究竟是怎么来的之前，我们先做一个简要回顾：</p>\n<ul>\n<li>joe和sara没有『继承』一个toString的属性；</li>\n<li>joe和sara实际上根本没有从Object.prototype上『继承』；</li>\n<li>joe和sara是链接到了Object.prototype上；</li>\n<li>joe和sara链接到了同一个Object.prototype上。</li>\n<li>如果想找到一个对象的（我们称它作O）原型，我们可以使用 Object.getPrototypeof(O)。</li>\n</ul>\n<p>然后我们再强调一遍：对象没有『继承自』他们的原型。他们只是委托到原型上。</p>\n<p>以上。</p>\n<p>接下来让我们深入一下。</p>\n<h3 id=\"设置对象的原型\"><a href=\"#设置对象的原型\" class=\"headerlink\" title=\"设置对象的原型\"></a>设置对象的原型</h3><p>我们已了解到基本上每个对象（下文以O指代）都有原型（下文以P指代），然后当我们查找O上没有的属性，JavaScript引擎就会在P上寻找这个属性。</p>\n<p>至此我们有两个问题：</p>\n<ul>\n<li>以上情况函数怎么玩？</li>\n<li>这些原型是从哪里来的？</li>\n</ul>\n<p>名为Object的函数</p>\n<p>在JavaScript引擎执行程序之前，它会创建一个环境让程序在内部执行，在执行环境中会创建一个函数，叫做Object, 以及一个关联对象，叫做Object.prototype。</p>\n<p>换句话说，Object和Object.prototype在任意执行中的JavaScript程序中永远存在。</p>\n<p>这个Object乍一看好像和其他函数没什么区别，但特别之处在于它是一个构造器——在调用它时返回一个新对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// \"object\"</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>();     <span class=\"comment\">// 这个 Object 函数的特点是不需要使用 new 关键字调用</span></div></pre></td></tr></table></figure>\n<p>这个Object.prototype对象是个……对象。正如其他对象一样，它有属性。</p>\n<p><img src=\"https://i.imgsafe.org/ebbd5e3.png\" alt=\"https://i.imgsafe.org/ebbd5e3.png\"></p>\n<p>关于Object和Object.prototype你需要知道以下几点：</p>\n<ol>\n<li>Object函数有一个叫做.prototype的属性，指向一个对象（Object.prototype）；</li>\n<li>Object.prototype对象有一个叫做.constructor的属性，指向一个函数（Object）。</li>\n</ol>\n<p>实际上，这个总体方案对于JavaScript中的所有函数都是适用的。当我们创建一个函数——下文称作 someFunction——这个函数就会有一个属性.prototype，指向一个叫做someFunction.prototype 的对象。</p>\n<p>与之相反，someFunction.prototype对象会有一个叫做.contructor的属性，它的引用指回函数someFunction。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Foo!'</span>);  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype); <span class=\"comment\">// 指向一个叫 'foo' 的对象</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype.constructor); <span class=\"comment\">// 指向 'foo' 函数</span></div><div class=\"line\"></div><div class=\"line\">foo.prototype.constructor(); <span class=\"comment\">// 输出 'Foo!' —— 仅为证明确实有 'foo.prototype.constructor' 这么个方法且指向原函数</span></div></pre></td></tr></table></figure>\n<p>需要记住以下几个要点：</p>\n<ol>\n<li>所有的函数都有一个属性，叫做 .prototype，它指向这个函数的关联对象。</li>\n<li>所有函数的原型都有一个属性，叫做 .constructor，它指向这个函数本身。</li>\n<li>一个函数原型的 .constructor 并非必须指向创建这个函数原型的函数……有点绕，我们等下会深入探讨一下。</li>\n</ol>\n<p>设置函数的原型有一些规则，在开始之前，我们先概括设置对象原型的三个规则：</p>\n<ol>\n<li>『默认』规则；</li>\n<li>使用new隐式设置原型；</li>\n<li>使用Object.create显式设置原型。</li>\n</ol>\n<h3 id=\"默认规则\"><a href=\"#默认规则\" class=\"headerlink\" title=\"默认规则\"></a>默认规则</h3><p>考虑下这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123; status : <span class=\"string\">'foobar'</span> &#125;;</div></pre></td></tr></table></figure>\n<p>十分简单，我们做的事儿就是创建一个叫foo的对象，然后给他一个叫status的属性。</p>\n<p>然后JavaScript在幕后多做了点工作。当我们在字面上创建一个对象时，JavaScript将对象的原型指向Object.prototype并设置其原型的.constructor指向Object：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123; status : <span class=\"string\">'foobar'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(foo) === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></div><div class=\"line\">foo.constructor === <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用new隐式设置原型\"><a href=\"#使用new隐式设置原型\" class=\"headerlink\" title=\"使用new隐式设置原型\"></a>使用new隐式设置原型</h3><p>让我们再看下之前调整过的 Food 例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在我们知道函数Food将会与一个叫做Food.prototype的对象关联。</p>\n<p>当我们使用new关键字创建一个对象，JavaScript将会：</p>\n<ol>\n<li>设置这个对象的原型指向我们使用new调用的函数的.prototype属性；</li>\n<li>设置这个对象的.constructor指向我们使用new调用到的构造函数。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tootsie_roll = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Tootsie Roll'</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(tootsie_roll) === Food.prototype; <span class=\"comment\">// true</span></div><div class=\"line\">tootsie_roll.constructor === Food; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这就可以让我们搞出下面这样的黑魔法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.cook = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cook</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> is cooking!`</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> dinner = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Lamb Chops'</span>, <span class=\"number\">52</span>, <span class=\"number\">8</span>, <span class=\"number\">32</span>);</div><div class=\"line\">dinner.cook(); <span class=\"comment\">// 'Lamb Chops are cooking!'</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用Object-create显式设置原型\"><a href=\"#使用Object-create显式设置原型\" class=\"headerlink\" title=\"使用Object.create显式设置原型\"></a>使用Object.create显式设置原型</h3><p>最后我们可以使用Object.create方法手工设置对象的原型引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</div><div class=\"line\">    speak () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Foo!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">Object</span>.create(foo);</div><div class=\"line\"></div><div class=\"line\">bar.speak(); <span class=\"comment\">// 'Foo!'</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(bar) === foo; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>还记得使用new调用函数的时候，JavaScript在幕后干了哪四件事儿吗？Object.create就干了这三件事儿：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>设置它的原型引用；</li>\n<li>返回这个新对象。</li>\n</ol>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" target=\"_blank\" rel=\"external\">你可以自己去看下MDN上写的那个polyfill。</a><br>（译者注：polyfill就是给老代码实现现有新功能的补丁代码，这里就是指老版本JS没有Object.create函数，MDN上有手工撸的一个替代方案）</p>\n<h3 id=\"模拟-class-行为\"><a href=\"#模拟-class-行为\" class=\"headerlink\" title=\"模拟 class 行为\"></a>模拟 class 行为</h3><p>直接使用原型来模拟面向类的行为需要一些技巧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FatFreeFood</span> (<span class=\"params\">name, protein, carbs</span>) </span>&#123;</div><div class=\"line\">    Food.call(<span class=\"keyword\">this</span>, name, protein, carbs, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置 \"subclass\" 关系</span></div><div class=\"line\"><span class=\"comment\">// =====================</span></div><div class=\"line\"><span class=\"comment\">// LINE A :: 使用 Object.create 手动设置 FatFreeFood's 『父类』.</span></div><div class=\"line\">FatFreeFood.prototype = <span class=\"built_in\">Object</span>.create(Food.prototype);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// LINE B :: 手工重置 constructor 的引用</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(FatFreeFood.constructor, <span class=\"string\">\"constructor\"</span>, &#123;</div><div class=\"line\">    enumerable : <span class=\"literal\">false</span>,</div><div class=\"line\">    writeable  : <span class=\"literal\">true</span>,</div><div class=\"line\">    value      : FatFreeFood</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在Line A，我们需要设置FatFreeFood.prototype使之等于一个新对象，这个新对象的原型引用是Food.prototype。如果没这么搞，我们的子类就不能访问『超类』的方法。</p>\n<p>不幸的是，这个导致了相当诡异的结果：FatFreeFood.constructor是Function，而不是FatFreeFood。为了保证一切正常，我们需要在Line B手工设置FatFreeFood.constructor。</p>\n<p>让开发者从使用原型对类行为笨拙的模仿中脱离苦海是class关键字的产生动机之一。它确实也提供了避免原型语法常见陷阱的解决方案。</p>\n<p>现在我们已经探究了太多关于JavaScript的原型机制，你应该更容易理解class关键字让一切变得多么简单了吧！</p>\n<h3 id=\"深入探究下方法\"><a href=\"#深入探究下方法\" class=\"headerlink\" title=\"深入探究下方法\"></a>深入探究下方法</h3><p>现在我们已了解到JavaScript原型系统的必要性，我们将深入探究一下类支持的三种方法，以及一种特殊情况，以结束本文的讨论。</p>\n<ul>\n<li>构造器；</li>\n<li>静态方法；</li>\n<li>原型方法；</li>\n<li>一种原型方法的特殊情况：『标记方法』。</li>\n</ul>\n<p>并非我提出的这三组方法，这要归功于Rauschmayer博士在探索ES6一书中的定义。</p>\n<h3 id=\"类构造器\"><a href=\"#类构造器\" class=\"headerlink\" title=\"类构造器\"></a>类构造器</h3><p>一个类的constructor方法用于关注我们的初始化逻辑，constructor方法有以下几个特殊点：</p>\n<ol>\n<li>只有在构造方法里，我们才可以调用父类的构造器；</li>\n<li>它在背后处理了所有设置原型链的工作；</li>\n<li>它被用作类的定义。</li>\n</ol>\n<p>第二点就是在JavaScript中使用class的一个主要好处，我们来引用一下《探索 ES6》书里的15.2.3.1 的标题：</p>\n<blockquote>\n<p>子类的原型就是超类</p>\n</blockquote>\n<p>正如我们所见，手工设置非常繁琐且容易出错。如果我们使用class关键字，JavaScript在内部会负责搞定这些设置，这一点也是使用class的优势。</p>\n<p>第三点有点意思。在JavaScript中类仅仅是个函数——它等同于与类中的constructor方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和之前一样的类定义……</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> Food; <span class=\"comment\">// 'function'</span></div></pre></td></tr></table></figure>\n<p>与一般把函数作为构造器的方式不同，我们不能不用new关键字而直接调用类构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> burrito = Food(<span class=\"string\">'Heaven'</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">25</span>); <span class=\"comment\">// 类型错误</span></div></pre></td></tr></table></figure>\n<p>这就引发了另一个问题：当我们不用new调用函数构造器的时候发生了什么？</p>\n<p>简短的回答是：对于任何没有显式返回的函数来说都是返回undefined。我们只需要相信用我们构造函数的用户都会使用构造调用。这就是社区为何约定构造方法的首字母大写：提醒使用者要用new来调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// D'oh . . .</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish); <span class=\"comment\">// 'undefined'</span></div></pre></td></tr></table></figure>\n<p>长一点的回答是：返回undefined，除非你手工检测是否使用被new调用，然后进行自己的处理。</p>\n<p>ES2015引入了一个属性使得这种检测变得简单: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\" target=\"_blank\" rel=\"external\">new.target</a>.</p>\n<p>new.target是一个定义在所有使用new调用的函数上的属性，包括类构造器。 当我们使用new关键字调用函数时，函数体内的new.target的值就是这个函数本身。如果函数没有被new调用，这个值就是undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 强行构造调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果用户忘了手工调用一下</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">new</span>.target)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Food(name, protein, carbs, fat);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 糟了，不过没关系！</span></div><div class=\"line\">fish; <span class=\"comment\">// 'Food &#123;name: \"Halibut\", protein: 20, carbs: 5, fat: 0&#125;'</span></div></pre></td></tr></table></figure>\n<p>在ES5里用起来也还行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Food))</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Food(name, protein, carbs, fat);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MDN文档讲述了new.target的更多细节，而且给有兴趣者配上了ES2015规范作为参考。规范里有关 [[Construct]] 的描述很有启发性。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法是构造方法自己的方法，不能被类的实例化对象调用。我们使用static关键字定义静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// 和之前一样……</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 添加静态方法</span></div><div class=\"line\">     <span class=\"keyword\">static</span> describe () &#123;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'\"Food\" 是一种存储了营养信息的数据类型'</span>);</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.describe(); <span class=\"comment\">// '\"Food\" 是一种存储了营养信息的数据类型'</span></div></pre></td></tr></table></figure>\n<p>静态方法与老式构造函数中直接属性赋值相似：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    Food.count += <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.count = <span class=\"number\">0</span>;</div><div class=\"line\">Food.describe = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`你创建了 <span class=\"subst\">$&#123;Food.count&#125;</span> 个 food`</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> dummy = <span class=\"keyword\">new</span> Food();</div><div class=\"line\">Food.describe(); <span class=\"comment\">// \"你创建了 1 个 food\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"原型方法\"><a href=\"#原型方法\" class=\"headerlink\" title=\"原型方法\"></a>原型方法</h3><p>任何不是构造方法和静态方法的方法都是原型方法。之所以叫原型方法，是因为我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 ES6：</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs, fat) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    toString () &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;  </div><div class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在 ES5 里：</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>  (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 『原型方法』的命名大概来自我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。</span></div><div class=\"line\">Food.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toString</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>应该说明，在方法定义时完全可以使用生成器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Range</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(from, to) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"keyword\">from</span>;</div><div class=\"line\">        <span class=\"keyword\">this</span>.to   = to;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    * generate () &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> counter = <span class=\"keyword\">this</span>.from,</div><div class=\"line\">            to      = <span class=\"keyword\">this</span>.to;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (counter &amp;lt; to) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (counter == to)</div><div class=\"line\">                <span class=\"keyword\">return</span> counter++;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">yield</span> counter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> range = <span class=\"keyword\">new</span> Range(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> gen = range.generate();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> range.generate()) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Generator 的值是 <span class=\"subst\">$&#123; val &#125;</span>. `</span>);</div><div class=\"line\">    <span class=\"comment\">//  Prints:</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 0.</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 1.</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 2.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"标志方法\"><a href=\"#标志方法\" class=\"headerlink\" title=\"标志方法\"></a>标志方法</h3><p>最后我们说说标志方法。这是一些名为Symbol值的方法，当我们在自定义对象中使用内置构造器时，JavaScript引擎可以识别并使用这些方法。</p>\n<p>MDN文档提供了一个Symbol是什么的简要概览：</p>\n<p>Symbol是一个唯一且不变的数据类型，可以作为一个对象的属性标示符。</p>\n<p>创建一个新的symbol，会给我们提供一个被认为是程序里的唯一标识的值。这一点对于命名对象的属性十分有用：我们可以确保不会不小心覆盖任何属性。使用Symbol做键值也不是无数的，所以他们很大程度上对外界是不可见的（也不完全是，可以通过Reflect.ownKeys获得）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> secureObject = &#123;</div><div class=\"line\">    <span class=\"comment\">// 这个键可以看作是唯一的</span></div><div class=\"line\">    [<span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"name\"</span>)] : <span class=\"string\">'Dr. Secure A. F.'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.getKeys(superSecureObject) ); <span class=\"comment\">// [] -- 标志属性不太好获取    </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Reflect</span>.ownKeys(secureObject) ); <span class=\"comment\">// [Symbol(\"name\")] -- 但也不是完全隐藏的</span></div></pre></td></tr></table></figure>\n<p>对我们来讲更有意思的是，这给我们提供了一种方式来告诉 JavaScript 引擎使用特定方法来达到特定的目的。</p>\n<p>所谓的『众所周知的Symbol』是一些特定对象的键，当你在定义对象中使用时他们时，JavaScript引擎会触发一些特定方法。</p>\n<p>这对于JavaScript来说有点怪异，我们还是看个例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 继承 Array 可以让我们直观的使用 'length'</span></div><div class=\"line\"><span class=\"comment\">// 同时可以让我们访问到内置方法，如</span></div><div class=\"line\"><span class=\"comment\">// map、filter、reduce、push、pop 等</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FoodSet</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// foods 把传递的任意参数收集为一个数组</span></div><div class=\"line\">    <span class=\"comment\">// 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator</span></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(...foods) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>();</div><div class=\"line\">        <span class=\"keyword\">this</span>.foods = [];</div><div class=\"line\">        foods.forEach((food) =&amp;gt; <span class=\"keyword\">this</span>.foods.push(food))</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 自定义迭代器行为，请注意，这不是多么好用的迭代器，但是个不错的例子</span></div><div class=\"line\">     <span class=\"comment\">// 键名前必须写星号</span></div><div class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator] () &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> position = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (position &amp;lt; <span class=\"keyword\">this</span>.foods.length) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (position === <span class=\"keyword\">this</span>.foods.length) &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> <span class=\"string\">\"Done!\"</span></div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">yield</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.foods[ position++ ]&#125;</span> is the food item at position <span class=\"subst\">$&#123;position&#125;</span>`</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 当我们的用户使用内置的数组方法，返回一个数组类型对象</span></div><div class=\"line\">     <span class=\"comment\">// 而不是 FoodSet 类型的。这使得我们的 FoodSet 可以被一些</span></div><div class=\"line\">     <span class=\"comment\">// 期望操作数组的代码操作</span></div><div class=\"line\">     <span class=\"keyword\">static</span> get [<span class=\"built_in\">Symbol</span>.species] () &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foodset = <span class=\"keyword\">new</span> FoodSet(<span class=\"keyword\">new</span> Food(<span class=\"string\">'Fish'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">16</span>), <span class=\"keyword\">new</span> Food(<span class=\"string\">'Hamburger'</span>, <span class=\"number\">26</span>, <span class=\"number\">48</span>, <span class=\"number\">24</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当我们使用 for ... of 操作 FoodSet 时，JavaScript 将会使用</span></div><div class=\"line\"><span class=\"comment\">// 我们之前用 [Symbol.iterator] 做键值的方法</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> food <span class=\"keyword\">of</span> foodset) &#123;</div><div class=\"line\">    <span class=\"comment\">// 打印全部 food</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log( food );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当我们执行数组的 `filter` 方法时，JavaScript 创建并返回一个新对象</span></div><div class=\"line\"><span class=\"comment\">// 我们在什么对象上执行 `filter` 方法，新对象就使用这个对象作为默认构造器来创建</span></div><div class=\"line\"><span class=\"comment\">// 然而大部分代码都希望 filter 返回一个数组，于是我们通过重写 [Symbol.species]</span></div><div class=\"line\"><span class=\"comment\">// 的方式告诉 JavaScript 使用数组的构造器</span></div><div class=\"line\"><span class=\"keyword\">const</span> healthy_foods = foodset.filter((food) =&amp;gt; food.name !== <span class=\"string\">'Hamburger'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log( healthy_foods <span class=\"keyword\">instanceof</span> FoodSet ); <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log( healthy_foods <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> );</div></pre></td></tr></table></figure>\n<p>当你使用for…of遍历一个对象时，JavaScript将会尝试执行对象的迭代器方法，这一方法就是该对象 Symbol.iterator属性上关联的方法。如果我们提供了自己的方法定义，JavaScript就会使用我们自定义的。如果没有自己制定的话，如果有默认的实现就用默认的，没有的话就不执行。</p>\n<p>Symbo.species更奇异了。在自定义的类中，默认的Symbol.species函数就是类的构造函数。当我们的子类有内置的集合（例如Array和Set）时，我们通常希望在使用父类的实例时也能使用子类。</p>\n<p>通过方法返回父类的实例而不是派生类的实例，使我们更能确保我们子类在大多数代码里的可用性。而Symbol.species可以实现这一功能。</p>\n<p>如果不怎么需要这个功能就别费力去搞了。Symbol的这种用法——或者说有关Symbol的全部用法——都还比较罕见。这些例子只是为了演示：</p>\n<ol>\n<li>我们可以在自定义类中使用JavaScript内置的特定构造器；</li>\n<li>用两个普通的例子展示了怎么实现这一点。</li>\n</ol>\n<h3 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>ES2015的class关键字没有带给我们 Java 里或是SmallTalk里那种『真正的类』。宁可说它只是提供了一种更加方便的语法来创建通过原型关联的对象，本质上没有什么新东西。</p>\n<h2 id=\"使用ES6写更好的JavaScript-part-III：好用的集合和反引号\"><a href=\"#使用ES6写更好的JavaScript-part-III：好用的集合和反引号\" class=\"headerlink\" title=\"使用ES6写更好的JavaScript part III：好用的集合和反引号\"></a>使用ES6写更好的JavaScript part III：好用的集合和反引号</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>ES2015发生了一些重大变革，像promises和generators. 但并非新标准的一切都高不可攀。 – 相当一部分新特性可以快速上手。</p>\n<p>在这篇文章里，我们来看下新特性带来的好处:</p>\n<ul>\n<li>新的集合: map，weakmap，set， weakset</li>\n<li>大部分的new String methods</li>\n<li>模板字符串。</li>\n</ul>\n<p>我们开始这个系列的最后一章吧。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>模板字符串 解决了三个痛点，允许你做如下操作:</p>\n<ol>\n<li>定义在字符串内部的表达式，称为 字符串插值。</li>\n<li>写多行字符串无须用换行符 (\\n) 拼接。</li>\n<li>使用“raw”字符串 – 在反斜杠内的字符串不会被转义，视为常量。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">“use strict”;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 三个模板字符串的例子:</span></div><div class=\"line\"></div><div class=\"line\">字符串插值，多行字符串，raw 字符串。</div><div class=\"line\">================================= */</div><div class=\"line\"><span class=\"comment\">// ================================== </span></div><div class=\"line\"><span class=\"comment\">// 1. 字符串插值 :: 解析任何一个字符串中的表达式。 </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + <span class=\"number\">1</span> = $&#123;<span class=\"number\">1</span> + <span class=\"number\">1</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ================================== </span></div><div class=\"line\"><span class=\"comment\">// 2. 多行字符串 :: 这样写: </span></div><div class=\"line\"><span class=\"keyword\">let</span> childe_roland = </div><div class=\"line\">I saw them and I knew them all. And yet &lt;br&gt; Dauntless the slug-horn to my lips I set, <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span> And blew “Childe Roland to the Dark Tower came.”</span></div><div class=\"line\"></div><div class=\"line\">// … 代替下面的写法: </div><div class=\"line\">child_roland = </div><div class=\"line\">‘I saw them and I knew them all. And yet\\n’ + </div><div class=\"line\">‘Dauntless the slug-horn to my lips I set,\\n’ + </div><div class=\"line\">‘And blew “Childe Roland to the Dark Tower came.”’;</div><div class=\"line\"></div><div class=\"line\">// ================================== </div><div class=\"line\">// 3. raw 字符串 :: 在字符串前加 raw 前缀，javascript 会忽略转义字符。 </div><div class=\"line\">// 依然会解析包在 $&#123;&#125; 的表达式 </div><div class=\"line\">const unescaped = String.rawThis $&#123;string()&#125; doesn't contain a newline!\\n</div><div class=\"line\"></div><div class=\"line\">function string () &#123; return “string”; &#125;</div><div class=\"line\"></div><div class=\"line\">console.log(unescaped); // ‘This string doesn’t contain a newline!\\n’ – 注意 \\n 会被原样输出</div><div class=\"line\"></div><div class=\"line\">// 你可以像 React 使用 JSX 一样，用模板字符串创建 HTML 模板 </div><div class=\"line\">const template = </div><div class=\"line\">`</div><div class=\"line\"></div><div class=\"line\">Example</div><div class=\"line\"></div><div class=\"line\">I’m a pure JS &amp; HTML template!</div><div class=\"line\"></div><div class=\"line\">`</div><div class=\"line\"></div><div class=\"line\">function getClass () &#123; </div><div class=\"line\">// Check application state, calculate a class based on that state </div><div class=\"line\">return “some-stateful-class”; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(template); // 这样使用略显笨，自己试试吧！</div><div class=\"line\"></div><div class=\"line\">// 另一个常用的例子是打印变量名: </div><div class=\"line\">const user = &#123; name : ‘Joe’ &#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(“User’s name is ” + user.name + “.”); // 有点冗长 </div><div class=\"line\">console.log(User's name is $&#123;user.name&#125;.); // 这样稍好一些</div></pre></td></tr></table></figure>\n<ol>\n<li><p>使用字符串插值，用反引号代替引号包裹字符串，并把我们想要的表达式嵌入在${}中。</p>\n</li>\n<li><p>对于多行字符串，只需要把你要写的字符串包裹在反引号里，在要换行的地方直接换行。 JavaScript 会在换行处插入新行。</p>\n</li>\n<li>使用原生字符串，在模板字符串前加前缀String.raw，仍然使用反引号包裹字符串。</li>\n</ol>\n<p>模板字符串或许只不过是一种语法糖 … 但它比语法糖略胜一筹。</p>\n<h3 id=\"新的字符串方法\"><a href=\"#新的字符串方法\" class=\"headerlink\" title=\"新的字符串方法\"></a>新的字符串方法</h3><p>ES2015也给String新增了一些方法。他们主要归为两类:</p>\n<ol>\n<li>通用的便捷方法</li>\n<li>扩充 Unicode 支持的方法。</li>\n</ol>\n<p>在本文里我们只讲第一类，同时unicode特定方法也有相当好的用例 。如果你感兴趣的话，这是地址在MDN的文档里，有一个关于字符串新方法的完整列表。</p>\n<h3 id=\"startsWith-amp-endsWith\"><a href=\"#startsWith-amp-endsWith\" class=\"headerlink\" title=\"startsWith &amp; endsWith\"></a>startsWith &amp; endsWith</h3><p>对新手而言，我们有String.prototype.startsWith。 它对任何字符串都有效，它需要两个参数:</p>\n<ol>\n<li>一个是 search string 还有</li>\n<li>整形的位置参数 n。这是可选的。</li>\n</ol>\n<p>String.prototype.startsWith方法会检查以nth位起的字符串是否以search string开始。如果没有位置参数，则默认从头开始。</p>\n<p>如果字符串以要搜索的字符串开头返回 true，否则返回 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串是以 \"This is one\" 开头吗?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"This is one\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串的第四个字符以 \"is\" 开头?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"is\"</span>, <span class=\"number\">4</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串的第五个字符以 \"is\" 开始?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"is\"</span>, <span class=\"number\">5</span>)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith\"></a>endsWith</h3><p>String.prototype.endsWith和startswith相似: 它也需要两个参数：一个是要搜索的字符串，一个是位置。</p>\n<p>然而String.prototype.endsWith位置参数会告诉函数要搜索的字符串在原始字符串中被当做结尾处理。</p>\n<p>换句话说，它会切掉nth后的所有字符串，并检查是否以要搜索的字符结尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.endsWith(<span class=\"string\">\"contrived example!\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.slice(<span class=\"number\">0</span>, <span class=\"number\">11</span>)); <span class=\"comment\">// \"This is one\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.endsWith(<span class=\"string\">\"one\"</span>, <span class=\"number\">11</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通常情况下，传一个位置参数向下面这样:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">substringEndsWith</span> (<span class=\"params\">string, search_string, position</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Chop off the end of the string</span></div><div class=\"line\">    <span class=\"keyword\">const</span> substring = string.slice(<span class=\"number\">0</span>, position);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 检查被截取的字符串是否已 search_string 结尾</span></div><div class=\"line\">    <span class=\"keyword\">return</span> substring.endsWith(search_string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes\"></a>includes</h3><p>ES2015也添加了String.prototype.includes。 你需要用字符串调用它，并且要传递一个搜索项。如果字符串包含搜索项会返回true，反之返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串是否包含单词 impressively ?</span></div><div class=\"line\">contrived_example.includes(<span class=\"string\">\"impressively\"</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>ES2015之前，我们只能这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\">contrived_example.indexOf(<span class=\"string\">\"impressively\"</span>) !== <span class=\"number\">-1</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>不算太坏。但是，String.prototype.includes是 一个改善，它屏蔽了任意整数返回值为true的漏洞。</p>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h3><p>还有String.prototype.repeat。可以对任意字符串使用，像includes一样，它会或多或少地完成函数名指示的工作。</p>\n<p>它只需要一个参数: 一个整型的count。使用案例说明一切，上代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> na = <span class=\"string\">\"na\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(na.repeat(<span class=\"number\">5</span>) + <span class=\"string\">\", Batman!\"</span>); <span class=\"comment\">// 'nanananana, Batman!'</span></div></pre></td></tr></table></figure>\n<h3 id=\"raw\"><a href=\"#raw\" class=\"headerlink\" title=\"raw\"></a>raw</h3><p>最后，我们有String.raw，我们在上面简单介绍过。</p>\n<p>一个模板字符串以 String.raw 为前缀，它将不会在字符串中转义:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 单右斜线要转义，我们需要双右斜线才能打印一个右斜线，\\n 在普通字符串里会被解析为换行</span></div><div class=\"line\">  *   */</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'This string \\\\ has fewer \\\\ backslashes \\\\ and \\n breaks the line.'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不想这样写的话用 raw 字符串</span></div><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`This string \\\\ has too many \\\\ backslashes \\\\ and \\n doesn't break the line.`</span></div></pre></td></tr></table></figure>\n<h3 id=\"Unicode方法\"><a href=\"#Unicode方法\" class=\"headerlink\" title=\"Unicode方法\"></a>Unicode方法</h3><p>虽然我们不涉及剩余的 string 方法，但是如果我不告诉你去这个主题的必读部分就会显得我疏忽。</p>\n<ul>\n<li>Dr Rauschmayer对于Unicode in JavaScript的介绍 </li>\n<li>他关于ES2015’s Unicode Support in Exploring ES6和The Absolute Minimum Every Software Developer Needs to Know About Unicode 的讨论。</li>\n</ul>\n<p>无论如何我不得不跳过它的最后一部分。虽然有些老但是还是有优点的。</p>\n<p>这里是文档中缺失的字符串方法，这样你会知道缺哪些东西了。</p>\n<ul>\n<li>String.fromCodePoint &amp; String.prototype.codePointAt;</li>\n<li>String.prototype.normalize;</li>\n<li>Unicode point escapes.</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>ES2015新增了一些集合类型:</p>\n<ol>\n<li>Map和WeakMap</li>\n<li>Set和WeakSet。</li>\n</ol>\n<p>合适的Map和Set类型十分方便使用，还有弱变量是一个令人兴奋的改动，虽然它对Javascript来说像舶来品一样。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>map就是简单的键值对。最简单的理解方式就是和object类似，一个键对应一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们可以把 foo 当键，bar 当值</span></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123; foo : <span class=\"string\">'bar'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对象键为 foo 的值为 bar</span></div><div class=\"line\">obj.foo === <span class=\"string\">'bar'</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>新的Map类型在概念上是相似的，但是可以使用任意的数据类型作为键 – 不止strings和symbols–还有除了pitfalls associated with trying to use an objects a map的一些东西。</p>\n<p>下面的片段例举了 Map 的 API.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造器</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_inventory = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// BASIC API METHODS</span></div><div class=\"line\"><span class=\"comment\">// Map.prototype.set (K, V) :: 创建一个键 K，并设置它的值为 V。</span></div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'The Dalmore'</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 你可以创建一个 map 里面包含一个有两个元素的数组</span></div><div class=\"line\">scotch_inventory = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">2</span>], [<span class=\"string\">'The Dalmore'</span>, <span class=\"number\">1</span>]]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 map 都有 size 属性，这个属性会告诉你 map 里有多少个键值对。</span></div><div class=\"line\"><span class=\"comment\">// 用 Map 或 Set 的时候，一定要使用 size ，不能使用 length</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.size); <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.get(K) :: 返回键相关的值。如果键不存在返回 undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.get(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.get(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.has(K) :: 如果 map 里包含键 K 返回true，否则返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.has(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.has(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.delete(K) :: 从 map 里删除键 K。成功返回true，不存在返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.delete(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true -- breaks my heart</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.clear() :: 清楚 map 中的所有键值对</span></div><div class=\"line\">scotch_inventory.clear();</div><div class=\"line\"><span class=\"built_in\">console</span>.log( scotch_inventory ); <span class=\"comment\">// Map &#123;&#125; -- long night</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 遍历方法</span></div><div class=\"line\"><span class=\"comment\">// Map 提供了多种方法遍历键值。 </span></div><div class=\"line\"><span class=\"comment\">//  重置值，继续探索</span></div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Glenfiddich 18'</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Map.prototype.forEach(callback[, thisArg]) :: 对 map 里的每个键值对执行一个回调函数 </span></div><div class=\"line\">  *   你可以在回调函数内部设置 'this' 的值，通过传递一个 thisArg 参数，那是可选的而且没有太大必要那样做</div><div class=\"line\">  *   最后，注意回调函数已经被传了键和值 */</div><div class=\"line\">scotch_inventory.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">quantity, scotch</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Excuse me while I sip this <span class=\"subst\">$&#123;scotch&#125;</span>.`</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.keys() :: 返回一个 map 中的所有键</span></div><div class=\"line\"><span class=\"keyword\">const</span> scotch_names = scotch_inventory.keys();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`We've got <span class=\"subst\">$&#123;name&#125;</span> in the cellar.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.values() :: 返回 map 中的所有值</span></div><div class=\"line\"><span class=\"keyword\">const</span> quantities = scotch_inventory.values();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> quantity <span class=\"keyword\">of</span> quantities) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;quantity&#125;</span> of . . . Uh . . . I forget`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 </span></div><div class=\"line\"><span class=\"comment\">//   以后会经常看到 map 里的键值对和 \"entries\" 关联 </span></div><div class=\"line\"><span class=\"keyword\">const</span> entries = scotch_inventory.entries();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> entries) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I remember! I drank <span class=\"subst\">$&#123;entry[1]&#125;</span> bottle of <span class=\"subst\">$&#123;entry[0]&#125;</span>!`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是Object在保存键值对的时候仍然有用。 如果符合下面的全部条件，你可能还是想用Object:</p>\n<ol>\n<li>当你写代码的时候，你知道你的键值对。</li>\n<li>你知道你可能不会去增加或删除你的键值对。</li>\n<li>你使用的键全都是 string 或 symbol。</li>\n</ol>\n<p>另一方面，如果符合以下任意条件，你可能会想使用一个 map。</p>\n<ol>\n<li>你需要遍历整个map – 然而这对 object 来说是难以置信的.</li>\n<li>当你写代码的时候不需要知道键的名字或数量。</li>\n<li>你需要复杂的键，像 Object 或 别的 Map (!).</li>\n</ol>\n<p>像遍历一个map一样遍历一个object是可行的，但奇妙的是–还会有一些坑潜伏在暗处。 Map更容易使用，并且增加了一些可集成的优势。然而object是以随机顺序遍历的，map是以插入的顺序遍历的。</p>\n<p>添加随意动态键名的键值对给一个object是可行的。但奇妙的是: 比如说如果你曾经遍历过一个伪 map，你需要记住手动更新条目数。</p>\n<p>最后一条，如果你要设置的键名不是string或symbol，你除了选择Map别无选择。</p>\n<p>上面的这些只是一些指导性的意见，并不是最好的规则。</p>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>你可能听说过一个特别棒的特性垃圾回收器，它会定期地检查不再使用的对象并清除。</p>\n<p>To quote Dr Rauschmayer:</p>\n<blockquote>\n<p>WeakMap 不会阻止它的键值被垃圾回收。那意味着你可以把数据和对象关联起来不用担心内存泄漏。</p>\n</blockquote>\n<p>换句换说，就是你的程序丢掉了WeakMap键的所有外部引用，他能自动垃圾回收他们的值。</p>\n<p>尽管大大简化了用例，考虑到SPA(单页面应用) 就是用来展示用户希望展示的东西，像一些物品描述和一张图片，我们可以理解为API返回的JSON。</p>\n<p>理论上来说我们可以通过缓存响应结果来减少请求服务器的次数。我们可以这样用Map :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">put</span> (<span class=\"params\">element, result</span>) </span>&#123;</div><div class=\"line\">    cache.set(element, result);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retrieve</span> (<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> cache.get(element);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>… 这是行得通的，但是有内存泄漏的危险。</p>\n<p>因为这是一个SPA，用户或许想离开这个视图，这样的话我们的 “视图”object就会失效，会被垃圾回收。</p>\n<p>不幸的是，如果你使用的是正常的Map ,当这些object不使用时，你必须自行清除。</p>\n<p>使用WeakMap替代就可以解决上面的问题:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// 不会再有内存泄露了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 剩下的都一样</span></div></pre></td></tr></table></figure>\n<p>这样当应用失去不需要的元素的引用时，垃圾回收系统可以自动重用那些元素。</p>\n<p>WeakMap的API和Map相似，但有如下几点不同:</p>\n<ol>\n<li>在WeakMap里你可以使用object作为键。 这意味着不能以String和Symbol做键。</li>\n<li>WeakMap只有set，get，has，和delete方法 – 那意味着你不能遍历weak map.</li>\n<li>WeakMaps没有size属性。</li>\n</ol>\n<p>不能遍历或检查WeakMap的长度的原因是，在遍历过程中可能会遇到垃圾回收系统的运行: 这一瞬间是满的，下一秒就没了。</p>\n<p>这种不可预测的行为需要谨慎对待，TC39(ECMA第39届技术委员会)曾试图避免禁止WeakMap的遍历和长度检测。</p>\n<p>其他的案例，可以在这里找到Use Cases for WeakMap，来自Exploring ES6.</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set就是只包含一个值的集合。换句换说，每个set的元素只会出现一次。</p>\n<p>这是一个有用的数据类型，如果你要追踪唯一并且固定的object ,比如说聊天室的当前用户。</p>\n<p>Set和Map有完全相同的API。主要的不同是Set没有set方法，因为它不能存储键值对。剩下的几乎相同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造器</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_collection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 基本的 API 方法</span></div><div class=\"line\"><span class=\"comment\">// Set.prototype.add (O) :: 和 set 一样，添加一个对象</span></div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Lagavulin 18'</span>);</div><div class=\"line\">scotch_collection.add(<span class=\"string\">'The Dalmore'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 你也可以用数组构造一个 set</span></div><div class=\"line\">scotch_collection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'Lagavulin 18'</span>, <span class=\"string\">'The Dalmore'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 set 都有一个 length 属性。这个属性会告诉你 set 里有多少对象</span></div><div class=\"line\"><span class=\"comment\">//   用 set 或 map 的时候，一定记住用 size，不用 length</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.size); <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.has(O) :: 包含对象 O 返回 true 否则返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.has(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.has(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.delete(O) :: 删除 set 中的 O 对象，成功返回 true，不存在返回 false</span></div><div class=\"line\">scotch_collection.delete(<span class=\"string\">'The Dalmore'</span>); <span class=\"comment\">// true -- break my heart</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.clear() :: 删除 set 中的所有对象</span></div><div class=\"line\">scotch_collection.clear();</div><div class=\"line\"><span class=\"built_in\">console</span>.log( scotch_collection ); <span class=\"comment\">// Set &#123;&#125; -- long night.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 迭代方法</span></div><div class=\"line\"> * Set 提供了多种方法遍历</div><div class=\"line\"> *  重新设置值，继续探索 */</div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Lagavulin 18'</span>);</div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Glenfiddich 18'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Set.prototype.forEach(callback[, thisArg]) :: 执行一个函数，回调函数</span></div><div class=\"line\"> *  set 里在每个的键值对。 You can set the value of 'this' inside </div><div class=\"line\"> *  the callback by passing a thisArg, but that's optional and seldom necessary. */</div><div class=\"line\">scotch_collection.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scotch</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Excuse me while I sip this <span class=\"subst\">$&#123;scotch&#125;</span>.`</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.values() :: 返回 set 中的所有值</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_names = scotch_collection.values();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;name&#125;</span> . . . I think.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.keys() ::  对 set 来说，和 Set.prototype.values() 方法一致</span></div><div class=\"line\">scotch_names = scotch_collection.keys();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;name&#125;</span> . . . I think.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Set.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 </span></div><div class=\"line\"> *   这有点多余，但是这种方法可以保留 map API 的可操作性</div><div class=\"line\"> *    */</div><div class=\"line\"><span class=\"keyword\">const</span> entries = scotch_collection.entries();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> entries) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I got some <span class=\"subst\">$&#123;entry[0]&#125;</span> in my cup and more <span class=\"subst\">$&#123;entry[1]&#125;</span> in my flask!`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>WeakSet相对于Set就像WeakMap相对于 Map :</p>\n<ol>\n<li>在WeakSet里object的引用是弱类型的。</li>\n<li>WeakSet没有property属性。</li>\n<li>不能遍历WeakSet。</li>\n</ol>\n<p>Weak set的用例并不多，但是这儿有一些Domenic Denicola称呼它们为“perfect for branding” – 意思就是标记一个对象以满足其他需求。</p>\n<p>这儿是他给的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 下面这个例子来自 Weakset 使用案例的邮件讨论 </span></div><div class=\"line\">  *    邮件的内容和讨论的其余部分在这儿:</div><div class=\"line\">  *      https://mail.mozilla.org/pipermail/es-discuss/2015-June/043027.html</div><div class=\"line\">  */</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foos = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    foos.add(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  method() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!foos.has(<span class=\"keyword\">this</span>)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Foo.prototype.method called on an incompatible object!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是一个轻量科学的方法防止大家在一个没有被Foo构造出的object上使用method。</p>\n<p>使用的WeakSet的优势是允许foo里的object使用完后被垃圾回收。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章里，我们已经了解了ES2015带来的一些好处，从string的便捷方法和模板变量到适当的Map和Set实现。</p>\n<p>String方法和模板字符串易于上手。同时你很快也就不用到处用weak set了，我认为你很快就会喜欢上Set和Map。</p>\n<p>整理转载：<a href=\"https://github.com/xitu/gold-miner\" target=\"_blank\" rel=\"external\">https://github.com/xitu/gold-miner</a></p>\n","excerpt":"","more":"<h2 id=\"使用-ES6-写更好的-JavaScript-part-I：广受欢迎新特性\"><a href=\"#使用-ES6-写更好的-JavaScript-part-I：广受欢迎新特性\" class=\"headerlink\" title=\"使用 ES6 写更好的 JavaScript part I：广受欢迎新特性\"></a>使用 ES6 写更好的 JavaScript part I：广受欢迎新特性</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>在ES2015规范敲定并且Node.js增添了大量的函数式子集的背景下，我们终于可以拍着胸脯说：未来就在眼前。</p>\n<p>… 我早就想这样说了</p>\n<p>但这是真的。V8引擎将很快实现规范，而且Node已经添加了大量可用于生产环境的ES2015特性。下面要列出的是一些我认为很有必要的特性，而且这些特性是不使用需要像Babel或者Traceur这样的翻译器就可以直接使用的。</p>\n<p>这篇文章将会讲到三个相当流行的ES2015特性，并且已经在Node中支持了了：</p>\n<ul>\n<li>用let和const声明块级作用域；</li>\n<li>箭头函数；</li>\n<li>简写属性和方法。</li>\n</ul>\n<p>让我们马上开始。</p>\n<h3 id=\"let和const声明块级作用域\"><a href=\"#let和const声明块级作用域\" class=\"headerlink\" title=\"let和const声明块级作用域\"></a>let和const声明块级作用域</h3><p>作用域是你程序中变量可见的区域。换句话说就是一系列的规则，它们决定了你声明的变量在哪里是可以使用的。</p>\n<p>大家应该都听过 ，在JavaScript中只有在函数内部才会创造新的作用域。然而你创建的98%的作用域事实上都是函数作用域，其实在JavaScript中有三种创建新作用域的方法。你可以这样：</p>\n<ol>\n<li>创建一个函数。你应该已经知道这种方式。</li>\n<li>创建一个catch块。 我绝对没哟开玩笑.</li>\n<li>创建一个代码块。如果你用的是ES2015，在一段代码块中用let或者const声明的变量会限制它们只在这个块中可见。这叫做块级作用域。</li>\n</ol>\n<p>一个代码块就是你用花括号包起来的部分。 { 像这样 }。在if/else声明和try/catch/finally块中经常出现。如果你想利用块作用域的优势，你可以用花括号包裹任意的代码来创建一个代码块</p>\n<p>考虑下面的代码片段。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 Node 中你需要使用 strict 模式尝试这个</span></div><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"string\">\"foo\"</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (foo) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> bar = <span class=\"string\">\"bar\"</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> foobar = foo + bar;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// foo 和 bar 这里都可见 </span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This situation is \"</span> + foo + bar + <span class=\"string\">\". I'm going home.\"</span>);</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This log statement is \"</span> + foobar + <span class=\"string\">\"! It threw a ReferenceError at me!\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"You got a \"</span> + err + <span class=\"string\">\"; no dice.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Just to prove to you that \"</span> + err + <span class=\"string\">\" doesn't exit outside of the above `catch` block.\"</span>);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Told you so.\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">baz();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(invisible);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"invisible hasn't been declared, yet, so we get a \"</span> + err);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> invisible = <span class=\"string\">\"You can't see me, yet\"</span>; <span class=\"comment\">// let 声明的变量在声明前是不可访问的</span></div></pre></td></tr></table></figure>\n<p>还有些要强调的</p>\n<ul>\n<li>注意foobar在if块之外是不可见的，因为我们没有用let声明；</li>\n<li>我们可以在任何地方使用foo ，因为我们用var定义它为全局作用域可见；</li>\n<li>我们可以在baz内部任何地方使用bar， 因为var-声明的变量是在定义的整个作用域内都可见。</li>\n<li>用let or const声明的变量不能在定义前调用。换句话说，它不会像var变量一样被编译器提升到作用域的开始处。</li>\n</ul>\n<p>const 与 let 类似，但有两点不同。</p>\n<ol>\n<li>必须给声明为const的变量在声明时赋值。不可以先声明后赋值。</li>\n<li>不能改变const变量的值，只有在创建它时可以给它赋值。如果你试图改变它的值，会得到一个TyepError。</li>\n</ol>\n<h3 id=\"let-amp-const-Who-Cares\"><a href=\"#let-amp-const-Who-Cares\" class=\"headerlink\" title=\"let &amp; const: Who Cares?\"></a>let &amp; const: Who Cares?</h3><p>我们已经用var将就了二十多年了，你可能在想我们真的需要新的类型声明关键字吗？（这里作者应该是想表达这个意思）</p>\n<p>问的好，简单的回答就是–不， 并不真正需要。但在可以用let和const的地方使用它们很有好处的。</p>\n<ul>\n<li>let和const声明变量时都不会被提升到作用域开始的地方，这样可以使代码可读性更强，制造尽可能少的迷惑。</li>\n<li>它会尽可能的约束变量的作用域，有助于减少令人迷惑的命名冲突。</li>\n<li>这样可以让程序只有在必须重新分配变量的情况下重新分配变量。 const 可以加强常量的引用。</li>\n</ul>\n<p>另一个例子就是 let 在 for 循环中的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> languages = [<span class=\"string\">'Danish'</span>, <span class=\"string\">'Norwegian'</span>, <span class=\"string\">'Swedish'</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//会污染全局变量!</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &amp;lt; languages.length; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;languages[i]&#125;</span> is a Scandinavian language.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 4</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &amp;lt; languages.length; j += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;languages[j]&#125;</span> is a Scandinavian language.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(j); <span class=\"comment\">// Reference error</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`You got a <span class=\"subst\">$&#123;err&#125;</span>; no dice.`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在for循环中使用var声明的计数器并不会真正把计数器的值限制在本次循环中。 而let可以。</p>\n<p>let在每次迭代时重新绑定循环变量有很大的优势，这样每个循环中拷贝自身 , 而不是共享全局范围内的变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 简洁明了</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &amp;lt; <span class=\"number\">6</span>; i += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I've waited \"</span> + i + <span class=\"string\">\" seconds!\"</span>);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span> * i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 功能完全混乱</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &amp;lt; <span class=\"number\">6</span>; j += <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I've waited \"</span> + j + <span class=\"string\">\" seconds for this!\"</span>);</div><div class=\"line\">    &#125;, <span class=\"number\">1000</span> * j);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>第一层循环会和你想象的一样工作。而下面的会每秒输出 “I’ve waited 6 seconds!”。</p>\n<p>好吧，我选择狗带。</p>\n<h3 id=\"动态this关键字的怪异\"><a href=\"#动态this关键字的怪异\" class=\"headerlink\" title=\"动态this关键字的怪异\"></a>动态this关键字的怪异</h3><p>JavaScript的this关键字因为总是不按套路出牌而臭名昭著。</p>\n<p>事实上，它的规则相当简单。不管怎么说，this在有些情形下会导致奇怪的用法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> polyglot = &#123;</div><div class=\"line\">    name : <span class=\"string\">\"Michel Thomas\"</span>,</div><div class=\"line\">    languages : [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>],</div><div class=\"line\">    introduce : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// this.name is \"Michel Thomas\"</span></div><div class=\"line\">        <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">this</span>.languages.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">language</span>) </span>&#123;</div><div class=\"line\">            <span class=\"comment\">// this.name is undefined, so we have to use our saved \"self\" variable </span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"My name is \"</span> + self.name + <span class=\"string\">\", and I speak \"</span> + language + <span class=\"string\">\".\"</span>);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">polyglot.introduce();</div></pre></td></tr></table></figure>\n<p>在introduce里, this.name是undefined。在回调函数外面，也就是forEach中， 它指向了polyglot对象。在这种情形下我们总是希望在函数内部this和函数外部的this指向同一个对象。</p>\n<p>问题是在JavaScript中函数会根据确定性四原则在调用时定义自己的this变量。这就是著名的动态this 机制。</p>\n<p>这些规则中没有一个是关于查找this所描述的“附近作用域”的；也就是说并没有一个确切的方法可以让JavaScript引擎能够基于包裹作用域来定义this的含义。</p>\n<p>这就意味着当引擎查找this的值时，可以找到值，但却和回调函数之外的不是同一个值。有两种传统的方案可以解决这个问题。</p>\n<ul>\n<li>在函数外面把this保存到一个变量中，通常取名self，并在内部函数中使用；</li>\n<li>或者在内部函数中调用bind阻止对this的赋值。</li>\n</ul>\n<p>以上两种办法均可生效，但会产生副作用。</p>\n<p>另一方面，如果内部函数没有设置它自己的this值，JavaScript会像查找其它变量那样查找this的值：通过遍历父作用域直到找到同名的变量。这样会让我们使用附近作用域代码中的this值，这就是著名的词法this。</p>\n<p>如果有样的特性，我们的代码将会更加的清晰，不是吗?</p>\n<h3 id=\"箭头函数中的词法this\"><a href=\"#箭头函数中的词法this\" class=\"headerlink\" title=\"箭头函数中的词法this\"></a>箭头函数中的词法this</h3><p>在 ES2015 中，我们有了这一特性。箭头函数不会绑定this值，允许我们利用词法绑定this关键字。这样我们就可以像这样重构上面的代码了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> polyglot = &#123;</div><div class=\"line\">    name : <span class=\"string\">\"Michel Thomas\"</span>,</div><div class=\"line\">    languages : [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>],</div><div class=\"line\">    introduce : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.languages.forEach((language) =&amp;gt; &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"My name is \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\", and I speak \"</span> + language + <span class=\"string\">\".\"</span>);</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>… 这样就会按照我们想的那样工作了。</p>\n<p>箭头函数有一些新的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> languages = [<span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"French\"</span>, <span class=\"string\">\"Italian\"</span>, <span class=\"string\">\"German\"</span>, <span class=\"string\">\"Polish\"</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 多行箭头函数必须使用花括号， </span></div><div class=\"line\"><span class=\"comment\">// 必须明确包含返回值语句</span></div><div class=\"line\">    <span class=\"keyword\">let</span> languages_lower = languages.map((language) =&amp;gt; &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> language.toLowerCase()</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 单行箭头函数，花括号是可省的，</span></div><div class=\"line\"><span class=\"comment\">// 函数默认返回最后一个表达式的值</span></div><div class=\"line\"><span class=\"comment\">// 你可以指明返回语句，这是可选的。</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map((language) =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果你的箭头函数只有一个参数，可以省略括号</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map(language =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果箭头函数有多个参数，必须用圆括号包裹</span></div><div class=\"line\"><span class=\"keyword\">let</span> languages_lower = languages.map((language, unused_param) =&amp;gt; language.toLowerCase());</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(languages_lower); <span class=\"comment\">// [\"spanish\", \"french\", \"italian\", \"german\", \"polish\"]</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 最后，如果你的函数没有参数，你必须在箭头前加上空的括号。</span></div><div class=\"line\">(() =&amp;gt; alert(<span class=\"string\">\"Hello!\"</span>))();</div></pre></td></tr></table></figure>\n<p>MDN关于箭头函数的文档解释的很好。</p>\n<h3 id=\"简写属性和方法\"><a href=\"#简写属性和方法\" class=\"headerlink\" title=\"简写属性和方法\"></a>简写属性和方法</h3><p>ES2015提供了在对象上定义属性和方法的一些新方式。</p>\n<h3 id=\"简写方法\"><a href=\"#简写方法\" class=\"headerlink\" title=\"简写方法\"></a>简写方法</h3><p>在 JavaScript 中， method 是对象的一个有函数值的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在ES2015中，我们可以这样简写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    foo () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'bar'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    * range (<span class=\"keyword\">from</span>, to) &#123;</div><div class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">from</span> &amp;lt; to) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">from</span> === to)</div><div class=\"line\">                <span class=\"keyword\">return</span> ++<span class=\"keyword\">from</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">yield</span> <span class=\"keyword\">from</span> ++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意你也可以使用生成器去定义方法。只需要在函数名前面加一个星号(*)。</p>\n<p>这些叫做 方法定义 。和传统的函数作为属性很像，但有一些不同：</p>\n<ul>\n<li>只能在方法定义处调用super；</li>\n<li>不允许用new调用方法定义。</li>\n</ul>\n<p>我会在随后的几篇文章中讲到super关键字。如果你等不及了， Exploring ES6中有关于它的干货。</p>\n<h3 id=\"简写和推导属性\"><a href=\"#简写和推导属性\" class=\"headerlink\" title=\"简写和推导属性\"></a>简写和推导属性</h3><p>ES6还引入了简写和推导属性 。</p>\n<p>如果对象的键值和变量名是一致的，那么你可以仅用变量名来初始化你的对象，而不是定义冗余的键值对。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"string\">'foo'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"string\">'bar'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 旧语法</span></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123;</div><div class=\"line\">    foo : foo,</div><div class=\"line\">    bar : bar</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 新语法</span></div><div class=\"line\"><span class=\"keyword\">const</span> myObject = &#123; foo, bar &#125;</div></pre></td></tr></table></figure>\n<p>两中语法都以foo和bar键值指向foo and bar变量。后面的方式语义上更加一致；这只是个语法糖。</p>\n<p>当用揭示模块模式来定义一些简洁的公共 API 的定义，我常常利用简写属性的优势。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Module</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'bar'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 这样写:</span></div><div class=\"line\">    <span class=\"keyword\">const</span> publicAPI = &#123; foo, bar &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">/* 不要这样写:</div><div class=\"line\">    const publicAPI =  &#123;</div><div class=\"line\">       foo : foo,</div><div class=\"line\">       bar : bar</div><div class=\"line\">    &#125; */</span> </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> publicAPI;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这里我们创建并返回了一个publicAPI对象，键值foo指向foo方法，键值bar指向bar方法。</p>\n<h3 id=\"推导属性名\"><a href=\"#推导属性名\" class=\"headerlink\" title=\"推导属性名\"></a>推导属性名</h3><p>这是不常见的例子，但ES6允许你用表达式做属性名。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myObj = &#123;</div><div class=\"line\">  <span class=\"comment\">// 设置属性名为 foo 函数的返回值</span></div><div class=\"line\">    [foo ()] () &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'foo'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(myObj.foo() ); <span class=\"comment\">// 'foo'</span></div></pre></td></tr></table></figure>\n<p>根据Dr. Raushmayer在Exploring ES6中讲的，这种特性最主要的用途是设置属性名与Symbol值一样。</p>\n<h3 id=\"Getter-和-Setter-方法\"><a href=\"#Getter-和-Setter-方法\" class=\"headerlink\" title=\"Getter 和 Setter 方法\"></a>Getter 和 Setter 方法</h3><p>最后，我想提一下get和set方法，它们在ES5中就已经支持了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 例子采用的是 MDN's 上关于 getter 的内容</span></div><div class=\"line\"><span class=\"comment\">//   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get</span></div><div class=\"line\"><span class=\"keyword\">const</span> speakingObj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 记录 “speak” 方法调用过多少次</span></div><div class=\"line\">    words : [],</div><div class=\"line\">    </div><div class=\"line\">    speak (word) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.words.push(word);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakingObj says '</span> + word + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;,</div><div class=\"line\">    </div><div class=\"line\">    get called () &#123;</div><div class=\"line\">        <span class=\"comment\">// 返回最新的单词</span></div><div class=\"line\">        <span class=\"keyword\">const</span> words = <span class=\"keyword\">this</span>.words;</div><div class=\"line\">        <span class=\"keyword\">if</span> (!words.length)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">'speakingObj hasn\\'t spoken, yet.'</span>;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">            <span class=\"keyword\">return</span> words[words.length - <span class=\"number\">1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(speakingObj.called); <span class=\"comment\">// 'speakingObj hasn't spoken, yet.'</span></div><div class=\"line\"></div><div class=\"line\">speakingObj.speak(<span class=\"string\">'blargh'</span>); <span class=\"comment\">// 'speakingObj says blargh!'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(speakingObj.called); <span class=\"comment\">// 'blargh'</span></div></pre></td></tr></table></figure>\n<p>使用getters时要记得下面这些:</p>\n<ul>\n<li>Getters不接受参数；</li>\n<li>属性名不可以和getter函数重名；</li>\n<li>可以用Object.defineProperty(OBJECT, “property name”, { get : function () { . . . } }) 动态创建 getter</li>\n</ul>\n<p>作为最后这点的例子，我们可以这样定义上面的 getter 方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> speakingObj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 记录 “speak” 方法调用过多少次</span></div><div class=\"line\">    words : [],</div><div class=\"line\">    </div><div class=\"line\">    speak (word) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.words.push(word);</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'speakingObj says '</span> + word + <span class=\"string\">'!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这只是为了证明观点。我是绝对不会这样写的</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">called</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 返回新的单词</span></div><div class=\"line\">    <span class=\"keyword\">const</span> words = <span class=\"keyword\">this</span>.words;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!words.length)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'speakingObj hasn\\'t spoken, yet.'</span>;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> words[words.length - <span class=\"number\">1</span>];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(speakingObj, <span class=\"string\">\"called\"</span>, get : getCalled ) </div><div class=\"line\">除了 getters，还有 setters。像平常一样，它们通过自定义的逻辑给对象设置属性。</div><div class=\"line\"><span class=\"meta\"></div><div class=\"line\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 创建一个新的 globetrotter（环球者）！</span></div><div class=\"line\"><span class=\"keyword\">const</span> globetrotter = &#123;</div><div class=\"line\">    <span class=\"comment\">// globetrotter 现在所处国家所说的语言 </span></div><div class=\"line\">    <span class=\"keyword\">const</span> current_lang = <span class=\"literal\">undefined</span>,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// globetrotter 已近环游过的国家</span></div><div class=\"line\">    <span class=\"keyword\">let</span> countries = <span class=\"number\">0</span>,</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 查看环游过哪些国家了</span></div><div class=\"line\">    get countryCount () &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.countries;</div><div class=\"line\">    &#125;, </div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// 不论 globe trotter 飞到哪里，都重新设置他的语言</span></div><div class=\"line\">    set languages (language) &#123;</div><div class=\"line\">        <span class=\"comment\">// 增加环游过的城市数</span></div><div class=\"line\">        countries += <span class=\"number\">1</span>;</div><div class=\"line\">    </div><div class=\"line\">        <span class=\"comment\">// 重置当前语言</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.current_lang = language; </div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">globetrotter.language = <span class=\"string\">'Japanese'</span>;</div><div class=\"line\">globetrotter.countryCount(); <span class=\"comment\">// 1</span></div><div class=\"line\"></div><div class=\"line\">globetrotter.language = <span class=\"string\">'Spanish'</span>;</div><div class=\"line\">globetrotter.countryCount(); <span class=\"comment\">// 2</span></div></pre></td></tr></table></figure>\n<p>上面讲的关于getters的也同样适用于setters，但有一点不同：</p>\n<ul>\n<li>getter不接受参数，setters必须接受正好一个参数。</li>\n</ul>\n<p>破坏这些规则中的任意一个都会抛出一个错误。</p>\n<p>既然 Angular 2 正在引入TypeCript并且把class带到了台前，我希望get and set能够流行起来… 但还有点希望它们不要流行起来。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>未来的JavaScript正在变成现实，是时候把它提供的东西都用起来了。这篇文章里，我们浏览了 ES2015的三个很流行的特性：</p>\n<ul>\n<li>let和const带来的块级作用域；</li>\n<li>箭头函数带来的this的词法作用域；</li>\n<li>简写属性和方法，以及getter和setter函数的回顾。</li>\n</ul>\n<h2 id=\"使用-ES6-编写更好的-JavaScript-Part-II：深入探究-类\"><a href=\"#使用-ES6-编写更好的-JavaScript-Part-II：深入探究-类\" class=\"headerlink\" title=\"使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]\"></a>使用 ES6 编写更好的 JavaScript Part II：深入探究 [类]</h2><h3 id=\"辞旧迎新\"><a href=\"#辞旧迎新\" class=\"headerlink\" title=\"辞旧迎新\"></a>辞旧迎新</h3><p>在本文的开始，我们要说明一件事：</p>\n<p>从本质上说，ES6的classes主要是给创建老式构造函数提供了一种更加方便的语法，并不是什么新魔法 —— Axel Rauschmayer，Exploring ES6作者</p>\n<p>从功能上来讲，class声明就是一个语法糖，它只是比我们之前一直使用的基于原型的行为委托功能更强大一点。本文将从新语法与原型的关系入手，仔细研究ES2015的class关键字。文中将提及以下内容：</p>\n<ul>\n<li>定义与实例化类；</li>\n<li>使用extends创建子类；</li>\n<li>子类中super语句的调用；</li>\n<li>以及重要的标记方法（symbol method）的例子。</li>\n</ul>\n<p>在此过程中，我们将特别注意 class 声明语法从本质上是如何映射到基于原型代码的。</p>\n<p>让我们从头开始说起。</p>\n<h3 id=\"退一步说：Classes不是什么\"><a href=\"#退一步说：Classes不是什么\" class=\"headerlink\" title=\"退一步说：Classes不是什么\"></a>退一步说：Classes不是什么</h3><p>JavaScript的『类』与Java、Python或者其他你可能用过的面向对象语言中的类不同。其实后者可能称作面向『类』的语言更为准确一些。</p>\n<p>在传统的面向类的语言中，我们创建的类是对象的模板。需要一个新对象时，我们实例化这个类，这一步操作告诉语言引擎将这个类的方法和属性复制到一个新实体上，这个实体称作实例。实例是我们自己的对象，且在实例化之后与父类毫无内在联系。</p>\n<p>而JavaScript没有这样的复制机制。在JavaScript中『实例化』一个类创建了一个新对象，但这个新对象却不独立于它的父类。</p>\n<p>正相反，它创建了一个与原型相连接的对象。即使是在实例化之后，对于原型的修改也会传递到实例化的新对象去。</p>\n<p>原型本身就是一个无比强大的设计模式。有许多使用了原型的技术模仿了传统类的机制，class便为这些技术提供了简洁的语法。</p>\n<p>总而言之：</p>\n<ul>\n<li>JavaScript不存在Java和其他面向对象语言中的类概念；</li>\n<li>JavaScript 的class很大程度上只是原型继承的语法糖，与传统的类继承有很大的不同。</li>\n</ul>\n<p>搞清楚这些之后，让我们先看一下class。</p>\n<h3 id=\"类基础：声明与表达式\"><a href=\"#类基础：声明与表达式\" class=\"headerlink\" title=\"类基础：声明与表达式\"></a>类基础：声明与表达式</h3><p>我们使用class 关键字创建类，关键字之后是变量标识符，最后是一个称作类主体的代码块。这种写法称作类的声明。没有使用extends关键字的类声明被称作基类：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Food 是一个基类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs, fat) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    toString () &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\"></div><div class=\"line\">chicken_breast.print(); <span class=\"comment\">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(chicken_breast.protein); <span class=\"comment\">// 26 (LINE A)</span></div></pre></td></tr></table></figure>\n<p>需要注意到以下事情：</p>\n<ul>\n<li>类只能包含方法定义，不能有数据属性；</li>\n<li>定义方法时，可以使用简写方法定义；</li>\n<li>与创建对象不同，我们不能在类主体中使用逗号分隔方法定义；</li>\n<li>我们可以在实例化对象上直接引用类的属性（如 LINE A）。</li>\n</ul>\n<p>类有一个独有的特性，就是 contructor 构造方法。在构造方法中我们可以初始化对象的属性。</p>\n<p>构造方法的定义并不是必须的。如果不写构造方法，引擎会为我们插入一个空的构造方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoConstructor</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/* JavaScript 会插入这样的代码：</div><div class=\"line\">     constructor () &#123; &#125;</div><div class=\"line\">    */</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> nemo = <span class=\"keyword\">new</span> NoConstructor(); <span class=\"comment\">// 能工作，但没啥意思</span></div></pre></td></tr></table></figure>\n<p>将一个类赋值给一个变量的形式叫类表达式，这种写法可以替代上面的语法形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这是一个匿名类表达式，在类主体中我们不能通过名称引用它</span></div><div class=\"line\"><span class=\"keyword\">const</span> Food = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和上面一样的类定义……</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这是一个命名类表达式，在类主体中我们可以通过名称引用它</span></div><div class=\"line\"><span class=\"keyword\">const</span> Food = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FoodClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和上面一样的类定义……</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//  添加一个新方法，证明我们可以通过内部名称引用 FoodClass……        </span></div><div class=\"line\">    printMacronutrients () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;FoodClass.name&#125;</span> | <span class=\"subst\">$&#123;FoodClass.protein&#125;</span> g P :: <span class=\"subst\">$&#123;FoodClass.carbs&#125;</span> g C :: <span class=\"subst\">$&#123;FoodClass.fat&#125;</span> g F`</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\">chicken_breast.printMacronutrients(); <span class=\"comment\">// 'Chicken Breast | 26g P :: 0g C :: 3.5g F'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 但是不能在外部引用</span></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(FoodClass.protein); <span class=\"comment\">// 引用错误</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (err) &#123;</div><div class=\"line\">    <span class=\"comment\">// pass</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一行为与匿名函数与命名函数表达式很类似。</p>\n<h3 id=\"使用extends创建子类以及使用super调用\"><a href=\"#使用extends创建子类以及使用super调用\" class=\"headerlink\" title=\"使用extends创建子类以及使用super调用\"></a>使用extends创建子类以及使用super调用</h3><p>使用extends创建的类被称作子类，或派生类。这一用法简单明了，我们直接在上面的例子中构建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// FatFreeFood 是一个派生类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FatFreeFood</span> <span class=\"keyword\">extends</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(name, protein, carbs, <span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.print();</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`Would you look at that -- <span class=\"subst\">$&#123;this.name&#125;</span> has no fat!`</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fat_free_yogurt = <span class=\"keyword\">new</span> FatFreeFood(<span class=\"string\">'Greek Yogurt'</span>, <span class=\"number\">16</span>, <span class=\"number\">12</span>);</div><div class=\"line\">fat_free_yogurt.print(); <span class=\"comment\">// 'Greek Yogurt | 26g P :: 16g C :: 0g F  /  Would you look at that -- Greek Yogurt has no fat!'</span></div></pre></td></tr></table></figure>\n<p>派生类拥有我们上文讨论的一切有关基类的特性，另外还有如下几点新特点：</p>\n<ul>\n<li>子类使用class关键字声明，之后紧跟一个标识符，然后使用extend关键字，最后写一个任意表达式。这个表达式通常来讲就是个标识符，但理论上也可以是函数。</li>\n<li>如果你的派生类需要引用它的父类，可以使用super关键字。</li>\n<li>一个派生类不能有一个空的构造函数。即使这个构造函数就是调用了一下super()，你也得把它显式的写出来。但派生类却可以没有构造函数。</li>\n<li>在派生类的构造函数中，必须先调用super，才能使用this关键字（译者注：仅在构造函数中是这样，在其他方法中可以直接使用this）。</li>\n</ul>\n<p>在JavaScript中仅有两个super关键字的使用场景：</p>\n<ol>\n<li>在子类构造函数中调用。如果初始化派生类是需要使用父类的构造函数，我们可以在子类的构造函数中调用super(parentConstructorParams)，传递任意需要的参数。</li>\n<li>引用父类的方法。在常规方法定义中，派生类可以使用点运算符来引用父类的方法：super.methodName。</li>\n</ol>\n<p>我们的 FatFreeFood 演示了这两种情况：</p>\n<ol>\n<li>在构造函数中，我们简单的调用了super，并将脂肪的量传入为0。</li>\n<li>在我们的print方法中，我们先调用了super.print，之后才添加了其他的逻辑。</li>\n</ol>\n<p>不管你信不信，我反正是信了以上说的已涵盖了有关class的基础语法，这就是你开始实验需要掌握的全部内容。</p>\n<h3 id=\"深入学习原型\"><a href=\"#深入学习原型\" class=\"headerlink\" title=\"深入学习原型\"></a>深入学习原型</h3><p>现在我们开始关注class是怎么映射到JavaScript内部的原型机制的。我们会关注以下几点：</p>\n<ul>\n<li>使用构造调用创建对象；</li>\n<li>原型连接的本质；</li>\n<li>属性和方法委托；</li>\n<li>使用原型模拟类。</li>\n<li>使用构造调用创建对象</li>\n</ul>\n<p>构造函数不是什么新鲜玩意儿。使用new关键字调用任意函数会使其返回一个对象 —— 这一步称作创建了一个构造调用，这种函数通常被称作构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 'new' 关键字调用 Food 方法，就是构造调用，该操作会返回一个对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> chicken_breast = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Chicken Breast'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">3.5</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(chicken_breast.protein) <span class=\"comment\">// 26</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不用 'new' 调用 Food 方法，会返回 'undefined'</span></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish); <span class=\"comment\">// 'undefined'</span></div></pre></td></tr></table></figure>\n<p>当我们使用new关键字调用函数时，JS内部执行了下面四个步骤：</p>\n<ol>\n<li>创建一个新对象（这里称它为O）；</li>\n<li>给O赋予一个连接到其他对象的链接，称为原型；</li>\n<li>将函数的this引用指向O；</li>\n<li>函数隐式返回O。</li>\n</ol>\n<p>在第三步和第四步之间，引擎会执行你函数中的具体逻辑。</p>\n<p>知道了这一点，我们就可以重写Food方法，使之不用new关键字也能工作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 演示示例：消除对 'new' 关键字的依赖</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 第一步：创建新对象</span></div><div class=\"line\">    <span class=\"keyword\">const</span> obj = &#123; &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第二步：链接原型——我们在下文会更加具体地探究原型的概念</span></div><div class=\"line\">    <span class=\"built_in\">Object</span>.setPrototypeOf(obj, Food.prototype);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第三步：设置 'this' 指向我们的新对象</span></div><div class=\"line\">    <span class=\"comment\">// 尽然我们不能再运行的执行上下文中重置 `this`</span></div><div class=\"line\">    <span class=\"comment\">// 我们在使用 'obj' 取代 'this' 来模拟第三步</span></div><div class=\"line\">    obj.name    = name;</div><div class=\"line\">    obj.protein = protein;</div><div class=\"line\">    obj.carbs   = carbs;</div><div class=\"line\">    obj.fat     = fat;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第四步：返回新创建的对象</span></div><div class=\"line\">    <span class=\"keyword\">return</span> obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish.protein); <span class=\"comment\">// 26</span></div></pre></td></tr></table></figure>\n<p>四步中的三步都是简单明了的。创建一个对象、赋值属性、然后写一个return声明，这些操作对大多数开发者来说没有理解上的问题——然而这就是难倒众人的黑魔法原型。</p>\n<h3 id=\"直观理解原型链\"><a href=\"#直观理解原型链\" class=\"headerlink\" title=\"直观理解原型链\"></a>直观理解原型链</h3><p>在通常情况下，JavaScript中的包括函数在内的所有对象都会链接到另一个对象上，这就是原型。</p>\n<p>如果我们访问一个对象本身没有的属性，JavaScript就会在对象的原型上检查该属性。换句话说，如果你对一个对象请求它没有的属性，它会对你说：『这个我不知道，问我的原型吧』。</p>\n<p>在另一个对象上查找不存在属性的过程称作委托。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// joe 没有 toString 方法……</span></div><div class=\"line\"><span class=\"keyword\">const</span> joe    = &#123; name : <span class=\"string\">'Joe'</span> &#125;,</div><div class=\"line\">    sara   = &#123; name : <span class=\"string\">'Sara'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.hasOwnProperty(joe, toString); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.hasOwnProperty(sara, toString); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ……但我们还是可以调用它！</span></div><div class=\"line\">joe.toString(); <span class=\"comment\">// '[object Object]'，而不是引用错误！</span></div><div class=\"line\">sara.toString(); <span class=\"comment\">// '[object Object]'，而不是引用错误！</span></div></pre></td></tr></table></figure>\n<p>尽管我们的 toString 的输出完全没啥用，但请注意：这段代码没有引起任何的ReferenceError！这是因为尽管joe和sara没有toString的属性，但他们的原型有啊。</p>\n<p>当我们寻找sara.toString()方法时，sara说：『我没有toString属性，找我的原型吧』。正如上文所说，JavaScript会亲切的询问Object.prototype 是否含有toString属性。由于原型上有这一属性，JS 就会把Object.prototype上的toString返回给我们程序并执行。</p>\n<p>sara本身没有属性没关系——我们会把查找操作委托到原型上。</p>\n<p>换言之，我们就可以访问到对象上并不存在的属性，只要其的原型上有这些属性。我们可以利用这一点将属性和方法赋值到对象的原型上，然后我们就可以调用这些属性，好像它们真的存在在那个对象上一样。</p>\n<p>更给力的是，如果几个对象共享相同的原型——正如上面的joe和sara的例子一样——当我们给原型赋值属性之后，它们就都可以访问了，无需将这些属性单独拷贝到每一个对象上。</p>\n<p>这就是为何大家把它称作原型继承——如果我的对象没有，但对象的原型有，那我的对象也能继承这个属性。</p>\n<p>事实上，这里并没有发生什么『继承』。在面向类的语言里，继承指从父类复制属性到子类的行为。在JavaScript里，没发生这种复制的操作，事实上这就是原型继承与类继承相比的一个主要优势。</p>\n<p>在我们探究原型究竟是怎么来的之前，我们先做一个简要回顾：</p>\n<ul>\n<li>joe和sara没有『继承』一个toString的属性；</li>\n<li>joe和sara实际上根本没有从Object.prototype上『继承』；</li>\n<li>joe和sara是链接到了Object.prototype上；</li>\n<li>joe和sara链接到了同一个Object.prototype上。</li>\n<li>如果想找到一个对象的（我们称它作O）原型，我们可以使用 Object.getPrototypeof(O)。</li>\n</ul>\n<p>然后我们再强调一遍：对象没有『继承自』他们的原型。他们只是委托到原型上。</p>\n<p>以上。</p>\n<p>接下来让我们深入一下。</p>\n<h3 id=\"设置对象的原型\"><a href=\"#设置对象的原型\" class=\"headerlink\" title=\"设置对象的原型\"></a>设置对象的原型</h3><p>我们已了解到基本上每个对象（下文以O指代）都有原型（下文以P指代），然后当我们查找O上没有的属性，JavaScript引擎就会在P上寻找这个属性。</p>\n<p>至此我们有两个问题：</p>\n<ul>\n<li>以上情况函数怎么玩？</li>\n<li>这些原型是从哪里来的？</li>\n</ul>\n<p>名为Object的函数</p>\n<p>在JavaScript引擎执行程序之前，它会创建一个环境让程序在内部执行，在执行环境中会创建一个函数，叫做Object, 以及一个关联对象，叫做Object.prototype。</p>\n<p>换句话说，Object和Object.prototype在任意执行中的JavaScript程序中永远存在。</p>\n<p>这个Object乍一看好像和其他函数没什么区别，但特别之处在于它是一个构造器——在调用它时返回一个新对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// \"object\"</span></div><div class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Object</span>();     <span class=\"comment\">// 这个 Object 函数的特点是不需要使用 new 关键字调用</span></div></pre></td></tr></table></figure>\n<p>这个Object.prototype对象是个……对象。正如其他对象一样，它有属性。</p>\n<p><img src=\"https://i.imgsafe.org/ebbd5e3.png\" alt=\"https://i.imgsafe.org/ebbd5e3.png\"></p>\n<p>关于Object和Object.prototype你需要知道以下几点：</p>\n<ol>\n<li>Object函数有一个叫做.prototype的属性，指向一个对象（Object.prototype）；</li>\n<li>Object.prototype对象有一个叫做.constructor的属性，指向一个函数（Object）。</li>\n</ol>\n<p>实际上，这个总体方案对于JavaScript中的所有函数都是适用的。当我们创建一个函数——下文称作 someFunction——这个函数就会有一个属性.prototype，指向一个叫做someFunction.prototype 的对象。</p>\n<p>与之相反，someFunction.prototype对象会有一个叫做.contructor的属性，它的引用指回函数someFunction。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span> (<span class=\"params\"></span>) </span>&#123;  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Foo!'</span>);  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype); <span class=\"comment\">// 指向一个叫 'foo' 的对象</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.prototype.constructor); <span class=\"comment\">// 指向 'foo' 函数</span></div><div class=\"line\"></div><div class=\"line\">foo.prototype.constructor(); <span class=\"comment\">// 输出 'Foo!' —— 仅为证明确实有 'foo.prototype.constructor' 这么个方法且指向原函数</span></div></pre></td></tr></table></figure>\n<p>需要记住以下几个要点：</p>\n<ol>\n<li>所有的函数都有一个属性，叫做 .prototype，它指向这个函数的关联对象。</li>\n<li>所有函数的原型都有一个属性，叫做 .constructor，它指向这个函数本身。</li>\n<li>一个函数原型的 .constructor 并非必须指向创建这个函数原型的函数……有点绕，我们等下会深入探讨一下。</li>\n</ol>\n<p>设置函数的原型有一些规则，在开始之前，我们先概括设置对象原型的三个规则：</p>\n<ol>\n<li>『默认』规则；</li>\n<li>使用new隐式设置原型；</li>\n<li>使用Object.create显式设置原型。</li>\n</ol>\n<h3 id=\"默认规则\"><a href=\"#默认规则\" class=\"headerlink\" title=\"默认规则\"></a>默认规则</h3><p>考虑下这段代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123; status : <span class=\"string\">'foobar'</span> &#125;;</div></pre></td></tr></table></figure>\n<p>十分简单，我们做的事儿就是创建一个叫foo的对象，然后给他一个叫status的属性。</p>\n<p>然后JavaScript在幕后多做了点工作。当我们在字面上创建一个对象时，JavaScript将对象的原型指向Object.prototype并设置其原型的.constructor指向Object：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123; status : <span class=\"string\">'foobar'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(foo) === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">// true</span></div><div class=\"line\">foo.constructor === <span class=\"built_in\">Object</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用new隐式设置原型\"><a href=\"#使用new隐式设置原型\" class=\"headerlink\" title=\"使用new隐式设置原型\"></a>使用new隐式设置原型</h3><p>让我们再看下之前调整过的 Food 例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在我们知道函数Food将会与一个叫做Food.prototype的对象关联。</p>\n<p>当我们使用new关键字创建一个对象，JavaScript将会：</p>\n<ol>\n<li>设置这个对象的原型指向我们使用new调用的函数的.prototype属性；</li>\n<li>设置这个对象的.constructor指向我们使用new调用到的构造函数。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> tootsie_roll = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Tootsie Roll'</span>, <span class=\"number\">0</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(tootsie_roll) === Food.prototype; <span class=\"comment\">// true</span></div><div class=\"line\">tootsie_roll.constructor === Food; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>这就可以让我们搞出下面这样的黑魔法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.cook = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cook</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> is cooking!`</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> dinner = <span class=\"keyword\">new</span> Food(<span class=\"string\">'Lamb Chops'</span>, <span class=\"number\">52</span>, <span class=\"number\">8</span>, <span class=\"number\">32</span>);</div><div class=\"line\">dinner.cook(); <span class=\"comment\">// 'Lamb Chops are cooking!'</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用Object-create显式设置原型\"><a href=\"#使用Object-create显式设置原型\" class=\"headerlink\" title=\"使用Object.create显式设置原型\"></a>使用Object.create显式设置原型</h3><p>最后我们可以使用Object.create方法手工设置对象的原型引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foo = &#123;</div><div class=\"line\">    speak () &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Foo!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> bar = <span class=\"built_in\">Object</span>.create(foo);</div><div class=\"line\"></div><div class=\"line\">bar.speak(); <span class=\"comment\">// 'Foo!'</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(bar) === foo; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>还记得使用new调用函数的时候，JavaScript在幕后干了哪四件事儿吗？Object.create就干了这三件事儿：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>设置它的原型引用；</li>\n<li>返回这个新对象。</li>\n</ol>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">你可以自己去看下MDN上写的那个polyfill。</a><br>（译者注：polyfill就是给老代码实现现有新功能的补丁代码，这里就是指老版本JS没有Object.create函数，MDN上有手工撸的一个替代方案）</p>\n<h3 id=\"模拟-class-行为\"><a href=\"#模拟-class-行为\" class=\"headerlink\" title=\"模拟 class 行为\"></a>模拟 class 行为</h3><p>直接使用原型来模拟面向类的行为需要一些技巧。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FatFreeFood</span> (<span class=\"params\">name, protein, carbs</span>) </span>&#123;</div><div class=\"line\">    Food.call(<span class=\"keyword\">this</span>, name, protein, carbs, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 设置 \"subclass\" 关系</span></div><div class=\"line\"><span class=\"comment\">// =====================</span></div><div class=\"line\"><span class=\"comment\">// LINE A :: 使用 Object.create 手动设置 FatFreeFood's 『父类』.</span></div><div class=\"line\">FatFreeFood.prototype = <span class=\"built_in\">Object</span>.create(Food.prototype);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// LINE B :: 手工重置 constructor 的引用</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(FatFreeFood.constructor, <span class=\"string\">\"constructor\"</span>, &#123;</div><div class=\"line\">    enumerable : <span class=\"literal\">false</span>,</div><div class=\"line\">    writeable  : <span class=\"literal\">true</span>,</div><div class=\"line\">    value      : FatFreeFood</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>在Line A，我们需要设置FatFreeFood.prototype使之等于一个新对象，这个新对象的原型引用是Food.prototype。如果没这么搞，我们的子类就不能访问『超类』的方法。</p>\n<p>不幸的是，这个导致了相当诡异的结果：FatFreeFood.constructor是Function，而不是FatFreeFood。为了保证一切正常，我们需要在Line B手工设置FatFreeFood.constructor。</p>\n<p>让开发者从使用原型对类行为笨拙的模仿中脱离苦海是class关键字的产生动机之一。它确实也提供了避免原型语法常见陷阱的解决方案。</p>\n<p>现在我们已经探究了太多关于JavaScript的原型机制，你应该更容易理解class关键字让一切变得多么简单了吧！</p>\n<h3 id=\"深入探究下方法\"><a href=\"#深入探究下方法\" class=\"headerlink\" title=\"深入探究下方法\"></a>深入探究下方法</h3><p>现在我们已了解到JavaScript原型系统的必要性，我们将深入探究一下类支持的三种方法，以及一种特殊情况，以结束本文的讨论。</p>\n<ul>\n<li>构造器；</li>\n<li>静态方法；</li>\n<li>原型方法；</li>\n<li>一种原型方法的特殊情况：『标记方法』。</li>\n</ul>\n<p>并非我提出的这三组方法，这要归功于Rauschmayer博士在探索ES6一书中的定义。</p>\n<h3 id=\"类构造器\"><a href=\"#类构造器\" class=\"headerlink\" title=\"类构造器\"></a>类构造器</h3><p>一个类的constructor方法用于关注我们的初始化逻辑，constructor方法有以下几个特殊点：</p>\n<ol>\n<li>只有在构造方法里，我们才可以调用父类的构造器；</li>\n<li>它在背后处理了所有设置原型链的工作；</li>\n<li>它被用作类的定义。</li>\n</ol>\n<p>第二点就是在JavaScript中使用class的一个主要好处，我们来引用一下《探索 ES6》书里的15.2.3.1 的标题：</p>\n<blockquote>\n<p>子类的原型就是超类</p>\n</blockquote>\n<p>正如我们所见，手工设置非常繁琐且容易出错。如果我们使用class关键字，JavaScript在内部会负责搞定这些设置，这一点也是使用class的优势。</p>\n<p>第三点有点意思。在JavaScript中类仅仅是个函数——它等同于与类中的constructor方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 和之前一样的类定义……</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typeof</span> Food; <span class=\"comment\">// 'function'</span></div></pre></td></tr></table></figure>\n<p>与一般把函数作为构造器的方式不同，我们不能不用new关键字而直接调用类构造器：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> burrito = Food(<span class=\"string\">'Heaven'</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">25</span>); <span class=\"comment\">// 类型错误</span></div></pre></td></tr></table></figure>\n<p>这就引发了另一个问题：当我们不用new调用函数构造器的时候发生了什么？</p>\n<p>简短的回答是：对于任何没有显式返回的函数来说都是返回undefined。我们只需要相信用我们构造函数的用户都会使用构造调用。这就是社区为何约定构造方法的首字母大写：提醒使用者要用new来调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// D'oh . . .</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(fish); <span class=\"comment\">// 'undefined'</span></div></pre></td></tr></table></figure>\n<p>长一点的回答是：返回undefined，除非你手工检测是否使用被new调用，然后进行自己的处理。</p>\n<p>ES2015引入了一个属性使得这种检测变得简单: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\">new.target</a>.</p>\n<p>new.target是一个定义在所有使用new调用的函数上的属性，包括类构造器。 当我们使用new关键字调用函数时，函数体内的new.target的值就是这个函数本身。如果函数没有被new调用，这个值就是undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 强行构造调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// 如果用户忘了手工调用一下</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">new</span>.target)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Food(name, protein, carbs, fat);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> fish = Food(<span class=\"string\">'Halibut'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 糟了，不过没关系！</span></div><div class=\"line\">fish; <span class=\"comment\">// 'Food &#123;name: \"Halibut\", protein: 20, carbs: 5, fat: 0&#125;'</span></div></pre></td></tr></table></figure>\n<p>在ES5里用起来也还行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Food))</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Food(name, protein, carbs, fat);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>MDN文档讲述了new.target的更多细节，而且给有兴趣者配上了ES2015规范作为参考。规范里有关 [[Construct]] 的描述很有启发性。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>静态方法是构造方法自己的方法，不能被类的实例化对象调用。我们使用static关键字定义静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">     <span class=\"comment\">// 和之前一样……</span></div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 添加静态方法</span></div><div class=\"line\">     <span class=\"keyword\">static</span> describe () &#123;</div><div class=\"line\">         <span class=\"built_in\">console</span>.log(<span class=\"string\">'\"Food\" 是一种存储了营养信息的数据类型'</span>);</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.describe(); <span class=\"comment\">// '\"Food\" 是一种存储了营养信息的数据类型'</span></div></pre></td></tr></table></figure>\n<p>静态方法与老式构造函数中直接属性赋值相似：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span> (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    Food.count += <span class=\"number\">1</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.name    = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs   = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat     = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Food.count = <span class=\"number\">0</span>;</div><div class=\"line\">Food.describe = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`你创建了 <span class=\"subst\">$&#123;Food.count&#125;</span> 个 food`</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> dummy = <span class=\"keyword\">new</span> Food();</div><div class=\"line\">Food.describe(); <span class=\"comment\">// \"你创建了 1 个 food\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"原型方法\"><a href=\"#原型方法\" class=\"headerlink\" title=\"原型方法\"></a>原型方法</h3><p>任何不是构造方法和静态方法的方法都是原型方法。之所以叫原型方法，是因为我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 ES6：</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span> (name, protein, carbs, fat) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">        <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">        <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    toString () &#123;  </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    print () &#123;  </div><div class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 在 ES5 里：</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Food</span>  (<span class=\"params\">name, protein, carbs, fat</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.protein = protein;</div><div class=\"line\">    <span class=\"keyword\">this</span>.carbs = carbs;</div><div class=\"line\">    <span class=\"keyword\">this</span>.fat = fat;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 『原型方法』的命名大概来自我们之前通过给构造函数的原型上附加方法的方式来实现这一功能。</span></div><div class=\"line\">Food.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toString</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.name&#125;</span> | <span class=\"subst\">$&#123;this.protein&#125;</span>g P :: <span class=\"subst\">$&#123;this.carbs&#125;</span>g C :: <span class=\"subst\">$&#123;this.fat&#125;</span>g F`</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Food.prototype.print = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">print</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.toString() );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>应该说明，在方法定义时完全可以使用生成器。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Range</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(from, to) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.from = <span class=\"keyword\">from</span>;</div><div class=\"line\">        <span class=\"keyword\">this</span>.to   = to;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    * generate () &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> counter = <span class=\"keyword\">this</span>.from,</div><div class=\"line\">            to      = <span class=\"keyword\">this</span>.to;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">while</span> (counter &amp;lt; to) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (counter == to)</div><div class=\"line\">                <span class=\"keyword\">return</span> counter++;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">yield</span> counter++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> range = <span class=\"keyword\">new</span> Range(<span class=\"number\">0</span>, <span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"keyword\">const</span> gen = range.generate();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> val <span class=\"keyword\">of</span> range.generate()) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Generator 的值是 <span class=\"subst\">$&#123; val &#125;</span>. `</span>);</div><div class=\"line\">    <span class=\"comment\">//  Prints:</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 0.</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 1.</span></div><div class=\"line\">    <span class=\"comment\">//    Generator 的值是 2.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"标志方法\"><a href=\"#标志方法\" class=\"headerlink\" title=\"标志方法\"></a>标志方法</h3><p>最后我们说说标志方法。这是一些名为Symbol值的方法，当我们在自定义对象中使用内置构造器时，JavaScript引擎可以识别并使用这些方法。</p>\n<p>MDN文档提供了一个Symbol是什么的简要概览：</p>\n<p>Symbol是一个唯一且不变的数据类型，可以作为一个对象的属性标示符。</p>\n<p>创建一个新的symbol，会给我们提供一个被认为是程序里的唯一标识的值。这一点对于命名对象的属性十分有用：我们可以确保不会不小心覆盖任何属性。使用Symbol做键值也不是无数的，所以他们很大程度上对外界是不可见的（也不完全是，可以通过Reflect.ownKeys获得）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> secureObject = &#123;</div><div class=\"line\">    <span class=\"comment\">// 这个键可以看作是唯一的</span></div><div class=\"line\">    [<span class=\"keyword\">new</span> <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"name\"</span>)] : <span class=\"string\">'Dr. Secure A. F.'</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.getKeys(superSecureObject) ); <span class=\"comment\">// [] -- 标志属性不太好获取    </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Reflect</span>.ownKeys(secureObject) ); <span class=\"comment\">// [Symbol(\"name\")] -- 但也不是完全隐藏的</span></div></pre></td></tr></table></figure>\n<p>对我们来讲更有意思的是，这给我们提供了一种方式来告诉 JavaScript 引擎使用特定方法来达到特定的目的。</p>\n<p>所谓的『众所周知的Symbol』是一些特定对象的键，当你在定义对象中使用时他们时，JavaScript引擎会触发一些特定方法。</p>\n<p>这对于JavaScript来说有点怪异，我们还是看个例子吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 继承 Array 可以让我们直观的使用 'length'</span></div><div class=\"line\"><span class=\"comment\">// 同时可以让我们访问到内置方法，如</span></div><div class=\"line\"><span class=\"comment\">// map、filter、reduce、push、pop 等</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FoodSet</span> <span class=\"keyword\">extends</span> <span class=\"title\">Array</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// foods 把传递的任意参数收集为一个数组</span></div><div class=\"line\">    <span class=\"comment\">// 参见：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator</span></div><div class=\"line\">    <span class=\"keyword\">constructor</span>(...foods) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>();</div><div class=\"line\">        <span class=\"keyword\">this</span>.foods = [];</div><div class=\"line\">        foods.forEach((food) =&amp;gt; <span class=\"keyword\">this</span>.foods.push(food))</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 自定义迭代器行为，请注意，这不是多么好用的迭代器，但是个不错的例子</span></div><div class=\"line\">     <span class=\"comment\">// 键名前必须写星号</span></div><div class=\"line\">     * [<span class=\"built_in\">Symbol</span>.iterator] () &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> position = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span> (position &amp;lt; <span class=\"keyword\">this</span>.foods.length) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (position === <span class=\"keyword\">this</span>.foods.length) &#123;</div><div class=\"line\">              <span class=\"keyword\">return</span> <span class=\"string\">\"Done!\"</span></div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              <span class=\"keyword\">yield</span> <span class=\"string\">`<span class=\"subst\">$&#123;this.foods[ position++ ]&#125;</span> is the food item at position <span class=\"subst\">$&#123;position&#125;</span>`</span>;</div><div class=\"line\">          &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// 当我们的用户使用内置的数组方法，返回一个数组类型对象</span></div><div class=\"line\">     <span class=\"comment\">// 而不是 FoodSet 类型的。这使得我们的 FoodSet 可以被一些</span></div><div class=\"line\">     <span class=\"comment\">// 期望操作数组的代码操作</span></div><div class=\"line\">     <span class=\"keyword\">static</span> get [<span class=\"built_in\">Symbol</span>.species] () &#123;</div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foodset = <span class=\"keyword\">new</span> FoodSet(<span class=\"keyword\">new</span> Food(<span class=\"string\">'Fish'</span>, <span class=\"number\">26</span>, <span class=\"number\">0</span>, <span class=\"number\">16</span>), <span class=\"keyword\">new</span> Food(<span class=\"string\">'Hamburger'</span>, <span class=\"number\">26</span>, <span class=\"number\">48</span>, <span class=\"number\">24</span>));</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当我们使用 for ... of 操作 FoodSet 时，JavaScript 将会使用</span></div><div class=\"line\"><span class=\"comment\">// 我们之前用 [Symbol.iterator] 做键值的方法</span></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> food <span class=\"keyword\">of</span> foodset) &#123;</div><div class=\"line\">    <span class=\"comment\">// 打印全部 food</span></div><div class=\"line\">    <span class=\"built_in\">console</span>.log( food );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 当我们执行数组的 `filter` 方法时，JavaScript 创建并返回一个新对象</span></div><div class=\"line\"><span class=\"comment\">// 我们在什么对象上执行 `filter` 方法，新对象就使用这个对象作为默认构造器来创建</span></div><div class=\"line\"><span class=\"comment\">// 然而大部分代码都希望 filter 返回一个数组，于是我们通过重写 [Symbol.species]</span></div><div class=\"line\"><span class=\"comment\">// 的方式告诉 JavaScript 使用数组的构造器</span></div><div class=\"line\"><span class=\"keyword\">const</span> healthy_foods = foodset.filter((food) =&amp;gt; food.name !== <span class=\"string\">'Hamburger'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log( healthy_foods <span class=\"keyword\">instanceof</span> FoodSet ); <span class=\"comment\">//</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log( healthy_foods <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> );</div></pre></td></tr></table></figure>\n<p>当你使用for…of遍历一个对象时，JavaScript将会尝试执行对象的迭代器方法，这一方法就是该对象 Symbol.iterator属性上关联的方法。如果我们提供了自己的方法定义，JavaScript就会使用我们自定义的。如果没有自己制定的话，如果有默认的实现就用默认的，没有的话就不执行。</p>\n<p>Symbo.species更奇异了。在自定义的类中，默认的Symbol.species函数就是类的构造函数。当我们的子类有内置的集合（例如Array和Set）时，我们通常希望在使用父类的实例时也能使用子类。</p>\n<p>通过方法返回父类的实例而不是派生类的实例，使我们更能确保我们子类在大多数代码里的可用性。而Symbol.species可以实现这一功能。</p>\n<p>如果不怎么需要这个功能就别费力去搞了。Symbol的这种用法——或者说有关Symbol的全部用法——都还比较罕见。这些例子只是为了演示：</p>\n<ol>\n<li>我们可以在自定义类中使用JavaScript内置的特定构造器；</li>\n<li>用两个普通的例子展示了怎么实现这一点。</li>\n</ol>\n<h3 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>ES2015的class关键字没有带给我们 Java 里或是SmallTalk里那种『真正的类』。宁可说它只是提供了一种更加方便的语法来创建通过原型关联的对象，本质上没有什么新东西。</p>\n<h2 id=\"使用ES6写更好的JavaScript-part-III：好用的集合和反引号\"><a href=\"#使用ES6写更好的JavaScript-part-III：好用的集合和反引号\" class=\"headerlink\" title=\"使用ES6写更好的JavaScript part III：好用的集合和反引号\"></a>使用ES6写更好的JavaScript part III：好用的集合和反引号</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>ES2015发生了一些重大变革，像promises和generators. 但并非新标准的一切都高不可攀。 – 相当一部分新特性可以快速上手。</p>\n<p>在这篇文章里，我们来看下新特性带来的好处:</p>\n<ul>\n<li>新的集合: map，weakmap，set， weakset</li>\n<li>大部分的new String methods</li>\n<li>模板字符串。</li>\n</ul>\n<p>我们开始这个系列的最后一章吧。</p>\n<h3 id=\"模板字符串\"><a href=\"#模板字符串\" class=\"headerlink\" title=\"模板字符串\"></a>模板字符串</h3><p>模板字符串 解决了三个痛点，允许你做如下操作:</p>\n<ol>\n<li>定义在字符串内部的表达式，称为 字符串插值。</li>\n<li>写多行字符串无须用换行符 (\\n) 拼接。</li>\n<li>使用“raw”字符串 – 在反斜杠内的字符串不会被转义，视为常量。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\">“use strict”;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 三个模板字符串的例子:</div><div class=\"line\"></div><div class=\"line\">字符串插值，多行字符串，raw 字符串。</div><div class=\"line\">================================= */</span></div><div class=\"line\"><span class=\"comment\">// ================================== </span></div><div class=\"line\"><span class=\"comment\">// 1. 字符串插值 :: 解析任何一个字符串中的表达式。 </span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> + <span class=\"number\">1</span> = $&#123;<span class=\"number\">1</span> + <span class=\"number\">1</span>&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ================================== </span></div><div class=\"line\"><span class=\"comment\">// 2. 多行字符串 :: 这样写: </span></div><div class=\"line\"><span class=\"keyword\">let</span> childe_roland = </div><div class=\"line\">I saw them and I knew them all. And yet &lt;br&gt; Dauntless the slug-horn to my lips I set, <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span> And blew “Childe Roland to the Dark Tower came.”</div><div class=\"line\"></div><div class=\"line\">// … 代替下面的写法: </div><div class=\"line\">child_roland = </div><div class=\"line\">‘I saw them and I knew them all. And yet\\n’ + </div><div class=\"line\">‘Dauntless the slug-horn to my lips I set,\\n’ + </div><div class=\"line\">‘And blew “Childe Roland to the Dark Tower came.”’;</div><div class=\"line\"></div><div class=\"line\">// ================================== </div><div class=\"line\">// 3. raw 字符串 :: 在字符串前加 raw 前缀，javascript 会忽略转义字符。 </div><div class=\"line\">// 依然会解析包在 $&#123;&#125; 的表达式 </div><div class=\"line\">const unescaped = String.rawThis $&#123;string()&#125; doesn't contain a newline!\\n</div><div class=\"line\"></div><div class=\"line\">function string () &#123; return “string”; &#125;</div><div class=\"line\"></div><div class=\"line\">console.log(unescaped); // ‘This string doesn’t contain a newline!\\n’ – 注意 \\n 会被原样输出</div><div class=\"line\"></div><div class=\"line\">// 你可以像 React 使用 JSX 一样，用模板字符串创建 HTML 模板 </div><div class=\"line\">const template = </div><div class=\"line\">`</div><div class=\"line\"></div><div class=\"line\">Example</div><div class=\"line\"></div><div class=\"line\">I’m a pure JS &amp; HTML template!</div><div class=\"line\"></div><div class=\"line\">`</div><div class=\"line\"></div><div class=\"line\">function getClass () &#123; </div><div class=\"line\">// Check application state, calculate a class based on that state </div><div class=\"line\">return “some-stateful-class”; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(template); // 这样使用略显笨，自己试试吧！</div><div class=\"line\"></div><div class=\"line\">// 另一个常用的例子是打印变量名: </div><div class=\"line\">const user = &#123; name : ‘Joe’ &#125;;</div><div class=\"line\"></div><div class=\"line\">console.log(“User’s name is ” + user.name + “.”); // 有点冗长 </div><div class=\"line\">console.log(User's name is $&#123;user.name&#125;.); // 这样稍好一些</span></div></pre></td></tr></table></figure>\n<ol>\n<li><p>使用字符串插值，用反引号代替引号包裹字符串，并把我们想要的表达式嵌入在${}中。</p>\n</li>\n<li><p>对于多行字符串，只需要把你要写的字符串包裹在反引号里，在要换行的地方直接换行。 JavaScript 会在换行处插入新行。</p>\n</li>\n<li>使用原生字符串，在模板字符串前加前缀String.raw，仍然使用反引号包裹字符串。</li>\n</ol>\n<p>模板字符串或许只不过是一种语法糖 … 但它比语法糖略胜一筹。</p>\n<h3 id=\"新的字符串方法\"><a href=\"#新的字符串方法\" class=\"headerlink\" title=\"新的字符串方法\"></a>新的字符串方法</h3><p>ES2015也给String新增了一些方法。他们主要归为两类:</p>\n<ol>\n<li>通用的便捷方法</li>\n<li>扩充 Unicode 支持的方法。</li>\n</ol>\n<p>在本文里我们只讲第一类，同时unicode特定方法也有相当好的用例 。如果你感兴趣的话，这是地址在MDN的文档里，有一个关于字符串新方法的完整列表。</p>\n<h3 id=\"startsWith-amp-endsWith\"><a href=\"#startsWith-amp-endsWith\" class=\"headerlink\" title=\"startsWith &amp; endsWith\"></a>startsWith &amp; endsWith</h3><p>对新手而言，我们有String.prototype.startsWith。 它对任何字符串都有效，它需要两个参数:</p>\n<ol>\n<li>一个是 search string 还有</li>\n<li>整形的位置参数 n。这是可选的。</li>\n</ol>\n<p>String.prototype.startsWith方法会检查以nth位起的字符串是否以search string开始。如果没有位置参数，则默认从头开始。</p>\n<p>如果字符串以要搜索的字符串开头返回 true，否则返回 false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串是以 \"This is one\" 开头吗?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"This is one\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串的第四个字符以 \"is\" 开头?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"is\"</span>, <span class=\"number\">4</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串的第五个字符以 \"is\" 开始?</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.startsWith(<span class=\"string\">\"is\"</span>, <span class=\"number\">5</span>)); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith\"></a>endsWith</h3><p>String.prototype.endsWith和startswith相似: 它也需要两个参数：一个是要搜索的字符串，一个是位置。</p>\n<p>然而String.prototype.endsWith位置参数会告诉函数要搜索的字符串在原始字符串中被当做结尾处理。</p>\n<p>换句话说，它会切掉nth后的所有字符串，并检查是否以要搜索的字符结尾。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.endsWith(<span class=\"string\">\"contrived example!\"</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.slice(<span class=\"number\">0</span>, <span class=\"number\">11</span>)); <span class=\"comment\">// \"This is one\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(contrived_example.endsWith(<span class=\"string\">\"one\"</span>, <span class=\"number\">11</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 通常情况下，传一个位置参数向下面这样:</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">substringEndsWith</span> (<span class=\"params\">string, search_string, position</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Chop off the end of the string</span></div><div class=\"line\">    <span class=\"keyword\">const</span> substring = string.slice(<span class=\"number\">0</span>, position);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 检查被截取的字符串是否已 search_string 结尾</span></div><div class=\"line\">    <span class=\"keyword\">return</span> substring.endsWith(search_string);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"includes\"><a href=\"#includes\" class=\"headerlink\" title=\"includes\"></a>includes</h3><p>ES2015也添加了String.prototype.includes。 你需要用字符串调用它，并且要传递一个搜索项。如果字符串包含搜索项会返回true，反之返回false。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> contrived_example = <span class=\"string\">\"This is one impressively contrived example!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 这个字符串是否包含单词 impressively ?</span></div><div class=\"line\">contrived_example.includes(<span class=\"string\">\"impressively\"</span>); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>ES2015之前，我们只能这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\">contrived_example.indexOf(<span class=\"string\">\"impressively\"</span>) !== <span class=\"number\">-1</span> <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>不算太坏。但是，String.prototype.includes是 一个改善，它屏蔽了任意整数返回值为true的漏洞。</p>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat\"></a>repeat</h3><p>还有String.prototype.repeat。可以对任意字符串使用，像includes一样，它会或多或少地完成函数名指示的工作。</p>\n<p>它只需要一个参数: 一个整型的count。使用案例说明一切，上代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> na = <span class=\"string\">\"na\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(na.repeat(<span class=\"number\">5</span>) + <span class=\"string\">\", Batman!\"</span>); <span class=\"comment\">// 'nanananana, Batman!'</span></div></pre></td></tr></table></figure>\n<h3 id=\"raw\"><a href=\"#raw\" class=\"headerlink\" title=\"raw\"></a>raw</h3><p>最后，我们有String.raw，我们在上面简单介绍过。</p>\n<p>一个模板字符串以 String.raw 为前缀，它将不会在字符串中转义:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 单右斜线要转义，我们需要双右斜线才能打印一个右斜线，\\n 在普通字符串里会被解析为换行</div><div class=\"line\">  *   */</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'This string \\\\ has fewer \\\\ backslashes \\\\ and \\n breaks the line.'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 不想这样写的话用 raw 字符串</span></div><div class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`This string \\\\ has too many \\\\ backslashes \\\\ and \\n doesn't break the line.`</span></div></pre></td></tr></table></figure>\n<h3 id=\"Unicode方法\"><a href=\"#Unicode方法\" class=\"headerlink\" title=\"Unicode方法\"></a>Unicode方法</h3><p>虽然我们不涉及剩余的 string 方法，但是如果我不告诉你去这个主题的必读部分就会显得我疏忽。</p>\n<ul>\n<li>Dr Rauschmayer对于Unicode in JavaScript的介绍 </li>\n<li>他关于ES2015’s Unicode Support in Exploring ES6和The Absolute Minimum Every Software Developer Needs to Know About Unicode 的讨论。</li>\n</ul>\n<p>无论如何我不得不跳过它的最后一部分。虽然有些老但是还是有优点的。</p>\n<p>这里是文档中缺失的字符串方法，这样你会知道缺哪些东西了。</p>\n<ul>\n<li>String.fromCodePoint &amp; String.prototype.codePointAt;</li>\n<li>String.prototype.normalize;</li>\n<li>Unicode point escapes.</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>ES2015新增了一些集合类型:</p>\n<ol>\n<li>Map和WeakMap</li>\n<li>Set和WeakSet。</li>\n</ol>\n<p>合适的Map和Set类型十分方便使用，还有弱变量是一个令人兴奋的改动，虽然它对Javascript来说像舶来品一样。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>map就是简单的键值对。最简单的理解方式就是和object类似，一个键对应一个值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 我们可以把 foo 当键，bar 当值</span></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123; foo : <span class=\"string\">'bar'</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 对象键为 foo 的值为 bar</span></div><div class=\"line\">obj.foo === <span class=\"string\">'bar'</span>; <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>新的Map类型在概念上是相似的，但是可以使用任意的数据类型作为键 – 不止strings和symbols–还有除了pitfalls associated with trying to use an objects a map的一些东西。</p>\n<p>下面的片段例举了 Map 的 API.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造器</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_inventory = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// BASIC API METHODS</span></div><div class=\"line\"><span class=\"comment\">// Map.prototype.set (K, V) :: 创建一个键 K，并设置它的值为 V。</span></div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">2</span>);</div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'The Dalmore'</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 你可以创建一个 map 里面包含一个有两个元素的数组</span></div><div class=\"line\">scotch_inventory = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([[<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">2</span>], [<span class=\"string\">'The Dalmore'</span>, <span class=\"number\">1</span>]]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 map 都有 size 属性，这个属性会告诉你 map 里有多少个键值对。</span></div><div class=\"line\"><span class=\"comment\">// 用 Map 或 Set 的时候，一定要使用 size ，不能使用 length</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.size); <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.get(K) :: 返回键相关的值。如果键不存在返回 undefined</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.get(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.get(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// undefined</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.has(K) :: 如果 map 里包含键 K 返回true，否则返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.has(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.has(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.delete(K) :: 从 map 里删除键 K。成功返回true，不存在返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_inventory.delete(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true -- breaks my heart</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.clear() :: 清楚 map 中的所有键值对</span></div><div class=\"line\">scotch_inventory.clear();</div><div class=\"line\"><span class=\"built_in\">console</span>.log( scotch_inventory ); <span class=\"comment\">// Map &#123;&#125; -- long night</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 遍历方法</span></div><div class=\"line\"><span class=\"comment\">// Map 提供了多种方法遍历键值。 </span></div><div class=\"line\"><span class=\"comment\">//  重置值，继续探索</span></div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Lagavulin 18'</span>, <span class=\"number\">1</span>);</div><div class=\"line\">scotch_inventory.set(<span class=\"string\">'Glenfiddich 18'</span>, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Map.prototype.forEach(callback[, thisArg]) :: 对 map 里的每个键值对执行一个回调函数 </div><div class=\"line\">  *   你可以在回调函数内部设置 'this' 的值，通过传递一个 thisArg 参数，那是可选的而且没有太大必要那样做</div><div class=\"line\">  *   最后，注意回调函数已经被传了键和值 */</span></div><div class=\"line\">scotch_inventory.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">quantity, scotch</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Excuse me while I sip this <span class=\"subst\">$&#123;scotch&#125;</span>.`</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.keys() :: 返回一个 map 中的所有键</span></div><div class=\"line\"><span class=\"keyword\">const</span> scotch_names = scotch_inventory.keys();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`We've got <span class=\"subst\">$&#123;name&#125;</span> in the cellar.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.values() :: 返回 map 中的所有值</span></div><div class=\"line\"><span class=\"keyword\">const</span> quantities = scotch_inventory.values();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> quantity <span class=\"keyword\">of</span> quantities) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;quantity&#125;</span> of . . . Uh . . . I forget`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Map.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 </span></div><div class=\"line\"><span class=\"comment\">//   以后会经常看到 map 里的键值对和 \"entries\" 关联 </span></div><div class=\"line\"><span class=\"keyword\">const</span> entries = scotch_inventory.entries();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> entries) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I remember! I drank <span class=\"subst\">$&#123;entry[1]&#125;</span> bottle of <span class=\"subst\">$&#123;entry[0]&#125;</span>!`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>但是Object在保存键值对的时候仍然有用。 如果符合下面的全部条件，你可能还是想用Object:</p>\n<ol>\n<li>当你写代码的时候，你知道你的键值对。</li>\n<li>你知道你可能不会去增加或删除你的键值对。</li>\n<li>你使用的键全都是 string 或 symbol。</li>\n</ol>\n<p>另一方面，如果符合以下任意条件，你可能会想使用一个 map。</p>\n<ol>\n<li>你需要遍历整个map – 然而这对 object 来说是难以置信的.</li>\n<li>当你写代码的时候不需要知道键的名字或数量。</li>\n<li>你需要复杂的键，像 Object 或 别的 Map (!).</li>\n</ol>\n<p>像遍历一个map一样遍历一个object是可行的，但奇妙的是–还会有一些坑潜伏在暗处。 Map更容易使用，并且增加了一些可集成的优势。然而object是以随机顺序遍历的，map是以插入的顺序遍历的。</p>\n<p>添加随意动态键名的键值对给一个object是可行的。但奇妙的是: 比如说如果你曾经遍历过一个伪 map，你需要记住手动更新条目数。</p>\n<p>最后一条，如果你要设置的键名不是string或symbol，你除了选择Map别无选择。</p>\n<p>上面的这些只是一些指导性的意见，并不是最好的规则。</p>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>你可能听说过一个特别棒的特性垃圾回收器，它会定期地检查不再使用的对象并清除。</p>\n<p>To quote Dr Rauschmayer:</p>\n<blockquote>\n<p>WeakMap 不会阻止它的键值被垃圾回收。那意味着你可以把数据和对象关联起来不用担心内存泄漏。</p>\n</blockquote>\n<p>换句换说，就是你的程序丢掉了WeakMap键的所有外部引用，他能自动垃圾回收他们的值。</p>\n<p>尽管大大简化了用例，考虑到SPA(单页面应用) 就是用来展示用户希望展示的东西，像一些物品描述和一张图片，我们可以理解为API返回的JSON。</p>\n<p>理论上来说我们可以通过缓存响应结果来减少请求服务器的次数。我们可以这样用Map :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">put</span> (<span class=\"params\">element, result</span>) </span>&#123;</div><div class=\"line\">    cache.set(element, result);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">retrieve</span> (<span class=\"params\">element</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> cache.get(element);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>… 这是行得通的，但是有内存泄漏的危险。</p>\n<p>因为这是一个SPA，用户或许想离开这个视图，这样的话我们的 “视图”object就会失效，会被垃圾回收。</p>\n<p>不幸的是，如果你使用的是正常的Map ,当这些object不使用时，你必须自行清除。</p>\n<p>使用WeakMap替代就可以解决上面的问题:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(); <span class=\"comment\">// 不会再有内存泄露了</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 剩下的都一样</span></div></pre></td></tr></table></figure>\n<p>这样当应用失去不需要的元素的引用时，垃圾回收系统可以自动重用那些元素。</p>\n<p>WeakMap的API和Map相似，但有如下几点不同:</p>\n<ol>\n<li>在WeakMap里你可以使用object作为键。 这意味着不能以String和Symbol做键。</li>\n<li>WeakMap只有set，get，has，和delete方法 – 那意味着你不能遍历weak map.</li>\n<li>WeakMaps没有size属性。</li>\n</ol>\n<p>不能遍历或检查WeakMap的长度的原因是，在遍历过程中可能会遇到垃圾回收系统的运行: 这一瞬间是满的，下一秒就没了。</p>\n<p>这种不可预测的行为需要谨慎对待，TC39(ECMA第39届技术委员会)曾试图避免禁止WeakMap的遍历和长度检测。</p>\n<p>其他的案例，可以在这里找到Use Cases for WeakMap，来自Exploring ES6.</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set就是只包含一个值的集合。换句换说，每个set的元素只会出现一次。</p>\n<p>这是一个有用的数据类型，如果你要追踪唯一并且固定的object ,比如说聊天室的当前用户。</p>\n<p>Set和Map有完全相同的API。主要的不同是Set没有set方法，因为它不能存储键值对。剩下的几乎相同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 构造器</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_collection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 基本的 API 方法</span></div><div class=\"line\"><span class=\"comment\">// Set.prototype.add (O) :: 和 set 一样，添加一个对象</span></div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Lagavulin 18'</span>);</div><div class=\"line\">scotch_collection.add(<span class=\"string\">'The Dalmore'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 你也可以用数组构造一个 set</span></div><div class=\"line\">scotch_collection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">'Lagavulin 18'</span>, <span class=\"string\">'The Dalmore'</span>]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 所有的 set 都有一个 length 属性。这个属性会告诉你 set 里有多少对象</span></div><div class=\"line\"><span class=\"comment\">//   用 set 或 map 的时候，一定记住用 size，不用 length</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.size); <span class=\"comment\">// 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.has(O) :: 包含对象 O 返回 true 否则返回 false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.has(<span class=\"string\">'The Dalmore'</span>)); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(scotch_collection.has(<span class=\"string\">'Glenfiddich 18'</span>)); <span class=\"comment\">// false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.delete(O) :: 删除 set 中的 O 对象，成功返回 true，不存在返回 false</span></div><div class=\"line\">scotch_collection.delete(<span class=\"string\">'The Dalmore'</span>); <span class=\"comment\">// true -- break my heart</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.clear() :: 删除 set 中的所有对象</span></div><div class=\"line\">scotch_collection.clear();</div><div class=\"line\"><span class=\"built_in\">console</span>.log( scotch_collection ); <span class=\"comment\">// Set &#123;&#125; -- long night.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 迭代方法</div><div class=\"line\"> * Set 提供了多种方法遍历</div><div class=\"line\"> *  重新设置值，继续探索 */</span></div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Lagavulin 18'</span>);</div><div class=\"line\">scotch_collection.add(<span class=\"string\">'Glenfiddich 18'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Set.prototype.forEach(callback[, thisArg]) :: 执行一个函数，回调函数</div><div class=\"line\"> *  set 里在每个的键值对。 You can set the value of 'this' inside </div><div class=\"line\"> *  the callback by passing a thisArg, but that's optional and seldom necessary. */</span></div><div class=\"line\">scotch_collection.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">scotch</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Excuse me while I sip this <span class=\"subst\">$&#123;scotch&#125;</span>.`</span>);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.values() :: 返回 set 中的所有值</span></div><div class=\"line\"><span class=\"keyword\">let</span> scotch_names = scotch_collection.values();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;name&#125;</span> . . . I think.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set.prototype.keys() ::  对 set 来说，和 Set.prototype.values() 方法一致</span></div><div class=\"line\">scotch_names = scotch_collection.keys();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">of</span> scotch_names) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I just drank <span class=\"subst\">$&#123;name&#125;</span> . . . I think.`</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Set.prototype.entries() :: 返回 map 的所有键值对，提供一个包含两个元素的数组 </div><div class=\"line\"> *   这有点多余，但是这种方法可以保留 map API 的可操作性</div><div class=\"line\"> *    */</span></div><div class=\"line\"><span class=\"keyword\">const</span> entries = scotch_collection.entries();</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> entries) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`I got some <span class=\"subst\">$&#123;entry[0]&#125;</span> in my cup and more <span class=\"subst\">$&#123;entry[1]&#125;</span> in my flask!`</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>WeakSet相对于Set就像WeakMap相对于 Map :</p>\n<ol>\n<li>在WeakSet里object的引用是弱类型的。</li>\n<li>WeakSet没有property属性。</li>\n<li>不能遍历WeakSet。</li>\n</ol>\n<p>Weak set的用例并不多，但是这儿有一些Domenic Denicola称呼它们为“perfect for branding” – 意思就是标记一个对象以满足其他需求。</p>\n<p>这儿是他给的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 下面这个例子来自 Weakset 使用案例的邮件讨论 </div><div class=\"line\">  *    邮件的内容和讨论的其余部分在这儿:</div><div class=\"line\">  *      https://mail.mozilla.org/pipermail/es-discuss/2015-June/043027.html</div><div class=\"line\">  */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> foos = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</div><div class=\"line\">    foos.add(<span class=\"keyword\">this</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  method() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!foos.has(<span class=\"keyword\">this</span>)) &#123;</div><div class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Foo.prototype.method called on an incompatible object!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是一个轻量科学的方法防止大家在一个没有被Foo构造出的object上使用method。</p>\n<p>使用的WeakSet的优势是允许foo里的object使用完后被垃圾回收。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这篇文章里，我们已经了解了ES2015带来的一些好处，从string的便捷方法和模板变量到适当的Map和Set实现。</p>\n<p>String方法和模板字符串易于上手。同时你很快也就不用到处用weak set了，我认为你很快就会喜欢上Set和Map。</p>\n<p>整理转载：<a href=\"https://github.com/xitu/gold-miner\">https://github.com/xitu/gold-miner</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cis75cphb000468dd5vmu624j","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cphh000768ddi0f8z6t0"},{"post_id":"cis75cphi000868ddshlqbzst","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpho000b68ddpskf459v"},{"post_id":"cis75cpgw000068ddmpr2lptl","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cphq000d68ddg5oqittc"},{"post_id":"cis75cpgw000068ddmpr2lptl","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cphs000g68ddnmincwzs"},{"post_id":"cis75cpho000c68ddrt2ry9zi","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cphv000i68ddm6l8uhiy"},{"post_id":"cis75cph2000168ddvst7mnjt","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cphx000l68ddt40lu93x"},{"post_id":"cis75cph8000368ddqt0sjxnf","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cphz000n68dd7bz5dxhv"},{"post_id":"cis75cphv000j68ddtwek2ixq","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpi1000q68ddch91ucsa"},{"post_id":"cis75cphe000668ddtdmdq6ax","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpi5000s68ddkpammgmm"},{"post_id":"cis75cpi2000r68ddq87w6zgp","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpi6000u68ddv80jdhs6"},{"post_id":"cis75cphk000968dddht4l9b1","tag_id":"cis75cpi1000p68dd52884f3y","_id":"cis75cpi9000x68ddircwi4d1"},{"post_id":"cis75cpi7000w68ddq3em2cpd","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpia000z68dde8af41av"},{"post_id":"cis75cpi9000y68ddo2uruhk8","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpid001268ddo6awoec7"},{"post_id":"cis75cpi9000y68ddo2uruhk8","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpif001468dd6jboocty"},{"post_id":"cis75cpi9000y68ddo2uruhk8","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpih001768dd56rkgrqz"},{"post_id":"cis75cphr000e68ddq1bc3991","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpik001968ddf0adpqgh"},{"post_id":"cis75cphr000e68ddq1bc3991","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpio001c68ddqo8blohu"},{"post_id":"cis75cpib001168ddxq5rcz1z","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpis001e68ddighn6vaf"},{"post_id":"cis75cpht000h68ddzd0uewh7","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpiv001h68ddxl04mcyr"},{"post_id":"cis75cpht000h68ddzd0uewh7","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpiw001j68dd4zacgdk4"},{"post_id":"cis75cphy000m68ddomlji6wg","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpiz001m68ddfry55kx9"},{"post_id":"cis75cphy000m68ddomlji6wg","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpj2001o68ddtue2ssde"},{"post_id":"cis75cpi0000o68ddpzieqq4g","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpj4001r68ddqkqsajma"},{"post_id":"cis75cpi0000o68ddpzieqq4g","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpj7001t68dd5h80um9t"},{"post_id":"cis75cpiv001i68dduoa7x6da","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpja001w68ddotsnhfxj"},{"post_id":"cis75cpi5000t68ddneiu7n55","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpjd001y68dduwkpa3ak"},{"post_id":"cis75cpi5000t68ddneiu7n55","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpjh002068ddx7v5zq8k"},{"post_id":"cis75cpid001368ddgkoo9dmx","tag_id":"cis75cpix001k68ddsmo4maco","_id":"cis75cpjj002368ddwct93ifw"},{"post_id":"cis75cpjb001x68ddy3cnxi51","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpjl002568ddrgc0m8xb"},{"post_id":"cis75cpif001668dd5ilnzf13","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpjo002868ddlmrh3ycg"},{"post_id":"cis75cpif001668dd5ilnzf13","tag_id":"cis75cpj9001v68ddanst8x5g","_id":"cis75cpjq002a68ddt31kdeyk"},{"post_id":"cis75cpii001868ddbvu5zj57","tag_id":"cis75cpjh002168ddch5opg4k","_id":"cis75cpjv002d68ddjgjdxpjv"},{"post_id":"cis75cpjm002768ddod375mvk","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpjx002f68ddfpspk57x"},{"post_id":"cis75cpjm002768ddod375mvk","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpjz002i68dd68cofdsu"},{"post_id":"cis75cpjo002968ddg79hati3","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpk0002k68ddemo03v4w"},{"post_id":"cis75cpil001b68dd5u1c9c6c","tag_id":"cis75cpjl002668ddojb2rwaf","_id":"cis75cpk2002n68dd60krz31q"},{"post_id":"cis75cpil001b68dd5u1c9c6c","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpk4002p68ddpyd6v2hd"},{"post_id":"cis75cpjq002b68dd3rbkg1zg","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpk6002s68ddgdjjkq7k"},{"post_id":"cis75cpjv002e68ddwy03scl1","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpk8002u68dd1tvegssf"},{"post_id":"cis75cpjx002g68dd67zze4ow","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpkc002w68ddp6ljokr8"},{"post_id":"cis75cpiq001d68ddhb4j2igl","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpke002z68ddxoh3y74p"},{"post_id":"cis75cpiq001d68ddhb4j2igl","tag_id":"cis75cpj9001v68ddanst8x5g","_id":"cis75cpkg003168dd53ebheiv"},{"post_id":"cis75cpk3002o68ddfe8eo1zi","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpki003468dd9rxo7062"},{"post_id":"cis75cpit001g68ddndr7h6vy","tag_id":"cis75cpk2002m68dd78qnni4j","_id":"cis75cpkk003668ddkrgfq14j"},{"post_id":"cis75cpk6002t68ddcmxr78sd","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cpkn003968dd5e26snvd"},{"post_id":"cis75cpiy001l68ddhylfd14h","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cpkp003b68ddyj9xfk1c"},{"post_id":"cis75cpk8002v68ddlz6oyuhy","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpkv003e68dd1g59ce2l"},{"post_id":"cis75cpk8002v68ddlz6oyuhy","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpkx003g68dd61rnpgn3"},{"post_id":"cis75cpkc002y68ddekaw57gg","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpkz003j68dd6vivgqro"},{"post_id":"cis75cpj0001n68ddar8g36kl","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cpl1003l68dd5903ebdr"},{"post_id":"cis75cpkf003068ddlo237l0k","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpl5003o68ddpv9gucc5"},{"post_id":"cis75cpkh003368dd2msnu7cy","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpl7003q68ddw5dbbzqy"},{"post_id":"cis75cpkh003368dd2msnu7cy","tag_id":"cis75cpi7000v68ddgn6suaze","_id":"cis75cpla003t68ddm7aqpo5o"},{"post_id":"cis75cpj2001p68dd8arto6yb","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cpld003v68ddwlfgmrro"},{"post_id":"cis75cpkj003568dd2tlzlksn","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cplh003y68ddq8a915zg"},{"post_id":"cis75cpkl003868dd9ys4avyv","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cplj004068ddgb7f9k7j"},{"post_id":"cis75cpkl003868dd9ys4avyv","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cplk004268ddnrw05zim"},{"post_id":"cis75cpj4001s68ddbumvfkgn","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cplo004568ddm8a8jp3o"},{"post_id":"cis75cpkw003f68ddiyr2h1kn","tag_id":"cis75cpjh002168ddch5opg4k","_id":"cis75cplq004768dd7vium1ry"},{"post_id":"cis75cpj8001u68ddqb1j9g7u","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpls004a68ddioeeg3c2"},{"post_id":"cis75cpj8001u68ddqb1j9g7u","tag_id":"cis75cpkq003c68dd9tssxytj","_id":"cis75cplw004c68ddy9ckcdfh"},{"post_id":"cis75cpjd001z68dde3j0niny","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cplz004f68ddllk4d0xc"},{"post_id":"cis75cpjd001z68dde3j0niny","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpm1004h68ddq7z9nuwe"},{"post_id":"cis75cpl1003m68ddu56t3j3u","tag_id":"cis75cpjh002168ddch5opg4k","_id":"cis75cpm3004k68ddvhml337z"},{"post_id":"cis75cpji002268dd48fqsdp4","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpm5004m68ddv758hgdf"},{"post_id":"cis75cpji002268dd48fqsdp4","tag_id":"cis75cpl3003n68ddefa6ap47","_id":"cis75cpm7004p68ddlzteq5zv"},{"post_id":"cis75cpjk002468dd2ahxja22","tag_id":"cis75cpk6002r68ddij5tc9db","_id":"cis75cpm8004r68ddj8mrp8yk"},{"post_id":"cis75cpjk002468dd2ahxja22","tag_id":"cis75cplh003x68dduvbxw22w","_id":"cis75cpma004u68ddody4za4r"},{"post_id":"cis75cplj004168ddineqj9ox","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpmb004w68ddrwyqutmo"},{"post_id":"cis75cpll004468dd7kbpk6ec","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpmd004z68ddtmpd59g0"},{"post_id":"cis75cpll004468dd7kbpk6ec","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpmf005168ddk9kalg2o"},{"post_id":"cis75cpjz002j68dde84vsnav","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpmh005468ddpvgkioxy"},{"post_id":"cis75cpjz002j68dde84vsnav","tag_id":"cis75cpkq003c68dd9tssxytj","_id":"cis75cpmk005668dd6ghriuvr"},{"post_id":"cis75cplp004668dd040szyss","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpmm005968ddrba1bzom"},{"post_id":"cis75cplr004968dd2876tyvx","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpmo005b68dd1aoletn5"},{"post_id":"cis75cpls004b68ddnxtfod5d","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpmr005d68dd6sugb0t5"},{"post_id":"cis75cpk1002l68ddjw7fwk8s","tag_id":"cis75cplq004868ddxu7tv1is","_id":"cis75cpmt005g68ddhho25sim"},{"post_id":"cis75cpk1002l68ddjw7fwk8s","tag_id":"cis75cplw004d68ddz24fjnbr","_id":"cis75cpmv005i68ddjitoph11"},{"post_id":"cis75cpm2004i68dd1c0p5wf5","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpmx005l68dd9tejf5kl"},{"post_id":"cis75cpm7004q68dd1ihd577p","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpmz005n68dd2ua64ioc"},{"post_id":"cis75cpk4002q68ddhd2e3pdl","tag_id":"cis75cplq004868ddxu7tv1is","_id":"cis75cpn1005q68dd0e54vmyq"},{"post_id":"cis75cpk4002q68ddhd2e3pdl","tag_id":"cis75cplw004d68ddz24fjnbr","_id":"cis75cpn2005s68ddvhzc1bxh"},{"post_id":"cis75cpm8004s68ddks7z7eev","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpn9005u68ddys5guh0w"},{"post_id":"cis75cpkn003a68ddbf4jlrxo","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpna005v68dd1rfqj2ln"},{"post_id":"cis75cpkn003a68ddbf4jlrxo","tag_id":"cis75cpma004t68dd8uugr1nv","_id":"cis75cpna005w68dd1fmq756e"},{"post_id":"cis75cpmc004x68dd8tyujsw5","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpna005y68ddgawp05dr"},{"post_id":"cis75cpmc004x68dd8tyujsw5","tag_id":"cis75cpjl002668ddojb2rwaf","_id":"cis75cpnb005z68ddyf5s1jdk"},{"post_id":"cis75cpme005068ddk8qa2af8","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnb006168ddeqvhjl8r"},{"post_id":"cis75cpkr003d68ddvcp3i4dr","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnc006268ddaqlhe3pm"},{"post_id":"cis75cpkr003d68ddvcp3i4dr","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpnd006468ddxq73vp6b"},{"post_id":"cis75cpmf005268dd8d8w070r","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnd006568dd3l8t4i4i"},{"post_id":"cis75cpmf005268dd8d8w070r","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpne006768ddyb9r6mz0"},{"post_id":"cis75cpmi005568dd4a6dy38m","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpne006868ddrhld4myg"},{"post_id":"cis75cpkx003i68ddwwwkevd1","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnf006a68ddlzfkhq53"},{"post_id":"cis75cpkx003i68ddwwwkevd1","tag_id":"cis75cpl3003n68ddefa6ap47","_id":"cis75cpnf006b68ddvv5c28yb"},{"post_id":"cis75cpmm005a68ddpqvbi2fr","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnf006d68dd7q28mq4w"},{"post_id":"cis75cpl0003k68ddl516eyqo","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpng006e68ddvqnzxa3l"},{"post_id":"cis75cpl0003k68ddl516eyqo","tag_id":"cis75cphe000568ddknyvwq12","_id":"cis75cpnh006g68dd9wrvl30m"},{"post_id":"cis75cpl0003k68ddl516eyqo","tag_id":"cis75cpml005868ddboi3282d","_id":"cis75cpnh006h68ddauyixfk8"},{"post_id":"cis75cpmp005c68dd0ihwchcn","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnh006i68ddwyxdprp2"},{"post_id":"cis75cpmp005c68dd0ihwchcn","tag_id":"cis75cpjl002668ddojb2rwaf","_id":"cis75cpni006k68dd31f0ho53"},{"post_id":"cis75cpmu005h68ddyfjeb9q5","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnj006l68ddybxmbz7g"},{"post_id":"cis75cpl6003p68dds0qkmeez","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnk006n68dd970z9hbm"},{"post_id":"cis75cpl6003p68dds0qkmeez","tag_id":"cis75cpmr005e68dd94zuwvu5","_id":"cis75cpnl006o68ddaoko93g0"},{"post_id":"cis75cpmv005k68ddjctycwnm","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnl006q68ddrvelgc5z"},{"post_id":"cis75cpmv005k68ddjctycwnm","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpnm006r68ddpmuwymcd"},{"post_id":"cis75cpmz005o68dd4iv6m4fa","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpnm006t68ddny7c14gy"},{"post_id":"cis75cpn1005r68ddb20284jf","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpnn006u68dd2j4cgucb"},{"post_id":"cis75cpn1005r68ddb20284jf","tag_id":"cis75cphn000a68ddtdfw5vsw","_id":"cis75cpnn006v68ddcllcgow5"},{"post_id":"cis75cpl7003r68ddksf2usmh","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpnn006w68ddhtg5sem3"},{"post_id":"cis75cpl7003r68ddksf2usmh","tag_id":"cis75cpmv005j68ddtrj8cpwr","_id":"cis75cpnn006x68ddnonqe4bc"},{"post_id":"cis75cpl7003r68ddksf2usmh","tag_id":"cis75cpn0005p68dds2qomd4o","_id":"cis75cpno006y68ddrfbljps0"},{"post_id":"cis75cplb003u68ddw06c9zyo","tag_id":"cis75cpn8005t68dduhcn70xl","_id":"cis75cpno006z68ddea6kfvfk"},{"post_id":"cis75cple003w68ddmq48pz5f","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpno007068dduyq44sns"},{"post_id":"cis75cple003w68ddmq48pz5f","tag_id":"cis75cpna005x68ddma7wepxg","_id":"cis75cpno007168dd9vabrq2z"},{"post_id":"cis75cpli003z68dd9s2awcey","tag_id":"cis75cpkx003h68dd7z331ws8","_id":"cis75cpno007268dd6f0r474e"},{"post_id":"cis75cpli003z68dd9s2awcey","tag_id":"cis75cpnb006068ddl5qo7byq","_id":"cis75cpno007368dd7kd5xg7r"},{"post_id":"cis75cplw004e68ddm63ja3bu","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpnp007468ddywgg0upb"},{"post_id":"cis75cplw004e68ddm63ja3bu","tag_id":"cis75cpna005x68ddma7wepxg","_id":"cis75cpnp007568dd8vqr2xl3"},{"post_id":"cis75cpm0004g68ddpqgx09op","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpnp007668ddwtzppc1q"},{"post_id":"cis75cpm0004g68ddpqgx09op","tag_id":"cis75cpnd006668ddfev78kq1","_id":"cis75cpnp007768ddlkp4dfof"},{"post_id":"cis75cpm0004g68ddpqgx09op","tag_id":"cis75cpnb006068ddl5qo7byq","_id":"cis75cpnp007868ddy8ql08oh"},{"post_id":"cis75cpm4004l68ddhqqqzsik","tag_id":"cis75cpn8005t68dduhcn70xl","_id":"cis75cpnp007968ddrg6wjoit"},{"post_id":"cis75cpm5004n68dd1qkgbpgw","tag_id":"cis75cpng006f68dd55v6sla6","_id":"cis75cpnq007a68dd2br09lfg"},{"post_id":"cis75cpma004v68dd25721p8k","tag_id":"cis75cpn8005t68dduhcn70xl","_id":"cis75cpnq007b68ddgv0ara9x"},{"post_id":"cis75cpmk005768ddi6yyzggs","tag_id":"cis75cpn8005t68dduhcn70xl","_id":"cis75cpnq007c68ddewlh7dw7"},{"post_id":"cis75cpms005f68ddm18hpb1s","tag_id":"cis75cpn8005t68dduhcn70xl","_id":"cis75cpnq007d68dd1qbvy34v"},{"post_id":"cis75cpmx005m68ddz2pitjdt","tag_id":"cis75cpj3001q68ddpy79nvfx","_id":"cis75cpnq007e68dds8go7ynk"},{"post_id":"cis75cpmx005m68ddz2pitjdt","tag_id":"cis75cpna005x68ddma7wepxg","_id":"cis75cpnr007f68dd0s5njty1"},{"post_id":"cis75cpnt007g68dd8qfc7xj0","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnv007i68ddbuy7hunj"},{"post_id":"cis75cpnu007h68dd6vml29bx","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpnw007j68ddj8byo60n"},{"post_id":"cis75cpnx007k68ddlk24k6hq","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpo0007m68ddre71twrv"},{"post_id":"cis75cpny007l68dd3lm39ii0","tag_id":"cis75cph5000268dd0x17m7do","_id":"cis75cpo0007n68dd9ur6j7yi"},{"post_id":"cis75cpny007l68dd3lm39ii0","tag_id":"cis75cpma004t68dd8uugr1nv","_id":"cis75cpo1007o68dddscqa65t"}],"Tag":[{"name":"javascript","_id":"cis75cph5000268dd0x17m7do"},{"name":"jquery","_id":"cis75cphe000568ddknyvwq12"},{"name":"css","_id":"cis75cphn000a68ddtdfw5vsw"},{"name":"other","_id":"cis75cpi1000p68dd52884f3y"},{"name":"angularjs","_id":"cis75cpi7000v68ddgn6suaze"},{"name":"http","_id":"cis75cpix001k68ddsmo4maco"},{"name":"linux","_id":"cis75cpj3001q68ddpy79nvfx"},{"name":"centos","_id":"cis75cpj9001v68ddanst8x5g"},{"name":"git","_id":"cis75cpjh002168ddch5opg4k"},{"name":"html5","_id":"cis75cpjl002668ddojb2rwaf"},{"name":"mac","_id":"cis75cpk2002m68dd78qnni4j"},{"name":"nodejs","_id":"cis75cpk6002r68ddij5tc9db"},{"name":"svn","_id":"cis75cpkq003c68dd9tssxytj"},{"name":"html","_id":"cis75cpkx003h68dd7z331ws8"},{"name":"json","_id":"cis75cpl3003n68ddefa6ap47"},{"name":"express","_id":"cis75cplh003x68dduvbxw22w"},{"name":"database","_id":"cis75cplq004868ddxu7tv1is"},{"name":"mongodb","_id":"cis75cplw004d68ddz24fjnbr"},{"name":"es6","_id":"cis75cpma004t68dd8uugr1nv"},{"name":"qunit","_id":"cis75cpml005868ddboi3282d"},{"name":"ajax","_id":"cis75cpmr005e68dd94zuwvu5"},{"name":"ngnix","_id":"cis75cpmv005j68ddtrj8cpwr"},{"name":"ssl","_id":"cis75cpn0005p68dds2qomd4o"},{"name":"其它","_id":"cis75cpn8005t68dduhcn70xl"},{"name":"ubuntu","_id":"cis75cpna005x68ddma7wepxg"},{"name":"php","_id":"cis75cpnb006068ddl5qo7byq"},{"name":"nginx","_id":"cis75cpnd006668ddfev78kq1"},{"name":"virtualbox","_id":"cis75cpng006f68dd55v6sla6"}]}}