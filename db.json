{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/my_theme/source/css/index.css","path":"css/index.css","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/12个CSS高级技巧汇总.md","hash":"ad2583c50bf698934a4017e0ce3c053bb7fcf930","modified":1463553115225},{"_id":"source/_posts/12个非常有用的JavaScript技巧.md","hash":"d941254a41337faa2fe6a78c0d56d1f13a1b7583","modified":1463391303459},{"_id":"source/_posts/12种不宜使用的Javascript语法.md","hash":"4f40d1fade82b8e9a3a51a30b7a815c1f7698edb","modified":1463553551976},{"_id":"source/_posts/200个纯CSS3写的图标 支持复制代码.md","hash":"d518963ab8f32e5fe78e5e3296343f2ab18cc827","modified":1463553755579},{"_id":"source/_posts/30行代码实现JavaScript中的MVC.md","hash":"8f1037f9fedfa730308e4abc98dbf9c2f75d04ec","modified":1463553678390},{"_id":"source/_posts/5个经典的前端面试问题.md","hash":"f8057387e16ba3e21f75af2cc297326f44007700","modified":1463552836341},{"_id":"source/_posts/7个你可能不认识的CSS单位.md","hash":"44451ad1efc23850ffc4be6944739bff5b063a78","modified":1463552883214},{"_id":"source/_posts/AngularJS开发人员最常犯的10个错误.md","hash":"d95b37a05932c7f1952b77f3d7d84afe587bed9c","modified":1463553813272},{"_id":"source/_posts/Angularjs知识点1.md","hash":"b572074a881a9bef8ed36e3851e1264614b9f5ea","modified":1463553951808},{"_id":"source/_posts/Angularjs知识点2.md","hash":"16246cad44b471af01fb23f8f713fae4847127eb","modified":1463553993874},{"_id":"source/_posts/Angularjs轻松实现表格按指定列排序.md","hash":"be78c2be5efa223ee2dd534e2526333e5a7b8912","modified":1464938396090},{"_id":"source/_posts/Array.prototype.reduce函数.md","hash":"b5a76959e319100ae3bdfc1b97a12fdc9c398e6a","modified":1463554111060},{"_id":"source/_posts/CSS vs JS动画：谁更快？.md","hash":"5d6804b4a3117245ff6b9ac36e3792577885ceb0","modified":1463470693101},{"_id":"source/_posts/CSS“隐藏”元素的几种方法的对比.md","hash":"35205673d5a729b21234bb6f44dd145a3cc6e387","modified":1463554260738},{"_id":"source/_posts/CSS实现垂直居中的常用方法.md","hash":"b493d9fe059f49f24884c2501fc35cd745900290","modified":1463554327233},{"_id":"source/_posts/mongoDB设置数据库并启动.md","hash":"5e46acc04dceffc8a37be8948cc9992af2ace508","modified":1464934697595},{"_id":"source/_posts/mongodb3.03开启认证.md","hash":"7ad97569ee49a8e383197e2092a22cd035e8670e","modified":1464934639472},{"_id":"source/_posts/【Angularjs文档翻译及实例】DOM事件.md","hash":"08862d1932f5f8eb67606cb16b479b3e08776bc4","modified":1463553421919},{"_id":"source/_posts/俞敏洪：我和马云就差了8个字.md","hash":"00c91e2e2ad1a62b933720d72de235b93c54eff0","modified":1463036652633},{"_id":"source/_posts/学会享受孤独是通往成功的第一步.md","hash":"719a24bb5eb3909b8f0569efbd3d36d02117e313","modified":1463035752952},{"_id":"source/_posts/毁灭程序员的15个障碍.md","hash":"f27d77b6615292d8fb9e7d3e3db4001771e695c0","modified":1463036665489},{"_id":"source/_posts/程序员累了怎么办？.md","hash":"db80827a420fc6c00b27d50f818fc7dbcee99fa5","modified":1463035679594},{"_id":"source/_posts/糟糕程序员的编程风格.md","hash":"8db3fb493cd530d7f196da377f64ae29e7cdf73e","modified":1463035612263},{"_id":"themes/my_theme/layout/archive.ejs","hash":"4846e5ddf47e2885384081b44c44fa2efd678f66","modified":1464942497201},{"_id":"themes/my_theme/layout/index.ejs","hash":"5c2e3eade32fdb07b8f3c1d9a19c2f0acb870615","modified":1464941762725},{"_id":"themes/my_theme/layout/layout.ejs","hash":"d4cb617380ed0cc11e2de3cb482c35dd6a05105d","modified":1464944202702},{"_id":"themes/my_theme/layout/post.ejs","hash":"df51106b0ac990c65a1939f1c5344ecfe037aa1f","modified":1464941965562},{"_id":"themes/my_theme/source/css/index.css","hash":"8e8689a076d53297a20e7380a328f40be076d1c8","modified":1464941748740},{"_id":"public/2016/05/18/Angularjs轻松实现表格按指定列排序/index.html","hash":"06cffe15e81d34d08ab2446b842fcc420a3aa6e1","modified":1464944459734},{"_id":"public/2016/04/11/Angularjs知识点1/index.html","hash":"951fe9574473be66d9703e9578134358af186576","modified":1464944459734},{"_id":"public/2016/04/11/Angularjs知识点2/index.html","hash":"c93769cb325cd06237733dd314a7b9ce9a7709e6","modified":1464944459735},{"_id":"public/2016/04/10/Array.prototype.reduce函数/index.html","hash":"06beb2638d8784853591eda9f7ea9a3effaec85e","modified":1464944459735},{"_id":"public/2016/03/02/学会享受孤独是通往成功的第一步/index.html","hash":"b0914ee245565b24152a8cd903bf9af7141f0a86","modified":1464944459735},{"_id":"public/2016/02/17/糟糕程序员的编程风格/index.html","hash":"f626219c662bca0b8e115b0c884d80927811e3ac","modified":1464944459735},{"_id":"public/2015/12/25/俞敏洪：我和马云就差了8个字/index.html","hash":"69809785a67aacbb8bc5d5a79b8019e8601569f7","modified":1464944459735},{"_id":"public/2015/10/10/程序员累了怎么办？/index.html","hash":"c87dc4e92f31fae00bc61b3a8177493fd5a5d619","modified":1464944459735},{"_id":"public/2015/09/18/mongoDB设置数据库并启动/index.html","hash":"73b24330cf52e6cd11d366d77194835b9534a4bc","modified":1464944459737},{"_id":"public/2015/07/18/mongodb3.03开启认证/index.html","hash":"6b699bfc6392737dc0ae5e7edba437722d4cf68d","modified":1464944459737},{"_id":"public/2015/04/19/12种不宜使用的Javascript语法/index.html","hash":"20d9877e0f6f964fc6c7343259a804819701035e","modified":1464944459738},{"_id":"public/2015/01/24/12个CSS高级技巧汇总/index.html","hash":"8f6121652de46d57bdf1d2859e2d1b80967df88e","modified":1464944459738},{"_id":"public/2015/01/04/7个你可能不认识的CSS单位/index.html","hash":"6384e538a709e80503a70cc01dbaf2d06f0a9f35","modified":1464944459738},{"_id":"public/2014/10/27/5个经典的前端面试问题/index.html","hash":"e05822c779efcfe67f73879c100f53f98f355b55","modified":1464944459738},{"_id":"public/2014/04/18/200个纯CSS3写的图标 支持复制代码/index.html","hash":"ed0d0c99f3cc56df42cc9d9eb19e67029fc93e79","modified":1464944459738},{"_id":"public/archives/index.html","hash":"2a571846cf1d919dd247d2de0e4393350b260b47","modified":1464944459738},{"_id":"public/archives/page/2/index.html","hash":"8f13f6e2f8d0591bbbfe75482ca477574c562d30","modified":1464944459738},{"_id":"public/archives/page/3/index.html","hash":"f31575875cabcbf6e9058e637e9644ab13c4b6b6","modified":1464944459738},{"_id":"public/archives/2014/index.html","hash":"d1e18cbfbea5de33cee74829330dc64e03aca023","modified":1464944459738},{"_id":"public/archives/2014/04/index.html","hash":"0159d24dc00336c65a640486ab7afca7fe439f8f","modified":1464944459738},{"_id":"public/archives/2014/10/index.html","hash":"855325e81351b4cb8f2e8e2e1df77340cf54baec","modified":1464944459738},{"_id":"public/archives/2015/index.html","hash":"a7ab576bfb7126e30593ff45ae0b12ca37df90f4","modified":1464944459738},{"_id":"public/archives/2015/01/index.html","hash":"afef3b41a2f5f318a1d7c534270075ceb81a8849","modified":1464944459739},{"_id":"public/archives/2015/04/index.html","hash":"742d5c8d2c40cb19281b4af0cf11c76765b13e7d","modified":1464944459739},{"_id":"public/archives/2015/07/index.html","hash":"4d4e5b6e7282b5801208c4b5c7d3f11d98d90e50","modified":1464944459739},{"_id":"public/archives/2015/09/index.html","hash":"b5a7ea7c395a091939d1fd70bdeb9b44e1065408","modified":1464944459739},{"_id":"public/archives/2015/10/index.html","hash":"4a1167c33cafa1448d6da2e70502fd37bb90ca4c","modified":1464944459739},{"_id":"public/archives/2015/12/index.html","hash":"8a8ced9dd6c94b0bd98e6620b488bb4842a238f0","modified":1464944459739},{"_id":"public/archives/2016/index.html","hash":"2a571846cf1d919dd247d2de0e4393350b260b47","modified":1464944459739},{"_id":"public/archives/2016/page/2/index.html","hash":"7fd43071af6961cb673d3291de49bc9f9635f9ce","modified":1464944459739},{"_id":"public/archives/2016/01/index.html","hash":"270317df9acf71c402dcda43ba4b7649d6224a83","modified":1464944459739},{"_id":"public/archives/2016/02/index.html","hash":"4a67d9de3f938caac5500f2868f73319f8a7c9e7","modified":1464944459739},{"_id":"public/archives/2016/03/index.html","hash":"bfc8fdb7fd63643ee1d788e43850bb0af859430c","modified":1464944459739},{"_id":"public/archives/2016/04/index.html","hash":"a731bd203f46e25a291c7f9f51a47e9cce7b069d","modified":1464944459739},{"_id":"public/archives/2016/05/index.html","hash":"125ddfed162d39c4b2ed8f3b834c8a2ff393eec0","modified":1464944459739},{"_id":"public/index.html","hash":"7dc698dc6f7e105211ad716acf256b7feb6660d3","modified":1464944459739},{"_id":"public/page/2/index.html","hash":"7dc698dc6f7e105211ad716acf256b7feb6660d3","modified":1464944459739},{"_id":"public/page/3/index.html","hash":"7dc698dc6f7e105211ad716acf256b7feb6660d3","modified":1464944459739},{"_id":"public/tags/css/index.html","hash":"a95c8b67b94f1557cca6a522f0e031d9ae05c223","modified":1464944459739},{"_id":"public/tags/javascript/index.html","hash":"b7096fe07cc6a158255597ef8ebbc231785a74ac","modified":1464944459740},{"_id":"public/tags/javascript/page/2/index.html","hash":"855325e81351b4cb8f2e8e2e1df77340cf54baec","modified":1464944459740},{"_id":"public/tags/jquery/index.html","hash":"201f78f3c145ebc538d7534c29badaadf9490940","modified":1464944459740},{"_id":"public/tags/angularjs/index.html","hash":"8604570a56588ccb6b847f262340543fae34c09d","modified":1464944459740},{"_id":"public/tags/database/index.html","hash":"8526be91972e0484e8919f426581f306f8ad61d6","modified":1464944459740},{"_id":"public/tags/mongodb/index.html","hash":"8526be91972e0484e8919f426581f306f8ad61d6","modified":1464944459740},{"_id":"public/tags/其它/index.html","hash":"b46f905675d060fc861fe4f8867adacd2b3b0daa","modified":1464944459740},{"_id":"public/2016/05/14/CSS vs JS动画：谁更快？/index.html","hash":"839da9983e064828093a19d092fc89ca6f89c06b","modified":1464944459740},{"_id":"public/2016/05/12/12个非常有用的JavaScript技巧/index.html","hash":"090e4fb59f2ea9460b08169e8cb0a045cb9d5917","modified":1464944459740},{"_id":"public/2016/04/17/AngularJS开发人员最常犯的10个错误/index.html","hash":"5a9d080bcb9d8bef7d8566c27fbb655c7bc391f3","modified":1464944459740},{"_id":"public/2016/03/06/CSS实现垂直居中的常用方法/index.html","hash":"fa8c1586cec32a2f4c3bf8f497a0c74477f63dcd","modified":1464944459740},{"_id":"public/2016/02/15/30行代码实现JavaScript中的MVC/index.html","hash":"6ea4aeb24597d8294f309f2491831f3d3955ac80","modified":1464944459740},{"_id":"public/2016/01/02/毁灭程序员的15个障碍/index.html","hash":"aab18db88cf76d0e5f13c9b40089186daa9ca925","modified":1464944459740},{"_id":"public/2015/10/26/CSS“隐藏”元素的几种方法的对比/index.html","hash":"5f32c3c775e4ba858eaff42e1efe21a1952aeb25","modified":1464944459740},{"_id":"public/2015/04/20/【Angularjs文档翻译及实例】DOM事件/index.html","hash":"22e12e52481679e812144cf560a40cb8c0782e02","modified":1464944459741},{"_id":"public/css/index.css","hash":"3de549c8aec5735a488803059119079d51618aa1","modified":1464944459786}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"12个CSS高级技巧汇总","date":"2015-01-23T16:00:00.000Z","_content":"\n**1、使用:not()在菜单上应用/取消应用边框**\n\n先给每一个菜单项添加边框\n\n```css\n/* add border */\n.nav li {\n\tborder-right: 1px solid #666;\n}\n```\n\n……然后再除去最后一个元素……\n\n```css\n//* remove border */\n.nav li:last-child {\n\tborder-right: none;\n}\n```\n\n……可以直接使用:not()伪类来应用元素：\n\n```css\n.nav li:not(:last-child) {\n\tborder-right: 1px solid #666;\n}\n```\n\n这样代码就干净，易读，易于理解了。\n\n当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：\n\n```css\n.nav li:first-child ~ li {\n\tborder-left: 1px solid #666;\n}\n```\n\n**2、给body添加行高**\n\n你不需要分别添加 line-height 到每个```<p>```，```<h*>```等。只要添加到body即可：\n\n```css\nbody {\n\tline-height: 1;\n}\n```\n\n这样文本元素就可以很容易地从body继承。\n\n**3、所有一切都垂直居中**\n\n要将所有元素垂直居中，太简单了：\n\n```css\nhtml, body {\n\theight: 100%;\n\tmargin: 0;\n}\n\nbody {\n\t-webkit-align-items: center;\n\t-ms-flex-align: center;\n\talign-items: center;\n\tdisplay: -webkit-flex;\n\tdisplay: flex;\n}\n```\n\n看，是不是很简单。\n\n> 注：在IE11中要小心flexbox。\n\n**4、逗号分隔的列表**\n\n让HTML列表项看上去像一个真正的，用逗号分隔的列表：\n\n```css\nul > li:not(:last-child)::after {\n\tcontent: \",\";\n}\n```\n\n对最后一个列表项使用:not()伪类。\n\n**5、使用负的nth-child选择项目**\n\n在CSS中使用负的 nth-child 选择项目1到项目n。\n\n```css\nli {\n\tdisplay: none;\n}\n\n/* select items 1 through 3 and display them */\nli:nth-child(-n+3) {\n\tdisplay: block;\n}\n```\n\n就是这么容易。\n\n**6、对图标使用SVG**\n\n我们没有理由不对图标使用SVG：\n\n```css\n.logo {\n\tbackground: url(\"logo.svg\");\n}\n```\n\nSVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。\n\n**7、优化显示文本**\n\n有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：\n\n```css\nhtml {\n\t-moz-osx-font-smoothing: grayscale;\n\t-webkit-font-smoothing: antialiased;\n\ttext-rendering: optimizeLegibility;\n}\n```\n\n注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。\n\n**8、对纯CSS滑块使用max-height**\n\n使用max-height和溢出隐藏来实现只有CSS的滑块：\n\n```css\n.slider ul {\n\tmax-height: 0;\n\toverlow: hidden;\n}\n\n.slider:hover ul {\n\tmax-height: 1000px;\n\ttransition: .3s ease;\n}\n```\n\n**9、继承box-sizing**\n\n让box-sizing继承html：\n\n```css\nhtml {\n\tbox-sizing: border-box;\n}\n\n*, *:before, *:after {\n\tbox-sizing: inherit;\n}\n```\n\n这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。\n\n**10、表格单元格等宽**\n\n表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：\n\n```css\n.calendar {\n\ttable-layout: fixed;\n}\n```\n\n**11、用Flexbox摆脱外边距的各种hack**\n\n当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：\n\n```css\n.list {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.list .person {\n\tflex-basis: 23%;\n}\n```\n\n现在，列表分隔符就会在均匀间隔的位置出现。\n\n**12、使用属性选择器用于空链接**\n\n当`<a>`元素没有文本值，但href属性有链接的时候显示链接：\n\n```css\na[href^=\"http\"]:empty::before {\n\tcontent: attr(href);\n}\n```\n\n相当方便。\n\n> 些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。","source":"_posts/12个CSS高级技巧汇总.md","raw":"---\ntitle: 12个CSS高级技巧汇总\ntags: [css]\ndate: 2015/01/24\n---\n\n**1、使用:not()在菜单上应用/取消应用边框**\n\n先给每一个菜单项添加边框\n\n```css\n/* add border */\n.nav li {\n\tborder-right: 1px solid #666;\n}\n```\n\n……然后再除去最后一个元素……\n\n```css\n//* remove border */\n.nav li:last-child {\n\tborder-right: none;\n}\n```\n\n……可以直接使用:not()伪类来应用元素：\n\n```css\n.nav li:not(:last-child) {\n\tborder-right: 1px solid #666;\n}\n```\n\n这样代码就干净，易读，易于理解了。\n\n当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：\n\n```css\n.nav li:first-child ~ li {\n\tborder-left: 1px solid #666;\n}\n```\n\n**2、给body添加行高**\n\n你不需要分别添加 line-height 到每个```<p>```，```<h*>```等。只要添加到body即可：\n\n```css\nbody {\n\tline-height: 1;\n}\n```\n\n这样文本元素就可以很容易地从body继承。\n\n**3、所有一切都垂直居中**\n\n要将所有元素垂直居中，太简单了：\n\n```css\nhtml, body {\n\theight: 100%;\n\tmargin: 0;\n}\n\nbody {\n\t-webkit-align-items: center;\n\t-ms-flex-align: center;\n\talign-items: center;\n\tdisplay: -webkit-flex;\n\tdisplay: flex;\n}\n```\n\n看，是不是很简单。\n\n> 注：在IE11中要小心flexbox。\n\n**4、逗号分隔的列表**\n\n让HTML列表项看上去像一个真正的，用逗号分隔的列表：\n\n```css\nul > li:not(:last-child)::after {\n\tcontent: \",\";\n}\n```\n\n对最后一个列表项使用:not()伪类。\n\n**5、使用负的nth-child选择项目**\n\n在CSS中使用负的 nth-child 选择项目1到项目n。\n\n```css\nli {\n\tdisplay: none;\n}\n\n/* select items 1 through 3 and display them */\nli:nth-child(-n+3) {\n\tdisplay: block;\n}\n```\n\n就是这么容易。\n\n**6、对图标使用SVG**\n\n我们没有理由不对图标使用SVG：\n\n```css\n.logo {\n\tbackground: url(\"logo.svg\");\n}\n```\n\nSVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。\n\n**7、优化显示文本**\n\n有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：\n\n```css\nhtml {\n\t-moz-osx-font-smoothing: grayscale;\n\t-webkit-font-smoothing: antialiased;\n\ttext-rendering: optimizeLegibility;\n}\n```\n\n注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。\n\n**8、对纯CSS滑块使用max-height**\n\n使用max-height和溢出隐藏来实现只有CSS的滑块：\n\n```css\n.slider ul {\n\tmax-height: 0;\n\toverlow: hidden;\n}\n\n.slider:hover ul {\n\tmax-height: 1000px;\n\ttransition: .3s ease;\n}\n```\n\n**9、继承box-sizing**\n\n让box-sizing继承html：\n\n```css\nhtml {\n\tbox-sizing: border-box;\n}\n\n*, *:before, *:after {\n\tbox-sizing: inherit;\n}\n```\n\n这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。\n\n**10、表格单元格等宽**\n\n表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：\n\n```css\n.calendar {\n\ttable-layout: fixed;\n}\n```\n\n**11、用Flexbox摆脱外边距的各种hack**\n\n当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：\n\n```css\n.list {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n\n.list .person {\n\tflex-basis: 23%;\n}\n```\n\n现在，列表分隔符就会在均匀间隔的位置出现。\n\n**12、使用属性选择器用于空链接**\n\n当`<a>`元素没有文本值，但href属性有链接的时候显示链接：\n\n```css\na[href^=\"http\"]:empty::before {\n\tcontent: attr(href);\n}\n```\n\n相当方便。\n\n> 些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。","slug":"12个CSS高级技巧汇总","published":1,"updated":"2016-05-18T06:31:55.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3up10000tsqbauix0i63","content":"<p><strong>1、使用:not()在菜单上应用/取消应用边框</strong></p>\n<p>先给每一个菜单项添加边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* add border */</span></span><br><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>……然后再除去最后一个元素……</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//* remove border */</span><br><span class=\"line\">.nav li:last-child &#123;</span><br><span class=\"line\">\tborder-right: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>……可以直接使用:not()伪类来应用元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样代码就干净，易读，易于理解了。</p>\n<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-left</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、给body添加行高</strong></p>\n<p>你不需要分别添加 line-height 到每个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```css</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">\tline-height: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样文本元素就可以很容易地从body继承。</p>\n<p><strong>3、所有一切都垂直居中</strong></p>\n<p>要将所有元素垂直居中，太简单了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-align-items</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">-ms-flex-align</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看，是不是很简单。</p>\n<blockquote>\n<p>注：在IE11中要小心flexbox。</p>\n</blockquote>\n<p><strong>4、逗号分隔的列表</strong></p>\n<p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &gt; <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对最后一个列表项使用:not()伪类。</p>\n<p><strong>5、使用负的nth-child选择项目</strong></p>\n<p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* select items 1 through 3 and display them */</span></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child(-n+3)</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是这么容易。</p>\n<p><strong>6、对图标使用SVG</strong></p>\n<p>我们没有理由不对图标使用SVG：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"logo.svg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>\n<p><strong>7、优化显示文本</strong></p>\n<p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</span><br><span class=\"line\">\t<span class=\"attribute\">text-rendering</span>: optimizeLegibility;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。</p>\n<p><strong>8、对纯CSS滑块使用max-height</strong></p>\n<p>使用max-height和溢出隐藏来实现只有CSS的滑块：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.slider</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">overlow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.slider</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: .<span class=\"number\">3s</span> ease;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>9、继承box-sizing</strong></p>\n<p>让box-sizing继承html：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。</p>\n<p><strong>10、表格单元格等宽</strong></p>\n<p>表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.calendar</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">table-layout</span>: fixed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>11、用Flexbox摆脱外边距的各种hack</strong></p>\n<p>当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.list</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">\t<span class=\"attribute\">justify-content</span>: space-between;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.list</span> <span class=\"selector-class\">.person</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">flex-basis</span>: <span class=\"number\">23%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，列表分隔符就会在均匀间隔的位置出现。</p>\n<p><strong>12、使用属性选择器用于空链接</strong></p>\n<p>当<code>&lt;a&gt;</code>元素没有文本值，但href属性有链接的时候显示链接：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href^=\"http\"]</span><span class=\"selector-pseudo\">:empty</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(href);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相当方便。</p>\n<blockquote>\n<p>些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。</p>\n</blockquote>\n","excerpt":"","more":"<p><strong>1、使用:not()在菜单上应用/取消应用边框</strong></p>\n<p>先给每一个菜单项添加边框</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* add border */</span></span><br><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>……然后再除去最后一个元素……</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//* remove border */</span><br><span class=\"line\">.nav li:last-child &#123;</span><br><span class=\"line\">\tborder-right: none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>……可以直接使用:not()伪类来应用元素：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样代码就干净，易读，易于理解了。</p>\n<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.nav</span> <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:first-child</span> ~ <span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border-left</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#666</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、给body添加行高</strong></p>\n<p>你不需要分别添加 line-height 到每个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">```css</span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">\tline-height: 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样文本元素就可以很容易地从body继承。</p>\n<p><strong>3、所有一切都垂直居中</strong></p>\n<p>要将所有元素垂直居中，太简单了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>, <span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-align-items</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">-ms-flex-align</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">align-items</span>: center;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看，是不是很简单。</p>\n<blockquote>\n<p>注：在IE11中要小心flexbox。</p>\n</blockquote>\n<p><strong>4、逗号分隔的列表</strong></p>\n<p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ul</span> &gt; <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:last-child)</span><span class=\"selector-pseudo\">::after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对最后一个列表项使用:not()伪类。</p>\n<p><strong>5、使用负的nth-child选择项目</strong></p>\n<p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">li</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* select items 1 through 3 and display them */</span></span><br><span class=\"line\"><span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child(-n+3)</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是这么容易。</p>\n<p><strong>6、对图标使用SVG</strong></p>\n<p>我们没有理由不对图标使用SVG：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">\"logo.svg\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>\n<p><strong>7、优化显示文本</strong></p>\n<p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-font-smoothing</span>: antialiased;</span><br><span class=\"line\">\t<span class=\"attribute\">text-rendering</span>: optimizeLegibility;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注：请负责任地使用optimizeLegibility。此外，IE/Edge没有text-rendering支持。</p>\n<p><strong>8、对纯CSS滑块使用max-height</strong></p>\n<p>使用max-height和溢出隐藏来实现只有CSS的滑块：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.slider</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">overlow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.slider</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-tag\">ul</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">max-height</span>: <span class=\"number\">1000px</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transition</span>: .<span class=\"number\">3s</span> ease;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>9、继承box-sizing</strong></p>\n<p>让box-sizing继承html：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">*, *<span class=\"selector-pseudo\">:before</span>, *<span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>: inherit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变box-sizing了。</p>\n<p><strong>10、表格单元格等宽</strong></p>\n<p>表格工作起来很麻烦，所以务必尽量使用table-layout: fixed来保持单元格的等宽：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.calendar</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">table-layout</span>: fixed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>11、用Flexbox摆脱外边距的各种hack</strong></p>\n<p>当需要用到列分隔符时，通过flexbox的space-between属性，你就可以摆脱nth-，first-，和last-child的hack了：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.list</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">\t<span class=\"attribute\">justify-content</span>: space-between;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.list</span> <span class=\"selector-class\">.person</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">flex-basis</span>: <span class=\"number\">23%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，列表分隔符就会在均匀间隔的位置出现。</p>\n<p><strong>12、使用属性选择器用于空链接</strong></p>\n<p>当<code>&lt;a&gt;</code>元素没有文本值，但href属性有链接的时候显示链接：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-attr\">[href^=\"http\"]</span><span class=\"selector-pseudo\">:empty</span><span class=\"selector-pseudo\">::before</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"built_in\">attr</span>(href);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相当方便。</p>\n<blockquote>\n<p>些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。</p>\n</blockquote>\n"},{"title":"12个非常有用的JavaScript技巧","date":"2016-05-11T16:00:00.000Z","_content":"\n在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。\n\n### 使用!!操作符转换布尔值\n\n有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回`true`值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用`!!variable`做检测，只要变量的值为:`0`、`null`、`\" \"`、`undefined`或者`NaN`都将返回的是`false`，反之返回的是`true`。比如下面的示例：\n\n```javascript\nfunction Account(cash) {\n    this.cash = cash;\n    this.hasMoney = !!cash;\n}\nvar account = new Account(100.50);\nconsole.log(account.cash); // 100.50\nconsole.log(account.hasMoney); // true\n\nvar emptyAccount = new Account(0);\nconsole.log(emptyAccount.cash); // 0\nconsole.log(emptyAccount.hasMoney); // false\n```\n\n在这个示例中，只要`account.cash`的值大于0，那么`account.hasMoney`返回的值就是`true`。\n\n### 使用+将字符串转换成数字\n\n这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：\n\n```javascript\nfunction toNumber(strNumber) {\n    return +strNumber;\n}\nconsole.log(toNumber(\"1234\")); // 1234\nconsole.log(toNumber(\"ACB\")); // NaN\n```\n\n这个也适用于`Date`，在本例中，它将返回的是时间戳数字：\n\n```javascript\nconsole.log(+new Date) // 1461288164385\n```\n\n### 并条件符\n\n如果你有一段这样的代码：\n\n```javascript\nif (conected) {\n    login;\n}\n```\n\n你也可以将变量简写，并且使用`&&`和函数连接在一起，比如上面的示例，可以简写成这样：\n\n```javascript\nconected && login;\n```\n\n如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：\n\n```javascript\nuser && user.login;\n```\n\n### 使用||运算符\n\n在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用`||`操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为`false`，那么第二个值将会认为是一个默认值。如下面这个示例：\n\n```javascript\nfunction User(name, age) {\n    this.name = name || \"Oliver Queen\";\n    this.age = age || 27;\n}\nvar user1 = new User;\nconsole.log(user1.name); // Oliver Queen\nconsole.log(user1.age); // 27\n\nvar user2 = new User(\"Barry Allen\", 25);\nconsole.log(user2.name); // Barry Allen\nconsole.log(user2.age); // 25\n```\n\n### 在循环中缓存array.length\n\n这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：\n\n```javascript\nfor(var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n}\n```\n\n如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：\n\n```javascript\nvar length = array.length;\nfor(var i = 0; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n你也可以写在这样：\n\n```javascript\nfor(var i = 0, length = array.length; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n### 检测对象中属性\n\n当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用`document.querySelector`来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：\n\n```javascript\nif ('querySelector' in document) {\n    document.querySelector(\"#id\");\n} else {\n    document.getElementById(\"id\");\n}\n```\n\n在这个示例中，如果document不存在querySelector函数，那么就会调用`docuemnt.getElementById(\"id\")`。\n\n### 获取数组中最后一个元素\n\n`Array.prototype.slice(begin,end)`用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.slice(-1)); // [6]\nconsole.log(array.slice(-2)); // [5,6]\nconsole.log(array.slice(-3)); // [4,5,6]\n```\n\n### 数组截断\n\n这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.length); // 6\narray.length = 3;\nconsole.log(array.length); // 3\nconsole.log(array); // [1,2,3]\n```\n\n### 替换所有\n\n`String.replace`函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：\n\n```javascript\nvar string = \"john john\";\nconsole.log(string.replace(/hn/, \"ana\")); // \"joana john\"\nconsole.log(string.replace(/hn/g, \"ana\")); // \"joana joana\"\n```\n\n### 合并数组\n\n如果你要合并两个数组，一般情况之下你都会使用`Array.concat`函数：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.concat(array2)); // [1,2,3,4,5,6];\n```\n\n然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用`Array.pus.apply(arr1,arr2)`来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];\n```\n\n### 将NodeList转换成数组\n\n如果你运行`document.querySelectorAll(“p”)`函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用`.slice.call(elements)`来实现：\n\n```javascript\nvar elements = document.querySelectorAll(\"p\"); // NodeList\nvar arrayElements = .slice.call(elements); // Now the NodeList is an array\nvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array\n```\n\n### 数组元素的洗牌\n\n对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：\n\n```javascript\nvar list = [1,2,3];\nconsole.log(list.sort(function { Math.random - 0.5 })); // [2,1,3]\n```\n\n### 总结\n\n现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。\n\n","source":"_posts/12个非常有用的JavaScript技巧.md","raw":"---\ntitle: 12个非常有用的JavaScript技巧\ntags: [javascript,jquery]\ndate: 2016/05/12\n---\n\n在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。\n\n### 使用!!操作符转换布尔值\n\n有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回`true`值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用`!!variable`做检测，只要变量的值为:`0`、`null`、`\" \"`、`undefined`或者`NaN`都将返回的是`false`，反之返回的是`true`。比如下面的示例：\n\n```javascript\nfunction Account(cash) {\n    this.cash = cash;\n    this.hasMoney = !!cash;\n}\nvar account = new Account(100.50);\nconsole.log(account.cash); // 100.50\nconsole.log(account.hasMoney); // true\n\nvar emptyAccount = new Account(0);\nconsole.log(emptyAccount.cash); // 0\nconsole.log(emptyAccount.hasMoney); // false\n```\n\n在这个示例中，只要`account.cash`的值大于0，那么`account.hasMoney`返回的值就是`true`。\n\n### 使用+将字符串转换成数字\n\n这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：\n\n```javascript\nfunction toNumber(strNumber) {\n    return +strNumber;\n}\nconsole.log(toNumber(\"1234\")); // 1234\nconsole.log(toNumber(\"ACB\")); // NaN\n```\n\n这个也适用于`Date`，在本例中，它将返回的是时间戳数字：\n\n```javascript\nconsole.log(+new Date) // 1461288164385\n```\n\n### 并条件符\n\n如果你有一段这样的代码：\n\n```javascript\nif (conected) {\n    login;\n}\n```\n\n你也可以将变量简写，并且使用`&&`和函数连接在一起，比如上面的示例，可以简写成这样：\n\n```javascript\nconected && login;\n```\n\n如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：\n\n```javascript\nuser && user.login;\n```\n\n### 使用||运算符\n\n在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用`||`操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为`false`，那么第二个值将会认为是一个默认值。如下面这个示例：\n\n```javascript\nfunction User(name, age) {\n    this.name = name || \"Oliver Queen\";\n    this.age = age || 27;\n}\nvar user1 = new User;\nconsole.log(user1.name); // Oliver Queen\nconsole.log(user1.age); // 27\n\nvar user2 = new User(\"Barry Allen\", 25);\nconsole.log(user2.name); // Barry Allen\nconsole.log(user2.age); // 25\n```\n\n### 在循环中缓存array.length\n\n这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：\n\n```javascript\nfor(var i = 0; i < array.length; i++) {\n    console.log(array[i]);\n}\n```\n\n如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：\n\n```javascript\nvar length = array.length;\nfor(var i = 0; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n你也可以写在这样：\n\n```javascript\nfor(var i = 0, length = array.length; i < length; i++) {\n    console.log(array[i]);\n}\n```\n\n### 检测对象中属性\n\n当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用`document.querySelector`来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：\n\n```javascript\nif ('querySelector' in document) {\n    document.querySelector(\"#id\");\n} else {\n    document.getElementById(\"id\");\n}\n```\n\n在这个示例中，如果document不存在querySelector函数，那么就会调用`docuemnt.getElementById(\"id\")`。\n\n### 获取数组中最后一个元素\n\n`Array.prototype.slice(begin,end)`用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.slice(-1)); // [6]\nconsole.log(array.slice(-2)); // [5,6]\nconsole.log(array.slice(-3)); // [4,5,6]\n```\n\n### 数组截断\n\n这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：\n\n```javascript\nvar array = [1,2,3,4,5,6];\nconsole.log(array.length); // 6\narray.length = 3;\nconsole.log(array.length); // 3\nconsole.log(array); // [1,2,3]\n```\n\n### 替换所有\n\n`String.replace`函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：\n\n```javascript\nvar string = \"john john\";\nconsole.log(string.replace(/hn/, \"ana\")); // \"joana john\"\nconsole.log(string.replace(/hn/g, \"ana\")); // \"joana joana\"\n```\n\n### 合并数组\n\n如果你要合并两个数组，一般情况之下你都会使用`Array.concat`函数：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.concat(array2)); // [1,2,3,4,5,6];\n```\n\n然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用`Array.pus.apply(arr1,arr2)`来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：\n\n```javascript\nvar array1 = [1,2,3];\nvar array2 = [4,5,6];\nconsole.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];\n```\n\n### 将NodeList转换成数组\n\n如果你运行`document.querySelectorAll(“p”)`函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用`.slice.call(elements)`来实现：\n\n```javascript\nvar elements = document.querySelectorAll(\"p\"); // NodeList\nvar arrayElements = .slice.call(elements); // Now the NodeList is an array\nvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array\n```\n\n### 数组元素的洗牌\n\n对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：\n\n```javascript\nvar list = [1,2,3];\nconsole.log(list.sort(function { Math.random - 0.5 })); // [2,1,3]\n```\n\n### 总结\n\n现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。\n\n","slug":"12个非常有用的JavaScript技巧","published":1,"updated":"2016-05-16T09:35:03.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3up90001tsqbn0m5mytn","content":"<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p>\n<h3 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用!!操作符转换布尔值\"></a>使用!!操作符转换布尔值</h3><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account</span>(<span class=\"params\">cash</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cash = cash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hasMoney = !!cash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> account = <span class=\"keyword\">new</span> Account(<span class=\"number\">100.50</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(account.cash); <span class=\"comment\">// 100.50</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(account.hasMoney); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> emptyAccount = <span class=\"keyword\">new</span> Account(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.cash); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.hasMoney); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，只要<code>account.cash</code>的值大于0，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p>\n<h3 id=\"使用-将字符串转换成数字\"><a href=\"#使用-将字符串转换成数字\" class=\"headerlink\" title=\"使用+将字符串转换成数字\"></a>使用+将字符串转换成数字</h3><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> +strNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n<p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>) <span class=\"comment\">// 1461288164385</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"并条件符\"><a href=\"#并条件符\" class=\"headerlink\" title=\"并条件符\"></a>并条件符</h3><p>如果你有一段这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (conected) &#123;</span><br><span class=\"line\">    login;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以将变量简写，并且使用<code>&amp;&amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conected &amp;&amp; login;</span><br></pre></td></tr></table></figure>\n<p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user &amp;&amp; user.login;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-运算符\"><a href=\"#使用-运算符\" class=\"headerlink\" title=\"使用||运算符\"></a>使用||运算符</h3><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"Oliver Queen\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age || <span class=\"number\">27</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> user1 = <span class=\"keyword\">new</span> User;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user1.name); <span class=\"comment\">// Oliver Queen</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user1.age); <span class=\"comment\">// 27</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Barry Allen\"</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user2.name); <span class=\"comment\">// Barry Allen</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user2.age); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"在循环中缓存array-length\"><a href=\"#在循环中缓存array-length\" class=\"headerlink\" title=\"在循环中缓存array.length\"></a>在循环中缓存array.length</h3><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以写在这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, length = array.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h3><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector</code>来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，如果document不存在querySelector函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p>\n<h3 id=\"获取数组中最后一个元素\"><a href=\"#获取数组中最后一个元素\" class=\"headerlink\" title=\"获取数组中最后一个元素\"></a>获取数组中最后一个元素</h3><p><code>Array.prototype.slice(begin,end)</code>用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-1</span>)); <span class=\"comment\">// [6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-2</span>)); <span class=\"comment\">// [5,6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-3</span>)); <span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h3><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></span><br><span class=\"line\">array.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"替换所有\"><a href=\"#替换所有\" class=\"headerlink\" title=\"替换所有\"></a>替换所有</h3><p><code>String.replace</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"john john\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana john\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/g</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana joana\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h3><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus.apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"将NodeList转换成数组\"><a href=\"#将NodeList转换成数组\" class=\"headerlink\" title=\"将NodeList转换成数组\"></a>将NodeList转换成数组</h3><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>.slice.call(elements)</code>来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeList</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = .slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组元素的洗牌\"><a href=\"#数组元素的洗牌\" class=\"headerlink\" title=\"数组元素的洗牌\"></a>数组元素的洗牌</h3><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span> </span>&#123; <span class=\"built_in\">Math</span>.random - <span class=\"number\">0.5</span> &#125;)); <span class=\"comment\">// [2,1,3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。</p>\n","excerpt":"","more":"<p>在这篇文章中将给大家分享12个有关于JavaScript的小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。</p>\n<h3 id=\"使用-操作符转换布尔值\"><a href=\"#使用-操作符转换布尔值\" class=\"headerlink\" title=\"使用!!操作符转换布尔值\"></a>使用!!操作符转换布尔值</h3><p>有时候我们需要对一个变量查检其是否存在或者检查值是否有一个有效值，如果存在就返回<code>true</code>值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用<code>!!variable</code>做检测，只要变量的值为:<code>0</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>undefined</code>或者<code>NaN</code>都将返回的是<code>false</code>，反之返回的是<code>true</code>。比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Account</span>(<span class=\"params\">cash</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cash = cash;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.hasMoney = !!cash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> account = <span class=\"keyword\">new</span> Account(<span class=\"number\">100.50</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(account.cash); <span class=\"comment\">// 100.50</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(account.hasMoney); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> emptyAccount = <span class=\"keyword\">new</span> Account(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.cash); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(emptyAccount.hasMoney); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<p>在这个示例中，只要<code>account.cash</code>的值大于0，那么<code>account.hasMoney</code>返回的值就是<code>true</code>。</p>\n<h3 id=\"使用-将字符串转换成数字\"><a href=\"#使用-将字符串转换成数字\" class=\"headerlink\" title=\"使用+将字符串转换成数字\"></a>使用+将字符串转换成数字</h3><p>这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">toNumber</span>(<span class=\"params\">strNumber</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> +strNumber;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"1234\"</span>)); <span class=\"comment\">// 1234</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(toNumber(<span class=\"string\">\"ACB\"</span>)); <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n<p>这个也适用于<code>Date</code>，在本例中，它将返回的是时间戳数字：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>) <span class=\"comment\">// 1461288164385</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"并条件符\"><a href=\"#并条件符\" class=\"headerlink\" title=\"并条件符\"></a>并条件符</h3><p>如果你有一段这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (conected) &#123;</span><br><span class=\"line\">    login;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以将变量简写，并且使用<code>&amp;&amp;</code>和函数连接在一起，比如上面的示例，可以简写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conected &amp;&amp; login;</span><br></pre></td></tr></table></figure>\n<p>如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user &amp;&amp; user.login;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-运算符\"><a href=\"#使用-运算符\" class=\"headerlink\" title=\"使用||运算符\"></a>使用||运算符</h3><p>在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用<code>||</code>操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为<code>false</code>，那么第二个值将会认为是一个默认值。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">User</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"Oliver Queen\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age || <span class=\"number\">27</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> user1 = <span class=\"keyword\">new</span> User;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user1.name); <span class=\"comment\">// Oliver Queen</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user1.age); <span class=\"comment\">// 27</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user2 = <span class=\"keyword\">new</span> User(<span class=\"string\">\"Barry Allen\"</span>, <span class=\"number\">25</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user2.name); <span class=\"comment\">// Barry Allen</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(user2.age); <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"在循环中缓存array-length\"><a href=\"#在循环中缓存array-length\" class=\"headerlink\" title=\"在循环中缓存array.length\"></a>在循环中缓存array.length</h3><p>这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以写在这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, length = array.length; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(array[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"检测对象中属性\"><a href=\"#检测对象中属性\" class=\"headerlink\" title=\"检测对象中属性\"></a>检测对象中属性</h3><p>当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用<code>document.querySelector</code>来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'querySelector'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"#id\"</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个示例中，如果document不存在querySelector函数，那么就会调用<code>docuemnt.getElementById(&quot;id&quot;)</code>。</p>\n<h3 id=\"获取数组中最后一个元素\"><a href=\"#获取数组中最后一个元素\" class=\"headerlink\" title=\"获取数组中最后一个元素\"></a>获取数组中最后一个元素</h3><p><code>Array.prototype.slice(begin,end)</code>用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-1</span>)); <span class=\"comment\">// [6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-2</span>)); <span class=\"comment\">// [5,6]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.slice(<span class=\"number\">-3</span>)); <span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组截断\"><a href=\"#数组截断\" class=\"headerlink\" title=\"数组截断\"></a>数组截断</h3><p>这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 6</span></span><br><span class=\"line\">array.length = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array); <span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"替换所有\"><a href=\"#替换所有\" class=\"headerlink\" title=\"替换所有\"></a>替换所有</h3><p><code>String.replace</code>函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll函数功能：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"john john\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana john\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string.replace(<span class=\"regexp\">/hn/g</span>, <span class=\"string\">\"ana\"</span>)); <span class=\"comment\">// \"joana joana\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"合并数组\"><a href=\"#合并数组\" class=\"headerlink\" title=\"合并数组\"></a>合并数组</h3><p>如果你要合并两个数组，一般情况之下你都会使用<code>Array.concat</code>函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.concat(array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<p>然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用<code>Array.pus.apply(arr1,arr2)</code>来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> array2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array1.push.apply(array1, array2)); <span class=\"comment\">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"将NodeList转换成数组\"><a href=\"#将NodeList转换成数组\" class=\"headerlink\" title=\"将NodeList转换成数组\"></a>将NodeList转换成数组</h3><p>如果你运行<code>document.querySelectorAll(“p”)</code>函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort、reduce、map、filter等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用<code>.slice.call(elements)</code>来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> elements = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"p\"</span>); <span class=\"comment\">// NodeList</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = .slice.call(elements); <span class=\"comment\">// Now the NodeList is an array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayElements = <span class=\"built_in\">Array</span>.from(elements); <span class=\"comment\">// This is another way of converting NodeList to Array</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组元素的洗牌\"><a href=\"#数组元素的洗牌\" class=\"headerlink\" title=\"数组元素的洗牌\"></a>数组元素的洗牌</h3><p>对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(list.sort(<span class=\"function\"><span class=\"keyword\">function</span> </span>&#123; <span class=\"built_in\">Math</span>.random - <span class=\"number\">0.5</span> &#125;)); <span class=\"comment\">// [2,1,3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>现在你学会了些有用的JavaScript小技巧。希望这些小技巧能在工作中帮助你解决一些麻烦，或者说这篇文章对你有所帮助。</p>\n"},{"title":"30行代码实现JavaScript中的MVC","date":"2016-02-14T16:00:00.000Z","_content":"\n从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。\n\n很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。\n\n这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。\n\n### 1. MVC的基础是观察者模式，这是实现model和view同步的关键\n\n为了简单起见，每个model实例中只包含一个primitive value值。\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    // model中的值改变时，应通知注册过的回调函数\n    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\n    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    // 注册监听的回调函数\n    this._listeners.push(listener);\n};\n// html代码：\n<div id=\"div1\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    var div1 = document.getElementById('div1');\n    model.watch(function (value) {\n        div1.innerHTML = value;\n    });\n    model.set('hello, this is a div');\n})();\n```\n\n借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？\n\n### 2. 实现bind方法，绑定model和view\n\n```\nModel.prototype.bind = function (node) {\n    // 将watch的逻辑和通用的回调函数放到这里\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\n// html代码：\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    model.bind(document.getElementById('div1'));\n    model.bind(document.getElementById('div2'));\n    model.set('this is a div');\n})();\n```\n\n通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？\n\n### 3. 实现controller，将绑定从逻辑代码中解耦\n\n细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。\n\n如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。\n\n```\nfunction Controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.querySelectorAll('[bind]');\n    // 将views处理为普通数组\n    views = Array.prototype.slice.call(views, 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelName] = models[modelName] || new Model();\n        // 完成该元素和指定model的绑定\n        models[modelName].bind(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n}\n// html:\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n// 逻辑代码：\nnew Controller(function (models) {\n    var model1 = models.model1;\n    model1.set('this is a div');\n});\n```\n\n就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。\n\n整理后去掉注释的”框架”代码：\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nModel.prototype.bind = function (node) {\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\nfunction Controller(callback) {\n    var models = {};\n    var views = Array.prototype.slice.call(document.querySelectorAll('[bind]'), 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        models[modelName] = models[modelName] || new Model();\n        models[modelName].bind(view);\n    });\n    callback.call(this, models);\n}\n```\n\n### 后记：\n\n笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。\n\n如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：\n\n1. 实现对input类标签的双向绑定\n2. 实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树\n3. 实现view层有关dom node隐藏/显示、创建/销毁的逻辑\n4. 集成virtual dom，增加dom diff的功能，提高渲染效率\n5. 提供依赖注入功能，实现控制反转\n6. 对innerHTML的赋值内容进行安全检查，防止恶意注入\n7. 实现model collection的逻辑，这里每个model只有一个值\n8. 利用es5中的setter改变set方法的实现，使得对model的修改更加简单\n9. 在view层中增加对属性和css的控制\n   10.支持类似AngularJS中双大括号的语法，只绑定部分html\n   ……\n\n一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈\n\n[转载地址](http://www.codeceo.com/article/30-line-javascript-mvc.html)\n","source":"_posts/30行代码实现JavaScript中的MVC.md","raw":"---\ntitle: 30行代码实现JavaScript中的MVC\ntags: [javascript]\ndate: 2016/02/15\n---\n\n从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。\n\n很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。\n\n这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。\n\n### 1. MVC的基础是观察者模式，这是实现model和view同步的关键\n\n为了简单起见，每个model实例中只包含一个primitive value值。\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    // model中的值改变时，应通知注册过的回调函数\n    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数\n    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    // 注册监听的回调函数\n    this._listeners.push(listener);\n};\n// html代码：\n<div id=\"div1\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    var div1 = document.getElementById('div1');\n    model.watch(function (value) {\n        div1.innerHTML = value;\n    });\n    model.set('hello, this is a div');\n})();\n```\n\n借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？\n\n### 2. 实现bind方法，绑定model和view\n\n```\nModel.prototype.bind = function (node) {\n    // 将watch的逻辑和通用的回调函数放到这里\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\n// html代码：\n<div id=\"div1\"></div>\n<div id=\"div2\"></div>\n// 逻辑代码：\n(function () {\n    var model = new Model();\n    model.bind(document.getElementById('div1'));\n    model.bind(document.getElementById('div2'));\n    model.set('this is a div');\n})();\n```\n\n通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？\n\n### 3. 实现controller，将绑定从逻辑代码中解耦\n\n细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。\n\n如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。\n\n```\nfunction Controller(callback) {\n    var models = {};\n    // 找到所有有bind属性的元素\n    var views = document.querySelectorAll('[bind]');\n    // 将views处理为普通数组\n    views = Array.prototype.slice.call(views, 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        // 取出或新建该元素所绑定的model\n        models[modelName] = models[modelName] || new Model();\n        // 完成该元素和指定model的绑定\n        models[modelName].bind(view);\n    });\n    // 调用controller的具体逻辑，将models传入，方便业务处理\n    callback.call(this, models);\n}\n// html:\n<div id=\"div1\" bind=\"model1\"></div>\n<div id=\"div2\" bind=\"model1\"></div>\n// 逻辑代码：\nnew Controller(function (models) {\n    var model1 = models.model1;\n    model1.set('this is a div');\n});\n```\n\n就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。\n\n整理后去掉注释的”框架”代码：\n\n```\nfunction Model(value) {\n    this._value = typeof value === 'undefined' ? '' : value;\n    this._listeners = [];\n}\nModel.prototype.set = function (value) {\n    var self = this;\n    self._value = value;\n    setTimeout(function () {\n        self._listeners.forEach(function (listener) {\n            listener.call(self, value);\n        });\n    });\n};\nModel.prototype.watch = function (listener) {\n    this._listeners.push(listener);\n};\nModel.prototype.bind = function (node) {\n    this.watch(function (value) {\n        node.innerHTML = value;\n    });\n};\nfunction Controller(callback) {\n    var models = {};\n    var views = Array.prototype.slice.call(document.querySelectorAll('[bind]'), 0);\n    views.forEach(function (view) {\n        var modelName = view.getAttribute('bind');\n        models[modelName] = models[modelName] || new Model();\n        models[modelName].bind(view);\n    });\n    callback.call(this, models);\n}\n```\n\n### 后记：\n\n笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。\n\n如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：\n\n1. 实现对input类标签的双向绑定\n2. 实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树\n3. 实现view层有关dom node隐藏/显示、创建/销毁的逻辑\n4. 集成virtual dom，增加dom diff的功能，提高渲染效率\n5. 提供依赖注入功能，实现控制反转\n6. 对innerHTML的赋值内容进行安全检查，防止恶意注入\n7. 实现model collection的逻辑，这里每个model只有一个值\n8. 利用es5中的setter改变set方法的实现，使得对model的修改更加简单\n9. 在view层中增加对属性和css的控制\n   10.支持类似AngularJS中双大括号的语法，只绑定部分html\n   ……\n\n一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈\n\n[转载地址](http://www.codeceo.com/article/30-line-javascript-mvc.html)\n","slug":"30行代码实现JavaScript中的MVC","published":1,"updated":"2016-05-18T06:41:18.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upg0003tsqb12i4u864","content":"<p>从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。</p>\n<p>很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。</p>\n<p>这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。</p>\n<h3 id=\"1-MVC的基础是观察者模式，这是实现model和view同步的关键\"><a href=\"#1-MVC的基础是观察者模式，这是实现model和view同步的关键\" class=\"headerlink\" title=\"1. MVC的基础是观察者模式，这是实现model和view同步的关键\"></a>1. MVC的基础是观察者模式，这是实现model和view同步的关键</h3><p>为了简单起见，每个model实例中只包含一个primitive value值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Model(value) &#123;</span><br><span class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class=\"line\">    this._listeners = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Model.prototype.set = function (value) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self._value = value;</span><br><span class=\"line\">    // model中的值改变时，应通知注册过的回调函数</span><br><span class=\"line\">    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数</span><br><span class=\"line\">    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        self._listeners.forEach(function (listener) &#123;</span><br><span class=\"line\">            listener.call(self, value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.watch = function (listener) &#123;</span><br><span class=\"line\">    // 注册监听的回调函数</span><br><span class=\"line\">    this._listeners.push(listener);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// html代码：</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var model = new Model();</span><br><span class=\"line\">    var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class=\"line\">    model.watch(function (value) &#123;</span><br><span class=\"line\">        div1.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    model.set(&apos;hello, this is a div&apos;);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？</p>\n<h3 id=\"2-实现bind方法，绑定model和view\"><a href=\"#2-实现bind方法，绑定model和view\" class=\"headerlink\" title=\"2. 实现bind方法，绑定model和view\"></a>2. 实现bind方法，绑定model和view</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Model.prototype.bind = function (node) &#123;</span><br><span class=\"line\">    // 将watch的逻辑和通用的回调函数放到这里</span><br><span class=\"line\">    this.watch(function (value) &#123;</span><br><span class=\"line\">        node.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// html代码：</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var model = new Model();</span><br><span class=\"line\">    model.bind(document.getElementById(&apos;div1&apos;));</span><br><span class=\"line\">    model.bind(document.getElementById(&apos;div2&apos;));</span><br><span class=\"line\">    model.set(&apos;this is a div&apos;);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？</p>\n<h3 id=\"3-实现controller，将绑定从逻辑代码中解耦\"><a href=\"#3-实现controller，将绑定从逻辑代码中解耦\" class=\"headerlink\" title=\"3. 实现controller，将绑定从逻辑代码中解耦\"></a>3. 实现controller，将绑定从逻辑代码中解耦</h3><p>细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。</p>\n<p>如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Controller(callback) &#123;</span><br><span class=\"line\">    var models = &#123;&#125;;</span><br><span class=\"line\">    // 找到所有有bind属性的元素</span><br><span class=\"line\">    var views = document.querySelectorAll(&apos;[bind]&apos;);</span><br><span class=\"line\">    // 将views处理为普通数组</span><br><span class=\"line\">    views = Array.prototype.slice.call(views, 0);</span><br><span class=\"line\">    views.forEach(function (view) &#123;</span><br><span class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class=\"line\">        // 取出或新建该元素所绑定的model</span><br><span class=\"line\">        models[modelName] = models[modelName] || new Model();</span><br><span class=\"line\">        // 完成该元素和指定model的绑定</span><br><span class=\"line\">        models[modelName].bind(view);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 调用controller的具体逻辑，将models传入，方便业务处理</span><br><span class=\"line\">    callback.call(this, models);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// html:</span><br><span class=\"line\">&lt;div id=&quot;div1&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;div2&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">new Controller(function (models) &#123;</span><br><span class=\"line\">    var model1 = models.model1;</span><br><span class=\"line\">    model1.set(&apos;this is a div&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。</p>\n<p>整理后去掉注释的”框架”代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Model(value) &#123;</span><br><span class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class=\"line\">    this._listeners = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Model.prototype.set = function (value) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self._value = value;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        self._listeners.forEach(function (listener) &#123;</span><br><span class=\"line\">            listener.call(self, value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.watch = function (listener) &#123;</span><br><span class=\"line\">    this._listeners.push(listener);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.bind = function (node) &#123;</span><br><span class=\"line\">    this.watch(function (value) &#123;</span><br><span class=\"line\">        node.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Controller(callback) &#123;</span><br><span class=\"line\">    var models = &#123;&#125;;</span><br><span class=\"line\">    var views = Array.prototype.slice.call(document.querySelectorAll(&apos;[bind]&apos;), 0);</span><br><span class=\"line\">    views.forEach(function (view) &#123;</span><br><span class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class=\"line\">        models[modelName] = models[modelName] || new Model();</span><br><span class=\"line\">        models[modelName].bind(view);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    callback.call(this, models);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h3><p>笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。</p>\n<p>如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：</p>\n<ol>\n<li>实现对input类标签的双向绑定</li>\n<li>实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树</li>\n<li>实现view层有关dom node隐藏/显示、创建/销毁的逻辑</li>\n<li>集成virtual dom，增加dom diff的功能，提高渲染效率</li>\n<li>提供依赖注入功能，实现控制反转</li>\n<li>对innerHTML的赋值内容进行安全检查，防止恶意注入</li>\n<li>实现model collection的逻辑，这里每个model只有一个值</li>\n<li>利用es5中的setter改变set方法的实现，使得对model的修改更加简单</li>\n<li>在view层中增加对属性和css的控制<br>10.支持类似AngularJS中双大括号的语法，只绑定部分html<br>……</li>\n</ol>\n<p>一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈</p>\n<p><a href=\"http://www.codeceo.com/article/30-line-javascript-mvc.html\" target=\"_blank\" rel=\"external\">转载地址</a></p>\n","excerpt":"","more":"<p>从09年左右开始，MVC逐渐在前端领域大放异彩，并终于在刚刚过去的2015年随着React Native的推出而迎来大爆发：AngularJS、EmberJS、Backbone、ReactJS、RiotJS、VueJS…… 一连串的名字走马观花式的出现和更迭，它们中一些已经渐渐淡出了大家的视野，一些还在迅速茁壮成长，一些则已经在特定的生态环境中独当一面舍我其谁。但不论如何，MVC已经并将持续深刻地影响前端工程师们的思维方式和工作方法。</p>\n<p>很多讲解MVC的例子都从一个具体的框架的某个概念入手，比如Backbone的collection或AngularJS中model，这当然不失为一个好办法。但框架之所以是框架，而不是类库（jQuery）或者工具集（Underscore），就是因为它们的背后有着众多优秀的设计理念和最佳实践，这些设计精髓相辅相成，环环相扣，缺一不可，要想在短时间内透过复杂的框架而看到某一种设计模式的本质并非是一件容易的事。</p>\n<p>这便是这篇随笔的由来——为了帮助大家理解概念而生的原型代码，应该越简单越好，简单到刚刚足以大家理解这个概念就够了。</p>\n<h3 id=\"1-MVC的基础是观察者模式，这是实现model和view同步的关键\"><a href=\"#1-MVC的基础是观察者模式，这是实现model和view同步的关键\" class=\"headerlink\" title=\"1. MVC的基础是观察者模式，这是实现model和view同步的关键\"></a>1. MVC的基础是观察者模式，这是实现model和view同步的关键</h3><p>为了简单起见，每个model实例中只包含一个primitive value值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Model(value) &#123;</span><br><span class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class=\"line\">    this._listeners = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Model.prototype.set = function (value) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self._value = value;</span><br><span class=\"line\">    // model中的值改变时，应通知注册过的回调函数</span><br><span class=\"line\">    // 按照Javascript事件处理的一般机制，我们异步地调用回调函数</span><br><span class=\"line\">    // 如果觉得setTimeout影响性能，也可以采用requestAnimationFrame</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        self._listeners.forEach(function (listener) &#123;</span><br><span class=\"line\">            listener.call(self, value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.watch = function (listener) &#123;</span><br><span class=\"line\">    // 注册监听的回调函数</span><br><span class=\"line\">    this._listeners.push(listener);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// html代码：</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var model = new Model();</span><br><span class=\"line\">    var div1 = document.getElementById(&apos;div1&apos;);</span><br><span class=\"line\">    model.watch(function (value) &#123;</span><br><span class=\"line\">        div1.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    model.set(&apos;hello, this is a div&apos;);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>借助观察者模式，我们已经实现了在调用model的set方法改变其值的时候，模板也同步更新，但这样的实现却很别扭，因为我们需要手动监听model值的改变（通过watch方法）并传入一个回调函数，有没有办法让view（一个或多个dom node）和model更简单的绑定呢？</p>\n<h3 id=\"2-实现bind方法，绑定model和view\"><a href=\"#2-实现bind方法，绑定model和view\" class=\"headerlink\" title=\"2. 实现bind方法，绑定model和view\"></a>2. 实现bind方法，绑定model和view</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Model.prototype.bind = function (node) &#123;</span><br><span class=\"line\">    // 将watch的逻辑和通用的回调函数放到这里</span><br><span class=\"line\">    this.watch(function (value) &#123;</span><br><span class=\"line\">        node.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// html代码：</span><br><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">    var model = new Model();</span><br><span class=\"line\">    model.bind(document.getElementById(&apos;div1&apos;));</span><br><span class=\"line\">    model.bind(document.getElementById(&apos;div2&apos;));</span><br><span class=\"line\">    model.set(&apos;this is a div&apos;);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>通过一个简单的封装，view和model之间的绑定已经初见雏形，即使需要绑定多个view，实现起来也很轻松。注意bind是Function类prototype上的一个原生方法，不过它和MVC的关系并不紧密，笔者又实在太喜欢bind这个单词，一语中的，言简意赅，所以索性在这里把原生方法覆盖了，大家可以忽略。言归正传，虽然绑定的复杂度降低了，这一步依然要依赖我们手动完成，有没有可能把绑定的逻辑从业务代码中彻底解耦呢？</p>\n<h3 id=\"3-实现controller，将绑定从逻辑代码中解耦\"><a href=\"#3-实现controller，将绑定从逻辑代码中解耦\" class=\"headerlink\" title=\"3. 实现controller，将绑定从逻辑代码中解耦\"></a>3. 实现controller，将绑定从逻辑代码中解耦</h3><p>细心的朋友可能已经注意到，虽然讲的是MVC，但是上文中却只出现了Model类，View类不出现可以理解，毕竟HTML就是现成的View（事实上本文中从始至终也只是利用HTML作为View，javascript代码中并没有出现过View类），那Controller类为何也隐身了呢？别急，其实所谓的”逻辑代码”就是一个框架逻辑（姑且将本文的原型玩具称之为框架）和业务逻辑耦合度很高的代码段，现在我们就来将它分解一下。</p>\n<p>如果要将绑定的逻辑交给框架完成，那么就需要告诉框架如何来完成绑定。由于JS中较难完成annotation（注解），我们可以在view中做这层标记——使用html的标签属性就是一个简单有效的办法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Controller(callback) &#123;</span><br><span class=\"line\">    var models = &#123;&#125;;</span><br><span class=\"line\">    // 找到所有有bind属性的元素</span><br><span class=\"line\">    var views = document.querySelectorAll(&apos;[bind]&apos;);</span><br><span class=\"line\">    // 将views处理为普通数组</span><br><span class=\"line\">    views = Array.prototype.slice.call(views, 0);</span><br><span class=\"line\">    views.forEach(function (view) &#123;</span><br><span class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class=\"line\">        // 取出或新建该元素所绑定的model</span><br><span class=\"line\">        models[modelName] = models[modelName] || new Model();</span><br><span class=\"line\">        // 完成该元素和指定model的绑定</span><br><span class=\"line\">        models[modelName].bind(view);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    // 调用controller的具体逻辑，将models传入，方便业务处理</span><br><span class=\"line\">    callback.call(this, models);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// html:</span><br><span class=\"line\">&lt;div id=&quot;div1&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div id=&quot;div2&quot; bind=&quot;model1&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">// 逻辑代码：</span><br><span class=\"line\">new Controller(function (models) &#123;</span><br><span class=\"line\">    var model1 = models.model1;</span><br><span class=\"line\">    model1.set(&apos;this is a div&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>就这么简单吗？就这么简单。MVC的本质就是在controller中完成业务逻辑，并对model进行修改，同时model的改变引起view的自动更新，这些逻辑在上面的代码中都有所体现，并且支持多个view、多个model。虽然不足以用于生产项目，但是希望对大家的MVC学习多少有些帮助。</p>\n<p>整理后去掉注释的”框架”代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Model(value) &#123;</span><br><span class=\"line\">    this._value = typeof value === &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class=\"line\">    this._listeners = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Model.prototype.set = function (value) &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self._value = value;</span><br><span class=\"line\">    setTimeout(function () &#123;</span><br><span class=\"line\">        self._listeners.forEach(function (listener) &#123;</span><br><span class=\"line\">            listener.call(self, value);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.watch = function (listener) &#123;</span><br><span class=\"line\">    this._listeners.push(listener);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Model.prototype.bind = function (node) &#123;</span><br><span class=\"line\">    this.watch(function (value) &#123;</span><br><span class=\"line\">        node.innerHTML = value;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Controller(callback) &#123;</span><br><span class=\"line\">    var models = &#123;&#125;;</span><br><span class=\"line\">    var views = Array.prototype.slice.call(document.querySelectorAll(&apos;[bind]&apos;), 0);</span><br><span class=\"line\">    views.forEach(function (view) &#123;</span><br><span class=\"line\">        var modelName = view.getAttribute(&apos;bind&apos;);</span><br><span class=\"line\">        models[modelName] = models[modelName] || new Model();</span><br><span class=\"line\">        models[modelName].bind(view);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    callback.call(this, models);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"后记：\"><a href=\"#后记：\" class=\"headerlink\" title=\"后记：\"></a>后记：</h3><p>笔者在学习Flux和redux的过程中，虽然掌握了工具的使用方法，但只是知其然而不知其所以然，对ReactJS官方文档中一直强调的 “Flux eschews MVC in favor of a unidirectional data flow” 不甚理解，始终觉得单向数据流和MVC并不冲突，不明白为什么在ReactJS的文档中这二者会被对立起来，有他无我，有我无他（eschew，避开）。终于下定决心，回到MVC的定义上重新研究，虽然平日工作里大大咧咧复制粘贴，但是咱们偶尔也得任性一把，咬文嚼字一番，对吧？这样的方式也的确帮助了我对于这句话的理解，这里可以把自己的思考分享给大家：之所以觉得MVC和flux中的单向数据流相似，可能是因为没有区分清楚MVC和观察者模式的关系造成的——MVC是基于观察者模式的，flux也是，因此这种相似性的由来是观察者模式，而不是MVC和flux本身。这样的理解也在四人组的设计模式原著中得到了印证：”The first and perhaps best-known example of the Observer pattern appears in Smalltalk Model/View/Controller (MVC), the user interface framework in the Smalltalk environment [KP88]. MVC’s Model class plays the role of Subject, while View is the base class for observers. ”。</p>\n<p>如果读者有兴趣在这样一个原型玩具的基础上继续拓展，可以参考下面的一些方向：</p>\n<ol>\n<li>实现对input类标签的双向绑定</li>\n<li>实现对controller所控制的scope的精准控制，这里一个controller就控制了整个dom树</li>\n<li>实现view层有关dom node隐藏/显示、创建/销毁的逻辑</li>\n<li>集成virtual dom，增加dom diff的功能，提高渲染效率</li>\n<li>提供依赖注入功能，实现控制反转</li>\n<li>对innerHTML的赋值内容进行安全检查，防止恶意注入</li>\n<li>实现model collection的逻辑，这里每个model只有一个值</li>\n<li>利用es5中的setter改变set方法的实现，使得对model的修改更加简单</li>\n<li>在view层中增加对属性和css的控制<br>10.支持类似AngularJS中双大括号的语法，只绑定部分html<br>……</li>\n</ol>\n<p>一个完善的框架要经过无数的提炼和修改，这里只是最初最初的第一步，不过别忘了，我们的征程是星辰大海，哈哈</p>\n<p><a href=\"http://www.codeceo.com/article/30-line-javascript-mvc.html\">转载地址</a></p>\n"},{"title":"12种不宜使用的Javascript语法","date":"2015-04-18T16:00:00.000Z","_content":"\n### 1、==\n\nJavascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。\n请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：\n\n```\nfalse == 'false'\nfalse == undefined\nfalse == null\nnull == undefined\n0 == ''\n```\n\n前三个是false，后两个是true。\n\n### 2、with\n\nwith的本意是减少键盘输入。比如\n\n```\nobj.a = obj.b;\nobj.c = obj.d;\n```\n\n可以简写成\n\n```\nwith(obj) {\n　　a = b;\n　　c = d;\n}\n```\n\n但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。\n\n### 3、eval\n\neval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。\n\neval能够做到的事情，不用它也能做到。比如\n\n```\neval(\"myValue = myObject.\" + myKey + \";\");\n```\n\n可以直接写成\n\n```\nmyValue = myObject[myKey];\n```\n\n至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行\n\n### 4、continue\n\n这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。\n\n### 5、switch 贯穿\n\nswitch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如\n\n```\nswitch(n) {\n　　case 1:\n　　case 2:\n　　　　break;\n}\n```\n\n这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。\n\n```\nswitch(n) {\n　　case 1:\n　　　　break;\n　　case 2:\n　　　　break;\n}\n```\n\n### 6、单行的块结构\n\nif、while、do和for，都是块结构语句，但是也可以接受单行命令。比如\n\n```\nif (ok) t = true;\n```\n\n甚至写成\n\n```\nif (ok)\n　　t = true;\n```\n\n这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。\n\n```\nif (ok){\n　　t = true;\n}\n```\n\n### 7、++和--\n\n递增运算符++和递减运算符--，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。\n\n### 8、位运算符\n\nJavascript完全套用了Java的位运算符，包括按位与&、按位或|、按位异或^、按位非~、左移<<、带符号的右移>>和用0补足的右移>>>。\n\n这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且\"按位与运算符\"&同\"逻辑与运算符\"&&，很容易混淆。\n\n### 9、function语句\n\n在Javascript中定义一个函数，有两种写法：\n\n```\nfunction foo() { }\n```\n\n和\n\n```\nvar foo = function () { }\n```\n\n两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。\n\n### 10、基本数据类型的包装对象\n\nJavascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：\n\n```\nnew String(\"Hello World\");\nnew Number(2000);\nnew Boolean(false);\n```\n\n这样写完全没有必要，而且非常费解，因此建议不要使用。\n\n另外，new Object和new Array也不建议使用，可以用{}和[]代替。\n\n### 11、new语句\n\nJavascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。\n\n类是这样定义的：\n\n```\nvar Cat = function (name) {\n　　this.name = name;\n　　this.saying = 'meow' ;\n}\n```\n\n然后，再生成一个对象\n\n```\nvar myCat = new Cat('mimi');\n```\n\n这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。\n\nDouglas Crockford给出了一个函数：\n\n```\nObject.beget = function (o) {\n　　var F = function (o) {};\n　　F.prototype = o ;\n　　return new F;\n};\n```\n\n创建对象时就利用这个函数，对原型对象进行操作：\n\n```\nvar Cat = {\n　　name:'',\n　　saying:'meow'\n};\nvar myCat = Object.beget(Cat);\n```\n\n对象生成后，可以自行对相关属性进行赋值：\n\n```\nmyCat.name = 'mimi';\n```\n\n### 12、void\n\n在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。\n\n```\nvoid 0; // undefined\n```\n\n这个命令没什么用，而且很令人困惑，建议避免使用。\n","source":"_posts/12种不宜使用的Javascript语法.md","raw":"---\ntitle: 12种不宜使用的Javascript语法\ntags: [javascript]\ndate: 2015/04/19\n---\n\n### 1、==\n\nJavascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。\n请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：\n\n```\nfalse == 'false'\nfalse == undefined\nfalse == null\nnull == undefined\n0 == ''\n```\n\n前三个是false，后两个是true。\n\n### 2、with\n\nwith的本意是减少键盘输入。比如\n\n```\nobj.a = obj.b;\nobj.c = obj.d;\n```\n\n可以简写成\n\n```\nwith(obj) {\n　　a = b;\n　　c = d;\n}\n```\n\n但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。\n\n### 3、eval\n\neval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。\n\neval能够做到的事情，不用它也能做到。比如\n\n```\neval(\"myValue = myObject.\" + myKey + \";\");\n```\n\n可以直接写成\n\n```\nmyValue = myObject[myKey];\n```\n\n至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行\n\n### 4、continue\n\n这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。\n\n### 5、switch 贯穿\n\nswitch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如\n\n```\nswitch(n) {\n　　case 1:\n　　case 2:\n　　　　break;\n}\n```\n\n这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。\n\n```\nswitch(n) {\n　　case 1:\n　　　　break;\n　　case 2:\n　　　　break;\n}\n```\n\n### 6、单行的块结构\n\nif、while、do和for，都是块结构语句，但是也可以接受单行命令。比如\n\n```\nif (ok) t = true;\n```\n\n甚至写成\n\n```\nif (ok)\n　　t = true;\n```\n\n这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。\n\n```\nif (ok){\n　　t = true;\n}\n```\n\n### 7、++和--\n\n递增运算符++和递减运算符--，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。\n\n### 8、位运算符\n\nJavascript完全套用了Java的位运算符，包括按位与&、按位或|、按位异或^、按位非~、左移<<、带符号的右移>>和用0补足的右移>>>。\n\n这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且\"按位与运算符\"&同\"逻辑与运算符\"&&，很容易混淆。\n\n### 9、function语句\n\n在Javascript中定义一个函数，有两种写法：\n\n```\nfunction foo() { }\n```\n\n和\n\n```\nvar foo = function () { }\n```\n\n两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。\n\n### 10、基本数据类型的包装对象\n\nJavascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：\n\n```\nnew String(\"Hello World\");\nnew Number(2000);\nnew Boolean(false);\n```\n\n这样写完全没有必要，而且非常费解，因此建议不要使用。\n\n另外，new Object和new Array也不建议使用，可以用{}和[]代替。\n\n### 11、new语句\n\nJavascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。\n\n类是这样定义的：\n\n```\nvar Cat = function (name) {\n　　this.name = name;\n　　this.saying = 'meow' ;\n}\n```\n\n然后，再生成一个对象\n\n```\nvar myCat = new Cat('mimi');\n```\n\n这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。\n\nDouglas Crockford给出了一个函数：\n\n```\nObject.beget = function (o) {\n　　var F = function (o) {};\n　　F.prototype = o ;\n　　return new F;\n};\n```\n\n创建对象时就利用这个函数，对原型对象进行操作：\n\n```\nvar Cat = {\n　　name:'',\n　　saying:'meow'\n};\nvar myCat = Object.beget(Cat);\n```\n\n对象生成后，可以自行对相关属性进行赋值：\n\n```\nmyCat.name = 'mimi';\n```\n\n### 12、void\n\n在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。\n\n```\nvoid 0; // undefined\n```\n\n这个命令没什么用，而且很令人困惑，建议避免使用。\n","slug":"12种不宜使用的Javascript语法","published":1,"updated":"2016-05-18T06:39:11.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upj0004tsqbjf0qr6kw","content":"<h3 id=\"1、\"><a href=\"#1、\" class=\"headerlink\" title=\"1、==\"></a>1、==</h3><p>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false == &apos;false&apos;</span><br><span class=\"line\">false == undefined</span><br><span class=\"line\">false == null</span><br><span class=\"line\">null == undefined</span><br><span class=\"line\">0 == &apos;&apos;</span><br></pre></td></tr></table></figure>\n<p>前三个是false，后两个是true。</p>\n<h3 id=\"2、with\"><a href=\"#2、with\" class=\"headerlink\" title=\"2、with\"></a>2、with</h3><p>with的本意是减少键盘输入。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.a = obj.b;</span><br><span class=\"line\">obj.c = obj.d;</span><br></pre></td></tr></table></figure>\n<p>可以简写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(obj) &#123;</span><br><span class=\"line\">　　a = b;</span><br><span class=\"line\">　　c = d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p>\n<h3 id=\"3、eval\"><a href=\"#3、eval\" class=\"headerlink\" title=\"3、eval\"></a>3、eval</h3><p>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>\n<p>eval能够做到的事情，不用它也能做到。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval(&quot;myValue = myObject.&quot; + myKey + &quot;;&quot;);</span><br></pre></td></tr></table></figure>\n<p>可以直接写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myValue = myObject[myKey];</span><br></pre></td></tr></table></figure>\n<p>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行</p>\n<h3 id=\"4、continue\"><a href=\"#4、continue\" class=\"headerlink\" title=\"4、continue\"></a>4、continue</h3><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>\n<h3 id=\"5、switch-贯穿\"><a href=\"#5、switch-贯穿\" class=\"headerlink\" title=\"5、switch 贯穿\"></a>5、switch 贯穿</h3><p>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(n) &#123;</span><br><span class=\"line\">　　case 1:</span><br><span class=\"line\">　　case 2:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(n) &#123;</span><br><span class=\"line\">　　case 1:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">　　case 2:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、单行的块结构\"><a href=\"#6、单行的块结构\" class=\"headerlink\" title=\"6、单行的块结构\"></a>6、单行的块结构</h3><p>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok) t = true;</span><br></pre></td></tr></table></figure>\n<p>甚至写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok)</span><br><span class=\"line\">　　t = true;</span><br></pre></td></tr></table></figure>\n<p>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok)&#123;</span><br><span class=\"line\">　　t = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7、-和–\"><a href=\"#7、-和–\" class=\"headerlink\" title=\"7、++和–\"></a>7、++和–</h3><p>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>\n<h3 id=\"8、位运算符\"><a href=\"#8、位运算符\" class=\"headerlink\" title=\"8、位运算符\"></a>8、位运算符</h3><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。</p>\n<p>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p>\n<h3 id=\"9、function语句\"><a href=\"#9、function语句\" class=\"headerlink\" title=\"9、function语句\"></a>9、function语句</h3><p>在Javascript中定义一个函数，有两种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = function () &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>\n<h3 id=\"10、基本数据类型的包装对象\"><a href=\"#10、基本数据类型的包装对象\" class=\"headerlink\" title=\"10、基本数据类型的包装对象\"></a>10、基本数据类型的包装对象</h3><p>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new String(&quot;Hello World&quot;);</span><br><span class=\"line\">new Number(2000);</span><br><span class=\"line\">new Boolean(false);</span><br></pre></td></tr></table></figure>\n<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>\n<p>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</p>\n<h3 id=\"11、new语句\"><a href=\"#11、new语句\" class=\"headerlink\" title=\"11、new语句\"></a>11、new语句</h3><p>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。</p>\n<p>类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Cat = function (name) &#123;</span><br><span class=\"line\">　　this.name = name;</span><br><span class=\"line\">　　this.saying = &apos;meow&apos; ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，再生成一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myCat = new Cat(&apos;mimi&apos;);</span><br></pre></td></tr></table></figure>\n<p>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>\n<p>Douglas Crockford给出了一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.beget = function (o) &#123;</span><br><span class=\"line\">　　var F = function (o) &#123;&#125;;</span><br><span class=\"line\">　　F.prototype = o ;</span><br><span class=\"line\">　　return new F;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>创建对象时就利用这个函数，对原型对象进行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Cat = &#123;</span><br><span class=\"line\">　　name:&apos;&apos;,</span><br><span class=\"line\">　　saying:&apos;meow&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var myCat = Object.beget(Cat);</span><br></pre></td></tr></table></figure>\n<p>对象生成后，可以自行对相关属性进行赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myCat.name = &apos;mimi&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12、void\"><a href=\"#12、void\" class=\"headerlink\" title=\"12、void\"></a>12、void</h3><p>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void 0; // undefined</span><br></pre></td></tr></table></figure>\n<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>\n","excerpt":"","more":"<h3 id=\"1、\"><a href=\"#1、\" class=\"headerlink\" title=\"1、==\"></a>1、==</h3><p>Javascript有两组相等运算符，一组是==和!=，另一组是===和!==。前者只比较值的相等，后者除了值以外，还比较类型是否相同。<br>请尽量不要使用前一组，永远只使用===和!==。因为==默认会进行类型转换，规则十分难记。如果你不相信的话，请回答下面五个判断式的值是true还是false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">false == &apos;false&apos;</span><br><span class=\"line\">false == undefined</span><br><span class=\"line\">false == null</span><br><span class=\"line\">null == undefined</span><br><span class=\"line\">0 == &apos;&apos;</span><br></pre></td></tr></table></figure>\n<p>前三个是false，后两个是true。</p>\n<h3 id=\"2、with\"><a href=\"#2、with\" class=\"headerlink\" title=\"2、with\"></a>2、with</h3><p>with的本意是减少键盘输入。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.a = obj.b;</span><br><span class=\"line\">obj.c = obj.d;</span><br></pre></td></tr></table></figure>\n<p>可以简写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(obj) &#123;</span><br><span class=\"line\">　　a = b;</span><br><span class=\"line\">　　c = d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p>\n<h3 id=\"3、eval\"><a href=\"#3、eval\" class=\"headerlink\" title=\"3、eval\"></a>3、eval</h3><p>eval用来直接执行一个字符串。这条语句也是不应该使用的，因为它有性能和安全性的问题，并且使得代码更难阅读。</p>\n<p>eval能够做到的事情，不用它也能做到。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval(&quot;myValue = myObject.&quot; + myKey + &quot;;&quot;);</span><br></pre></td></tr></table></figure>\n<p>可以直接写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myValue = myObject[myKey];</span><br></pre></td></tr></table></figure>\n<p>至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行</p>\n<h3 id=\"4、continue\"><a href=\"#4、continue\" class=\"headerlink\" title=\"4、continue\"></a>4、continue</h3><p>这条命令的作用是返回到循环的头部，但是循环本来就会返回到头部。所以通过适当的构造，完全可以避免使用这条命令，使得效率得到改善。</p>\n<h3 id=\"5、switch-贯穿\"><a href=\"#5、switch-贯穿\" class=\"headerlink\" title=\"5、switch 贯穿\"></a>5、switch 贯穿</h3><p>switch结构中的case语句，默认是顺序执行，除非遇到break，return和throw。有的程序员喜欢利用这个特点，比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(n) &#123;</span><br><span class=\"line\">　　case 1:</span><br><span class=\"line\">　　case 2:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样写容易出错，而且难以发现。因此建议避免switch贯穿，凡是有case的地方，一律加上break。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch(n) &#123;</span><br><span class=\"line\">　　case 1:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">　　case 2:</span><br><span class=\"line\">　　　　break;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6、单行的块结构\"><a href=\"#6、单行的块结构\" class=\"headerlink\" title=\"6、单行的块结构\"></a>6、单行的块结构</h3><p>if、while、do和for，都是块结构语句，但是也可以接受单行命令。比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok) t = true;</span><br></pre></td></tr></table></figure>\n<p>甚至写成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok)</span><br><span class=\"line\">　　t = true;</span><br></pre></td></tr></table></figure>\n<p>这样不利于阅读代码，而且将来添加语句时非常容易出错。建议不管是否只有一行命令，都一律加上大括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (ok)&#123;</span><br><span class=\"line\">　　t = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7、-和–\"><a href=\"#7、-和–\" class=\"headerlink\" title=\"7、++和–\"></a>7、++和–</h3><p>递增运算符++和递减运算符–，直接来自C语言，表面上可以让代码变得很紧凑，但是实际上会让代码看上去更复杂和更晦涩。因此为了代码的整洁性和易读性，不用为好。</p>\n<h3 id=\"8、位运算符\"><a href=\"#8、位运算符\" class=\"headerlink\" title=\"8、位运算符\"></a>8、位运算符</h3><p>Javascript完全套用了Java的位运算符，包括按位与&amp;、按位或|、按位异或^、按位非~、左移&lt;&lt;、带符号的右移&gt;&gt;和用0补足的右移&gt;&gt;&gt;。</p>\n<p>这套运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数。如果使用它们的话，Javascript不得不将运算数先转为整数，然后再进行运算，这样就降低了速度。而且”按位与运算符”&amp;同”逻辑与运算符”&amp;&amp;，很容易混淆。</p>\n<h3 id=\"9、function语句\"><a href=\"#9、function语句\" class=\"headerlink\" title=\"9、function语句\"></a>9、function语句</h3><p>在Javascript中定义一个函数，有两种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = function () &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>两种写法完全等价。但是在解析的时候，前一种写法会被解析器自动提升到代码的头部，因此违背了函数应该先定义后使用的要求，所以建议定义函数时，全部采用后一种写法。</p>\n<h3 id=\"10、基本数据类型的包装对象\"><a href=\"#10、基本数据类型的包装对象\" class=\"headerlink\" title=\"10、基本数据类型的包装对象\"></a>10、基本数据类型的包装对象</h3><p>Javascript的基本数据类型包括字符串、数字、布尔值，它们都有对应的包装对象String、Number和Boolean。所以，有人会这样定义相关值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new String(&quot;Hello World&quot;);</span><br><span class=\"line\">new Number(2000);</span><br><span class=\"line\">new Boolean(false);</span><br></pre></td></tr></table></figure>\n<p>这样写完全没有必要，而且非常费解，因此建议不要使用。</p>\n<p>另外，new Object和new Array也不建议使用，可以用{}和[]代替。</p>\n<h3 id=\"11、new语句\"><a href=\"#11、new语句\" class=\"headerlink\" title=\"11、new语句\"></a>11、new语句</h3><p>Javascript是世界上第一个被大量使用的支持Lambda函数的语言，本质上属于与Lisp同类的函数式编程语言。但是当前世界，90%以上的程序员都是使用面向对象编程。为了靠近主流，Javascript做出了妥协，采纳了类的概念，允许根据类生成对象。</p>\n<p>类是这样定义的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Cat = function (name) &#123;</span><br><span class=\"line\">　　this.name = name;</span><br><span class=\"line\">　　this.saying = &apos;meow&apos; ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后，再生成一个对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myCat = new Cat(&apos;mimi&apos;);</span><br></pre></td></tr></table></figure>\n<p>这种利用函数生成类、利用new生成对象的语法，其实非常奇怪，一点都不符合直觉。而且，使用的时候，很容易忘记加上new，就会变成执行函数，然后莫名其妙多出几个全局变量。所以，建议不要这样创建对象，而采用一种变通方法。</p>\n<p>Douglas Crockford给出了一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.beget = function (o) &#123;</span><br><span class=\"line\">　　var F = function (o) &#123;&#125;;</span><br><span class=\"line\">　　F.prototype = o ;</span><br><span class=\"line\">　　return new F;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>创建对象时就利用这个函数，对原型对象进行操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var Cat = &#123;</span><br><span class=\"line\">　　name:&apos;&apos;,</span><br><span class=\"line\">　　saying:&apos;meow&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var myCat = Object.beget(Cat);</span><br></pre></td></tr></table></figure>\n<p>对象生成后，可以自行对相关属性进行赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myCat.name = &apos;mimi&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"12、void\"><a href=\"#12、void\" class=\"headerlink\" title=\"12、void\"></a>12、void</h3><p>在大多数语言中，void都是一种类型，表示没有值。但是在Javascript中，void是一个运算符，接受一个运算数，并返回undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void 0; // undefined</span><br></pre></td></tr></table></figure>\n<p>这个命令没什么用，而且很令人困惑，建议避免使用。</p>\n"},{"title":"200个纯CSS3写的图标 支持复制代码","date":"2014-04-17T16:00:00.000Z","_content":"\n这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png)\n\n网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png)\n\n这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！\n\n传送门：[CSS3 Icons](http://www.uiplayground.in/css3-icons/)\n","source":"_posts/200个纯CSS3写的图标 支持复制代码.md","raw":"---\ntitle: 200个纯CSS3写的图标 支持复制代码\ntags: [css]\ndate: 2014/04/18\n---\n\n这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png)\n\n网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。\n\n![img](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png)\n\n[大图](http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png)\n\n这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！\n\n传送门：[CSS3 Icons](http://www.uiplayground.in/css3-icons/)\n","slug":"200个纯CSS3写的图标 支持复制代码","published":1,"updated":"2016-05-18T06:42:35.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upl0006tsqb9makq0yh","content":"<p>这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png\" target=\"_blank\" rel=\"external\">大图</a></p>\n<p>网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png\" target=\"_blank\" rel=\"external\">大图</a></p>\n<p>这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！</p>\n<p>传送门：<a href=\"http://www.uiplayground.in/css3-icons/\" target=\"_blank\" rel=\"external\">CSS3 Icons</a></p>\n","excerpt":"","more":"<p>这次给大家介绍一个CSS3图标网站，这个网站包含了200个纯CSS3写的图标，用户可以自动复制来研究。因为目前扁平化设计越来越流行，再加有些用Retina分辨率的显示器，使用CSS3来作为图标确实是很不错的方案，当然也可以用图标字体来制作，但没CSS3画出来方便。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons.png\">大图</a></p>\n<p>网站有很200+的纯CSS3图标，用户只需要点击对应的图标就会弹出一段CSS代码，只要您复制过去就能使用了，而且有很多很实用的。</p>\n<p><img src=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show-300x150.png\" alt=\"img\"></p>\n<p><a href=\"http://23.244.200.48/wp-content/uploads/2014/07/css3-icons-show.png\">大图</a></p>\n<p>这些对于前端人员来说，用来学习和研究CSS3也是不错的选择。相查看更多CSS3图标？请点击下面的传送门链接！</p>\n<p>传送门：<a href=\"http://www.uiplayground.in/css3-icons/\">CSS3 Icons</a></p>\n"},{"title":"5个经典的前端面试问题","date":"2014-10-26T16:00:00.000Z","_content":"\n###问题1：Scope作用范围\n\n考虑下面的代码：\n\n```\n(function() {\n   var a = b = 5;\n})();\n\nconsole.log(b);\n```\n\n什么会被打印在控制台上？\n\n回答\n\n上面的代码会打印 5。\n\n这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。\n\n这个问题的另一个诀窍是，它没有使用严格模式 ('use strict';) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：\n\n```\n(function() {\n   'use strict';\n   var a = window.b = 5;\n})();\n \nconsole.log(b);\n```\n\n###问题2：创建“原生”（native）方法\n\n给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：\n\n```\nconsole.log('hello'.repeatify(3));\n```\n\n应打印 hellohellohello。\n\n回答\n\n一个可能的实现如下所示：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {\n   var str = '';\n   for (var i = 0; i < times; i++) {\n      str += this;\n   }\n   return str;\n};\n```\n\n现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。\n\n这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {/* code here */};\n```\n\n当你被要求做好JavaScript函数兼容时这种技术特别有用。\n\n###问题3：声明提升（Hoisting）\n\n执行这段代码，输出什么结果。\n\n```\nfunction test() {\n   console.log(a);\n   console.log(foo());\n   var a = 1;\n   function foo() {\n      return 2;\n   }\n}\n \ntest();\n```\n\n回答\n\n这段代码的结果是 undefined 和 2。\n\n原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：\n\n```\nfunction test() {\n   var a;\n   function foo() {\n      return 2;\n   }\n  \n   console.log(a);\n   console.log(foo());\n     \n   a = 1;\n}\n  \ntest();\n```\n\n###问题4：this在JavaScript中如何工作的\n\n面的代码会输出什么结果？给出你的答案。\n\n```\nvar fullname = 'John Doe';\nvar obj = {\n   fullname: 'Colin Ihrig',\n   prop: {\n      fullname: 'Aurelio De Rosa',\n      getFullname: function() {\n         return this.fullname;\n      }\n   }\n};\n \nconsole.log(obj.prop.getFullname());\n  \nvar test = obj.prop.getFullname;\n  \nconsole.log(test());\n```\n\n回答\n\n答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。\n\n在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。\n\n###问题5：call() 和 apply()\n\n现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。\n\n回答\n\n该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：\n\n```\nconsole.log(test.call(obj.prop));\n```\n\n###结论\n\n在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。\n\n如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。\n\n来源：[http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html](http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html)\n","source":"_posts/5个经典的前端面试问题.md","raw":"---\ntitle: 5个经典的前端面试问题\ntags: [javascript]\ndate: 2014/10/27\n---\n\n###问题1：Scope作用范围\n\n考虑下面的代码：\n\n```\n(function() {\n   var a = b = 5;\n})();\n\nconsole.log(b);\n```\n\n什么会被打印在控制台上？\n\n回答\n\n上面的代码会打印 5。\n\n这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。\n\n这个问题的另一个诀窍是，它没有使用严格模式 ('use strict';) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：\n\n```\n(function() {\n   'use strict';\n   var a = window.b = 5;\n})();\n \nconsole.log(b);\n```\n\n###问题2：创建“原生”（native）方法\n\n给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：\n\n```\nconsole.log('hello'.repeatify(3));\n```\n\n应打印 hellohellohello。\n\n回答\n\n一个可能的实现如下所示：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {\n   var str = '';\n   for (var i = 0; i < times; i++) {\n      str += this;\n   }\n   return str;\n};\n```\n\n现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。\n\n这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：\n\n```\nString.prototype.repeatify = String.prototype.repeatify || function(times) {/* code here */};\n```\n\n当你被要求做好JavaScript函数兼容时这种技术特别有用。\n\n###问题3：声明提升（Hoisting）\n\n执行这段代码，输出什么结果。\n\n```\nfunction test() {\n   console.log(a);\n   console.log(foo());\n   var a = 1;\n   function foo() {\n      return 2;\n   }\n}\n \ntest();\n```\n\n回答\n\n这段代码的结果是 undefined 和 2。\n\n原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：\n\n```\nfunction test() {\n   var a;\n   function foo() {\n      return 2;\n   }\n  \n   console.log(a);\n   console.log(foo());\n     \n   a = 1;\n}\n  \ntest();\n```\n\n###问题4：this在JavaScript中如何工作的\n\n面的代码会输出什么结果？给出你的答案。\n\n```\nvar fullname = 'John Doe';\nvar obj = {\n   fullname: 'Colin Ihrig',\n   prop: {\n      fullname: 'Aurelio De Rosa',\n      getFullname: function() {\n         return this.fullname;\n      }\n   }\n};\n \nconsole.log(obj.prop.getFullname());\n  \nvar test = obj.prop.getFullname;\n  \nconsole.log(test());\n```\n\n回答\n\n答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。\n\n在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。\n\n###问题5：call() 和 apply()\n\n现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。\n\n回答\n\n该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：\n\n```\nconsole.log(test.call(obj.prop));\n```\n\n###结论\n\n在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。\n\n如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。\n\n来源：[http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html](http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html)\n","slug":"5个经典的前端面试问题","published":1,"updated":"2016-05-18T06:27:16.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upr0008tsqbgopa130q","content":"<p>###问题1：Scope作用范围</p>\n<p>考虑下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">   var a = b = 5;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b);</span><br></pre></td></tr></table></figure>\n<p>什么会被打印在控制台上？</p>\n<p>回答</p>\n<p>上面的代码会打印 5。</p>\n<p>这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>\n<p>这个问题的另一个诀窍是，它没有使用严格模式 (‘use strict’;) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">   &apos;use strict&apos;;</span><br><span class=\"line\">   var a = window.b = 5;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(b);</span><br></pre></td></tr></table></figure>\n<p>###问题2：创建“原生”（native）方法</p>\n<p>给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;hello&apos;.repeatify(3));</span><br></pre></td></tr></table></figure>\n<p>应打印 hellohellohello。</p>\n<p>回答</p>\n<p>一个可能的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;</span><br><span class=\"line\">   var str = &apos;&apos;;</span><br><span class=\"line\">   for (var i = 0; i &lt; times; i++) &#123;</span><br><span class=\"line\">      str += this;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。</p>\n<p>这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;/* code here */&#125;;</span><br></pre></td></tr></table></figure>\n<p>当你被要求做好JavaScript函数兼容时这种技术特别有用。</p>\n<p>###问题3：声明提升（Hoisting）</p>\n<p>执行这段代码，输出什么结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">   console.log(a);</span><br><span class=\"line\">   console.log(foo());</span><br><span class=\"line\">   var a = 1;</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">      return 2;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>回答</p>\n<p>这段代码的结果是 undefined 和 2。</p>\n<p>原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">   var a;</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">      return 2;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   console.log(a);</span><br><span class=\"line\">   console.log(foo());</span><br><span class=\"line\">     </span><br><span class=\"line\">   a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>###问题4：this在JavaScript中如何工作的</p>\n<p>面的代码会输出什么结果？给出你的答案。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fullname = &apos;John Doe&apos;;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   fullname: &apos;Colin Ihrig&apos;,</span><br><span class=\"line\">   prop: &#123;</span><br><span class=\"line\">      fullname: &apos;Aurelio De Rosa&apos;,</span><br><span class=\"line\">      getFullname: function() &#123;</span><br><span class=\"line\">         return this.fullname;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(obj.prop.getFullname());</span><br><span class=\"line\">  </span><br><span class=\"line\">var test = obj.prop.getFullname;</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(test());</span><br></pre></td></tr></table></figure>\n<p>回答</p>\n<p>答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。</p>\n<p>在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。</p>\n<p>###问题5：call() 和 apply()</p>\n<p>现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。</p>\n<p>回答</p>\n<p>该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(test.call(obj.prop));</span><br></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。</p>\n<p>如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。</p>\n<p>来源：<a href=\"http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html</a></p>\n","excerpt":"","more":"<p>###问题1：Scope作用范围</p>\n<p>考虑下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">   var a = b = 5;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(b);</span><br></pre></td></tr></table></figure>\n<p>什么会被打印在控制台上？</p>\n<p>回答</p>\n<p>上面的代码会打印 5。</p>\n<p>这个问题的诀窍是，这里有两个变量声明，但 a 使用关键字var声明的。代表它是一个函数的局部变量。与此相反，b 变成了全局变量。</p>\n<p>这个问题的另一个诀窍是，它没有使用严格模式 (‘use strict’;) 。如果启用了严格模式，代码就会引发ReferenceError的错误：B没有定义（b is not defined）。请记住，严格模式，则需要明确指定，才能实现全局变量声明。比如，你应该写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">   &apos;use strict&apos;;</span><br><span class=\"line\">   var a = window.b = 5;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(b);</span><br></pre></td></tr></table></figure>\n<p>###问题2：创建“原生”（native）方法</p>\n<p>给字符串对象定义一个repeatify功能。当传入一个整数n时，它会返回重复n次字符串的结果。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;hello&apos;.repeatify(3));</span><br></pre></td></tr></table></figure>\n<p>应打印 hellohellohello。</p>\n<p>回答</p>\n<p>一个可能的实现如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;</span><br><span class=\"line\">   var str = &apos;&apos;;</span><br><span class=\"line\">   for (var i = 0; i &lt; times; i++) &#123;</span><br><span class=\"line\">      str += this;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   return str;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>现在的问题测试开发者有关JavaScript继承和prototype的知识点。这也验证了开发者是否知道该如果扩展内置对象（尽管这不应该做的）。</p>\n<p>这里的另一个要点是，你要知道如何不覆盖可能已经定义的功能。通过测试一下该功能定义之前并不存在：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String.prototype.repeatify = String.prototype.repeatify || function(times) &#123;/* code here */&#125;;</span><br></pre></td></tr></table></figure>\n<p>当你被要求做好JavaScript函数兼容时这种技术特别有用。</p>\n<p>###问题3：声明提升（Hoisting）</p>\n<p>执行这段代码，输出什么结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">   console.log(a);</span><br><span class=\"line\">   console.log(foo());</span><br><span class=\"line\">   var a = 1;</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">      return 2;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>回答</p>\n<p>这段代码的结果是 undefined 和 2。</p>\n<p>原因是，变量和函数的声明都被提前了（移到了函数的顶部），但变量不分配任何值。因此，在打印变量的时候，它在函数中存在（它被声明了），但它仍然是 undefined 。表示换句话说，上面的代码等同于以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test() &#123;</span><br><span class=\"line\">   var a;</span><br><span class=\"line\">   function foo() &#123;</span><br><span class=\"line\">      return 2;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   console.log(a);</span><br><span class=\"line\">   console.log(foo());</span><br><span class=\"line\">     </span><br><span class=\"line\">   a = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure>\n<p>###问题4：this在JavaScript中如何工作的</p>\n<p>面的代码会输出什么结果？给出你的答案。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fullname = &apos;John Doe&apos;;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">   fullname: &apos;Colin Ihrig&apos;,</span><br><span class=\"line\">   prop: &#123;</span><br><span class=\"line\">      fullname: &apos;Aurelio De Rosa&apos;,</span><br><span class=\"line\">      getFullname: function() &#123;</span><br><span class=\"line\">         return this.fullname;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(obj.prop.getFullname());</span><br><span class=\"line\">  </span><br><span class=\"line\">var test = obj.prop.getFullname;</span><br><span class=\"line\">  </span><br><span class=\"line\">console.log(test());</span><br></pre></td></tr></table></figure>\n<p>回答</p>\n<p>答案是Aurelio De Rosa和John Doe。原因是，在一个函数中，this的行为，取决于JavaScript函数的调用方式和定义方式，而不仅仅是看它如何被定义的。</p>\n<p>在第一个 console.log()调用中，getFullname() 被调用作为obj.prop对象的函数。所以，上下文指的是后者，函数返回该对象的fullname。与此相反，当getFullname()被分配到test变量时，上下文指的是全局对象（window）。这是因为test是被隐式设置为全局对象的属性。出于这个原因，该函数返回window的fullname，即定义在第一行的那个值。</p>\n<p>###问题5：call() 和 apply()</p>\n<p>现在让你解决前一个问题，使最后的console.log() 打印 Aurelio De Rosa。</p>\n<p>回答</p>\n<p>该问题可以通过强制使用 call() 或者 apply() 改变函数上下文。在下面我将使用call()，但在这种情况下，apply()会输出相同的结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(test.call(obj.prop));</span><br></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>在这篇文章中，我们已经讨论了用来测试JavaScript开发者的五个经典问题。面试的概念和涵盖的主题通常是非常相似的。如果你不知道的一些问题的答案，不必担心：学习和经验可以慢慢积累。</p>\n<p>如果你有其他一些有趣的问题，不要犹豫，与我们分享。它会帮助很多开发者。</p>\n<p>来源：<a href=\"http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html\">http://www.cnblogs.com/tianzhi9885/archive/2014/10/27/4053055.html</a></p>\n"},{"title":"AngularJS开发人员最常犯的10个错误","date":"2016-04-16T16:00:00.000Z","_content":"\n### 简介\n\nAngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。\n\n### 1. MVC目录结构\n\nAngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：\n\n```\ntemplates/\n    _login.html\n    _feed.html\napp/\n    app.js\n    controllers/\n        LoginController.js\n        FeedController.js\n    directives/\n        FeedEntryDirective.js\n    services/\n        LoginService.js\n        FeedService.js\n    filters/\n        CapatalizeFilter.js\n```\n\n看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。\n\n与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：\n\n```\napp/\n    app.js\n    Feed/\n        _feed.html\n        FeedController.js\n        FeedEntryDirective.js\n        FeedService.js\n    Login/\n        _login.html\n        LoginController.js\n        LoginService.js\n    Shared/\n        CapatalizeFilter.js\n```\n\n这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。\n\n### 2. 模块\n\n将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。\n\n```\nvar app = angular.module('app',[]);\napp.service('MyService', function(){\n    \n//service code\n});\napp.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n```\n\n在此之后，一个常见的策略是对相同类型的对象归类。\n\n```\nvar services = angular.module('services',[]);\nservices.service('MyService', function(){\n    \n//service code\n});\n \nvar controllers = angular.module('controllers',['services']);\ncontrollers.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n \nvar app = angular.module('app',['controllers', 'services']);\n```\n\n这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。\n\n```\nvar sharedServicesModule = angular.module('sharedServices',[]);\nsharedServices.service('NetworkService', function($http){});\n \nvar loginModule = angular.module('login',['sharedServices']);\nloginModule.service('loginService', function(NetworkService){});\nloginModule.controller('loginCtrl', function($scope, loginService){});\n \nvar app = angular.module('app', ['sharedServices', 'login']);\n```\n\n当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。\n\n### 3. 依赖注入\n\n依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：\n\n```\nvar app = angular.module('app',[]);\n \napp.controller('MainCtrl', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n});\n```\n\n这里，很明显，MainCtrl依赖$scope和$timeout。\n\n直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：\n\n```\nvar app=angular.module(\"app\",[]);\napp.controller(\"MainCtrl\",function(e,t){t(function(){console.log(e)},1e3)})\n```\n\n现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。\n\n```\napp.controller('MainCtrl', ['$scope', '$timeout', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n}]);\n```\n\n这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：\n\n```\napp.controller(\"MainCtrl\",[\"$scope\",\"$timeout\",function(e,t){t(function(){console.log(e)},1e3)}])\n```\n\n**3.1 全局依赖**\n\n在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。\n\n使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。\n\nUnderscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：\n\n```\nvar underscore = angular.module('underscore', []);\nunderscore.factory('_', function() {\n  return window._; \n//Underscore must already be loaded on the page\n});\nvar app = angular.module('app', ['underscore']);\n \napp.controller('MainCtrl', ['$scope', '_', function($scope, _) {\n    init = function() {\n          _.keys($scope);\n      }\n \n      init();\n}]);\n```\n\n这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。\n\n这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。\n\n### 4. 控制器膨胀\n\n控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。\n\n数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。\n\nAngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。\n\n### 5. Service vs Factory\n\n几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！\n\n以下是它们在AngularJS源代码中的定义：\n\n```\nfunction factory(name, factoryFn) { \n    return provider(name, { $get: factoryFn }); \n}\n \nfunction service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n}\n```\n\n从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。\n\n由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。\n\n以下是一个例子，展示了一个service和一个factory如何完成相同的事情：\n\n```\nvar app = angular.module('app',[]);\n \napp.service('helloWorldService', function(){\n    this.hello = function() {\n        return \"Hello World\";\n    };\n});\n \napp.factory('helloWorldFactory', function(){\n    return {\n        hello: function() {\n            return \"Hello World\";\n        }\n    }\n});\n```\n\n当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。\n\n既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。\n\n```\napp.factory('helloFactory', function() {\n    return function(name) {\n        this.name = name;\n \n        this.hello = function() {\n            return \"Hello \" + this.name;\n        };\n    };\n});\n```\n\n这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。\n\n```\napp.controller('helloCtrl', function($scope, helloWorldService, helloWorldFactory, helloFactory) {\n    init = function() {\n      helloWorldService.hello(); \n//'Hello World'\n      helloWorldFactory.hello(); \n//'Hello World'\n      new helloFactory('Readers').hello() \n//'Hello Readers'\n    }\n \n    init();\n});\n```\n\n在初学时，最好只使用service。\n\nFactory在设计一个包含很多私有方法的类时也很有用：\n\n```\napp.factory('privateFactory', function(){\n    var privateFunc = function(name) {\n        return name.split(\"\").reverse().join(\"\"); \n//reverses the name\n    };\n \n    return {\n        hello: function(name){\n          return \"Hello \" + privateFunc(name);\n        }\n    };\n});\n```\n\n通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。\n\n### 6. 没有使用Batarang\n\nBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。\n\nBatarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。\n\nBatarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。\n\n最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。\n\n### 7. 过多的watcher\n\n在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）\n\n以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：\n\n```\n(function () { \n    var root = $(document.getElementsByTagName('body'));\n    var watchers = [];\n \n    var f = function (element) {\n        if (element.data().hasOwnProperty('$scope')) {\n            angular.forEach(element.data().$scope.$$watchers, function (watcher) {\n                watchers.push(watcher);\n            });\n        }\n \n        angular.forEach(element.children(), function (childElement) {\n            f($(childElement));\n        });\n    };\n \n    f(root);\n \n    console.log(watchers.length);\n})();\n```\n\n通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。\n\n当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。\n\n### 8. 限定$scope的范围\n\nJavascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）\n\n由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。\n\n比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user}}</span>\n        <input ng-model=\"user\"></input>\n   </div>\n</div>\n```\n\n那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？\n\n如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。\n\n当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）\n\n所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user.name}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user.name}}</span>\n        <input ng-model=\"user.name\"></input>\n   </div>\n</div>\n```\n\n现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。\n\n这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。\n\n### 9. 手工测试\n\n由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。\n\n不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。\n\n**9.1 Protractor**\n\n单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。\n\n我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。\n\nProtractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。\n\n我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。\n\n**9.2 Karma**\n\n一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。\n\nKarma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。\n\n### 10. 使用jQuery\n\njQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。\n\nAngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。\n\n为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。\n\nDOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。\n\n但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。\n\n### 结论\n\nAngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。\n","source":"_posts/AngularJS开发人员最常犯的10个错误.md","raw":"---\ntitle: AngularJS开发人员最常犯的10个错误\ntags: [javascript,angularjs]\ndate: 2016/04/17\n---\n\n### 简介\n\nAngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。\n\n### 1. MVC目录结构\n\nAngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：\n\n```\ntemplates/\n    _login.html\n    _feed.html\napp/\n    app.js\n    controllers/\n        LoginController.js\n        FeedController.js\n    directives/\n        FeedEntryDirective.js\n    services/\n        LoginService.js\n        FeedService.js\n    filters/\n        CapatalizeFilter.js\n```\n\n看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。\n\n与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：\n\n```\napp/\n    app.js\n    Feed/\n        _feed.html\n        FeedController.js\n        FeedEntryDirective.js\n        FeedService.js\n    Login/\n        _login.html\n        LoginController.js\n        LoginService.js\n    Shared/\n        CapatalizeFilter.js\n```\n\n这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。\n\n### 2. 模块\n\n将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。\n\n```\nvar app = angular.module('app',[]);\napp.service('MyService', function(){\n    \n//service code\n});\napp.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n```\n\n在此之后，一个常见的策略是对相同类型的对象归类。\n\n```\nvar services = angular.module('services',[]);\nservices.service('MyService', function(){\n    \n//service code\n});\n \nvar controllers = angular.module('controllers',['services']);\ncontrollers.controller('MyCtrl', function($scope, MyService){\n    \n//controller code\n});\n \nvar app = angular.module('app',['controllers', 'services']);\n```\n\n这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。\n\n```\nvar sharedServicesModule = angular.module('sharedServices',[]);\nsharedServices.service('NetworkService', function($http){});\n \nvar loginModule = angular.module('login',['sharedServices']);\nloginModule.service('loginService', function(NetworkService){});\nloginModule.controller('loginCtrl', function($scope, loginService){});\n \nvar app = angular.module('app', ['sharedServices', 'login']);\n```\n\n当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。\n\n### 3. 依赖注入\n\n依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：\n\n```\nvar app = angular.module('app',[]);\n \napp.controller('MainCtrl', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n});\n```\n\n这里，很明显，MainCtrl依赖$scope和$timeout。\n\n直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：\n\n```\nvar app=angular.module(\"app\",[]);\napp.controller(\"MainCtrl\",function(e,t){t(function(){console.log(e)},1e3)})\n```\n\n现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。\n\n```\napp.controller('MainCtrl', ['$scope', '$timeout', function($scope, $timeout){\n    $timeout(function(){\n        console.log($scope);\n    }, 1000);\n}]);\n```\n\n这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：\n\n```\napp.controller(\"MainCtrl\",[\"$scope\",\"$timeout\",function(e,t){t(function(){console.log(e)},1e3)}])\n```\n\n**3.1 全局依赖**\n\n在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。\n\n使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。\n\nUnderscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：\n\n```\nvar underscore = angular.module('underscore', []);\nunderscore.factory('_', function() {\n  return window._; \n//Underscore must already be loaded on the page\n});\nvar app = angular.module('app', ['underscore']);\n \napp.controller('MainCtrl', ['$scope', '_', function($scope, _) {\n    init = function() {\n          _.keys($scope);\n      }\n \n      init();\n}]);\n```\n\n这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。\n\n这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。\n\n### 4. 控制器膨胀\n\n控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。\n\n数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。\n\nAngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。\n\n### 5. Service vs Factory\n\n几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！\n\n以下是它们在AngularJS源代码中的定义：\n\n```\nfunction factory(name, factoryFn) { \n    return provider(name, { $get: factoryFn }); \n}\n \nfunction service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n}\n```\n\n从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。\n\n由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。\n\n以下是一个例子，展示了一个service和一个factory如何完成相同的事情：\n\n```\nvar app = angular.module('app',[]);\n \napp.service('helloWorldService', function(){\n    this.hello = function() {\n        return \"Hello World\";\n    };\n});\n \napp.factory('helloWorldFactory', function(){\n    return {\n        hello: function() {\n            return \"Hello World\";\n        }\n    }\n});\n```\n\n当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。\n\n既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。\n\n```\napp.factory('helloFactory', function() {\n    return function(name) {\n        this.name = name;\n \n        this.hello = function() {\n            return \"Hello \" + this.name;\n        };\n    };\n});\n```\n\n这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。\n\n```\napp.controller('helloCtrl', function($scope, helloWorldService, helloWorldFactory, helloFactory) {\n    init = function() {\n      helloWorldService.hello(); \n//'Hello World'\n      helloWorldFactory.hello(); \n//'Hello World'\n      new helloFactory('Readers').hello() \n//'Hello Readers'\n    }\n \n    init();\n});\n```\n\n在初学时，最好只使用service。\n\nFactory在设计一个包含很多私有方法的类时也很有用：\n\n```\napp.factory('privateFactory', function(){\n    var privateFunc = function(name) {\n        return name.split(\"\").reverse().join(\"\"); \n//reverses the name\n    };\n \n    return {\n        hello: function(name){\n          return \"Hello \" + privateFunc(name);\n        }\n    };\n});\n```\n\n通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。\n\n### 6. 没有使用Batarang\n\nBatarang是一个出色的Chrome插件，用来开发和测试AngularJS app。\n\nBatarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。\n\nBatarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。\n\n最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。\n\n### 7. 过多的watcher\n\n在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）\n\n以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：\n\n```\n(function () { \n    var root = $(document.getElementsByTagName('body'));\n    var watchers = [];\n \n    var f = function (element) {\n        if (element.data().hasOwnProperty('$scope')) {\n            angular.forEach(element.data().$scope.$$watchers, function (watcher) {\n                watchers.push(watcher);\n            });\n        }\n \n        angular.forEach(element.children(), function (childElement) {\n            f($(childElement));\n        });\n    };\n \n    f(root);\n \n    console.log(watchers.length);\n})();\n```\n\n通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。\n\n当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。\n\n### 8. 限定$scope的范围\n\nJavascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）\n\n由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。\n\n比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user}}</span>\n        <input ng-model=\"user\"></input>\n   </div>\n</div>\n```\n\n那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？\n\n如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。\n\n当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）\n\n所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。\n\n```\n<div ng-controller=\"navCtrl\">\n   <span>{{user.name}}</span>\n   <div ng-controller=\"loginCtrl\">\n        <span>{{user.name}}</span>\n        <input ng-model=\"user.name\"></input>\n   </div>\n</div>\n```\n\n现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。\n\n这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。\n\n### 9. 手工测试\n\n由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。\n\n不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。\n\n**9.1 Protractor**\n\n单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。\n\n我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。\n\nProtractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。\n\n我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。\n\n**9.2 Karma**\n\n一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。\n\nKarma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。\n\n### 10. 使用jQuery\n\njQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。\n\nAngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。\n\n为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。\n\nDOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。\n\n但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。\n\n### 结论\n\nAngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。\n","slug":"AngularJS开发人员最常犯的10个错误","published":1,"updated":"2016-05-18T06:43:33.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upu000atsqb28ic6xve","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>AngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。</p>\n<h3 id=\"1-MVC目录结构\"><a href=\"#1-MVC目录结构\" class=\"headerlink\" title=\"1. MVC目录结构\"></a>1. MVC目录结构</h3><p>AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templates/</span><br><span class=\"line\">    _login.html</span><br><span class=\"line\">    _feed.html</span><br><span class=\"line\">app/</span><br><span class=\"line\">    app.js</span><br><span class=\"line\">    controllers/</span><br><span class=\"line\">        LoginController.js</span><br><span class=\"line\">        FeedController.js</span><br><span class=\"line\">    directives/</span><br><span class=\"line\">        FeedEntryDirective.js</span><br><span class=\"line\">    services/</span><br><span class=\"line\">        LoginService.js</span><br><span class=\"line\">        FeedService.js</span><br><span class=\"line\">    filters/</span><br><span class=\"line\">        CapatalizeFilter.js</span><br></pre></td></tr></table></figure>\n<p>看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。</p>\n<p>与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app/</span><br><span class=\"line\">    app.js</span><br><span class=\"line\">    Feed/</span><br><span class=\"line\">        _feed.html</span><br><span class=\"line\">        FeedController.js</span><br><span class=\"line\">        FeedEntryDirective.js</span><br><span class=\"line\">        FeedService.js</span><br><span class=\"line\">    Login/</span><br><span class=\"line\">        _login.html</span><br><span class=\"line\">        LoginController.js</span><br><span class=\"line\">        LoginService.js</span><br><span class=\"line\">    Shared/</span><br><span class=\"line\">        CapatalizeFilter.js</span><br></pre></td></tr></table></figure>\n<p>这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。</p>\n<h3 id=\"2-模块\"><a href=\"#2-模块\" class=\"headerlink\" title=\"2. 模块\"></a>2. 模块</h3><p>将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">app.service(&apos;MyService&apos;, function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//service code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//controller code</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在此之后，一个常见的策略是对相同类型的对象归类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var services = angular.module(&apos;services&apos;,[]);</span><br><span class=\"line\">services.service(&apos;MyService&apos;, function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//service code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);</span><br><span class=\"line\">controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//controller code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]);</span><br></pre></td></tr></table></figure>\n<p>这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);</span><br><span class=\"line\">sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);</span><br><span class=\"line\">loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);</span><br><span class=\"line\">loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]);</span><br></pre></td></tr></table></figure>\n<p>当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。</p>\n<h3 id=\"3-依赖注入\"><a href=\"#3-依赖注入\" class=\"headerlink\" title=\"3. 依赖注入\"></a>3. 依赖注入</h3><p>依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123;</span><br><span class=\"line\">    $timeout(function()&#123;</span><br><span class=\"line\">        console.log($scope);</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里，很明显，MainCtrl依赖$scope和$timeout。</p>\n<p>直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app=angular.module(&quot;app&quot;,[]);</span><br><span class=\"line\">app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;)</span><br></pre></td></tr></table></figure>\n<p>现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123;</span><br><span class=\"line\">    $timeout(function()&#123;</span><br><span class=\"line\">        console.log($scope);</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;])</span><br></pre></td></tr></table></figure>\n<p><strong>3.1 全局依赖</strong></p>\n<p>在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。</p>\n<p>使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。</p>\n<p>Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var underscore = angular.module(&apos;underscore&apos;, []);</span><br><span class=\"line\">underscore.factory(&apos;_&apos;, function() &#123;</span><br><span class=\"line\">  return window._; </span><br><span class=\"line\">//Underscore must already be loaded on the page</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123;</span><br><span class=\"line\">    init = function() &#123;</span><br><span class=\"line\">          _.keys($scope);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">      init();</span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。</p>\n<p>这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。</p>\n<h3 id=\"4-控制器膨胀\"><a href=\"#4-控制器膨胀\" class=\"headerlink\" title=\"4. 控制器膨胀\"></a>4. 控制器膨胀</h3><p>控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。</p>\n<p>数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。</p>\n<p>AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。</p>\n<h3 id=\"5-Service-vs-Factory\"><a href=\"#5-Service-vs-Factory\" class=\"headerlink\" title=\"5. Service vs Factory\"></a>5. Service vs Factory</h3><p>几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！</p>\n<p>以下是它们在AngularJS源代码中的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factory(name, factoryFn) &#123; </span><br><span class=\"line\">    return provider(name, &#123; $get: factoryFn &#125;); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">function service(name, constructor) &#123;</span><br><span class=\"line\">    return factory(name, [&apos;$injector&apos;, function($injector) &#123;</span><br><span class=\"line\">      return $injector.instantiate(constructor);</span><br><span class=\"line\">    &#125;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。</p>\n<p>由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。</p>\n<p>以下是一个例子，展示了一个service和一个factory如何完成相同的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.service(&apos;helloWorldService&apos;, function()&#123;</span><br><span class=\"line\">    this.hello = function() &#123;</span><br><span class=\"line\">        return &quot;Hello World&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.factory(&apos;helloWorldFactory&apos;, function()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        hello: function() &#123;</span><br><span class=\"line\">            return &quot;Hello World&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。</p>\n<p>既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;helloFactory&apos;, function() &#123;</span><br><span class=\"line\">    return function(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\"> </span><br><span class=\"line\">        this.hello = function() &#123;</span><br><span class=\"line\">            return &quot;Hello &quot; + this.name;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123;</span><br><span class=\"line\">    init = function() &#123;</span><br><span class=\"line\">      helloWorldService.hello(); </span><br><span class=\"line\">//&apos;Hello World&apos;</span><br><span class=\"line\">      helloWorldFactory.hello(); </span><br><span class=\"line\">//&apos;Hello World&apos;</span><br><span class=\"line\">      new helloFactory(&apos;Readers&apos;).hello() </span><br><span class=\"line\">//&apos;Hello Readers&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在初学时，最好只使用service。</p>\n<p>Factory在设计一个包含很多私有方法的类时也很有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;privateFactory&apos;, function()&#123;</span><br><span class=\"line\">    var privateFunc = function(name) &#123;</span><br><span class=\"line\">        return name.split(&quot;&quot;).reverse().join(&quot;&quot;); </span><br><span class=\"line\">//reverses the name</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        hello: function(name)&#123;</span><br><span class=\"line\">          return &quot;Hello &quot; + privateFunc(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。</p>\n<h3 id=\"6-没有使用Batarang\"><a href=\"#6-没有使用Batarang\" class=\"headerlink\" title=\"6. 没有使用Batarang\"></a>6. 没有使用Batarang</h3><p>Batarang是一个出色的Chrome插件，用来开发和测试AngularJS app。</p>\n<p>Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。</p>\n<p>Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。</p>\n<p>最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。</p>\n<h3 id=\"7-过多的watcher\"><a href=\"#7-过多的watcher\" class=\"headerlink\" title=\"7. 过多的watcher\"></a>7. 过多的watcher</h3><p>在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）</p>\n<p>以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123; </span><br><span class=\"line\">    var root = $(document.getElementsByTagName(&apos;body&apos;));</span><br><span class=\"line\">    var watchers = [];</span><br><span class=\"line\"> </span><br><span class=\"line\">    var f = function (element) &#123;</span><br><span class=\"line\">        if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123;</span><br><span class=\"line\">            angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123;</span><br><span class=\"line\">                watchers.push(watcher);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        angular.forEach(element.children(), function (childElement) &#123;</span><br><span class=\"line\">            f($(childElement));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    f(root);</span><br><span class=\"line\"> </span><br><span class=\"line\">    console.log(watchers.length);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。</p>\n<p>当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。</p>\n<h3 id=\"8-限定-scope的范围\"><a href=\"#8-限定-scope的范围\" class=\"headerlink\" title=\"8. 限定$scope的范围\"></a>8. 限定$scope的范围</h3><p>Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）</p>\n<p>由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。</p>\n<p>比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</span><br><span class=\"line\">   &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">   &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？</p>\n<p>如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。</p>\n<p>当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）</p>\n<p>所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</span><br><span class=\"line\">   &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">   &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。</p>\n<p>这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。</p>\n<h3 id=\"9-手工测试\"><a href=\"#9-手工测试\" class=\"headerlink\" title=\"9. 手工测试\"></a>9. 手工测试</h3><p>由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。</p>\n<p>不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。</p>\n<p><strong>9.1 Protractor</strong></p>\n<p>单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。</p>\n<p>我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。</p>\n<p>Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。</p>\n<p>我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。</p>\n<p><strong>9.2 Karma</strong></p>\n<p>一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。</p>\n<p>Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。</p>\n<h3 id=\"10-使用jQuery\"><a href=\"#10-使用jQuery\" class=\"headerlink\" title=\"10. 使用jQuery\"></a>10. 使用jQuery</h3><p>jQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。</p>\n<p>AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。</p>\n<p>为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。</p>\n<p>DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。</p>\n<p>但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>AngularJS是目前最为活跃的Javascript框架之一，AngularJS的目标之一是简化开发过程，这使得AngularJS非常善于构建小型app原型，但AngularJS对于全功能的客户端应用程序同样强大，它结合了开发简便，特性广泛和出众的性能，使其被广泛使用。然而，大量使用也会产生诸多误区。以下这份列表摘取了常见的一些AngularJS的错误用法，尤其是在app开发过程中。</p>\n<h3 id=\"1-MVC目录结构\"><a href=\"#1-MVC目录结构\" class=\"headerlink\" title=\"1. MVC目录结构\"></a>1. MVC目录结构</h3><p>AngularJS，直白地说，就是一个MVC框架。它的模型并没有像backbone.js框架那样定义的如此明确，但它的体系结构却恰如其分。当你工作于一个MVC框架时，普遍的做法是根据文件类型对其进行归类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">templates/</span><br><span class=\"line\">    _login.html</span><br><span class=\"line\">    _feed.html</span><br><span class=\"line\">app/</span><br><span class=\"line\">    app.js</span><br><span class=\"line\">    controllers/</span><br><span class=\"line\">        LoginController.js</span><br><span class=\"line\">        FeedController.js</span><br><span class=\"line\">    directives/</span><br><span class=\"line\">        FeedEntryDirective.js</span><br><span class=\"line\">    services/</span><br><span class=\"line\">        LoginService.js</span><br><span class=\"line\">        FeedService.js</span><br><span class=\"line\">    filters/</span><br><span class=\"line\">        CapatalizeFilter.js</span><br></pre></td></tr></table></figure>\n<p>看起来，这似乎是一个显而易见的结构，更何况Rails也是这么干的。然而一旦app规模开始扩张，这种结构会导致你一次需要打开很多目录，无论你是使用sublime，Visual Studio或是Vim结合Nerd Tree，你都会投入很多时间在目录树中不断地滑上滑下。</p>\n<p>与按照类型划分文件不同，取而代之的，我们可以按照特性划分文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app/</span><br><span class=\"line\">    app.js</span><br><span class=\"line\">    Feed/</span><br><span class=\"line\">        _feed.html</span><br><span class=\"line\">        FeedController.js</span><br><span class=\"line\">        FeedEntryDirective.js</span><br><span class=\"line\">        FeedService.js</span><br><span class=\"line\">    Login/</span><br><span class=\"line\">        _login.html</span><br><span class=\"line\">        LoginController.js</span><br><span class=\"line\">        LoginService.js</span><br><span class=\"line\">    Shared/</span><br><span class=\"line\">        CapatalizeFilter.js</span><br></pre></td></tr></table></figure>\n<p>这种目录结构使得我们能够更容易地找到与某个特性相关的所有文件，继而加快我们的开发进度。尽管将.html和.js文件置于一处可能存在争议，但节省下来的时间更有价值。</p>\n<h3 id=\"2-模块\"><a href=\"#2-模块\" class=\"headerlink\" title=\"2. 模块\"></a>2. 模块</h3><p>将所有东西都一股脑放在主模块下是很常见的，对于小型app，刚开始并没有什么问题，然而很快你就会发现坑爹的事来了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\">app.service(&apos;MyService&apos;, function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//service code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//controller code</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在此之后，一个常见的策略是对相同类型的对象归类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var services = angular.module(&apos;services&apos;,[]);</span><br><span class=\"line\">services.service(&apos;MyService&apos;, function()&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//service code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var controllers = angular.module(&apos;controllers&apos;,[&apos;services&apos;]);</span><br><span class=\"line\">controllers.controller(&apos;MyCtrl&apos;, function($scope, MyService)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">//controller code</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var app = angular.module(&apos;app&apos;,[&apos;controllers&apos;, &apos;services&apos;]);</span><br></pre></td></tr></table></figure>\n<p>这种方式和前面第一部分所谈到的目录结构差不多：不够好。根据相同的理念，可以按照特性归类，这会带来可扩展性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sharedServicesModule = angular.module(&apos;sharedServices&apos;,[]);</span><br><span class=\"line\">sharedServices.service(&apos;NetworkService&apos;, function($http)&#123;&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var loginModule = angular.module(&apos;login&apos;,[&apos;sharedServices&apos;]);</span><br><span class=\"line\">loginModule.service(&apos;loginService&apos;, function(NetworkService)&#123;&#125;);</span><br><span class=\"line\">loginModule.controller(&apos;loginCtrl&apos;, function($scope, loginService)&#123;&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;sharedServices&apos;, &apos;login&apos;]);</span><br></pre></td></tr></table></figure>\n<p>当我们开发一个大型应用程序时，可能并不是所有东西都包含在一个页面上。将同一类特性置于一个模块内，能使跨app间重用模块变得更容易。</p>\n<h3 id=\"3-依赖注入\"><a href=\"#3-依赖注入\" class=\"headerlink\" title=\"3. 依赖注入\"></a>3. 依赖注入</h3><p>依赖注入是AngularJS最好的模式之一，它使得测试更为简单，并且依赖任何指定对象都很明确。AngularJS的注入方式非常灵活，最简单的方式只需要将依赖的名字传入模块的function中即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.controller(&apos;MainCtrl&apos;, function($scope, $timeout)&#123;</span><br><span class=\"line\">    $timeout(function()&#123;</span><br><span class=\"line\">        console.log($scope);</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里，很明显，MainCtrl依赖$scope和$timeout。</p>\n<p>直到你准备将其部署到生产环境并希望精简代码时，一切都很美好。如果使用UglifyJS，之前的例子会变成下面这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app=angular.module(&quot;app&quot;,[]);</span><br><span class=\"line\">app.controller(&quot;MainCtrl&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;)</span><br></pre></td></tr></table></figure>\n<p>现在AngularJS怎么知道MainCtrl依赖谁？AngularJS提供了一种非常简单的解决方法，即将依赖作为一个数组传入，数组的最后一个元素是一个函数，所有的依赖项作为它的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;$timeout&apos;, function($scope, $timeout)&#123;</span><br><span class=\"line\">    $timeout(function()&#123;</span><br><span class=\"line\">        console.log($scope);</span><br><span class=\"line\">    &#125;, 1000);</span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>这样做能够精简代码，并且AngularJS知道如何解释这些明确的依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&quot;MainCtrl&quot;,[&quot;$scope&quot;,&quot;$timeout&quot;,function(e,t)&#123;t(function()&#123;console.log(e)&#125;,1e3)&#125;])</span><br></pre></td></tr></table></figure>\n<p><strong>3.1 全局依赖</strong></p>\n<p>在编写AngularJS程序时，时常会出现这种情况：某个对象有一个依赖，而这个对象又将其自身绑定在全局scope上，这意味着在任何AngularJS代码中这个依赖都是可用的，但这却破坏了依赖注入模型，并会导致一些问题，尤其体现在测试过程中。</p>\n<p>使用AngularJS可以很容易的将这些全局依赖封装进模块中，所以它们可以像AngularJS标准模块那样被注入进去。</p>\n<p>Underscrore.js是一个很赞的库，它可以以函数式的风格简化Javascript代码，通过以下方式，你可以将其转化为一个模块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var underscore = angular.module(&apos;underscore&apos;, []);</span><br><span class=\"line\">underscore.factory(&apos;_&apos;, function() &#123;</span><br><span class=\"line\">  return window._; </span><br><span class=\"line\">//Underscore must already be loaded on the page</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">var app = angular.module(&apos;app&apos;, [&apos;underscore&apos;]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.controller(&apos;MainCtrl&apos;, [&apos;$scope&apos;, &apos;_&apos;, function($scope, _) &#123;</span><br><span class=\"line\">    init = function() &#123;</span><br><span class=\"line\">          _.keys($scope);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">      init();</span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>这样的做法允许应用程序继续以AngularJS依赖注入的风格进行开发，同时在测试阶段也能将underscore交换出去。</p>\n<p>这可能看上去十分琐碎，没什么必要，但如果你的代码中正在使用use strict（而且必须使用），那这就是必要的了。</p>\n<h3 id=\"4-控制器膨胀\"><a href=\"#4-控制器膨胀\" class=\"headerlink\" title=\"4. 控制器膨胀\"></a>4. 控制器膨胀</h3><p>控制器是AngularJS的肉和土豆，一不小心就会将过多的逻辑加入其中，尤其是刚开始的时候。控制器永远都不应该去操作DOM，或是持有DOM选择器，那是我们需要使用指令和ng-model的地方。同样的，业务逻辑应该存在于服务中，而非控制器。</p>\n<p>数据也应该存储在服务中，除非它们已经被绑定在$scope上了。服务本身是单例的，在应用程序的整个生命周期都存在，然而控制器在应用程序的各状态间是瞬态的。如果数据被保存在控制器中，当它被再次实例化时就需要重新从某处获取数据。即使将数据存储于localStorage中，检索的速度也要比Javascript变量慢一个数量级。</p>\n<p>AngularJS在遵循单一职责原则（SRP）时运行良好，如果控制器是视图和模型间的协调者，那么它所包含的逻辑就应该尽量少，这同样会给测试带来便利。</p>\n<h3 id=\"5-Service-vs-Factory\"><a href=\"#5-Service-vs-Factory\" class=\"headerlink\" title=\"5. Service vs Factory\"></a>5. Service vs Factory</h3><p>几乎每一个AngularJS开发人员在初学时都会被这些名词所困扰，这真的不太应该，因为它们就是针对几乎相同事物的语法糖而已！</p>\n<p>以下是它们在AngularJS源代码中的定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factory(name, factoryFn) &#123; </span><br><span class=\"line\">    return provider(name, &#123; $get: factoryFn &#125;); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">function service(name, constructor) &#123;</span><br><span class=\"line\">    return factory(name, [&apos;$injector&apos;, function($injector) &#123;</span><br><span class=\"line\">      return $injector.instantiate(constructor);</span><br><span class=\"line\">    &#125;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源代码中你可以看到，service仅仅是调用了factory函数，而后者又调用了provider函数。事实上，AngularJS也为一些值、常量和装饰提供额外的provider封装，而这些并没有导致类似的困惑，它们的文档都非常清晰。</p>\n<p>由于service仅仅是调用了factory函数，这有什么区别呢？线索在$injector.instantiate：在这个函数中，$injector在service的构造函数中创建了一个新的实例。</p>\n<p>以下是一个例子，展示了一个service和一个factory如何完成相同的事情：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var app = angular.module(&apos;app&apos;,[]);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.service(&apos;helloWorldService&apos;, function()&#123;</span><br><span class=\"line\">    this.hello = function() &#123;</span><br><span class=\"line\">        return &quot;Hello World&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">app.factory(&apos;helloWorldFactory&apos;, function()&#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        hello: function() &#123;</span><br><span class=\"line\">            return &quot;Hello World&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当helloWorldService或helloWorldFactory被注入到控制器中，它们都有一个hello方法，返回”hello world”。service的构造函数在声明时被实例化了一次，同时factory对象在每一次被注入时传递，但是仍然只有一个factory实例。所有的providers都是单例。</p>\n<p>既然能做相同的事，为什么需要两种不同的风格呢？相对于service，factory提供了更多的灵活性，因为它可以返回函数，这些函数之后可以被新建出来。这迎合了面向对象编程中工厂模式的概念，工厂可以是一个能够创建其他对象的对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;helloFactory&apos;, function() &#123;</span><br><span class=\"line\">    return function(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\"> </span><br><span class=\"line\">        this.hello = function() &#123;</span><br><span class=\"line\">            return &quot;Hello &quot; + this.name;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这里是一个控制器示例，使用了service和两个factory，helloFactory返回了一个函数，当新建对象时会设置name的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.controller(&apos;helloCtrl&apos;, function($scope, helloWorldService, helloWorldFactory, helloFactory) &#123;</span><br><span class=\"line\">    init = function() &#123;</span><br><span class=\"line\">      helloWorldService.hello(); </span><br><span class=\"line\">//&apos;Hello World&apos;</span><br><span class=\"line\">      helloWorldFactory.hello(); </span><br><span class=\"line\">//&apos;Hello World&apos;</span><br><span class=\"line\">      new helloFactory(&apos;Readers&apos;).hello() </span><br><span class=\"line\">//&apos;Hello Readers&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    init();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在初学时，最好只使用service。</p>\n<p>Factory在设计一个包含很多私有方法的类时也很有用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.factory(&apos;privateFactory&apos;, function()&#123;</span><br><span class=\"line\">    var privateFunc = function(name) &#123;</span><br><span class=\"line\">        return name.split(&quot;&quot;).reverse().join(&quot;&quot;); </span><br><span class=\"line\">//reverses the name</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        hello: function(name)&#123;</span><br><span class=\"line\">          return &quot;Hello &quot; + privateFunc(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过这个例子，我们可以让privateFactory的公有API无法访问到privateFunc方法，这种模式在service中是可以做到的，但在factory中更容易。</p>\n<h3 id=\"6-没有使用Batarang\"><a href=\"#6-没有使用Batarang\" class=\"headerlink\" title=\"6. 没有使用Batarang\"></a>6. 没有使用Batarang</h3><p>Batarang是一个出色的Chrome插件，用来开发和测试AngularJS app。</p>\n<p>Batarang提供了浏览模型的能力，这使得我们有能力观察AngularJS内部是如何确定绑定到作用域上的模型的，这在处理指令以及隔离一定范围观察绑定值时非常有用。</p>\n<p>Batarang也提供了一个依赖图， 如果我们正在接触一个未经测试的代码库，这个依赖图就很有用，它能决定哪些服务应该被重点关照。</p>\n<p>最后，Batarang提供了性能分析。Angular能做到开包即用，性能良好，然而对于一个充满了自定义指令和复杂逻辑的应用而言，有时候就不那么流畅了。使用Batarang性能工具，能够直接观察到在一个digest周期中哪个函数运行了最长时间。性能工具也能展示一棵完整的watch树，在我们拥有很多watcher时，这很有用。</p>\n<h3 id=\"7-过多的watcher\"><a href=\"#7-过多的watcher\" class=\"headerlink\" title=\"7. 过多的watcher\"></a>7. 过多的watcher</h3><p>在上一点中我们提到，AngularJS能做到开包即用，性能良好。由于需要在一个digest周期中完成脏数据检查，一旦watcher的数量增长到大约2000时，这个周期就会产生显著的性能问题。（2000这个数字不能说一定会造成性能大幅下降，但这是一个不错的经验数值。在AngularJS 1.3 release版本中，已经有一些允许严格控制digest周期的改动了，Aaron Gray有一篇很好的文章对此进行解释。）</p>\n<p>以下这个“立即执行的函数表达式(IIFE)”会打印出当前页面上所有的watcher的个数，你可以简单的将其粘贴到控制台中，观察结果。这段IIFE来源于Jared在StackOverflow上的回答：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function () &#123; </span><br><span class=\"line\">    var root = $(document.getElementsByTagName(&apos;body&apos;));</span><br><span class=\"line\">    var watchers = [];</span><br><span class=\"line\"> </span><br><span class=\"line\">    var f = function (element) &#123;</span><br><span class=\"line\">        if (element.data().hasOwnProperty(&apos;$scope&apos;)) &#123;</span><br><span class=\"line\">            angular.forEach(element.data().$scope.$$watchers, function (watcher) &#123;</span><br><span class=\"line\">                watchers.push(watcher);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        angular.forEach(element.children(), function (childElement) &#123;</span><br><span class=\"line\">            f($(childElement));</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    f(root);</span><br><span class=\"line\"> </span><br><span class=\"line\">    console.log(watchers.length);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>通过这个方式得到watcher的数量，结合Batarang性能板块中的watch树，应该可以看到哪里存在重复代码，或着哪里存在不变数据同时拥有watch。</p>\n<p>当存在不变数据，而你又想用AngularJS将其模版化，可以考虑使用bindonce。Bindonce是一个简单的指令，允许你使用AngularJS中的模版，但它并不会加入watch，这就保证了watch数量不会增长。</p>\n<h3 id=\"8-限定-scope的范围\"><a href=\"#8-限定-scope的范围\" class=\"headerlink\" title=\"8. 限定$scope的范围\"></a>8. 限定$scope的范围</h3><p>Javascript基于原型的继承与面向对象中基于类的继承有着微妙的区别，这通常不是什么问题，但这个微妙之处在使用$scope时就会表现出来。在AngularJS中，每个$scope都会继承父$scope，最高层称之为$rootScope。（$scope与传统指令有些不同，它们有一定的作用范围i，且只继承显式声明的属性。）</p>\n<p>由于原型继承的特点，在父类和子类间共享数据不太重要，不过如果不小心的话，也很容易误用了一个父$scope的属性。</p>\n<p>比如说，我们需要在一个导航栏上显示一个用户名，这个用户名是在登录表单中输入的，下面这种尝试应该是能工作的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</span><br><span class=\"line\">   &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;user&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;input ng-model=&quot;user&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">   &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>那么问题来了……：在text input中设置了user的ng-model，当用户在其中输入内容时，哪个模版会被更新？navCtrl还是loginCtrl，还是都会？</p>\n<p>如果你选择了loginCtrl，那么你可能已经理解了原型继承是如何工作的了。</p>\n<p>当你检索字面值时，原型链并不起作用。如果navCtrl也同时被更新的话，检索原型链是必须的；但如果值是一个对象，这就会发生。（记住，在Javascript中，函数、数组和对象都是对象）</p>\n<p>所以为了获得预期的行为，需要在navCtrl中创建一个对象，它可以被loginCtrl引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-controller=&quot;navCtrl&quot;&gt;</span><br><span class=\"line\">   &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">   &lt;div ng-controller=&quot;loginCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;input ng-model=&quot;user.name&quot;&gt;&lt;/input&gt;</span><br><span class=\"line\">   &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>现在，由于user是一个对象，原型链就会起作用，navCtrl模版和$scope和loginCtrl都会被更新。</p>\n<p>这看上去是一个很做作的例子，但是当你使用某些指令去创建子$scope，如ngRepeat时，这个问题很容易就会产生。</p>\n<h3 id=\"9-手工测试\"><a href=\"#9-手工测试\" class=\"headerlink\" title=\"9. 手工测试\"></a>9. 手工测试</h3><p>由于TDD可能不是每个开发人员都喜欢的开发方式，因此当开发人员检查代码是否工作或是否影响了其它东西时，他们会做手工测试。</p>\n<p>不去测试AngularJS app，这是没有道理的。AngularJS的设计使得它从头到底都是可测试的，依赖注入和ngMock模块就是明证。AngularJS核心团队已经开发了众多能够使测试更上一层楼的工具。</p>\n<p><strong>9.1 Protractor</strong></p>\n<p>单元测试是一个测试工作的基础，但考虑到app的日益复杂，集成测试更贴近实际情况。幸运的是，AngularJS的核心团队已经提供了必要的工具。</p>\n<p>我们已经建立了Protractor，一个端到端的测试器用以模拟用户交互，这能够帮助你验证你的AngularJS程序的健康状况。</p>\n<p>Protractor使用Jasmine测试框架定义测试，Protractor针对不同的页面交互行为有一个非常健壮的API。</p>\n<p>我们还有一些其他的端到端测试工具，但是Protractor的优势是它能够理解如何与AngularJS代码协同工作，尤其是在$digest周期中。</p>\n<p><strong>9.2 Karma</strong></p>\n<p>一旦我们用Protractor完成了集成测试的编写工作，接下去就是执行测试了。等待测试执行，尤其是集成测试，对每个开发人员都是一种淡淡的忧伤。AngularJS的核心团队也感到极为蛋疼，于是他们开发了Karma。</p>\n<p>Karma是一个测试器，它有助于关闭反馈回路。Karma之所以能够做到这点，是因为它在指定文件被改变时就运行测试。Karma同时也会在多个浏览器上运行测试，不同的设备也可以指向Karma服务器，这样就能够更好地覆盖真实世界的应用场景。</p>\n<h3 id=\"10-使用jQuery\"><a href=\"#10-使用jQuery\" class=\"headerlink\" title=\"10. 使用jQuery\"></a>10. 使用jQuery</h3><p>jQuery是一个酷炫的库，它有标准化的跨平台开发，几乎已经成为了现代化Web开发的必需品。不过尽管JQuery如此多的优秀特性，它的理念和AngularJS并不一致。</p>\n<p>AngularJS是一个用来建立app的框架，而JQuery则是一个简化“HTML文档操作、事件处理、动画和Ajax”的库。这是两者最基本的区别，AngularJS致力于程序的体系结构，与HTML页面无关。</p>\n<p>为了更好的理解如何建立一个AngularJS程序，请停止使用jQuery。JQuery使开发人员以现存的HTML标准思考问题，但正如文档里所说的，“AngularJS能够让你在应用程序中扩张HTML这个词汇”。</p>\n<p>DOM操作应该只在指令中完成，但这并不意味着他们只能用JQuery封装。在你使用JQuery之前，你应该总是去想一下这个功能是不是AngularJS已经提供了。当指令互相依赖时能够创建强大的工具，这确实很强大。</p>\n<p>但一个非常棒的JQuery是必需品时，这一天可能会到来，但在一开始就引入它，是一个常见的错误。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>AngularJS是一卓越的框架，在社区的帮助下始终在进步。虽说AngularJS仍然是一个不断发展的概念，但我希望人们能够遵循以上谈到的这些约定，避免开发AngularJS应用所遇到的那些问题。</p>\n"},{"title":"Angularjs知识点1","date":"2016-04-10T16:00:00.000Z","_content":"\n### 知识点：\n\n+ ng-repeat\n+ ng-class-odd\n+ ng-class-even\n\n### 代码及演示：\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/kmqf1hpq/)\n","source":"_posts/Angularjs知识点1.md","raw":"---\ntitle: Angularjs知识点1\ntags: [javascript,angularjs]\ndate: 2016/04/11\n---\n\n### 知识点：\n\n+ ng-repeat\n+ ng-class-odd\n+ ng-class-even\n\n### 代码及演示：\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/kmqf1hpq/)\n","slug":"Angularjs知识点1","published":1,"updated":"2016-05-18T06:45:51.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3upy000dtsqbxrrzxkwr","content":"<h3 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h3><ul>\n<li>ng-repeat</li>\n<li>ng-class-odd</li>\n<li>ng-class-even</li>\n</ul>\n<h3 id=\"代码及演示：\"><a href=\"#代码及演示：\" class=\"headerlink\" title=\"代码及演示：\"></a>代码及演示：</h3><p><a href=\"https://jsfiddle.net/Lionney/kmqf1hpq/\" target=\"_blank\" rel=\"external\">jsfiddle.net</a></p>\n","excerpt":"","more":"<h3 id=\"知识点：\"><a href=\"#知识点：\" class=\"headerlink\" title=\"知识点：\"></a>知识点：</h3><ul>\n<li>ng-repeat</li>\n<li>ng-class-odd</li>\n<li>ng-class-even</li>\n</ul>\n<h3 id=\"代码及演示：\"><a href=\"#代码及演示：\" class=\"headerlink\" title=\"代码及演示：\"></a>代码及演示：</h3><p><a href=\"https://jsfiddle.net/Lionney/kmqf1hpq/\">jsfiddle.net</a></p>\n"},{"title":"7个你可能不认识的CSS单位","date":"2015-01-03T16:00:00.000Z","_content":"\n众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。\n随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。\n\n这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。\n\n今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~\n\n###rem\n\n我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。\n\n```\n    <body>\n      <div class=\"test\">Test</div>\n    </body>\n    \n    body {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px\n    }\n```\n\n你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。\n\n但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。\n\n```\n    <body>\n      <div>\n        Test <!-- 14 * 1.2 = 16.8px -->\n        <div>\n          Test <!-- 16.8 * 1.2 = 20.16px -->\n          <div>\n            Test <!-- 20.16 * 1.2 = 24.192px -->\n          </div>\n        </div>\n      </div>\n    </body>\n```\n\n###实例\n\n虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。\n\n```\n    html {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2rem;\n    }\n```\n\n这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。\n\n适用于网格布局\nRems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，\n\n```\n    .container {\n      width: 70rem; // 70 * 14px = 980px\n    }\n    \n```\n\n概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。\n\n###vh and vw\n\n响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。\n\n1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。\n\n可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。\n\n```\n    .slide {\n      height: 100vh;\n    }\n```\n\n假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！\n实例\n\n###vmin and vmax\n\nvh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。\n那么问题来了，我们应该在什么场景下使用这两个单位呢？\n假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：\n\n```\n    .box {\n      height: 100vmin;\n      width: 100vmin;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png)\n\n如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）\n\n```\n    .box {\n        height: 100vmax;\n        width: 100vmax;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png)\n\n结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。\n\n###ex and ch\n\nex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。\n\nch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。\n\nex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png)\n\nx-height; the height of the lower case x\n\n这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用\n上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：\n\n```\n    sup {\n        position: relative;\n        bottom: 1ex;\n    }\n    sub {\n        position: relative;\n        bottom: -1ex;\n    }\n```\n\n###结论\n\n持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！\n","source":"_posts/7个你可能不认识的CSS单位.md","raw":"---\ntitle: 7个你可能不认识的CSS单位\ntags: [css]\ndate: 2015/01/04\n---\n\n众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。\n随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。\n\n这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。\n\n今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~\n\n###rem\n\n我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。\n\n```\n    <body>\n      <div class=\"test\">Test</div>\n    </body>\n    \n    body {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px\n    }\n```\n\n你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。\n\n但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。\n\n```\n    <body>\n      <div>\n        Test <!-- 14 * 1.2 = 16.8px -->\n        <div>\n          Test <!-- 16.8 * 1.2 = 20.16px -->\n          <div>\n            Test <!-- 20.16 * 1.2 = 24.192px -->\n          </div>\n        </div>\n      </div>\n    </body>\n```\n\n###实例\n\n虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。\n\n```\n    html {\n      font-size: 14px;\n    }\n    div {\n      font-size: 1.2rem;\n    }\n```\n\n这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。\n\n适用于网格布局\nRems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，\n\n```\n    .container {\n      width: 70rem; // 70 * 14px = 980px\n    }\n    \n```\n\n概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。\n\n###vh and vw\n\n响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。\n\n1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。\n\n可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。\n\n```\n    .slide {\n      height: 100vh;\n    }\n```\n\n假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！\n实例\n\n###vmin and vmax\n\nvh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。\n那么问题来了，我们应该在什么场景下使用这两个单位呢？\n假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：\n\n```\n    .box {\n      height: 100vmin;\n      width: 100vmin;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png)\n\n如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）\n\n```\n    .box {\n        height: 100vmax;\n        width: 100vmax;\n    }\n```\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png)\n\n结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。\n\n###ex and ch\n\nex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。\n\nch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。\n\nex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。\n\n![img](http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png)\n\nx-height; the height of the lower case x\n\n这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用\n上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：\n\n```\n    sup {\n        position: relative;\n        bottom: 1ex;\n    }\n    sub {\n        position: relative;\n        bottom: -1ex;\n    }\n```\n\n###结论\n\n持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！\n","slug":"7个你可能不认识的CSS单位","published":1,"updated":"2016-05-18T06:28:03.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqc000etsqbnaza1us2","content":"<p>众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。<br>随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。</p>\n<p>这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。</p>\n<p>今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~</p>\n<p>###rem</p>\n<p>我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div class=&quot;test&quot;&gt;Test&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。</p>\n<p>但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    Test &lt;!-- 14 * 1.2 = 16.8px --&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>###实例</p>\n<p>虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。</html></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &#123;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  font-size: 1.2rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。</p>\n<p>适用于网格布局<br>Rems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">  width: 70rem; // 70 * 14px = 980px</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。</p>\n<p>###vh and vw</p>\n<p>响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。</p>\n<p>1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。</p>\n<p>可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.slide &#123;</span><br><span class=\"line\">  height: 100vh;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！<br>实例</p>\n<p>###vmin and vmax</p>\n<p>vh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。<br>那么问题来了，我们应该在什么场景下使用这两个单位呢？<br>假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  height: 100vmin;</span><br><span class=\"line\">  width: 100vmin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png\" alt=\"img\"></p>\n<p>如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">    height: 100vmax;</span><br><span class=\"line\">    width: 100vmax;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png\" alt=\"img\"></p>\n<p>结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。</p>\n<p>###ex and ch</p>\n<p>ex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。</p>\n<p>ch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。</p>\n<p>ex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。</p>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png\" alt=\"img\"></p>\n<p>x-height; the height of the lower case x</p>\n<p>这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用<br>上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sup &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    bottom: 1ex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sub &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    bottom: -1ex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！</p>\n","excerpt":"","more":"<p>众所周知CSS技术我们虽然很熟悉，在使用的过程却很容易被困住，这让我们在新问题出现的时候变得很不利。<br>随着web继续不断地发展，对于新技术新解决方案的要求也会不断增长。因此，作为网页设计师和前端开发人员，我们别无选择，必须熟悉我们手上的工具，做到知己知彼，这样才能百战不殆。</p>\n<p>这就意味着有那么些个特别的货，虽然平常都不怎么会用上，但是一旦某个地方需要它们了，他们就真的是特么得合适不过来了呢。</p>\n<p>今儿，我就准备向大伙儿介绍一些你们之前可能很少见过CSS家伙们。他们每个都是度量的单位，类似pixel 和 em 这样的，但是很有可能你之前从来就没听过这些家伙们！就让我们一起来交个朋友吧~</p>\n<p>###rem</p>\n<p>我们首先介绍下和我们熟悉的很相似的货。em 被定义为相对于当前对象内文本的字体大小。炒个栗子，如果你给body小哥设置了font-size字体大小，那么body小哥的任何子元素的1em就是等于body设置的font-size。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div class=&quot;test&quot;&gt;Test&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你看，这里div这娃的字体大小是1.2em。解释来说，就是他从body爹爹那里继承的字体大小（这里是14px）的1.2倍，结果就是16.8px。</p>\n<p>但是，如果你用em一层一层级联得定义嵌套元素的字体大小又会花生什么事情呢？在下面这一小段代码里我们应用了和上面一样一样的CSS，每一个div都从它上一级父元素继承了字体大小，并且逐渐得增加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    Test &lt;!-- 14 * 1.2 = 16.8px --&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n<p>###实例</p>\n<p>虽然在某些地方这正是我们想要的，但是通常情况下我们还是希望就依赖单一的相对度量单位就好。这时候嘛，我们就可以使用 rem 了。 ‘r’是“root”的缩写，意思就是1rem等于根元素的字体大小；大部分情况下，根元素就是<html>元素了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html &#123;</span><br><span class=\"line\">  font-size: 14px;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">div &#123;</span><br><span class=\"line\">  font-size: 1.2rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在上面的那三个嵌套的div娃们的字体大小都是 1.2*14px = 16.8px 了。</p>\n<p>适用于网格布局<br>Rems 不仅仅只是在设置字体大小上很方便。再炒个栗子，你可以用基于html根元素字体大小的rem作为整个网格布局或者UI库的大小单位，然后在其他特定的地方用em单位。这样将会给你带来更多的字体大小和伸缩的可控性，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.container &#123;</span><br><span class=\"line\">  width: 70rem; // 70 * 14px = 980px</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>概念上来说，这个方法的思想就是让你的界面根据你的内容进行缩放。但是，这样做并不是对所有的情况都有意义。</p>\n<p>###vh and vw</p>\n<p>响应式web设计离不开百分比。但是，CSS百分比并不是所有的问题的最佳解决方案。CSS的宽度是相对于包含它的最近的父元素的宽度的。但是如果你就想用视口（viewpoint）的宽度或者高度，而不是父元素的，那该肿么办？ 这就是 vh 和 vw 单位为我们提供的。</p>\n<p>1vh 等于1/100的视口高度。栗子：浏览器高度900px, 1 vh = 900px/100 = 9 px。同理，如果视口宽度未750， 1vw = 750px/100 = 7.5 px。</p>\n<p>可以想象到的，他们有很多很多的用途。比如，我们用很简单的方法只用一行CSS代码就实现同屏幕等高的框。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.slide &#123;</span><br><span class=\"line\">  height: 100vh;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设你要来一个和屏幕同宽的标题，你只要设置这个标题的font-size的单位为vm，那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果，有木有？！<br>实例</p>\n<p>###vmin and vmax</p>\n<p>vh和 vm 依据于视口的高度和宽度，相对的，vmin 和 vmax则关于视口高度和宽度两者的最小或者最大值。比如，浏览器的宽度设置为1100px，高度设置为700px， 1vmin = 1px， 1vmax = 11px。如果宽度设置为800px,高度设置为1080px, 1vmin就等于8px, 1vmax则未10.8px。<br>那么问题来了，我们应该在什么场景下使用这两个单位呢？<br>假设有一个元素，你需要让它始终在屏幕上可见。只要对其高度和宽度使用vmin单位，并赋予其低于100的值就可以做到了。再来个栗子，可以这样定义一个至少有两个边触摸到屏幕的方形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">  height: 100vmin;</span><br><span class=\"line\">  width: 100vmin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832472821993_000.png\" alt=\"img\"></p>\n<p>如果你要让这个方形框框始终铺满整个视口的可见区域（四边始终触摸到屏幕的四边）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.box &#123;</span><br><span class=\"line\">    height: 100vmax;</span><br><span class=\"line\">    width: 100vmax;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832575575866_000.png\" alt=\"img\"></p>\n<p>结合使用这些单位可以为我们提供一个新颖有意思的方式来灵活地利用我们视口的大小。</p>\n<p>###ex and ch</p>\n<p>ex 和 ch 单位，类似于 em 和 rem, 依赖于当前的字体和字体大小。 但是，不同的是，这两货是基于字体的度量单位，依赖于设定的字体。</p>\n<p>ch 单位通常被定义为数字0的宽度。你可以在Eric Meyers的博客里找到关于它的一些有意思的讨论，例如将一个等宽字体的字母”N”的宽度设置为40ch，那么在另一种类型的字体里它却可以包含40个字母。这个单位的传统用途主要是盲文的排版，但是除此之外，肯定还有可以应用他的地方。</p>\n<p>ex 定义为当前字体的小写x字母的高度或者 1/2 的 1em。 很多时候，它是字体的中间标志。</p>\n<p><img src=\"http://limeng.u.qiniudn.com/7个你可能不认识的CSS单位_20141119_13060832651563303_000.png\" alt=\"img\"></p>\n<p>x-height; the height of the lower case x</p>\n<p>这些单位有很多用途，大部分用于版式的微调。比方说，sup 元素（上角文字标），可以通过position:relative;bottom: 1ex;实现 。类似的方法，你可以实现一个下角文字标。浏览器默认的方式是利用<br>上标和下标特定垂直对齐规则，但是如果你想更细粒度更精确得控制，你可以像下面这样做：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sup &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    bottom: 1ex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sub &#123;</span><br><span class=\"line\">    position: relative;</span><br><span class=\"line\">    bottom: -1ex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###结论</p>\n<p>持续关注不断发展壮大的CSS技术无疑是很重要的，这样你才能掌握你所持有的工具的全部技能。说不定将来你遇到的某个特殊的问题就需要使用这些复杂的单位来解决。花点时间去阅读新的技术规范，注册订阅一些不错的网站或者资源，类似 cssweekly这样的。 当然不要忘记现在就去注册像TUTS +这样的网站来获取每周的更新，课程，免费教程还有资源！</p>\n"},{"title":"Angularjs轻松实现表格按指定列排序","date":"2016-05-17T16:00:00.000Z","_content":"\n使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：\n\nhtml代码：\n\n```html\n<table class=\"table table-border\" ng-app=\"myapp\" ng-controller=\"orderByCtrl\">\n    <thead>\n        <tr>\n            <th>inx</th>\n            <th ng-click=\"col='name';desc=!desc\">name</th>\n            <!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 -->\n            <th ng-click=\"col='gender';desc=!desc\">gender</th>\n            <th ng-click=\"col='age';desc=!desc\">age</th>\n            <th ng-click=\"col='score';desc=!desc\">score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr ng-repeat=\"d in data|orderBy:col:desc\">\n            <td ng-bind=\"$index+1\"></td>\n            <td ng-bind=\"d.name\"></td>\n            <td ng-bind=\"d.gender\"></td>\n            <td ng-bind=\"d.age\"></td>\n            <td ng-bind=\"d.score\"></td>\n        </tr>\n    </tbody>\n</table>\n```\n\njs代码：\n\n```javascript\nvar app = angular.module('myapp', []);\n\napp.controller('orderByCtrl', function($scope) {\n    $scope.col = 'name';//默认按name列排序\n    $scope.desc = 0;//默认排序条件升序\n    $scope.data = [{\n        name: 'name 1',\n        gender: 'male',\n        age: 26,\n        score: 70\n    }, {\n        name: 'name 2',\n        gender: 'female',\n        age: 24,\n        score: 84\n    }, {\n        name: 'name 3',\n        gender: 'male',\n        age: 20,\n        score: 76\n    }, {\n        name: 'name 4',\n        gender: 'female',\n        age: 22,\n        score: 64\n    }];\n\n\n})\n```\n\n让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式\n\n```css\nth {\n    cursor: pointer;\n}\n```\n\n运行结果[点击这里](https://jsfiddle.net/Lionney/xowyoaxj/)查看\n","source":"_posts/Angularjs轻松实现表格按指定列排序.md","raw":"---\ntitle: Angularjs轻松实现表格按指定列排序\ntags: [javascript,angularjs]\ndate: 2016/05/18\n---\n\n使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：\n\nhtml代码：\n\n```html\n<table class=\"table table-border\" ng-app=\"myapp\" ng-controller=\"orderByCtrl\">\n    <thead>\n        <tr>\n            <th>inx</th>\n            <th ng-click=\"col='name';desc=!desc\">name</th>\n            <!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 -->\n            <th ng-click=\"col='gender';desc=!desc\">gender</th>\n            <th ng-click=\"col='age';desc=!desc\">age</th>\n            <th ng-click=\"col='score';desc=!desc\">score</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr ng-repeat=\"d in data|orderBy:col:desc\">\n            <td ng-bind=\"$index+1\"></td>\n            <td ng-bind=\"d.name\"></td>\n            <td ng-bind=\"d.gender\"></td>\n            <td ng-bind=\"d.age\"></td>\n            <td ng-bind=\"d.score\"></td>\n        </tr>\n    </tbody>\n</table>\n```\n\njs代码：\n\n```javascript\nvar app = angular.module('myapp', []);\n\napp.controller('orderByCtrl', function($scope) {\n    $scope.col = 'name';//默认按name列排序\n    $scope.desc = 0;//默认排序条件升序\n    $scope.data = [{\n        name: 'name 1',\n        gender: 'male',\n        age: 26,\n        score: 70\n    }, {\n        name: 'name 2',\n        gender: 'female',\n        age: 24,\n        score: 84\n    }, {\n        name: 'name 3',\n        gender: 'male',\n        age: 20,\n        score: 76\n    }, {\n        name: 'name 4',\n        gender: 'female',\n        age: 22,\n        score: 64\n    }];\n\n\n})\n```\n\n让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式\n\n```css\nth {\n    cursor: pointer;\n}\n```\n\n运行结果[点击这里](https://jsfiddle.net/Lionney/xowyoaxj/)查看\n","slug":"Angularjs轻松实现表格按指定列排序","published":1,"updated":"2016-06-03T07:19:56.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqg000gtsqbje6m8mn9","content":"<p>使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：</p>\n<p>html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table table-border\"</span> <span class=\"attr\">ng-app</span>=<span class=\"string\">\"myapp\"</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"orderByCtrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>inx<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='name';desc=!desc\"</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='gender';desc=!desc\"</span>&gt;</span>gender<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='age';desc=!desc\"</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='score';desc=!desc\"</span>&gt;</span>score<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"d in data|orderBy:col:desc\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"$index+1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.gender\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.age\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.score\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</span><br><span class=\"line\"></span><br><span class=\"line\">app.controller(<span class=\"string\">'orderByCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">    $scope.col = <span class=\"string\">'name'</span>;<span class=\"comment\">//默认按name列排序</span></span><br><span class=\"line\">    $scope.desc = <span class=\"number\">0</span>;<span class=\"comment\">//默认排序条件升序</span></span><br><span class=\"line\">    $scope.data = [&#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 1'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">26</span>,</span><br><span class=\"line\">        score: <span class=\"number\">70</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 2'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'female'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">24</span>,</span><br><span class=\"line\">        score: <span class=\"number\">84</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 3'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">20</span>,</span><br><span class=\"line\">        score: <span class=\"number\">76</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 4'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'female'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">22</span>,</span><br><span class=\"line\">        score: <span class=\"number\">64</span></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">th</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果<a href=\"https://jsfiddle.net/Lionney/xowyoaxj/\" target=\"_blank\" rel=\"external\">点击这里</a>查看</p>\n","excerpt":"","more":"<p>使用Angularjs的过滤器，可以很容易的实现在表格中，点击某一列标题进行排序，实现过程如下：</p>\n<p>html代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">class</span>=<span class=\"string\">\"table table-border\"</span> <span class=\"attr\">ng-app</span>=<span class=\"string\">\"myapp\"</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"orderByCtrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>inx<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='name';desc=!desc\"</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 当点击列标题时，执行click事件，将排序条件反转，即，如果原来是升序则将按降序，降序亦如此 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='gender';desc=!desc\"</span>&gt;</span>gender<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='age';desc=!desc\"</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">th</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"col='score';desc=!desc\"</span>&gt;</span>score<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tr</span> <span class=\"attr\">ng-repeat</span>=<span class=\"string\">\"d in data|orderBy:col:desc\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"$index+1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.gender\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.age\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">ng-bind</span>=<span class=\"string\">\"d.score\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>js代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> app = angular.module(<span class=\"string\">'myapp'</span>, []);</span><br><span class=\"line\"></span><br><span class=\"line\">app.controller(<span class=\"string\">'orderByCtrl'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">    $scope.col = <span class=\"string\">'name'</span>;<span class=\"comment\">//默认按name列排序</span></span><br><span class=\"line\">    $scope.desc = <span class=\"number\">0</span>;<span class=\"comment\">//默认排序条件升序</span></span><br><span class=\"line\">    $scope.data = [&#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 1'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">26</span>,</span><br><span class=\"line\">        score: <span class=\"number\">70</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 2'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'female'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">24</span>,</span><br><span class=\"line\">        score: <span class=\"number\">84</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 3'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'male'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">20</span>,</span><br><span class=\"line\">        score: <span class=\"number\">76</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        name: <span class=\"string\">'name 4'</span>,</span><br><span class=\"line\">        gender: <span class=\"string\">'female'</span>,</span><br><span class=\"line\">        age: <span class=\"number\">22</span>,</span><br><span class=\"line\">        score: <span class=\"number\">64</span></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>让运行界面好看些，使用了bootstrap.min.css样式库。为了交互性考虑，在表头增加了手指样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">th</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">cursor</span>: pointer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果<a href=\"https://jsfiddle.net/Lionney/xowyoaxj/\">点击这里</a>查看</p>\n"},{"title":"Angularjs知识点2","date":"2016-04-10T16:00:00.000Z","_content":"### 知识点\n\n+ ng-show\n+ ng-hide\n+ ng-switch\n\n### 代码及演示\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/jor7q4eq/)\n","source":"_posts/Angularjs知识点2.md","raw":"---\ntitle: Angularjs知识点2\ntags: [javascript,angularjs]\ndate: 2016/04/11\n---\n### 知识点\n\n+ ng-show\n+ ng-hide\n+ ng-switch\n\n### 代码及演示\n\n[jsfiddle.net](https://jsfiddle.net/Lionney/jor7q4eq/)\n","slug":"Angularjs知识点2","published":1,"updated":"2016-05-18T06:46:33.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqi000itsqbmn1euw92","content":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>ng-show</li>\n<li>ng-hide</li>\n<li>ng-switch</li>\n</ul>\n<h3 id=\"代码及演示\"><a href=\"#代码及演示\" class=\"headerlink\" title=\"代码及演示\"></a>代码及演示</h3><p><a href=\"https://jsfiddle.net/Lionney/jor7q4eq/\" target=\"_blank\" rel=\"external\">jsfiddle.net</a></p>\n","excerpt":"","more":"<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ul>\n<li>ng-show</li>\n<li>ng-hide</li>\n<li>ng-switch</li>\n</ul>\n<h3 id=\"代码及演示\"><a href=\"#代码及演示\" class=\"headerlink\" title=\"代码及演示\"></a>代码及演示</h3><p><a href=\"https://jsfiddle.net/Lionney/jor7q4eq/\">jsfiddle.net</a></p>\n"},{"title":"CSS vs JS动画：谁更快？","date":"2016-05-13T16:00:00.000Z","_content":"\n> 这篇文章翻译自 Julian Shapiro 的 [CSS vs. JS Animation: Which is Faster?](http://davidwalsh.name/css-js-animation)。Julian Shapiro 也是 [Velocity.js](http://julian.com/research/velocity/) 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。\n\nJavascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？\n\n这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。\n\n### jQuery\n\n让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n- jQuery 不能避免[layout thrashing](http://wilsonpage.co.uk/preventing-layout-thrashing/)（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。\n- jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易[让动画卡住](http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html)。\n- jQuery使用了`setInterval`而不是 `reqeustAnimationFrame(RAF)`，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）\n\n注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。\n\n### 实现样例\n\n为了避免layout thrashing，我们需要批量访问和更新DOM。\n\n```javascript\nvar currentTop,currentLeft; /* 有 layout thrashing. */\n\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */ \n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */ \n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */ \n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */ |\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：\n\n```javascript\nvar startingTop = 0; \n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {    \n\t/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */    \n\telement.style.top = (startingTop += 1/60);}, 16); \n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {    \n\telement.style.top = (startingTop += 1/60);\n} \n\t\nwindow.requestAnimationFrame(tick); \n```\n\n你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。\n\n### CSS Transition\n\nCSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：\n\n1. 通过优化 DOM 操作，避免内存消耗来减少卡顿\n2. 使用与 RAF 类似的机制\n3. 强制使用硬件加速 （通过 GPU 来提高动画性能）\n\n然而实际上Javascript也可以使用这些优化。[GSAP](http://www.greensock.com/gsap-js/) 已经做这些优化很久了。[Velocity.js](http://velocityjs.org/) 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。\n\n面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！\n\n让我们来看看CSS动画库的缺陷吧：\n\n- Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的[博客](http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/)谈到过这个问题。\n- IE 10以下的浏览器不支持transition。而目前IE8和IE9还是[很流行](http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share)的。\n- transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。\n\n反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。\n\n> 我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是[Transit](https://github.com/rstacruz/jquery.transit)。\n\n### Javascript动画\n\n所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个[3D 动画的demo](http://julian.com/research/velocity/demo.html)，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个[多媒体小动画](http://julian.com/research/velocity/playground.html)，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个[虚拟世界](http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs)，通常需要canvas才能完成。\n\n为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的[官方文档](http://velocityjs.org/)。\n\n之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：\n\n- 同步DOM ->在整个动画链中微调堆栈以达到最小的layout thrashing。\n- 缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）\n- 在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）\n- 忽略那些变动小到根本看不出来的DOM更新\n\n让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。\n\n```javascript\n$element  \n\t/* Slide the element down into view. */ \n\t.velocity({ opacity: 1, top: \"50%\" })\n\t/* After a delay of 1000ms, slide the element out of view. */    \n\t.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 }); \n```\n\n在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。\n\n浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。\n\n最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。\n\n- GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。\n- GSAP需要[付费](http://www.greensock.com/licensing/)才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。\n- 性能方面，两者几乎相当，很难区分胜负。\n\n> 我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。\n\n### Velocity.js\n\n之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。\n\n简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。\n\n更进一步从易用性的角度来讲，Velocity使用了jQuery的`$.queue()`方法，因此可以无缝过渡到jQuery的`$.animate()`、`$.fade()`和`$.delay()`方法。并且Velocity的语法和`$.animate()`一摸一样，所以我们根本不需要修改页面的现有代码。\n\n让我们快速过一下Velocity.js的例子：\n\n```javascript\n$element   \n\t.delay(1000)    \n\t/* Use Velocity to animate the element's top property over a duration of 2000ms. */    \n\t.velocity({ top: \"50%\" }, 2000)    \n\t/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */    \n\t.fadeOut(1000); \n```\n\n如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：\n\n```javascript\n$element    \n\t/* Scroll the browser to the top of this element over a duration of 1000ms. */    \n\t.velocity(\"scroll\", 1000)    \n\t/* Then rotate the element around its Y axis by 360 degrees. */    \n\t.velocity({ rotateY: \"360deg\" }, 1000); |\n```\n\n### 总结\n\nVelocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往[VelocityJS.org](http://velocityjs.org/)了解。\n\n在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：\n\n- [Jank Free](http://www.youtube.com/watch?v=n8ep4leoN9A)\n- [Rendering Without Lumps](http://www.youtube.com/watch?v=cmZqLzPy0XE)\n- [Faster Websites](http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance)\n\n转载整理：[http://web.jobbole.com](http://web.jobbole.com/86121/)","source":"_posts/CSS vs JS动画：谁更快？.md","raw":"---\ntitle: CSS vs JS动画：谁更快？\ntags: [javascript,jquery,css]\ndate: 2016/05/14\n---\n\n> 这篇文章翻译自 Julian Shapiro 的 [CSS vs. JS Animation: Which is Faster?](http://davidwalsh.name/css-js-animation)。Julian Shapiro 也是 [Velocity.js](http://julian.com/research/velocity/) 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。\n\nJavascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？\n\n这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。\n\n### jQuery\n\n让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：\n\n- jQuery 不能避免[layout thrashing](http://wilsonpage.co.uk/preventing-layout-thrashing/)（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。\n- jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易[让动画卡住](http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html)。\n- jQuery使用了`setInterval`而不是 `reqeustAnimationFrame(RAF)`，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）\n\n注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。\n\n### 实现样例\n\n为了避免layout thrashing，我们需要批量访问和更新DOM。\n\n```javascript\nvar currentTop,currentLeft; /* 有 layout thrashing. */\n\ncurrentTop = element.style.top; /* 访问 */\nelement.style.top = currentTop + 1; /* 更新 */ \n\ncurrentLeft = element.style.left; /* 访问 */\nelement.style.left = currentLeft + 1; /* 更新 */ \n\n/* 没有 layout thrashing. */\ncurrentTop = element.style.top; /* 访问 */\ncurrentLeft = element.style.left; /* 访问 */ \n\nelement.style.top = currentTop + 1; /* 更新 */\nelement.style.left = currentLeft + 1; /* 更新 */ |\n```\n\n在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。\n\n类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：\n\n```javascript\nvar startingTop = 0; \n\n/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */\nsetInterval(function() {    \n\t/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */    \n\telement.style.top = (startingTop += 1/60);}, 16); \n\n/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */\nfunction tick () {    \n\telement.style.top = (startingTop += 1/60);\n} \n\t\nwindow.requestAnimationFrame(tick); \n```\n\n你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。\n\n### CSS Transition\n\nCSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：\n\n1. 通过优化 DOM 操作，避免内存消耗来减少卡顿\n2. 使用与 RAF 类似的机制\n3. 强制使用硬件加速 （通过 GPU 来提高动画性能）\n\n然而实际上Javascript也可以使用这些优化。[GSAP](http://www.greensock.com/gsap-js/) 已经做这些优化很久了。[Velocity.js](http://velocityjs.org/) 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。\n\n面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！\n\n让我们来看看CSS动画库的缺陷吧：\n\n- Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的[博客](http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/)谈到过这个问题。\n- IE 10以下的浏览器不支持transition。而目前IE8和IE9还是[很流行](http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share)的。\n- transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。\n\n反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。\n\n> 我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是[Transit](https://github.com/rstacruz/jquery.transit)。\n\n### Javascript动画\n\n所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个[3D 动画的demo](http://julian.com/research/velocity/demo.html)，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个[多媒体小动画](http://julian.com/research/velocity/playground.html)，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个[虚拟世界](http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs)，通常需要canvas才能完成。\n\n为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的[官方文档](http://velocityjs.org/)。\n\n之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：\n\n- 同步DOM ->在整个动画链中微调堆栈以达到最小的layout thrashing。\n- 缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）\n- 在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）\n- 忽略那些变动小到根本看不出来的DOM更新\n\n让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。\n\n```javascript\n$element  \n\t/* Slide the element down into view. */ \n\t.velocity({ opacity: 1, top: \"50%\" })\n\t/* After a delay of 1000ms, slide the element out of view. */    \n\t.velocity({ opacity: 0, top: \"-50%\" }, { delay: 1000 }); \n```\n\n在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。\n\n浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。\n\n最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。\n\n- GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。\n- GSAP需要[付费](http://www.greensock.com/licensing/)才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。\n- 性能方面，两者几乎相当，很难区分胜负。\n\n> 我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。\n\n### Velocity.js\n\n之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。\n\n简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。\n\n更进一步从易用性的角度来讲，Velocity使用了jQuery的`$.queue()`方法，因此可以无缝过渡到jQuery的`$.animate()`、`$.fade()`和`$.delay()`方法。并且Velocity的语法和`$.animate()`一摸一样，所以我们根本不需要修改页面的现有代码。\n\n让我们快速过一下Velocity.js的例子：\n\n```javascript\n$element   \n\t.delay(1000)    \n\t/* Use Velocity to animate the element's top property over a duration of 2000ms. */    \n\t.velocity({ top: \"50%\" }, 2000)    \n\t/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */    \n\t.fadeOut(1000); \n```\n\n如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：\n\n```javascript\n$element    \n\t/* Scroll the browser to the top of this element over a duration of 1000ms. */    \n\t.velocity(\"scroll\", 1000)    \n\t/* Then rotate the element around its Y axis by 360 degrees. */    \n\t.velocity({ rotateY: \"360deg\" }, 1000); |\n```\n\n### 总结\n\nVelocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往[VelocityJS.org](http://velocityjs.org/)了解。\n\n在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：\n\n- [Jank Free](http://www.youtube.com/watch?v=n8ep4leoN9A)\n- [Rendering Without Lumps](http://www.youtube.com/watch?v=cmZqLzPy0XE)\n- [Faster Websites](http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance)\n\n转载整理：[http://web.jobbole.com](http://web.jobbole.com/86121/)","slug":"CSS vs JS动画：谁更快？","published":1,"updated":"2016-05-17T07:38:13.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqo000ltsqbwjt8cjdg","content":"<blockquote>\n<p>这篇文章翻译自 Julian Shapiro 的 <a href=\"http://davidwalsh.name/css-js-animation\" target=\"_blank\" rel=\"external\">CSS vs. JS Animation: Which is Faster?</a>。Julian Shapiro 也是 <a href=\"http://julian.com/research/velocity/\" target=\"_blank\" rel=\"external\">Velocity.js</a> 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。</p>\n</blockquote>\n<p>Javascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？</p>\n<p>这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。</p>\n<h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><p>让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：</p>\n<ul>\n<li>jQuery 不能避免<a href=\"http://wilsonpage.co.uk/preventing-layout-thrashing/\" target=\"_blank\" rel=\"external\">layout thrashing</a>（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。</li>\n<li>jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易<a href=\"http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\" target=\"_blank\" rel=\"external\">让动画卡住</a>。</li>\n<li>jQuery使用了<code>setInterval</code>而不是 <code>reqeustAnimationFrame(RAF)</code>，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）</li>\n</ul>\n<p>注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。</p>\n<h3 id=\"实现样例\"><a href=\"#实现样例\" class=\"headerlink\" title=\"实现样例\"></a>实现样例</h3><p>为了避免layout thrashing，我们需要批量访问和更新DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentTop,currentLeft; <span class=\"comment\">/* 有 layout thrashing. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 没有 layout thrashing. */</span></span><br><span class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span></span><br><span class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> |</span><br></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startingTop = <span class=\"number\">0</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">\t<span class=\"comment\">/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */</span>    </span><br><span class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);&#125;, <span class=\"number\">16</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span> (<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(tick);</span><br></pre></td></tr></table></figure>\n<p>你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。</p>\n<h3 id=\"CSS-Transition\"><a href=\"#CSS-Transition\" class=\"headerlink\" title=\"CSS Transition\"></a>CSS Transition</h3><p>CSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：</p>\n<ol>\n<li>通过优化 DOM 操作，避免内存消耗来减少卡顿</li>\n<li>使用与 RAF 类似的机制</li>\n<li>强制使用硬件加速 （通过 GPU 来提高动画性能）</li>\n</ol>\n<p>然而实际上Javascript也可以使用这些优化。<a href=\"http://www.greensock.com/gsap-js/\" target=\"_blank\" rel=\"external\">GSAP</a> 已经做这些优化很久了。<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">Velocity.js</a> 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。</p>\n<p>面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！</p>\n<p>让我们来看看CSS动画库的缺陷吧：</p>\n<ul>\n<li>Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的<a href=\"http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/\" target=\"_blank\" rel=\"external\">博客</a>谈到过这个问题。</li>\n<li>IE 10以下的浏览器不支持transition。而目前IE8和IE9还是<a href=\"http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share\" target=\"_blank\" rel=\"external\">很流行</a>的。</li>\n<li>transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。</li>\n</ul>\n<p>反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。</p>\n<blockquote>\n<p>我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是<a href=\"https://github.com/rstacruz/jquery.transit\" target=\"_blank\" rel=\"external\">Transit</a>。</p>\n</blockquote>\n<h3 id=\"Javascript动画\"><a href=\"#Javascript动画\" class=\"headerlink\" title=\"Javascript动画\"></a>Javascript动画</h3><p>所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个<a href=\"http://julian.com/research/velocity/demo.html\" target=\"_blank\" rel=\"external\">3D 动画的demo</a>，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个<a href=\"http://julian.com/research/velocity/playground.html\" target=\"_blank\" rel=\"external\">多媒体小动画</a>，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个<a href=\"http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs\" target=\"_blank\" rel=\"external\">虚拟世界</a>，通常需要canvas才能完成。</p>\n<p>为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">官方文档</a>。</p>\n<p>之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：</p>\n<ul>\n<li>同步DOM -&gt;在整个动画链中微调堆栈以达到最小的layout thrashing。</li>\n<li>缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）</li>\n<li>在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）</li>\n<li>忽略那些变动小到根本看不出来的DOM更新</li>\n</ul>\n<p>让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element  </span><br><span class=\"line\">\t<span class=\"comment\">/* Slide the element down into view. */</span> </span><br><span class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">1</span>, top: <span class=\"string\">\"50%\"</span> &#125;)</span><br><span class=\"line\">\t<span class=\"comment\">/* After a delay of 1000ms, slide the element out of view. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">0</span>, top: <span class=\"string\">\"-50%\"</span> &#125;, &#123; delay: <span class=\"number\">1000</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。</p>\n<p>浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。</p>\n<p>最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。</p>\n<ul>\n<li>GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。</li>\n<li>GSAP需要<a href=\"http://www.greensock.com/licensing/\" target=\"_blank\" rel=\"external\">付费</a>才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。</li>\n<li>性能方面，两者几乎相当，很难区分胜负。</li>\n</ul>\n<blockquote>\n<p>我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。</p>\n</blockquote>\n<h3 id=\"Velocity-js\"><a href=\"#Velocity-js\" class=\"headerlink\" title=\"Velocity.js\"></a>Velocity.js</h3><p>之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。</p>\n<p>简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。</p>\n<p>更进一步从易用性的角度来讲，Velocity使用了jQuery的<code>$.queue()</code>方法，因此可以无缝过渡到jQuery的<code>$.animate()</code>、<code>$.fade()</code>和<code>$.delay()</code>方法。并且Velocity的语法和<code>$.animate()</code>一摸一样，所以我们根本不需要修改页面的现有代码。</p>\n<p>让我们快速过一下Velocity.js的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element   </span><br><span class=\"line\">\t.delay(<span class=\"number\">1000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Use Velocity to animate the element's top property over a duration of 2000ms. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; top: <span class=\"string\">\"50%\"</span> &#125;, <span class=\"number\">2000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */</span>    </span><br><span class=\"line\">\t.fadeOut(<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element    </span><br><span class=\"line\">\t<span class=\"comment\">/* Scroll the browser to the top of this element over a duration of 1000ms. */</span>    </span><br><span class=\"line\">\t.velocity(<span class=\"string\">\"scroll\"</span>, <span class=\"number\">1000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Then rotate the element around its Y axis by 360 degrees. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; rotateY: <span class=\"string\">\"360deg\"</span> &#125;, <span class=\"number\">1000</span>); |</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Velocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往<a href=\"http://velocityjs.org/\" target=\"_blank\" rel=\"external\">VelocityJS.org</a>了解。</p>\n<p>在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：</p>\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=n8ep4leoN9A\" target=\"_blank\" rel=\"external\">Jank Free</a></li>\n<li><a href=\"http://www.youtube.com/watch?v=cmZqLzPy0XE\" target=\"_blank\" rel=\"external\">Rendering Without Lumps</a></li>\n<li><a href=\"http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance\" target=\"_blank\" rel=\"external\">Faster Websites</a></li>\n</ul>\n<p>转载整理：<a href=\"http://web.jobbole.com/86121/\" target=\"_blank\" rel=\"external\">http://web.jobbole.com</a></p>\n","excerpt":"","more":"<blockquote>\n<p>这篇文章翻译自 Julian Shapiro 的 <a href=\"http://davidwalsh.name/css-js-animation\">CSS vs. JS Animation: Which is Faster?</a>。Julian Shapiro 也是 <a href=\"http://julian.com/research/velocity/\">Velocity.js</a> 的创造者。这是一个非常高效、简单易用的JS动画库。他在Web动画方面有很高的造诣。</p>\n</blockquote>\n<p>Javascript 动画怎么可能总是和 CSS transition 一样快，甚至更快呢？到底是什么秘密呢？Adobe 和 Google 是怎么做到让他们的富媒体移动网站的速度和 native app 媲美的？</p>\n<p>这篇文章会一步步告诉你为什么基于 Javascript 的 DOM 动画库（比如 Velocity.js 和 GSAP）能够比 jQuery 和基于 CSS 的动画库更高效。</p>\n<h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><p>让我们从基本开始说起： Javascript和jQuery两者不能混为一谈。Javascript 动画很快，而jQuery动画很慢。为什么呢？因为尽管jQuery异常强大，但是它的设计目标并不是一个高效的动画引擎：</p>\n<ul>\n<li>jQuery 不能避免<a href=\"http://wilsonpage.co.uk/preventing-layout-thrashing/\">layout thrashing</a>（有人喜欢将其翻译为“布局颠簸”，会导致多余relayout/reflow），因为它的代码不仅仅用于动画，它还用于很多其他场景。</li>\n<li>jQuery的内存消耗较大，经常会触发垃圾回收。而垃圾回收触发时很容易<a href=\"http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html\">让动画卡住</a>。</li>\n<li>jQuery使用了<code>setInterval</code>而不是 <code>reqeustAnimationFrame(RAF)</code>，因为 RAF 会在窗口失去焦点时停止触发，这会导致jQuery的bug。（目前jQuery已经使用了RAF）</li>\n</ul>\n<p>注意 layout thrashing 会导致动画在开始的时候卡顿，垃圾回收的触发会导致动画运行过程中的卡顿，不使用 RAF 则会导致动画帧率低。</p>\n<h3 id=\"实现样例\"><a href=\"#实现样例\" class=\"headerlink\" title=\"实现样例\"></a>实现样例</h3><p>为了避免layout thrashing，我们需要批量访问和更新DOM。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currentTop,currentLeft; <span class=\"comment\">/* 有 layout thrashing. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 没有 layout thrashing. */</span></span><br><span class=\"line\">currentTop = element.style.top; <span class=\"comment\">/* 访问 */</span></span><br><span class=\"line\">currentLeft = element.style.left; <span class=\"comment\">/* 访问 */</span> </span><br><span class=\"line\"></span><br><span class=\"line\">element.style.top = currentTop + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span></span><br><span class=\"line\">element.style.left = currentLeft + <span class=\"number\">1</span>; <span class=\"comment\">/* 更新 */</span> |</span><br></pre></td></tr></table></figure>\n<p>在更新操作之后的访问操作会强制浏览器重新计算页面元素的样式（因为要将更新的样式应用上去才能获取正确的值）。这在一般操作下没多大的性能损失，但是放在间隔仅仅16ms的动画中则会导致显著的性能开销。只需要稍微改动下操作的顺序就可以大大提高动画的性能。</p>\n<p>类似地，使用RAF也不会让你大量重构代码。让我们来比较下使用RAF和使用setInterval的区别：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startingTop = <span class=\"number\">0</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* setInterval: Runs every 16ms to achieve 60fps (1000ms/60 ~= 16ms). */</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">\t<span class=\"comment\">/* Since this ticks 60 times a second, we divide the top property's increment of 1 unit per 1 second by 60. */</span>    </span><br><span class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);&#125;, <span class=\"number\">16</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* requestAnimationFrame: Attempts to run at 60fps based on whether the browser is in an optimal state. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tick</span> (<span class=\"params\"></span>) </span>&#123;    </span><br><span class=\"line\">\telement.style.top = (startingTop += <span class=\"number\">1</span>/<span class=\"number\">60</span>);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"built_in\">window</span>.requestAnimationFrame(tick);</span><br></pre></td></tr></table></figure>\n<p>你只需要稍微修改下代码来使用RAF，就可以让你的动画性能有巨大的提高。</p>\n<h3 id=\"CSS-Transition\"><a href=\"#CSS-Transition\" class=\"headerlink\" title=\"CSS Transition\"></a>CSS Transition</h3><p>CSS transition的动画逻辑是由浏览器来执行，所以它的性能能够比jQuery动画好。它的优势体现在：</p>\n<ol>\n<li>通过优化 DOM 操作，避免内存消耗来减少卡顿</li>\n<li>使用与 RAF 类似的机制</li>\n<li>强制使用硬件加速 （通过 GPU 来提高动画性能）</li>\n</ol>\n<p>然而实际上Javascript也可以使用这些优化。<a href=\"http://www.greensock.com/gsap-js/\">GSAP</a> 已经做这些优化很久了。<a href=\"http://velocityjs.org/\">Velocity.js</a> 是一个新兴的动画引擎，它不仅仅做了这些优化，甚至走的更远些。我们稍后会谈到这些。</p>\n<p>面对事实，让Javascript动画得以媲美CSS动画的性能只是我们伟大计划的第一步。第二步才是重头戏，要让Javascript动画比CSS动画还要快！</p>\n<p>让我们来看看CSS动画库的缺陷吧：</p>\n<ul>\n<li>Transition强制使用了GPU的硬件加速。导致浏览器一直处于高负荷运转的状态，这反而会让动画变的卡顿。这在移动浏览器上更为严重。（特别要说明的是，当数据在浏览器的主线程和合成线程之间频繁传输的时候特别消耗性能，故容易导致卡顿。某些CSS属性，不会受到影响。Adobe 的<a href=\"http://blogs.adobe.com/webplatform/2014/03/18/css-animations-and-transitions-performance/\">博客</a>谈到过这个问题。</li>\n<li>IE 10以下的浏览器不支持transition。而目前IE8和IE9还是<a href=\"http://thenextweb.com/insider/2014/02/01/ie11-passes-ie10-market-share-firefox-slips-bit-chrome-gains-back-share\">很流行</a>的。</li>\n<li>transition不能完全被Javascript控制（只能通过Javascript来触发transition），因为浏览器不知道如何同时让Javascript控制动画又同时优化动画的性能。</li>\n</ul>\n<p>反过来说：基于Javascript可以决定什么时候启用硬件加速，它可以支持全版本的IE，并且它完全可以进行批量动画的优化。</p>\n<blockquote>\n<p>我的建议是：当你只在移动平台上开发，并且动画只是简单的状态切换，那么适合用纯CSS transition。在这种情况下，transition是高性能的原生支持方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥Javascript库。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的app。那么我推荐你使用一个动画库，这样你的动画可以保持高效，并且你的工作流也更可控。有一个特别的库做的特别棒，它可以用Javascript控制CSS transition。这就是<a href=\"https://github.com/rstacruz/jquery.transit\">Transit</a>。</p>\n</blockquote>\n<h3 id=\"Javascript动画\"><a href=\"#Javascript动画\" class=\"headerlink\" title=\"Javascript动画\"></a>Javascript动画</h3><p>所以Javascript可以比CSS transition性能更好。但是它到底有多块呢？它快到足够可以构建一个<a href=\"http://julian.com/research/velocity/demo.html\">3D 动画的demo</a>，通常需要用到 WebGL 才能完成。并且它快到足够搭建一个<a href=\"http://julian.com/research/velocity/playground.html\">多媒体小动画</a>，通常需要Flash或者 After Effects才能完成。并且它还快到可以构建一个<a href=\"http://danielraftery.com/read/Animating-Awesomeness-with-Velocityjs\">虚拟世界</a>，通常需要canvas才能完成。</p>\n<p>为了更直接的来比较主流动画库的性能，包括Transit（使用了 CSS transition），让我们打开Velocity的<a href=\"http://velocityjs.org/\">官方文档</a>。</p>\n<p>之前那个问题还在：Javascript是如何达到高性能的呢？下面是一个列表，列举了基于Javascript的动画库能做的事情：</p>\n<ul>\n<li>同步DOM -&gt;在整个动画链中微调堆栈以达到最小的layout thrashing。</li>\n<li>缓存链式操作中的属性值，这样可以最小化DOM的查询操作（这就是高性能DOM动画的阿喀琉斯之踵）</li>\n<li>在同一个跨同层元素的调用中缓存单位转化比率（例如px转换成%、em等等单位）</li>\n<li>忽略那些变动小到根本看不出来的DOM更新</li>\n</ul>\n<p>让我们重新温习下之前学到的关于layout thrashing的知识点。Velocity.js运用了这些最佳实践，缓存了动画结束时的属性值，在紧接的下一次动画开始时使用。这样可以避免重新查询动画的起始属性值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element  </span><br><span class=\"line\">\t<span class=\"comment\">/* Slide the element down into view. */</span> </span><br><span class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">1</span>, top: <span class=\"string\">\"50%\"</span> &#125;)</span><br><span class=\"line\">\t<span class=\"comment\">/* After a delay of 1000ms, slide the element out of view. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; opacity: <span class=\"number\">0</span>, top: <span class=\"string\">\"-50%\"</span> &#125;, &#123; delay: <span class=\"number\">1000</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>在上面的样例中，第二次调用Velocity时已经知道了opacity的起始值为1，top的值为50%。</p>\n<p>浏览器也可以使用与此类似的优化，但是要做这些事情太过激进，使用场景也会受到限制，开发者就有可能会写出有bug的动画代码。jQuery就是因为这个原因没有使用RAF（如上所说），浏览器永远不会强行实施可能打破规范或者可能偏离期望行为的优化。</p>\n<p>最后，让我们来比较下两个Javascript框架（velocity.js和GSAP）。</p>\n<ul>\n<li>GASP是一个快速且功能丰富的动画平台。Velocity则更为轻量级，它大大地改善了UI动画性能和工作流程。</li>\n<li>GSAP需要<a href=\"http://www.greensock.com/licensing/\">付费</a>才能用于商业产品。Velocity是完全免费的，它使用了自由度极高的MIT协议。</li>\n<li>性能方面，两者几乎相当，很难区分胜负。</li>\n</ul>\n<blockquote>\n<p>我个人推荐在你需要如下功能时使用GSAP：精确控制时间（例如remapping，暂停/继续/跳过），或者需要动作（例如：贝赛尔曲线路径），又或者复杂的动画组合/队列。这些特性对游戏开发或者复杂的应用很重要，但是对普通的web app的UI不太需要。</p>\n</blockquote>\n<h3 id=\"Velocity-js\"><a href=\"#Velocity-js\" class=\"headerlink\" title=\"Velocity.js\"></a>Velocity.js</h3><p>之前提到了GSAP有着丰富的功能，但这不代表Velocity的功能简单。相反的，Velocity在 zip压缩之后只有7kb，它不仅仅实现了jQuery animate方法的所有功能，还包含了颜色、transforms、loop、easings、class动画和滚动动画等功能。</p>\n<p>简单的说就是Velocity包含了jQuery、jQuery UI和CSS transition的功能。</p>\n<p>更进一步从易用性的角度来讲，Velocity使用了jQuery的<code>$.queue()</code>方法，因此可以无缝过渡到jQuery的<code>$.animate()</code>、<code>$.fade()</code>和<code>$.delay()</code>方法。并且Velocity的语法和<code>$.animate()</code>一摸一样，所以我们根本不需要修改页面的现有代码。</p>\n<p>让我们快速过一下Velocity.js的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element   </span><br><span class=\"line\">\t.delay(<span class=\"number\">1000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Use Velocity to animate the element's top property over a duration of 2000ms. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; top: <span class=\"string\">\"50%\"</span> &#125;, <span class=\"number\">2000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Use a standard jQuery method to fade the element out once Velocity is done animating top. */</span>    </span><br><span class=\"line\">\t.fadeOut(<span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<p>如下是一个高级用法：滚动网页到当前元素并且旋转元素。这样的动画只需要简单的几行代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$element    </span><br><span class=\"line\">\t<span class=\"comment\">/* Scroll the browser to the top of this element over a duration of 1000ms. */</span>    </span><br><span class=\"line\">\t.velocity(<span class=\"string\">\"scroll\"</span>, <span class=\"number\">1000</span>)    </span><br><span class=\"line\">\t<span class=\"comment\">/* Then rotate the element around its Y axis by 360 degrees. */</span>    </span><br><span class=\"line\">\t.velocity(&#123; rotateY: <span class=\"string\">\"360deg\"</span> &#125;, <span class=\"number\">1000</span>); |</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Velocity 的目标是成 DOM动画领域性能最好易用性最高的库。这篇文章主要关注了性能方面。易用性方面可以前往<a href=\"http://velocityjs.org/\">VelocityJS.org</a>了解。</p>\n<p>在结束之前，请记住一个高性能的UI绝不仅仅是选择一个正确的动画库。页面上的其他代码也需要优化。可以看看Google那些非常棒的演讲：</p>\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=n8ep4leoN9A\">Jank Free</a></li>\n<li><a href=\"http://www.youtube.com/watch?v=cmZqLzPy0XE\">Rendering Without Lumps</a></li>\n<li><a href=\"http://www.devoxx.com/display/DV12/Faster+Websites++Crash+Course+on+Frontend+Performance\">Faster Websites</a></li>\n</ul>\n<p>转载整理：<a href=\"http://web.jobbole.com/86121/\">http://web.jobbole.com</a></p>\n"},{"title":"Array.prototype.reduce函数","date":"2016-04-09T16:00:00.000Z","_content":"\n### 概述\n\nreduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\n### 语法\n\n`arr.reduce(callback,[initialValue])`\n\n**参数**\n\n*callback 执行数组中每个值的函数，包含四个参数*\n\n> *previousValue*\n> 上一次调用回调返回的值，或者是提供的初始值（initialValue）\n> *currentValue*\n> 数组中当前被处理的元素\n> *index*\n> 当前元素在数组中的索引\n> *array*\n> 调用 reduce 的数组\n> *initialValue*\n> 作为第一次调用 callback 的第一个参数。\n\n### 描述\n\nreduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。\n\n回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。\n\n例如执行下面的代码\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n});\n```\n\n回调被执行四次，每次的参数和返回值如下表：\n\n| previousValue | currentValue | index | array | return | value       |\n| ------------- | ------------ | ----- | ----- | ------ | ----------- |\n| first         | call         | 0     | 1     | 1      | [0,1,2,3,4] |\n| second        | call         | 1     | 2     | 2      | [0,1,2,3,4] |\n| third         | call         | 3     | 3     | 3      | [0,1,2,3,4] |\n| fourth        | call         | 6     | 4     | 4      | [0,1,2,3,4] |\n\nreduce 的返回值是回调函数最后一次被调用的返回值（10）。\n\n如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n}, 10);\n```\n\n| previousValue | currentValue | index | array | return      | value |\n| ------------- | ------------ | ----- | ----- | ----------- | ----- |\n| 第一次调用         | 10           | 0     | 0     | [0,1,2,3,4] | 10    |\n| 第二次调用         | 10           | 1     | 1     | [0,1,2,3,4] | 11    |\n| 第三次调用         | 11           | 2     | 2     | [0,1,2,3,4] | 13    |\n| 第四次调用         | 13           | 3     | 3     | [0,1,2,3,4] | 16    |\n| 第五次调用         | 16           | 4     | 4     | [0,1,2,3,4] | 20    |\n\n### 例子\n\n例子:将数组所有项相加\n\n```\nvar total = [0, 1, 2, 3].reduce(function(a, b) {\n    return a + b;\n});\n// total == 6\n```\n\n例子: 数组扁平化\n\n```\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n    return a.concat(b);\n});\n// flattened is [0, 1, 2, 3, 4, 5]\n```\n\n### 兼容旧环境（Polyfill）\n\nArray.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。\n\n```\nif ('function' !== typeof Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback, opt_initialValue){\n    'use strict';\n    if (null === this || 'undefined' === typeof this) {\n      // At the moment all modern browsers, that support strict mode, have\n      // native implementation of Array.prototype.reduce. For instance, IE8\n      // does not support strict mode, so this check is actually useless.\n      throw new TypeError(\n          'Array.prototype.reduce called on null or undefined');\n    }\n    if ('function' !== typeof callback) {\n      throw new TypeError(callback + ' is not a function');\n    }\n    var index, value,\n        length = this.length >>> 0,\n        isValueSet = false;\n    if (1 < arguments.length) {\n      value = opt_initialValue;\n      isValueSet = true;\n    }\n    for (index = 0; length > index; ++index) {\n      if (this.hasOwnProperty(index)) {\n        if (isValueSet) {\n          value = callback(value, this[index], index, this);\n        }\n        else {\n          value = this[index];\n          isValueSet = true;\n        }\n      }\n    }\n    if (!isValueSet) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    return value;\n  };\n}\n```\n\n### 浏览器兼容性\n**Desktop**\n\n| Feature       | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari |\n| ------------- | ------ | --------------- | ----------------- | ----- | ------ |\n| Basic support | (Yes)  | 3.0(1.9)        | 9                 | 10.5  | 4.0    |\n\n**Mobile**\n\n| Feature       | Android | Chrome for Android | Firefox Mobile (Gecko) | IE Mobile | Opera Mobile | Safari Mobile |\n| ------------- | ------- | ------------------ | ---------------------- | --------- | ------------ | ------------- |\n| Basic support | (Yes)   | (Yes)              | (Yes)                  | (Yes)     | (Yes)        | (Yes)         |\n","source":"_posts/Array.prototype.reduce函数.md","raw":"---\ntitle: Array.prototype.reduce函数\ntags: [javascript]\ndate: 2016/04/10\n---\n\n### 概述\n\nreduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\n### 语法\n\n`arr.reduce(callback,[initialValue])`\n\n**参数**\n\n*callback 执行数组中每个值的函数，包含四个参数*\n\n> *previousValue*\n> 上一次调用回调返回的值，或者是提供的初始值（initialValue）\n> *currentValue*\n> 数组中当前被处理的元素\n> *index*\n> 当前元素在数组中的索引\n> *array*\n> 调用 reduce 的数组\n> *initialValue*\n> 作为第一次调用 callback 的第一个参数。\n\n### 描述\n\nreduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。\n\n回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。\n\n例如执行下面的代码\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n});\n```\n\n回调被执行四次，每次的参数和返回值如下表：\n\n| previousValue | currentValue | index | array | return | value       |\n| ------------- | ------------ | ----- | ----- | ------ | ----------- |\n| first         | call         | 0     | 1     | 1      | [0,1,2,3,4] |\n| second        | call         | 1     | 2     | 2      | [0,1,2,3,4] |\n| third         | call         | 3     | 3     | 3      | [0,1,2,3,4] |\n| fourth        | call         | 6     | 4     | 4      | [0,1,2,3,4] |\n\nreduce 的返回值是回调函数最后一次被调用的返回值（10）。\n\n如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：\n\n```\n[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array){\n  return previousValue + currentValue;\n}, 10);\n```\n\n| previousValue | currentValue | index | array | return      | value |\n| ------------- | ------------ | ----- | ----- | ----------- | ----- |\n| 第一次调用         | 10           | 0     | 0     | [0,1,2,3,4] | 10    |\n| 第二次调用         | 10           | 1     | 1     | [0,1,2,3,4] | 11    |\n| 第三次调用         | 11           | 2     | 2     | [0,1,2,3,4] | 13    |\n| 第四次调用         | 13           | 3     | 3     | [0,1,2,3,4] | 16    |\n| 第五次调用         | 16           | 4     | 4     | [0,1,2,3,4] | 20    |\n\n### 例子\n\n例子:将数组所有项相加\n\n```\nvar total = [0, 1, 2, 3].reduce(function(a, b) {\n    return a + b;\n});\n// total == 6\n```\n\n例子: 数组扁平化\n\n```\nvar flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) {\n    return a.concat(b);\n});\n// flattened is [0, 1, 2, 3, 4, 5]\n```\n\n### 兼容旧环境（Polyfill）\n\nArray.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。\n\n```\nif ('function' !== typeof Array.prototype.reduce) {\n  Array.prototype.reduce = function(callback, opt_initialValue){\n    'use strict';\n    if (null === this || 'undefined' === typeof this) {\n      // At the moment all modern browsers, that support strict mode, have\n      // native implementation of Array.prototype.reduce. For instance, IE8\n      // does not support strict mode, so this check is actually useless.\n      throw new TypeError(\n          'Array.prototype.reduce called on null or undefined');\n    }\n    if ('function' !== typeof callback) {\n      throw new TypeError(callback + ' is not a function');\n    }\n    var index, value,\n        length = this.length >>> 0,\n        isValueSet = false;\n    if (1 < arguments.length) {\n      value = opt_initialValue;\n      isValueSet = true;\n    }\n    for (index = 0; length > index; ++index) {\n      if (this.hasOwnProperty(index)) {\n        if (isValueSet) {\n          value = callback(value, this[index], index, this);\n        }\n        else {\n          value = this[index];\n          isValueSet = true;\n        }\n      }\n    }\n    if (!isValueSet) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n    return value;\n  };\n}\n```\n\n### 浏览器兼容性\n**Desktop**\n\n| Feature       | Chrome | Firefox (Gecko) | Internet Explorer | Opera | Safari |\n| ------------- | ------ | --------------- | ----------------- | ----- | ------ |\n| Basic support | (Yes)  | 3.0(1.9)        | 9                 | 10.5  | 4.0    |\n\n**Mobile**\n\n| Feature       | Android | Chrome for Android | Firefox Mobile (Gecko) | IE Mobile | Opera Mobile | Safari Mobile |\n| ------------- | ------- | ------------------ | ---------------------- | --------- | ------------ | ------------- |\n| Basic support | (Yes)   | (Yes)              | (Yes)                  | (Yes)     | (Yes)        | (Yes)         |\n","slug":"Array.prototype.reduce函数","published":1,"updated":"2016-05-18T06:48:31.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqr000ntsqbwesaaoop","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>arr.reduce(callback,[initialValue])</code></p>\n<p><strong>参数</strong></p>\n<p><em>callback 执行数组中每个值的函数，包含四个参数</em></p>\n<blockquote>\n<p><em>previousValue</em><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）<br><em>currentValue</em><br>数组中当前被处理的元素<br><em>index</em><br>当前元素在数组中的索引<br><em>array</em><br>调用 reduce 的数组<br><em>initialValue</em><br>作为第一次调用 callback 的第一个参数。</p>\n</blockquote>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>\n<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>\n<p>例如执行下面的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class=\"line\">  return previousValue + currentValue;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>回调被执行四次，每次的参数和返回值如下表：</p>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first</td>\n<td>call</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>second</td>\n<td>call</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>third</td>\n<td>call</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>fourth</td>\n<td>call</td>\n<td>6</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数最后一次被调用的返回值（10）。</p>\n<p>如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class=\"line\">  return previousValue + currentValue;</span><br><span class=\"line\">&#125;, 10);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次调用</td>\n<td>10</td>\n<td>0</td>\n<td>0</td>\n<td>[0,1,2,3,4]</td>\n<td>10</td>\n</tr>\n<tr>\n<td>第二次调用</td>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n<td>11</td>\n</tr>\n<tr>\n<td>第三次调用</td>\n<td>11</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n<td>13</td>\n</tr>\n<tr>\n<td>第四次调用</td>\n<td>13</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n<td>16</td>\n</tr>\n<tr>\n<td>第五次调用</td>\n<td>16</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>例子:将数组所有项相加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var total = [0, 1, 2, 3].reduce(function(a, b) &#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// total == 6</span><br></pre></td></tr></table></figure>\n<p>例子: 数组扁平化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</span><br><span class=\"line\">    return a.concat(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// flattened is [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容旧环境（Polyfill）\"><a href=\"#兼容旧环境（Polyfill）\" class=\"headerlink\" title=\"兼容旧环境（Polyfill）\"></a>兼容旧环境（Polyfill）</h3><p>Array.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&apos;function&apos; !== typeof Array.prototype.reduce) &#123;</span><br><span class=\"line\">  Array.prototype.reduce = function(callback, opt_initialValue)&#123;</span><br><span class=\"line\">    &apos;use strict&apos;;</span><br><span class=\"line\">    if (null === this || &apos;undefined&apos; === typeof this) &#123;</span><br><span class=\"line\">      // At the moment all modern browsers, that support strict mode, have</span><br><span class=\"line\">      // native implementation of Array.prototype.reduce. For instance, IE8</span><br><span class=\"line\">      // does not support strict mode, so this check is actually useless.</span><br><span class=\"line\">      throw new TypeError(</span><br><span class=\"line\">          &apos;Array.prototype.reduce called on null or undefined&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (&apos;function&apos; !== typeof callback) &#123;</span><br><span class=\"line\">      throw new TypeError(callback + &apos; is not a function&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var index, value,</span><br><span class=\"line\">        length = this.length &gt;&gt;&gt; 0,</span><br><span class=\"line\">        isValueSet = false;</span><br><span class=\"line\">    if (1 &lt; arguments.length) &#123;</span><br><span class=\"line\">      value = opt_initialValue;</span><br><span class=\"line\">      isValueSet = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (index = 0; length &gt; index; ++index) &#123;</span><br><span class=\"line\">      if (this.hasOwnProperty(index)) &#123;</span><br><span class=\"line\">        if (isValueSet) &#123;</span><br><span class=\"line\">          value = callback(value, this[index], index, this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">          value = this[index];</span><br><span class=\"line\">          isValueSet = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!isValueSet) &#123;</span><br><span class=\"line\">      throw new TypeError(&apos;Reduce of empty array with no initial value&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p><strong>Desktop</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Chrome</th>\n<th>Firefox (Gecko)</th>\n<th>Internet Explorer</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>3.0(1.9)</td>\n<td>9</td>\n<td>10.5</td>\n<td>4.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mobile</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Android</th>\n<th>Chrome for Android</th>\n<th>Firefox Mobile (Gecko)</th>\n<th>IE Mobile</th>\n<th>Opera Mobile</th>\n<th>Safari Mobile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p><code>arr.reduce(callback,[initialValue])</code></p>\n<p><strong>参数</strong></p>\n<p><em>callback 执行数组中每个值的函数，包含四个参数</em></p>\n<blockquote>\n<p><em>previousValue</em><br>上一次调用回调返回的值，或者是提供的初始值（initialValue）<br><em>currentValue</em><br>数组中当前被处理的元素<br><em>index</em><br>当前元素在数组中的索引<br><em>array</em><br>调用 reduce 的数组<br><em>initialValue</em><br>作为第一次调用 callback 的第一个参数。</p>\n</blockquote>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>\n<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>\n<p>例如执行下面的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class=\"line\">  return previousValue + currentValue;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>回调被执行四次，每次的参数和返回值如下表：</p>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first</td>\n<td>call</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>second</td>\n<td>call</td>\n<td>1</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>third</td>\n<td>call</td>\n<td>3</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n<tr>\n<td>fourth</td>\n<td>call</td>\n<td>6</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数最后一次被调用的返回值（10）。</p>\n<p>如果把初始值作为第二个参数传入 reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0,1,2,3,4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class=\"line\">  return previousValue + currentValue;</span><br><span class=\"line\">&#125;, 10);</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>previousValue</th>\n<th>currentValue</th>\n<th>index</th>\n<th>array</th>\n<th>return</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>第一次调用</td>\n<td>10</td>\n<td>0</td>\n<td>0</td>\n<td>[0,1,2,3,4]</td>\n<td>10</td>\n</tr>\n<tr>\n<td>第二次调用</td>\n<td>10</td>\n<td>1</td>\n<td>1</td>\n<td>[0,1,2,3,4]</td>\n<td>11</td>\n</tr>\n<tr>\n<td>第三次调用</td>\n<td>11</td>\n<td>2</td>\n<td>2</td>\n<td>[0,1,2,3,4]</td>\n<td>13</td>\n</tr>\n<tr>\n<td>第四次调用</td>\n<td>13</td>\n<td>3</td>\n<td>3</td>\n<td>[0,1,2,3,4]</td>\n<td>16</td>\n</tr>\n<tr>\n<td>第五次调用</td>\n<td>16</td>\n<td>4</td>\n<td>4</td>\n<td>[0,1,2,3,4]</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>例子:将数组所有项相加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var total = [0, 1, 2, 3].reduce(function(a, b) &#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// total == 6</span><br></pre></td></tr></table></figure>\n<p>例子: 数组扁平化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123;</span><br><span class=\"line\">    return a.concat(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// flattened is [0, 1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"兼容旧环境（Polyfill）\"><a href=\"#兼容旧环境（Polyfill）\" class=\"headerlink\" title=\"兼容旧环境（Polyfill）\"></a>兼容旧环境（Polyfill）</h3><p>Array.prototype.reduce 被添加到 ECMA-262 标准第 5 版；因此可能在某些实现环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未能原生支持 reduce 的实现环境中使用它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (&apos;function&apos; !== typeof Array.prototype.reduce) &#123;</span><br><span class=\"line\">  Array.prototype.reduce = function(callback, opt_initialValue)&#123;</span><br><span class=\"line\">    &apos;use strict&apos;;</span><br><span class=\"line\">    if (null === this || &apos;undefined&apos; === typeof this) &#123;</span><br><span class=\"line\">      // At the moment all modern browsers, that support strict mode, have</span><br><span class=\"line\">      // native implementation of Array.prototype.reduce. For instance, IE8</span><br><span class=\"line\">      // does not support strict mode, so this check is actually useless.</span><br><span class=\"line\">      throw new TypeError(</span><br><span class=\"line\">          &apos;Array.prototype.reduce called on null or undefined&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (&apos;function&apos; !== typeof callback) &#123;</span><br><span class=\"line\">      throw new TypeError(callback + &apos; is not a function&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var index, value,</span><br><span class=\"line\">        length = this.length &gt;&gt;&gt; 0,</span><br><span class=\"line\">        isValueSet = false;</span><br><span class=\"line\">    if (1 &lt; arguments.length) &#123;</span><br><span class=\"line\">      value = opt_initialValue;</span><br><span class=\"line\">      isValueSet = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (index = 0; length &gt; index; ++index) &#123;</span><br><span class=\"line\">      if (this.hasOwnProperty(index)) &#123;</span><br><span class=\"line\">        if (isValueSet) &#123;</span><br><span class=\"line\">          value = callback(value, this[index], index, this);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">          value = this[index];</span><br><span class=\"line\">          isValueSet = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (!isValueSet) &#123;</span><br><span class=\"line\">      throw new TypeError(&apos;Reduce of empty array with no initial value&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"浏览器兼容性\"><a href=\"#浏览器兼容性\" class=\"headerlink\" title=\"浏览器兼容性\"></a>浏览器兼容性</h3><p><strong>Desktop</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Chrome</th>\n<th>Firefox (Gecko)</th>\n<th>Internet Explorer</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>3.0(1.9)</td>\n<td>9</td>\n<td>10.5</td>\n<td>4.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mobile</strong></p>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Android</th>\n<th>Chrome for Android</th>\n<th>Firefox Mobile (Gecko)</th>\n<th>IE Mobile</th>\n<th>Opera Mobile</th>\n<th>Safari Mobile</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Basic support</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n<td>(Yes)</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"CSS“隐藏”元素的几种方法的对比","date":"2015-10-25T16:00:00.000Z","_content":"\n一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！\n\n几种方法的简单介绍\n\n首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。\n\n`display:none`\n\n### 设置元素的display为none是最常用的隐藏元素的方法。\n\n```\n.hide {\n     display:none;\n}\n```\n\n将元素设置为`display:none`后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。\n\n```\nvisibility:hidden\n```\n\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和`display:none`的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。\n\n```\n.hidden{\n   visibility:hidden\n}\n```\n`visibility:hidden`适用于那些元素隐藏后不希望页面布局会发生变化的场景\n\n```\nopacity:0\n```\n\nopacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。\n\n```\n.transparent {\n   opacity:0;\n}\n```\n\n这种方法和`visibility:hidden`的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。\n\n### 设置height，width等盒模型属性为0\n\n这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其`overflow:hidden`来隐藏其子元素，这算是一种奇技淫巧。\n\n```\n.hiddenBox {\n   margin:0;\n   border:0;\n   padding:0;\n   height:0;\n   width:0;\n   overflow:hidden;\n}\n```\n\n这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的`overflow:hidden`后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。\n\n### 元素隐藏后的事件响应\n\n如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n    }\n    .none { display: none; }\n    .hidden { visibility: hidden; }\n    .opacity0 { opacity: 0; }\n    .height0 { height: 0; }  \n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n    $(\".none\").on(\"click\", function () {\n        console.log(\"none clicked\");\n    })\n    $(\".hidden\").on(\"click\", function () {\n        console.log(\"hidden clicked\");\n    })\n    $(\".opacity0\").on(\"click\", function () {\n        console.log(\"opacity0 clicked\");\n    })\n    $(\".height0\").on(\"click\", function () {\n        console.log(\"height0 clicked\");\n    })\n</script>\n```\n\n这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：\n\n1、`display:none`：元素彻底消失，很显然不会触发其点击事件\n\n2、`visibility:hidden`：无法触发其点击事件，有一种说法是`display:none`是元素看不见摸不着，而`visibility:hidden`是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。\n\n3、`opacity:0`：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件\n\n4、`height:0`：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。\n\n但是这些结论真的准确吗？\n我们在上面的代码中添加这样一句代码：\n\n```\n$(\".none\").click();\n```\n\n结果发现，触发了click事件，也就是通过JS可以触发被设置为`display:none`的元素的事件。\n所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！\n\n### CSS3 transition对这几种方法的影响\n\nCSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n        transition: all linear 2s;  \n    }\n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n$(\".none\").on(\"click\", function () {\n    console.log(\"none clicked\");\n    $(this).css(\"display\", \"none\");\n})\n$(\".hidden\").on(\"click\", function () {\n    console.log(\"hidden clicked\");\n    $(this).css(\"visibility\", \"hidden\");\n})\n$(\".opacity0\").on(\"click\", function () {\n    console.log(\"opacity0 clicked\");\n    $(this).css(\"opacity\", 0);\n})\n$(\".height0\").on(\"click\", function () {\n    console.log(\"height0 clicked\");\n    $(this).css({\n        \"height\": 0,\n    });\n})\n</script>\n```\n\n经过测试，可以看到：\n1、`display:none`：完全不受transition属性的影响，元素立即消失\n2、`visibility:hidden`：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果\n3、opacity和height等属性能够进行正常的动画效果\n\n假设我们要通过CSS3来做一个淡出的动画效果，应该如下：\n\n```\n.fadeOut { visibility: visible; opacity: 1; transition: all linear 2s; }\n.fadeOut:hover { visibility: hidden; opacity: 0; }\n```\n\n应该同时设置元素的visibility和opacity属性。\n\n### 总结说明\n\n本文总结说明了“隐藏”元素的几种方式，其中最常用的还是`display:none`和`visibility:hidden`。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！\n\n### 补充\n\n来自评论区小伙伴们补充的技巧：\n\n1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外\n\n2、设置元素的position与z-index，将z-index设置成尽量小的负数\n","source":"_posts/CSS“隐藏”元素的几种方法的对比.md","raw":"---\ntitle: CSS“隐藏”元素的几种方法的对比\ntags: [css]\ndate: 2015/10/26\n---\n\n一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！\n\n几种方法的简单介绍\n\n首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。\n\n`display:none`\n\n### 设置元素的display为none是最常用的隐藏元素的方法。\n\n```\n.hide {\n     display:none;\n}\n```\n\n将元素设置为`display:none`后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。\n\n```\nvisibility:hidden\n```\n\n设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和`display:none`的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。\n\n```\n.hidden{\n   visibility:hidden\n}\n```\n`visibility:hidden`适用于那些元素隐藏后不希望页面布局会发生变化的场景\n\n```\nopacity:0\n```\n\nopacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。\n\n```\n.transparent {\n   opacity:0;\n}\n```\n\n这种方法和`visibility:hidden`的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。\n\n### 设置height，width等盒模型属性为0\n\n这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其`overflow:hidden`来隐藏其子元素，这算是一种奇技淫巧。\n\n```\n.hiddenBox {\n   margin:0;\n   border:0;\n   padding:0;\n   height:0;\n   width:0;\n   overflow:hidden;\n}\n```\n\n这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的`overflow:hidden`后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。\n\n### 元素隐藏后的事件响应\n\n如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n    }\n    .none { display: none; }\n    .hidden { visibility: hidden; }\n    .opacity0 { opacity: 0; }\n    .height0 { height: 0; }  \n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n    $(\".none\").on(\"click\", function () {\n        console.log(\"none clicked\");\n    })\n    $(\".hidden\").on(\"click\", function () {\n        console.log(\"hidden clicked\");\n    })\n    $(\".opacity0\").on(\"click\", function () {\n        console.log(\"opacity0 clicked\");\n    })\n    $(\".height0\").on(\"click\", function () {\n        console.log(\"height0 clicked\");\n    })\n</script>\n```\n\n这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：\n\n1、`display:none`：元素彻底消失，很显然不会触发其点击事件\n\n2、`visibility:hidden`：无法触发其点击事件，有一种说法是`display:none`是元素看不见摸不着，而`visibility:hidden`是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。\n\n3、`opacity:0`：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件\n\n4、`height:0`：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。\n\n但是这些结论真的准确吗？\n我们在上面的代码中添加这样一句代码：\n\n```\n$(\".none\").click();\n```\n\n结果发现，触发了click事件，也就是通过JS可以触发被设置为`display:none`的元素的事件。\n所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！\n\n### CSS3 transition对这几种方法的影响\n\nCSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：\n\n```\n<style>\n    div { \n        width: 100px; \n        height: 100px; \n        background: red; \n        margin: 15px; \n        padding: 10px; \n        border: 5px solid green; \n        display: inline-block; \n        overflow: hidden; \n        transition: all linear 2s;  \n    }\n</style>  \n\n<div class=\"none\"></div>\n<div class=\"hidden\"></div>\n<div class=\"opacity0\"></div>\n<div class=\"height0\">aa</div>  \n\n<script src=\"/Scripts/jquery-1.10.2.min.js\"></script>\n<script>\n$(\".none\").on(\"click\", function () {\n    console.log(\"none clicked\");\n    $(this).css(\"display\", \"none\");\n})\n$(\".hidden\").on(\"click\", function () {\n    console.log(\"hidden clicked\");\n    $(this).css(\"visibility\", \"hidden\");\n})\n$(\".opacity0\").on(\"click\", function () {\n    console.log(\"opacity0 clicked\");\n    $(this).css(\"opacity\", 0);\n})\n$(\".height0\").on(\"click\", function () {\n    console.log(\"height0 clicked\");\n    $(this).css({\n        \"height\": 0,\n    });\n})\n</script>\n```\n\n经过测试，可以看到：\n1、`display:none`：完全不受transition属性的影响，元素立即消失\n2、`visibility:hidden`：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果\n3、opacity和height等属性能够进行正常的动画效果\n\n假设我们要通过CSS3来做一个淡出的动画效果，应该如下：\n\n```\n.fadeOut { visibility: visible; opacity: 1; transition: all linear 2s; }\n.fadeOut:hover { visibility: hidden; opacity: 0; }\n```\n\n应该同时设置元素的visibility和opacity属性。\n\n### 总结说明\n\n本文总结说明了“隐藏”元素的几种方式，其中最常用的还是`display:none`和`visibility:hidden`。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！\n\n### 补充\n\n来自评论区小伙伴们补充的技巧：\n\n1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外\n\n2、设置元素的position与z-index，将z-index设置成尽量小的负数\n","slug":"CSS“隐藏”元素的几种方法的对比","published":1,"updated":"2016-05-18T06:51:00.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqw000qtsqbsj33smx3","content":"<p>一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！</p>\n<p>几种方法的简单介绍</p>\n<p>首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。</p>\n<p><code>display:none</code></p>\n<h3 id=\"设置元素的display为none是最常用的隐藏元素的方法。\"><a href=\"#设置元素的display为none是最常用的隐藏元素的方法。\" class=\"headerlink\" title=\"设置元素的display为none是最常用的隐藏元素的方法。\"></a>设置元素的display为none是最常用的隐藏元素的方法。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hide &#123;</span><br><span class=\"line\">     display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visibility:hidden</span><br></pre></td></tr></table></figure>\n<p>设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和<code>display:none</code>的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hidden&#123;</span><br><span class=\"line\">   visibility:hidden</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>visibility:hidden</code>适用于那些元素隐藏后不希望页面布局会发生变化的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opacity:0</span><br></pre></td></tr></table></figure>\n<p>opacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transparent &#123;</span><br><span class=\"line\">   opacity:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法和<code>visibility:hidden</code>的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。</p>\n<h3 id=\"设置height，width等盒模型属性为0\"><a href=\"#设置height，width等盒模型属性为0\" class=\"headerlink\" title=\"设置height，width等盒模型属性为0\"></a>设置height，width等盒模型属性为0</h3><p>这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素，这算是一种奇技淫巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hiddenBox &#123;</span><br><span class=\"line\">   margin:0;</span><br><span class=\"line\">   border:0;</span><br><span class=\"line\">   padding:0;</span><br><span class=\"line\">   height:0;</span><br><span class=\"line\">   width:0;</span><br><span class=\"line\">   overflow:hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的<code>overflow:hidden</code>后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。</p>\n<h3 id=\"元素隐藏后的事件响应\"><a href=\"#元素隐藏后的事件响应\" class=\"headerlink\" title=\"元素隐藏后的事件响应\"></a>元素隐藏后的事件响应</h3><p>如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    div &#123; </span><br><span class=\"line\">        width: 100px; </span><br><span class=\"line\">        height: 100px; </span><br><span class=\"line\">        background: red; </span><br><span class=\"line\">        margin: 15px; </span><br><span class=\"line\">        padding: 10px; </span><br><span class=\"line\">        border: 5px solid green; </span><br><span class=\"line\">        display: inline-block; </span><br><span class=\"line\">        overflow: hidden; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .none &#123; display: none; &#125;</span><br><span class=\"line\">    .hidden &#123; visibility: hidden; &#125;</span><br><span class=\"line\">    .opacity0 &#123; opacity: 0; &#125;</span><br><span class=\"line\">    .height0 &#123; height: 0; &#125;  </span><br><span class=\"line\">&lt;/style&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    $(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;none clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;hidden clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;opacity0 clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;height0 clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：</p>\n<p>1、<code>display:none</code>：元素彻底消失，很显然不会触发其点击事件</p>\n<p>2、<code>visibility:hidden</code>：无法触发其点击事件，有一种说法是<code>display:none</code>是元素看不见摸不着，而<code>visibility:hidden</code>是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。</p>\n<p>3、<code>opacity:0</code>：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件</p>\n<p>4、<code>height:0</code>：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。</p>\n<p>但是这些结论真的准确吗？<br>我们在上面的代码中添加这样一句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;.none&quot;).click();</span><br></pre></td></tr></table></figure>\n<p>结果发现，触发了click事件，也就是通过JS可以触发被设置为<code>display:none</code>的元素的事件。<br>所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！</p>\n<h3 id=\"CSS3-transition对这几种方法的影响\"><a href=\"#CSS3-transition对这几种方法的影响\" class=\"headerlink\" title=\"CSS3 transition对这几种方法的影响\"></a>CSS3 transition对这几种方法的影响</h3><p>CSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    div &#123; </span><br><span class=\"line\">        width: 100px; </span><br><span class=\"line\">        height: 100px; </span><br><span class=\"line\">        background: red; </span><br><span class=\"line\">        margin: 15px; </span><br><span class=\"line\">        padding: 10px; </span><br><span class=\"line\">        border: 5px solid green; </span><br><span class=\"line\">        display: inline-block; </span><br><span class=\"line\">        overflow: hidden; </span><br><span class=\"line\">        transition: all linear 2s;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;none clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;display&quot;, &quot;none&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;hidden clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;visibility&quot;, &quot;hidden&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;opacity0 clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;opacity&quot;, 0);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;height0 clicked&quot;);</span><br><span class=\"line\">    $(this).css(&#123;</span><br><span class=\"line\">        &quot;height&quot;: 0,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>经过测试，可以看到：<br>1、<code>display:none</code>：完全不受transition属性的影响，元素立即消失<br>2、<code>visibility:hidden</code>：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果<br>3、opacity和height等属性能够进行正常的动画效果</p>\n<p>假设我们要通过CSS3来做一个淡出的动画效果，应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fadeOut &#123; visibility: visible; opacity: 1; transition: all linear 2s; &#125;</span><br><span class=\"line\">.fadeOut:hover &#123; visibility: hidden; opacity: 0; &#125;</span><br></pre></td></tr></table></figure>\n<p>应该同时设置元素的visibility和opacity属性。</p>\n<h3 id=\"总结说明\"><a href=\"#总结说明\" class=\"headerlink\" title=\"总结说明\"></a>总结说明</h3><p>本文总结说明了“隐藏”元素的几种方式，其中最常用的还是<code>display:none</code>和<code>visibility:hidden</code>。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>来自评论区小伙伴们补充的技巧：</p>\n<p>1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外</p>\n<p>2、设置元素的position与z-index，将z-index设置成尽量小的负数</p>\n","excerpt":"","more":"<p>一说起CSS隐藏元素，我想大部分小伙伴们都会想到的第一种方法就是设置display为none。这是最为人所熟知也是最常用的方法。我相信还有不少人想到使用设置visibility为hidden来隐藏元素，这种方式也是常用的方法，而且也有很多人知道两者的不同。除了这两种方法，本文还总结了一些比较不常用的方法，比较了这几种“隐藏”元素方法的区别和优缺点，欢迎大家交流！！</p>\n<p>几种方法的简单介绍</p>\n<p>首先我们分别来说说到底有哪几种隐藏元素的方法，有一些方法是众所周知的，还有一些算是一种技巧。</p>\n<p><code>display:none</code></p>\n<h3 id=\"设置元素的display为none是最常用的隐藏元素的方法。\"><a href=\"#设置元素的display为none是最常用的隐藏元素的方法。\" class=\"headerlink\" title=\"设置元素的display为none是最常用的隐藏元素的方法。\"></a>设置元素的display为none是最常用的隐藏元素的方法。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hide &#123;</span><br><span class=\"line\">     display:none;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将元素设置为<code>display:none</code>后，元素在页面上将彻底消失，元素本来占有的空间就会被其他元素占有，也就是说它会导致浏览器的重排和重绘。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">visibility:hidden</span><br></pre></td></tr></table></figure>\n<p>设置元素的visibility为hidden也是一种常用的隐藏元素的方法，和<code>display:none</code>的区别在于，元素在页面消失后，其占据的空间依旧会保留着，所以它只会导致浏览器重绘而不会重排。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hidden&#123;</span><br><span class=\"line\">   visibility:hidden</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>visibility:hidden</code>适用于那些元素隐藏后不希望页面布局会发生变化的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opacity:0</span><br></pre></td></tr></table></figure>\n<p>opacity属性我相信大家都知道表示元素的透明度，而将元素的透明度设置为0后，在我们用户眼中，元素也是隐藏的，这算是一种隐藏元素的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.transparent &#123;</span><br><span class=\"line\">   opacity:0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方法和<code>visibility:hidden</code>的一个共同点是元素隐藏后依旧占据着空间，但我们都知道，设置透明度为0后，元素只是隐身了，它依旧存在页面中。</p>\n<h3 id=\"设置height，width等盒模型属性为0\"><a href=\"#设置height，width等盒模型属性为0\" class=\"headerlink\" title=\"设置height，width等盒模型属性为0\"></a>设置height，width等盒模型属性为0</h3><p>这是我总结的一种比较奇葩的技巧，简单说就是将元素的margin，border，padding，height和width等影响元素盒模型的属性设置成0，如果元素内有子元素或内容，还应该设置其<code>overflow:hidden</code>来隐藏其子元素，这算是一种奇技淫巧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.hiddenBox &#123;</span><br><span class=\"line\">   margin:0;</span><br><span class=\"line\">   border:0;</span><br><span class=\"line\">   padding:0;</span><br><span class=\"line\">   height:0;</span><br><span class=\"line\">   width:0;</span><br><span class=\"line\">   overflow:hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式既不实用，也可能存在着着一些问题。但平时我们用到的一些页面效果可能就是采用这种方式来完成的，比如jquery的slideUp动画，它就是设置元素的<code>overflow:hidden</code>后，接着通过定时器，不断地设置元素的height，margin-top，margin-bottom，border-top，border-bottom，padding-top，padding-bottom为0，从而达到slideUp的效果。</p>\n<h3 id=\"元素隐藏后的事件响应\"><a href=\"#元素隐藏后的事件响应\" class=\"headerlink\" title=\"元素隐藏后的事件响应\"></a>元素隐藏后的事件响应</h3><p>如果被隐藏的元素绑定了一些事件，我们执行了相关操作后，这些事件是否会被响应并执行呢，看看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    div &#123; </span><br><span class=\"line\">        width: 100px; </span><br><span class=\"line\">        height: 100px; </span><br><span class=\"line\">        background: red; </span><br><span class=\"line\">        margin: 15px; </span><br><span class=\"line\">        padding: 10px; </span><br><span class=\"line\">        border: 5px solid green; </span><br><span class=\"line\">        display: inline-block; </span><br><span class=\"line\">        overflow: hidden; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .none &#123; display: none; &#125;</span><br><span class=\"line\">    .hidden &#123; visibility: hidden; &#125;</span><br><span class=\"line\">    .opacity0 &#123; opacity: 0; &#125;</span><br><span class=\"line\">    .height0 &#123; height: 0; &#125;  </span><br><span class=\"line\">&lt;/style&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    $(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;none clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;hidden clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;opacity0 clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    $(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">        console.log(&quot;height0 clicked&quot;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这段代码将四种隐藏元素的方法分别展示出来，然后绑定其点击事件，经过测试，主要有下面的结论：</p>\n<p>1、<code>display:none</code>：元素彻底消失，很显然不会触发其点击事件</p>\n<p>2、<code>visibility:hidden</code>：无法触发其点击事件，有一种说法是<code>display:none</code>是元素看不见摸不着，而<code>visibility:hidden</code>是看不见摸得着，这种说法是不准确的，设置元素的visibility后无法触发点击事件，说明这种方法元素也是消失了，只是依然占据着页面空间。</p>\n<p>3、<code>opacity:0</code>：可以触发点击事件，原因也很简单，设置元素透明度为0后，元素只是相对于人眼不存在而已，对浏览器来说，它还是存在的，所以可以触发点击事件</p>\n<p>4、<code>height:0</code>：将元素的高度设置为0，并且设置overflow:hidden。使用这种方法来隐藏元素，是否可以触发事件要根据具体的情况来分析。如果元素设置了border，padding等属性不为0，很显然，页面上还是能看到这个元素的，触发元素的点击事件完全没有问题。如果全部属性都设置为0，很显然，这个元素相当于消失了，即无法触发点击事件。</p>\n<p>但是这些结论真的准确吗？<br>我们在上面的代码中添加这样一句代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;.none&quot;).click();</span><br></pre></td></tr></table></figure>\n<p>结果发现，触发了click事件，也就是通过JS可以触发被设置为<code>display:none</code>的元素的事件。<br>所以前面无法触发点击事件的真正原因是鼠标无法真正接触到被设置成隐藏的元素！！！</p>\n<h3 id=\"CSS3-transition对这几种方法的影响\"><a href=\"#CSS3-transition对这几种方法的影响\" class=\"headerlink\" title=\"CSS3 transition对这几种方法的影响\"></a>CSS3 transition对这几种方法的影响</h3><p>CSS3提供的transition极大地提高了网页动画的编写，但并不是每一种CSS属性都可以通过transition来进行动画的。我们修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    div &#123; </span><br><span class=\"line\">        width: 100px; </span><br><span class=\"line\">        height: 100px; </span><br><span class=\"line\">        background: red; </span><br><span class=\"line\">        margin: 15px; </span><br><span class=\"line\">        padding: 10px; </span><br><span class=\"line\">        border: 5px solid green; </span><br><span class=\"line\">        display: inline-block; </span><br><span class=\"line\">        overflow: hidden; </span><br><span class=\"line\">        transition: all linear 2s;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&quot;none&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;hidden&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;opacity0&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=&quot;height0&quot;&gt;aa&lt;/div&gt;  </span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script src=&quot;/Scripts/jquery-1.10.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">$(&quot;.none&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;none clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;display&quot;, &quot;none&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.hidden&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;hidden clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;visibility&quot;, &quot;hidden&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.opacity0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;opacity0 clicked&quot;);</span><br><span class=\"line\">    $(this).css(&quot;opacity&quot;, 0);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(&quot;.height0&quot;).on(&quot;click&quot;, function () &#123;</span><br><span class=\"line\">    console.log(&quot;height0 clicked&quot;);</span><br><span class=\"line\">    $(this).css(&#123;</span><br><span class=\"line\">        &quot;height&quot;: 0,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>经过测试，可以看到：<br>1、<code>display:none</code>：完全不受transition属性的影响，元素立即消失<br>2、<code>visibility:hidden</code>：元素消失的时间跟transition属性设置的时间一样，但是没有动画效果<br>3、opacity和height等属性能够进行正常的动画效果</p>\n<p>假设我们要通过CSS3来做一个淡出的动画效果，应该如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.fadeOut &#123; visibility: visible; opacity: 1; transition: all linear 2s; &#125;</span><br><span class=\"line\">.fadeOut:hover &#123; visibility: hidden; opacity: 0; &#125;</span><br></pre></td></tr></table></figure>\n<p>应该同时设置元素的visibility和opacity属性。</p>\n<h3 id=\"总结说明\"><a href=\"#总结说明\" class=\"headerlink\" title=\"总结说明\"></a>总结说明</h3><p>本文总结说明了“隐藏”元素的几种方式，其中最常用的还是<code>display:none</code>和<code>visibility:hidden</code>。其他的方式只能算是奇技淫巧，并不推荐使用它们来隐藏元素，它们的真正用途应该不在隐藏元素，而是通过了解这些方法的特点，挖掘出其真正的使用场景。欢迎大家交流！！</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>来自评论区小伙伴们补充的技巧：</p>\n<p>1、设置元素的position与left，top，bottom，right等，将元素移出至屏幕外</p>\n<p>2、设置元素的position与z-index，将z-index设置成尽量小的负数</p>\n"},{"title":"CSS实现垂直居中的常用方法","date":"2016-03-05T16:00:00.000Z","_content":"\n在前端开发过程中，盒子居中是常常用到的。\n\n其中，居中又可以分为水平居中和垂直居中。\n\n水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。\n\n但是垂直居中相对来说是比较复杂一些的。\n\n下面我们一起来讨论一下实现垂直居中的方法。\n\n首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-001](resource/css-ju-zhong-001.png)\n\n我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-002](resource/css-ju-zhong-002.png)\n\n\n很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。\n\n不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0; \n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下图所示：\n\n![css-ju-zhong-003](resource/css-ju-zhong-003.png)\n\ndiv垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：\n\n![css-ju-zhong-004](resource/css-ju-zhong-004.png)\n\n通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            margin-top: -150px; \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-005](resource/css-ju-zhong-005.png)\n\n确实已经居中了。好兴奋！有木有？！\n\n除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            transform: translateY(-50%);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-006](resource/css-ju-zhong-006.png)\n\n上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            display: flex;\n            align-items: center; /*定义body的元素垂直居中*/\n            justify-content: center; /*定义body的里的元素水平居中*/\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;        \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果：\n\n![css-ju-zhong-007](resource/css-ju-zhong-007.png)\n\n除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？\n\n[http://www.codeceo.com/article/css-vertical-align-center.html](http://www.codeceo.com/article/css-vertical-align-center.html)\n","source":"_posts/CSS实现垂直居中的常用方法.md","raw":"---\ntitle: CSS实现垂直居中的常用方法\ntags: [css]\ndate: 2016/03/06\n---\n\n在前端开发过程中，盒子居中是常常用到的。\n\n其中，居中又可以分为水平居中和垂直居中。\n\n水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。\n\n但是垂直居中相对来说是比较复杂一些的。\n\n下面我们一起来讨论一下实现垂直居中的方法。\n\n首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-001](resource/css-ju-zhong-001.png)\n\n我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-002](resource/css-ju-zhong-002.png)\n\n\n很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。\n\n不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0; \n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下图所示：\n\n![css-ju-zhong-003](resource/css-ju-zhong-003.png)\n\ndiv垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：\n\n![css-ju-zhong-004](resource/css-ju-zhong-004.png)\n\n通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            margin-top: -150px; \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-005](resource/css-ju-zhong-005.png)\n\n确实已经居中了。好兴奋！有木有？！\n\n除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;\n            margin: 0 auto; /*水平居中*/\n            position: relative; /*脱离文档流*/\n            top: 50%; /*偏移*/\n            transform: translateY(-50%);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果如下：\n\n![css-ju-zhong-006](resource/css-ju-zhong-006.png)\n\n上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>index</title>\n    <style>\n        html,body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            display: flex;\n            align-items: center; /*定义body的元素垂直居中*/\n            justify-content: center; /*定义body的里的元素水平居中*/\n        }\n        .content {\n            width: 300px;\n            height: 300px;\n            background: orange;        \n        }\n    </style>\n</head>\n<body>\n    <div class=\"content\"></div>\n</body>\n</html>\n```\n\n效果：\n\n![css-ju-zhong-007](resource/css-ju-zhong-007.png)\n\n除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？\n\n[http://www.codeceo.com/article/css-vertical-align-center.html](http://www.codeceo.com/article/css-vertical-align-center.html)\n","slug":"CSS实现垂直居中的常用方法","published":1,"updated":"2016-05-18T06:52:07.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3uqz000stsqbhtxloz71","content":"<p>在前端开发过程中，盒子居中是常常用到的。</p>\n<p>其中，居中又可以分为水平居中和垂直居中。</p>\n<p>水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。</p>\n<p>但是垂直居中相对来说是比较复杂一些的。</p>\n<p>下面我们一起来讨论一下实现垂直居中的方法。</p>\n<p>首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-001.png\" alt=\"css-ju-zhong-001\"></p>\n<p>我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-002.png\" alt=\"css-ju-zhong-002\"></p>\n<p>很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。</p>\n<p>不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html, body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0; </span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html, body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下图所示：</p>\n<p><img src=\"resource/css-ju-zhong-003.png\" alt=\"css-ju-zhong-003\"></p>\n<p>div垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：</p>\n<p><img src=\"resource/css-ju-zhong-004.png\" alt=\"css-ju-zhong-004\"></p>\n<p>通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">            margin-top: -150px; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-005.png\" alt=\"css-ju-zhong-005\"></p>\n<p>确实已经居中了。好兴奋！有木有？！</p>\n<p>除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">            transform: translateY(-50%);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-006.png\" alt=\"css-ju-zhong-006\"></p>\n<p>上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\">            display: flex;</span><br><span class=\"line\">            align-items: center; /*定义body的元素垂直居中*/</span><br><span class=\"line\">            justify-content: center; /*定义body的里的元素水平居中*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"resource/css-ju-zhong-007.png\" alt=\"css-ju-zhong-007\"></p>\n<p>除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？</p>\n<p><a href=\"http://www.codeceo.com/article/css-vertical-align-center.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/css-vertical-align-center.html</a></p>\n","excerpt":"","more":"<p>在前端开发过程中，盒子居中是常常用到的。</p>\n<p>其中，居中又可以分为水平居中和垂直居中。</p>\n<p>水平居中是比较容易的，直接设置元素的margin: 0 auto就可以实现。</p>\n<p>但是垂直居中相对来说是比较复杂一些的。</p>\n<p>下面我们一起来讨论一下实现垂直居中的方法。</p>\n<p>首先，定义一个需要垂直居中的div元素，他的宽度和高度均为300px，背景色为橙色。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-001.png\" alt=\"css-ju-zhong-001\"></p>\n<p>我们需要使得这个橙色的div居中，到底该怎么办呢？首先我们让实现水平居中，上面已经提到过了，可以通过设置margin: 0 auto实现水平居中，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-002.png\" alt=\"css-ju-zhong-002\"></p>\n<p>很好，已经实现水平居中了！接下来该打大boss了——实现垂直居中。</p>\n<p>不过，在这之前，我们先要设置div元素的祖先元素html和body的高度为100%（因为他们默认是为0的），并且清除默认样式，即把margin和padding设置为0（如果不清除默认样式的话，浏览器就会出现滚动条，聪明的亲，自己想想问什么）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html, body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0; </span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们需要做的事情就是要让div往下移动了。我们都知道top属性可以使得元素向下偏移的。但是，由于默认情况下，元素在文档流里是从上往下、从左到右布局的，我们是不可以直接通过top属性改变他的垂直偏移的。这就就需要使用position属性使它脱离文档流流了。这很简单，只要设置它的值为relative就行了。对于position属性不熟悉的，可以自己去w3c看一下。下面我们就让div脱离文档流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html, body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>我们刷新一下页面，发现跟之前是没有任何变化的，因为，我们仅仅是使div脱离了文档流，但是还没开始移动他的垂直偏移。好，下面我们就让它偏移吧！垂直偏移需要用到top属性，它的值可以是具体的像素，也可以是百分数。因为我们现在不知道父元素（即body）的具体高度，所以，是不可以通过具体像素来偏移的，而应该用百分数。既然是要让它居中嘛！好，那么我们就让它的值为50%不就行了吗？问题真的那么简单，我们来试一下，就设置50%试一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下图所示：</p>\n<p><img src=\"resource/css-ju-zhong-003.png\" alt=\"css-ju-zhong-003\"></p>\n<p>div垂直方向上面并没有居中。明显是偏下了。下面，我们在浏览器中间画一条红线用来参考，如下图：</p>\n<p><img src=\"resource/css-ju-zhong-004.png\" alt=\"css-ju-zhong-004\"></p>\n<p>通过观察上图，只要让div的中心移动到红线的位置，那么整个div就居中了。那怎么让它中心移动到红线处呢？从图中可以观察到，从div的中心到红线的距离是div自身高度的一半。这时候，我们可以使用通过margin-top属性来设置，因为div的自身高度是300，所以，需要设置他的margin-top值为-150。为什么是要设置成负数的呢？因为正数是向下偏移，我们是希望div向上偏移，所以应该是负数，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">            margin-top: -150px; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-005.png\" alt=\"css-ju-zhong-005\"></p>\n<p>确实已经居中了。好兴奋！有木有？！</p>\n<p>除了可以使用margin-top把div往上偏移之外，CSS3的transform属性也可以实现这个功能，通过设置div的transform: translateY(-50%)，意思是使得div向上平移（translate）自身高度的一半(50%)。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;</span><br><span class=\"line\">            margin: 0 auto; /*水平居中*/</span><br><span class=\"line\">            position: relative; /*脱离文档流*/</span><br><span class=\"line\">            top: 50%; /*偏移*/</span><br><span class=\"line\">            transform: translateY(-50%);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果如下：</p>\n<p><img src=\"resource/css-ju-zhong-006.png\" alt=\"css-ju-zhong-006\"></p>\n<p>上面的两种方法，我们都是基于设置div的top值为50%之后，再进行调整垂偏移量来实现居中的。如果使用CSS3的弹性布局（flex）的话，问题就会变得容易多了。使用CSS3的弹性布局很简单，只要设置父元素（这里是指body）的display的值为flex即可。具体代码如下，对代码不做过多的解释，如果想了解弹性布局的可以看阮一峰老师的博客<a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：\">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html：</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;index&lt;/title&gt;</span><br><span class=\"line\">    &lt;style&gt;</span><br><span class=\"line\">        html,body &#123;</span><br><span class=\"line\">            width: 100%;</span><br><span class=\"line\">            height: 100%;</span><br><span class=\"line\">            margin: 0;</span><br><span class=\"line\">            padding: 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        body &#123;</span><br><span class=\"line\">            display: flex;</span><br><span class=\"line\">            align-items: center; /*定义body的元素垂直居中*/</span><br><span class=\"line\">            justify-content: center; /*定义body的里的元素水平居中*/</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        .content &#123;</span><br><span class=\"line\">            width: 300px;</span><br><span class=\"line\">            height: 300px;</span><br><span class=\"line\">            background: orange;        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>效果：</p>\n<p><img src=\"resource/css-ju-zhong-007.png\" alt=\"css-ju-zhong-007\"></p>\n<p>除了上面3中方法之外，当然可能还存在许多的可以实现垂直居中的方法。比如可以将父容器设置为display:table ，然后将子元素也就是要垂直居中显示的元素设置为 display:table-cell 。但是，这是不值得推荐的，因为会破坏整体的布局。如果用table布局，那么为什么不直接使用table标签了？那不更加方便吗？</p>\n<p><a href=\"http://www.codeceo.com/article/css-vertical-align-center.html\">http://www.codeceo.com/article/css-vertical-align-center.html</a></p>\n"},{"title":"mongoDB设置数据库并启动","date":"2015-09-17T16:00:00.000Z","_content":"\n```\n$ mongod --dbpath blog/data\n```\n\n会输出：\n\n```\n$ waiting for connections on port 27017\n```\n\n浏览器输入：\n\nhttp://localhost:27017\n\n会输出：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n\n即为成功。\n","source":"_posts/mongoDB设置数据库并启动.md","raw":"---\ntitle: mongoDB设置数据库并启动\ntags: [database,mongodb]\ndate: 2015/09/18\n---\n\n```\n$ mongod --dbpath blog/data\n```\n\n会输出：\n\n```\n$ waiting for connections on port 27017\n```\n\n浏览器输入：\n\nhttp://localhost:27017\n\n会输出：\n\nIt looks like you are trying to access MongoDB over HTTP on the native driver port.\n\n即为成功。\n","slug":"mongoDB设置数据库并启动","published":1,"updated":"2016-06-03T06:18:17.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3ur2000vtsqbzwv89sbu","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mongod --dbpath blog/data</span><br></pre></td></tr></table></figure>\n<p>会输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ waiting for connections on port 27017</span><br></pre></td></tr></table></figure>\n<p>浏览器输入：</p>\n<p><a href=\"http://localhost:27017\" target=\"_blank\" rel=\"external\">http://localhost:27017</a></p>\n<p>会输出：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port.</p>\n<p>即为成功。</p>\n","excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mongod --dbpath blog/data</span><br></pre></td></tr></table></figure>\n<p>会输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ waiting for connections on port 27017</span><br></pre></td></tr></table></figure>\n<p>浏览器输入：</p>\n<p><a href=\"http://localhost:27017\">http://localhost:27017</a></p>\n<p>会输出：</p>\n<p>It looks like you are trying to access MongoDB over HTTP on the native driver port.</p>\n<p>即为成功。</p>\n"},{"title":"mongodb3.03开启认证","date":"2015-07-17T16:00:00.000Z","_content":"\n下载了最新mongodb3.03版本，当使用--auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：\n\n（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） \n\nWindows下我做了一个bat文件，用来启动mongodb，命令行如下： \n\n```\nmongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth \n```\n\n最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false \n\n1、首先关闭认证，也就是不带--auth参数，启动mongodb \n\n2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 \n\n3、use userdb  切换到自己的数据库，输入db，显示userdb \n\n4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n\n5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 \n\n```\nauthenticate db: userdb { authenticate: 1, nonce: \"xxx\", user: \"myuser\", key: \"xxx\" } \n2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document \n```\n\n此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： \n\n首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： \n\n```\n> use admin \nswitched to db admin \n>  var schema = db.system.version.findOne({\"_id\" : \"authSchema\"}) \n> schema.currentVersion = 3 \n3 \n> db.system.version.save(schema) \nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) \n```\n\n不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 \n\n```\n> use admin \nswitched to db admin \n> db.system.users.find() \n[...] \n{ \"_id\" : \"userdb.myuser\", \"user\" : \"myuser\", \"db\" : \"userdb\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"XXXXXXXXXXXXXXXXXXXXXXXX\", \"storedKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\", \"serverKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\" } }, \"roles\" : [ { \"role\" : \"dbOwner\", \"db\" : \"userdb\" } ] } \n```\n\n解决方式就是删除刚刚创建的用户，重新重建即可： \n\n```\n> use userdb \nswitched to db userdb \n> db.dropUser(\"myuser\") \ntrue \n>db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n```\n\n然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK \n\n[转载自：http://21jhf.iteye.com/blog/2216103](http://21jhf.iteye.com/blog/2216103)\n","source":"_posts/mongodb3.03开启认证.md","raw":"---\ntitle: mongodb3.03开启认证\ntags: [database,mongodb]\ndate: 2015/07/18  \n---\n\n下载了最新mongodb3.03版本，当使用--auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：\n\n（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） \n\nWindows下我做了一个bat文件，用来启动mongodb，命令行如下： \n\n```\nmongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth \n```\n\n最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false \n\n1、首先关闭认证，也就是不带--auth参数，启动mongodb \n\n2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 \n\n3、use userdb  切换到自己的数据库，输入db，显示userdb \n\n4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n\n5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 \n\n```\nauthenticate db: userdb { authenticate: 1, nonce: \"xxx\", user: \"myuser\", key: \"xxx\" } \n2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document \n```\n\n此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： \n\n首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： \n\n```\n> use admin \nswitched to db admin \n>  var schema = db.system.version.findOne({\"_id\" : \"authSchema\"}) \n> schema.currentVersion = 3 \n3 \n> db.system.version.save(schema) \nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 }) \n```\n\n不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 \n\n```\n> use admin \nswitched to db admin \n> db.system.users.find() \n[...] \n{ \"_id\" : \"userdb.myuser\", \"user\" : \"myuser\", \"db\" : \"userdb\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"XXXXXXXXXXXXXXXXXXXXXXXX\", \"storedKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\", \"serverKey\" : \"XXXXXXXXXXXXXXXXXXXXXXXXXXX\" } }, \"roles\" : [ { \"role\" : \"dbOwner\", \"db\" : \"userdb\" } ] } \n```\n\n解决方式就是删除刚刚创建的用户，重新重建即可： \n\n```\n> use userdb \nswitched to db userdb \n> db.dropUser(\"myuser\") \ntrue \n>db.createUser({user:'myuser',pwd:'123456',roles:[{role:'dbOwner',db:'userdb'}]}) \n```\n\n然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK \n\n[转载自：http://21jhf.iteye.com/blog/2216103](http://21jhf.iteye.com/blog/2216103)\n","slug":"mongodb3.03开启认证","published":1,"updated":"2016-06-03T06:17:19.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3ur9000xtsqbiogqfy48","content":"<p>下载了最新mongodb3.03版本，当使用–auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：</p>\n<p>（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） </p>\n<p>Windows下我做了一个bat文件，用来启动mongodb，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth</span><br></pre></td></tr></table></figure>\n<p>最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false </p>\n<p>1、首先关闭认证，也就是不带–auth参数，启动mongodb </p>\n<p>2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 </p>\n<p>3、use userdb  切换到自己的数据库，输入db，显示userdb </p>\n<p>4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:’myuser’,pwd:’123456’,roles:[{role:’dbOwner’,db:’userdb’}]}) </p>\n<p>5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">authenticate db: userdb &#123; authenticate: 1, nonce: &quot;xxx&quot;, user: &quot;myuser&quot;, key: &quot;xxx&quot; &#125; </span><br><span class=\"line\">2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document</span><br></pre></td></tr></table></figure>\n<p>此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： </p>\n<p>首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin </span><br><span class=\"line\">switched to db admin </span><br><span class=\"line\">&gt;  var schema = db.system.version.findOne(&#123;&quot;_id&quot; : &quot;authSchema&quot;&#125;) </span><br><span class=\"line\">&gt; schema.currentVersion = 3 </span><br><span class=\"line\">3 </span><br><span class=\"line\">&gt; db.system.version.save(schema) </span><br><span class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>\n<p>不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin </span><br><span class=\"line\">switched to db admin </span><br><span class=\"line\">&gt; db.system.users.find() </span><br><span class=\"line\">[...] </span><br><span class=\"line\">&#123; &quot;_id&quot; : &quot;userdb.myuser&quot;, &quot;user&quot; : &quot;myuser&quot;, &quot;db&quot; : &quot;userdb&quot;, &quot;credentials&quot; : &#123; &quot;SCRAM-SHA-1&quot; : &#123; &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;storedKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;serverKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; &#125; &#125;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;userdb&quot; &#125; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>解决方式就是删除刚刚创建的用户，重新重建即可： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use userdb </span><br><span class=\"line\">switched to db userdb </span><br><span class=\"line\">&gt; db.dropUser(&quot;myuser&quot;) </span><br><span class=\"line\">true </span><br><span class=\"line\">&gt;db.createUser(&#123;user:&apos;myuser&apos;,pwd:&apos;123456&apos;,roles:[&#123;role:&apos;dbOwner&apos;,db:&apos;userdb&apos;&#125;]&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK </p>\n<p><a href=\"http://21jhf.iteye.com/blog/2216103\" target=\"_blank\" rel=\"external\">转载自：http://21jhf.iteye.com/blog/2216103</a></p>\n","excerpt":"","more":"<p>下载了最新mongodb3.03版本，当使用–auth 参数命令行开启mongodb用户认证时遇到很多问题，现总结如下：</p>\n<p>（百度上搜到的基本都是老版本的，看到db.addUser的就是，请忽略） </p>\n<p>Windows下我做了一个bat文件，用来启动mongodb，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --dbpath db\\data --port 27017 --directoryperdb --logpath db\\logs\\mongodb.log --logappend --auth</span><br></pre></td></tr></table></figure>\n<p>最后的参数就是开启和关闭认证，如果是conf配置文件，应该是auth=true或false </p>\n<p>1、首先关闭认证，也就是不带–auth参数，启动mongodb </p>\n<p>2、使用命令行进入mongodb目录，输入mongo命令，默认进入test数据库 </p>\n<p>3、use userdb  切换到自己的数据库，输入db，显示userdb </p>\n<p>4、创建用户，角色为dbOwner，数据库为userdb，命令行应该是db.createUser({user:’myuser’,pwd:’123456’,roles:[{role:’dbOwner’,db:’userdb’}]}) </p>\n<p>5、切换到admin数据库，use admin，db，显示admin，db.shutdownServer()关闭服务器，填上认证参数，启动mongodb；以前的版本此时使用mongovue就可以使用myuser登录到userdb数据库上了，但是3.0.3版本不行，打开mongodb.log文件发现如下错误 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">authenticate db: userdb &#123; authenticate: 1, nonce: &quot;xxx&quot;, user: &quot;myuser&quot;, key: &quot;xxx&quot; &#125; </span><br><span class=\"line\">2015-06-02T09:57:18.877+0800 I ACCESS   [conn2] Failed to authenticate myuser@userdb with mechanism MONGODB-CR: AuthenticationFailed MONGODB-CR credentials missing in the user document</span><br></pre></td></tr></table></figure>\n<p>此1-5步骤针对是3.0.3以前版本已经ok，如果是3.0.3，mongodb加入了SCRAM-SHA-1校验方式，需要第三方工具配合进行验证，下面给出具体解决办法： </p>\n<p>首先关闭认证，修改system.version文档里面的authSchema版本为3，初始安装时候应该是5，命令行如下： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin </span><br><span class=\"line\">switched to db admin </span><br><span class=\"line\">&gt;  var schema = db.system.version.findOne(&#123;&quot;_id&quot; : &quot;authSchema&quot;&#125;) </span><br><span class=\"line\">&gt; schema.currentVersion = 3 </span><br><span class=\"line\">3 </span><br><span class=\"line\">&gt; db.system.version.save(schema) </span><br><span class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure>\n<p>不过如果你现在开启认证，仍然会提示AuthenticationFailed MONGODB-CR credentials missing in the user document 原因是原来创建的用户已经使用了SCRAM-SHA-1认证方式 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin </span><br><span class=\"line\">switched to db admin </span><br><span class=\"line\">&gt; db.system.users.find() </span><br><span class=\"line\">[...] </span><br><span class=\"line\">&#123; &quot;_id&quot; : &quot;userdb.myuser&quot;, &quot;user&quot; : &quot;myuser&quot;, &quot;db&quot; : &quot;userdb&quot;, &quot;credentials&quot; : &#123; &quot;SCRAM-SHA-1&quot; : &#123; &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;storedKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;, &quot;serverKey&quot; : &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; &#125; &#125;, &quot;roles&quot; : [ &#123; &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;userdb&quot; &#125; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>解决方式就是删除刚刚创建的用户，重新重建即可： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use userdb </span><br><span class=\"line\">switched to db userdb </span><br><span class=\"line\">&gt; db.dropUser(&quot;myuser&quot;) </span><br><span class=\"line\">true </span><br><span class=\"line\">&gt;db.createUser(&#123;user:&apos;myuser&apos;,pwd:&apos;123456&apos;,roles:[&#123;role:&apos;dbOwner&apos;,db:&apos;userdb&apos;&#125;]&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后关闭服务器，开启认证，重启服务器，用mongovue连接，一切OK </p>\n<p><a href=\"http://21jhf.iteye.com/blog/2216103\">转载自：http://21jhf.iteye.com/blog/2216103</a></p>\n"},{"title":"俞敏洪：我和马云就差了8个字","date":"2015-12-24T16:00:00.000Z","_content":"\n\n\n马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。\n\n但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。\n\n有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。\n\n阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。\n\n请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。\n\n人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！\n\n有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。\n\n为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？\n\n我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。\n\n因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。\n\n人生就像心电图，一帆风顺，你就挂了！\n\n心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。\n\n有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。\n\n人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。\n\n人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。\n\n我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。\n\n刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。\n\n有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。\n\n随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。\n\n世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？\n","source":"_posts/俞敏洪：我和马云就差了8个字.md","raw":"---\ntitle: 俞敏洪：我和马云就差了8个字\ntags: [其它]\ndate: 2015/12/25\n---\n\n\n\n马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。\n\n但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。\n\n有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。\n\n阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。\n\n请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。\n\n人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！\n\n有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。\n\n当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。\n\n为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？\n\n我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。\n\n因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。\n\n人生就像心电图，一帆风顺，你就挂了！\n\n心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。\n\n有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。\n\n人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。\n\n人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。\n\n我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。\n\n刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。\n\n当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。\n\n有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。\n\n随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。\n\n世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？\n\n他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。\n\n到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？\n","slug":"俞敏洪：我和马云就差了8个字","published":1,"updated":"2016-05-12T07:04:12.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3urd0010tsqby6f3l132","content":"<p>马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。</p>\n<p>但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。</p>\n<p>有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。</p>\n<p>阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。</p>\n<p>请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。</p>\n<p>人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！</p>\n<p>有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。</p>\n<p>为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？</p>\n<p>我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。</p>\n<p>因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。</p>\n<p>人生就像心电图，一帆风顺，你就挂了！</p>\n<p>心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。</p>\n<p>有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。</p>\n<p>人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。</p>\n<p>人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。</p>\n<p>我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。</p>\n<p>刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。</p>\n<p>有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。</p>\n<p>随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。</p>\n<p>世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？</p>\n","excerpt":"","more":"<p>马云，我真的非常的佩服他，首先佩服他的是他跟我有同样的经历，我考了3年才考上了大学；他也是考了3年。我比他还要幸运一点，我考上的是北大的本科，马云考上的是杭州师范学院的专科。可见，我们除了长相上的不同，还有智商上的差别。</p>\n<p>但是，阿里巴巴在去年到美国纽交所去上市，市值200亿美金，新东方比阿里巴巴早走了一步，我们在2006年就到美国上市，新东方的市值到今天为止才40亿美金。当然同学们不要小看40亿，你想做一个40亿美元的公司给我看看也是不容易的。</p>\n<p>有时候我想，我跟马云的差距在什么地方呢？后来发现，我跟他的差距就在最后八个字上，马云是一个典型的越败越战，愈挫愈勇的人物，我是典型的不是越败越战，愈挫愈勇的人物。我到后来有了这样一点精神，也是从周围的朋友身上学来的。</p>\n<p>阿里巴巴是马云做的第5个公司。马云在大学毕业以后，当了大学老师，也跟我一样，出来开了一个外语培训班，新东方第一个外语培训班招生人数13人，3年以后，新东方同期学生到了5000人，一举成功。马云第一个培训班招了20个人，3年以后的培训班还是20个人，开培训班失败了。马云又做了一个翻译社，怎么做怎么亏本，紧接着做了一个中国黄页，又失败了。马云又跑到北京开了一个合资公司，做了不到半年，还是失败了。</p>\n<p>请大家想一想，如果是你，连做4个公司都失败了，你会怎么办？你会怎么想自己？你会想，老子天生不是干这个事情的料，我天生是给别人打工的料，我再也不开公司了。但马云想的是，前面的失败是为了奠定未来做世界大公司的基础。我终于看出了，我和马云的区别。</p>\n<p>人的区别，不在于家庭身份，不在于长相，不在于上什么大学。请记住了，这个世界上，能掌管命运的就是你自己。没有任何人能把你从泥泞中拉起来，只有你自己可以爬起来；没有任何人可以阻止你前进，只要你自己往前走。这个世界上，90%的人是追随者，但你不是，请记住，你是来引领这个世界的！</p>\n<p>有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>我们的生命需要什么呢？突破，突破，再突破！有时，挡住我们前进的脚步，恰恰是不愿意迈出第一个脚步的自己。</p>\n<p>当我走进北大的时候，我连续几年充满了自卑，总感觉自己这也不行，那也不行，讲普通话不会讲，文艺体育才能不行，我唯一会的体育运动是游泳，但只会狗刨。上游泳课时，我的老师哈哈大笑，说从来没有看到一个人狗刨游得这么快，当时我无地自容。在北大看到男女同学谈恋爱，我发现自己根本没有勇气去追求我喜欢的女生，尽管我喜欢了很多的女生。</p>\n<p>为什么呢？因为我无法摆脱自卑，我无法摆脱我自轻的贱，我自己看不起自己。我是农村的孩子，穿的是破衣服，长相比马云好看一点，但是也不咋地。我想去追，到最后结果不就是被拒绝吗？不就是丢面子吗？</p>\n<p>我在大学四年，从来没有参加过任何学生和干部的竞选，因为我知道，我要竞选的话，80%的可能性都会失败，大家会怎么评价我呢？你看俞敏洪连他都想竞选学生会的干部，为了避免失败我干脆什么也不干。现在回想起我的大学生活，除了读了几本书，交了几个朋友，其他的生活几乎是一片空白。</p>\n<p>因为害怕，不愿意突破自己，最后导致我们永远在原地踏步。我们必须突破自卑的壳，自轻的贱，胆怯的虚，失败的惧，才可以奋勇向前。</p>\n<p>人生就像心电图，一帆风顺，你就挂了！</p>\n<p>心电图本身就是高高低低，非常不平整，它表明了生命的活力，如果说你的人生是一帆风顺的，证明你挂了，你的人生一帆风顺，有可能是你难得遇到挫折，精神就崩溃了。后来我终于想明白了，宁可生命中多点挫折，也不愿意生命中只是铺满了鲜花，因为在挫折中间，你能看到更多的风景，你能更多的感受到人生的酸甜苦辣。</p>\n<p>有一次黄晓明说，俞老师，我演的还好吧？我说你演得很好了，可惜你没有把我的气质演出来，他说什么是气质？我说气质是一个男人在经历了无数的风风雨雨之后，每一个动作都充满人生的智慧，这就是气质。</p>\n<p>人生的道路从来没有直路可走，每一个人只要心里有山峰，道路再曲折，也能够到达你人生的顶峰和山顶，希望大家一起共同努力。</p>\n<p>人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>我希望成为中国教育领域中间最优秀的教育助手，说得好听一点，教育家。但是到现在为止，我也不知道，走向教育家应该是做什么？但是我知道，我在这条路上一直在努力。</p>\n<p>我的人生，是从阶段性目标开始的。第一个目标，成为一个优秀的农民；第二个目标，离开农村，考上大学；第三个目标，是希望毕业以后，留在北大当老师；第四个目标，希望可以到美国去读书；前面三个目标都实现了，但是第四个目标，最后彻底绝望而告终。但是现在想一想，我突然发现，幸亏被拒签了。正是拒签让我一次一次的绝望，让我想到，我在北大永远不会有钱，我必须自己挣钱，所以有了新东方。所以说阶段性的目标，只要你可以坚持下去也是好事。</p>\n<p>刚才我说到了，人生最重要的是什么？注意力和穿透力。什么是穿透力，就是可以排除周围所有的纷纷扰扰，眼睛盯着你前行的路，那就是穿透力。</p>\n<p>当我们的生命有目标，如果你的眼睛可以穿透困难，走向目标，目标永远就是最大的。你就会变成成功者，当你的眼睛只看到困难，目标被困难阻挡的时候，你永远是一个失败者。</p>\n<p>有多少同学在生活中遇到困难放弃自己的目标：考试，考不过去就放弃了；交朋友，交不了就放弃了；找工作，投了几份简历没有人要就放弃了；创业，一次失败就放弃了。我们的生活中放弃了太多的东西，看到了太多的困难，以至于我们一次一次变成了失败者，但是你没有像马云一样，从一直失败，一直失败，走向成功，你也没有像我一样，走向成功。其实成功不在于坚持了多久，只有在一次一次没有希望的时候依然坚持下去，才有用。</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>在长大的过程中，我们失去童年，失去了青年，不知不觉走向了中年。我们有多少人在30岁以后，慢慢告诉自己，你必须坚持？我们大部分人都看到的是什么？我们日益变得平庸，我们人生充满迷茫；我们随着碰到各种各样的困难。</p>\n<p>随着我们失恋，随着我们大学毕业找工作，随着我们创业找不到资源，我们越来越变得胆怯，越来越变得懦弱。我们开始放弃自己的梦想，我们甚至放弃自己微小的目标。到最后，我们附和整个社会，还给自己起了一个非常好听的名字，就叫“和光同尘”。其实，是把你的光弄没了，而你的精神和灵魂，确实掩盖了所有的尘埃。</p>\n<p>世界上80%的人，都在默默无闻中渡过自己的一辈子，都在抱怨中过着每天的日子，都在对社会以及对周围的亲人和朋友不满足，来打发自己的日子，他们从来没有想过，身上到底丢了什么东西？</p>\n<p>他们丢掉了梦想，丢掉了坚持，丢掉了信念，再也没有什么东西值得相信。留下的是什么？是平庸，迷茫，懦弱，放弃和附和。</p>\n<p>到今天为止，我已经是新东方年龄最大的人，过了50岁，但非常庆幸的是，我依然每时每刻都告诉自己，都在问自己，我的梦想在哪里？我的信念在哪里？我还在坚持一些什么？我是不是已经变得懦弱，已经变得平庸，已经变得放弃自己的理想？</p>\n"},{"title":"【Angularjs文档翻译及实例】DOM事件","date":"2015-04-19T16:00:00.000Z","_content":"\n把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。\n\n> 约定：\n> 此文中ngXxx表示ng-xxx属性名。\n\n### ngBlur\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-blur=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数     | 类型         | 详情                              |      |\n| :----- | :--------- | :------------------------------ | ---- |\n| ngBlur | expression | 表达式将在失去焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngFocus\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-focus=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                            |      |\n| :------ | :--------- | :---------------------------- | ---- |\n| ngFocus | expression | 表达在获得焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngChange\n\n**用法**\n\n```\n<input\n  ng-change=\"expression\">\n...\n</input>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                 |      |\n| :------- | :--------- | :----------------- | ---- |\n| ngChange | expression | 表达式将在input控件被改变时触发 |      |\n\n### ngChecked\n\n**用法**\n\n```\n<INPUT\n  ng-checked=\"expression\">\n...\n</INPUT>\n```\n\n**参数**\n\n| 参数        | 类型         | 详情                          |      |\n| :-------- | :--------- | :-------------------------- | ---- |\n| ngChecked | expression | 如果表达式为真，那么就会在元素上设置checked属性 |      |\n\n### ngClick\n\n**用法**\n\n```\n<ANY\n  ng-click=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                             |      |\n| :------ | :--------- | :----------------------------- | ---- |\n| ngClick | expression | 当被点击的时候触发表达式（事件对象与$event一样可获得） |      |\n\n\n\n\n### ngKeydown/ngKeypress/ngKeyup\n\n**用法**\n\n```\n<ANY\n  ng-keydown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keypress=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keyup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                                       |      |\n| :--------- | :--------- | :--------------------------------------- | ---- |\n| ngKeydown  | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeypress | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeyup    | expression | 表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n\n### ngMousedown/ngMouseup\n\n**用法**\n\n```\n<ANY\n  ng-mousedown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数          | 类型         | 详情                             |      |\n| :---------- | :--------- | :----------------------------- | ---- |\n| ngMousedown | expression | 表达式在鼠标按下时被触发（事件对象与$event一样可获得） |      |\n| ngMouseup   | expression | 表达式在鼠标释放时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseenter/ngMousemove\n\n**用法**\n\n```\n<ANY\n  ng-mouseenter=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mousemove=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                                 |      |\n| :----------- | :--------- | :--------------------------------- | ---- |\n| ngMouseenter | expression | 表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）   |      |\n| ngMousemove  | expression | 表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseover/ngMouseleave\n\n**用法**\n\n```\n<ANY\n  ng-mouseover=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseleave=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                               |      |\n| :----------- | :--------- | :------------------------------- | ---- |\n| ngMouseover  | expression | 表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得） |      |\n| ngMouseleave | expression | 表达式在鼠标离开时被触发（事件对象与$event一样可获得）   |      |\n\n### ngSelected\n\n**用法**\n\n```\n<OPTION\n  ng-selected=\"expression\">\n...\n</OPTION>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                         |      |\n| :--------- | :--------- | :------------------------- | ---- |\n| ngSelected | expression | 表达式为真时，selected属性将被设置在元素上。 |      |\n\n### ngSubmit\n\n**用法**\n\n```\n<form\n  ng-submit=\"expression\">\n...\n</form>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                             |      |\n| :------- | :--------- | :----------------------------- | ---- |\n| ngSubmit | expression | 提交表单时，表达式被触发（事件对象与$event一样可获得） |      |\n\n\n### 综合实例\n\n**html代码**\n\n```\n<div ng-app=\"myapp\">\n    <form name=\"form\" ng-controller=\"formCtrl\">\n        <p>\n            <input type=\"text\" ng-model=\"blur\" ng-blur=\"blur='be blured'\" ng-focus=\"blur='got focus,click other place'\" placeholder=\"click me\" />\n        </p>\n        <p>\n            <span ng-model=\"mouseEvent\" ng-mouseenter=\"mouseEvent='mouseenter'\" ng-mouseleave=\"mouseEvent='mouseleave'\" ng-bind=\"mouseEvent\" ng-init=\"mouseEvent='touch me'\">touch me</span>\n        </p>\n        <p>\n            <input type=\"text\" ng-model=\"change\" ng-change=\"changeEvent()\" placeholder=\"change me\" />\n        </p>\n        <p>\n            msg1:{{changeStatus}},content:{{change}}\n        </p>\n        <p>\n            <input type=\"button\" ng-click=\"btnClickChangeCheckboxEvent()\" value=\"change status of checkbox->\" />\n            <input type=\"checkbox\" ng-model=\"checkbox\" ng-checked=\"isStatus\" />\n        </p>\n        <p>\n            <input type=\"checkbox\" ng-model=\"option\" />change status of select\n            <select>\n                <option>A</option>\n                <option ng-selected=\"option\">B</option>\n            </select>\n        </p>\n    </form>\n</div>\n```\n\n**js代码**\n\n```\nangular.module('myapp', [])\n    .controller('formCtrl', function($scope) {\n        $scope.change = 'change me';\n        $scope.changeStatus = 'no change';\n        $scope.isStatus = false;\n        $scope.option = false;\n\n        $scope.changeEvent = function() {\n            $scope.changeStatus = 'be changed';\n        }\n\n        $scope.btnClickChangeCheckboxEvent = function() {\n            $scope.isStatus = !$scope.isStatus;\n        }\n    });\n```\n\nDEMO地址：[https://jsfiddle.net/Lionney/vLkoz9d3/](https://jsfiddle.net/Lionney/vLkoz9d3/)\n\n如有问题，请指正。\n","source":"_posts/【Angularjs文档翻译及实例】DOM事件.md","raw":"---\ntitle: 【Angularjs文档翻译及实例】DOM事件\ntags: [javascript,angularjs]\ndate: 2015/04/20\n---\n\n把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。\n\n> 约定：\n> 此文中ngXxx表示ng-xxx属性名。\n\n### ngBlur\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-blur=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数     | 类型         | 详情                              |      |\n| :----- | :--------- | :------------------------------ | ---- |\n| ngBlur | expression | 表达式将在失去焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngFocus\n\n**用法**\n\n```\n<window, input, select, textarea, a\n  ng-focus=\"expression\">\n...\n</window, input, select, textarea, a>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                            |      |\n| :------ | :--------- | :---------------------------- | ---- |\n| ngFocus | expression | 表达在获得焦点时被触发（事件对象与$event一样可获得） |      |\n\n### ngChange\n\n**用法**\n\n```\n<input\n  ng-change=\"expression\">\n...\n</input>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                 |      |\n| :------- | :--------- | :----------------- | ---- |\n| ngChange | expression | 表达式将在input控件被改变时触发 |      |\n\n### ngChecked\n\n**用法**\n\n```\n<INPUT\n  ng-checked=\"expression\">\n...\n</INPUT>\n```\n\n**参数**\n\n| 参数        | 类型         | 详情                          |      |\n| :-------- | :--------- | :-------------------------- | ---- |\n| ngChecked | expression | 如果表达式为真，那么就会在元素上设置checked属性 |      |\n\n### ngClick\n\n**用法**\n\n```\n<ANY\n  ng-click=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数      | 类型         | 详情                             |      |\n| :------ | :--------- | :----------------------------- | ---- |\n| ngClick | expression | 当被点击的时候触发表达式（事件对象与$event一样可获得） |      |\n\n\n\n\n### ngKeydown/ngKeypress/ngKeyup\n\n**用法**\n\n```\n<ANY\n  ng-keydown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keypress=\"expression\">\n...\n</ANY>\n<ANY\n  ng-keyup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                                       |      |\n| :--------- | :--------- | :--------------------------------------- | ---- |\n| ngKeydown  | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeypress | expression | 表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n| ngKeyup    | expression | 表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等） |      |\n\n### ngMousedown/ngMouseup\n\n**用法**\n\n```\n<ANY\n  ng-mousedown=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseup=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数          | 类型         | 详情                             |      |\n| :---------- | :--------- | :----------------------------- | ---- |\n| ngMousedown | expression | 表达式在鼠标按下时被触发（事件对象与$event一样可获得） |      |\n| ngMouseup   | expression | 表达式在鼠标释放时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseenter/ngMousemove\n\n**用法**\n\n```\n<ANY\n  ng-mouseenter=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mousemove=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                                 |      |\n| :----------- | :--------- | :--------------------------------- | ---- |\n| ngMouseenter | expression | 表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）   |      |\n| ngMousemove  | expression | 表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得） |      |\n\n### ngMouseover/ngMouseleave\n\n**用法**\n\n```\n<ANY\n  ng-mouseover=\"expression\">\n...\n</ANY>\n<ANY\n  ng-mouseleave=\"expression\">\n...\n</ANY>\n```\n\n**参数**\n\n| 参数           | 类型         | 详情                               |      |\n| :----------- | :--------- | :------------------------------- | ---- |\n| ngMouseover  | expression | 表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得） |      |\n| ngMouseleave | expression | 表达式在鼠标离开时被触发（事件对象与$event一样可获得）   |      |\n\n### ngSelected\n\n**用法**\n\n```\n<OPTION\n  ng-selected=\"expression\">\n...\n</OPTION>\n```\n\n**参数**\n\n| 参数         | 类型         | 详情                         |      |\n| :--------- | :--------- | :------------------------- | ---- |\n| ngSelected | expression | 表达式为真时，selected属性将被设置在元素上。 |      |\n\n### ngSubmit\n\n**用法**\n\n```\n<form\n  ng-submit=\"expression\">\n...\n</form>\n```\n\n**参数**\n\n| 参数       | 类型         | 详情                             |      |\n| :------- | :--------- | :----------------------------- | ---- |\n| ngSubmit | expression | 提交表单时，表达式被触发（事件对象与$event一样可获得） |      |\n\n\n### 综合实例\n\n**html代码**\n\n```\n<div ng-app=\"myapp\">\n    <form name=\"form\" ng-controller=\"formCtrl\">\n        <p>\n            <input type=\"text\" ng-model=\"blur\" ng-blur=\"blur='be blured'\" ng-focus=\"blur='got focus,click other place'\" placeholder=\"click me\" />\n        </p>\n        <p>\n            <span ng-model=\"mouseEvent\" ng-mouseenter=\"mouseEvent='mouseenter'\" ng-mouseleave=\"mouseEvent='mouseleave'\" ng-bind=\"mouseEvent\" ng-init=\"mouseEvent='touch me'\">touch me</span>\n        </p>\n        <p>\n            <input type=\"text\" ng-model=\"change\" ng-change=\"changeEvent()\" placeholder=\"change me\" />\n        </p>\n        <p>\n            msg1:{{changeStatus}},content:{{change}}\n        </p>\n        <p>\n            <input type=\"button\" ng-click=\"btnClickChangeCheckboxEvent()\" value=\"change status of checkbox->\" />\n            <input type=\"checkbox\" ng-model=\"checkbox\" ng-checked=\"isStatus\" />\n        </p>\n        <p>\n            <input type=\"checkbox\" ng-model=\"option\" />change status of select\n            <select>\n                <option>A</option>\n                <option ng-selected=\"option\">B</option>\n            </select>\n        </p>\n    </form>\n</div>\n```\n\n**js代码**\n\n```\nangular.module('myapp', [])\n    .controller('formCtrl', function($scope) {\n        $scope.change = 'change me';\n        $scope.changeStatus = 'no change';\n        $scope.isStatus = false;\n        $scope.option = false;\n\n        $scope.changeEvent = function() {\n            $scope.changeStatus = 'be changed';\n        }\n\n        $scope.btnClickChangeCheckboxEvent = function() {\n            $scope.isStatus = !$scope.isStatus;\n        }\n    });\n```\n\nDEMO地址：[https://jsfiddle.net/Lionney/vLkoz9d3/](https://jsfiddle.net/Lionney/vLkoz9d3/)\n\n如有问题，请指正。\n","slug":"【Angularjs文档翻译及实例】DOM事件","published":1,"updated":"2016-05-18T06:37:01.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3urg0012tsqbwdei135s","content":"<p>把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。</p>\n<blockquote>\n<p>约定：<br>此文中ngXxx表示ng-xxx属性名。</p>\n</blockquote>\n<h3 id=\"ngBlur\"><a href=\"#ngBlur\" class=\"headerlink\" title=\"ngBlur\"></a>ngBlur</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;window, input, select, textarea, a</span><br><span class=\"line\">  ng-blur=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/window, input, select, textarea, a&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngBlur</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在失去焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngFocus\"><a href=\"#ngFocus\" class=\"headerlink\" title=\"ngFocus\"></a>ngFocus</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;window, input, select, textarea, a</span><br><span class=\"line\">  ng-focus=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/window, input, select, textarea, a&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngFocus</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达在获得焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChange\"><a href=\"#ngChange\" class=\"headerlink\" title=\"ngChange\"></a>ngChange</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  ng-change=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/input&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChange</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在input控件被改变时触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChecked\"><a href=\"#ngChecked\" class=\"headerlink\" title=\"ngChecked\"></a>ngChecked</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;INPUT</span><br><span class=\"line\">  ng-checked=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/INPUT&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChecked</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">如果表达式为真，那么就会在元素上设置checked属性</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngClick\"><a href=\"#ngClick\" class=\"headerlink\" title=\"ngClick\"></a>ngClick</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-click=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngClick</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">当被点击的时候触发表达式（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngKeydown-ngKeypress-ngKeyup\"><a href=\"#ngKeydown-ngKeypress-ngKeyup\" class=\"headerlink\" title=\"ngKeydown/ngKeypress/ngKeyup\"></a>ngKeydown/ngKeypress/ngKeyup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keydown=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keypress=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keyup=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngKeydown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeypress</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeyup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMousedown-ngMouseup\"><a href=\"#ngMousedown-ngMouseup\" class=\"headerlink\" title=\"ngMousedown/ngMouseup\"></a>ngMousedown/ngMouseup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mousedown=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseup=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMousedown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标按下时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标释放时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseenter-ngMousemove\"><a href=\"#ngMouseenter-ngMousemove\" class=\"headerlink\" title=\"ngMouseenter/ngMousemove\"></a>ngMouseenter/ngMousemove</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseenter=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mousemove=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseenter</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMousemove</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseover-ngMouseleave\"><a href=\"#ngMouseover-ngMouseleave\" class=\"headerlink\" title=\"ngMouseover/ngMouseleave\"></a>ngMouseover/ngMouseleave</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseover=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseleave=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseover</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseleave</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标离开时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSelected\"><a href=\"#ngSelected\" class=\"headerlink\" title=\"ngSelected\"></a>ngSelected</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;OPTION</span><br><span class=\"line\">  ng-selected=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/OPTION&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSelected</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式为真时，selected属性将被设置在元素上。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSubmit\"><a href=\"#ngSubmit\" class=\"headerlink\" title=\"ngSubmit\"></a>ngSubmit</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form</span><br><span class=\"line\">  ng-submit=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSubmit</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">提交表单时，表达式被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"综合实例\"><a href=\"#综合实例\" class=\"headerlink\" title=\"综合实例\"></a>综合实例</h3><p><strong>html代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-app=&quot;myapp&quot;&gt;</span><br><span class=\"line\">    &lt;form name=&quot;form&quot; ng-controller=&quot;formCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;blur&quot; ng-blur=&quot;blur=&apos;be blured&apos;&quot; ng-focus=&quot;blur=&apos;got focus,click other place&apos;&quot; placeholder=&quot;click me&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;span ng-model=&quot;mouseEvent&quot; ng-mouseenter=&quot;mouseEvent=&apos;mouseenter&apos;&quot; ng-mouseleave=&quot;mouseEvent=&apos;mouseleave&apos;&quot; ng-bind=&quot;mouseEvent&quot; ng-init=&quot;mouseEvent=&apos;touch me&apos;&quot;&gt;touch me&lt;/span&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;change&quot; ng-change=&quot;changeEvent()&quot; placeholder=&quot;change me&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            msg1:&#123;&#123;changeStatus&#125;&#125;,content:&#123;&#123;change&#125;&#125;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;button&quot; ng-click=&quot;btnClickChangeCheckboxEvent()&quot; value=&quot;change status of checkbox-&gt;&quot; /&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;checkbox&quot; ng-checked=&quot;isStatus&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;option&quot; /&gt;change status of select</span><br><span class=\"line\">            &lt;select&gt;</span><br><span class=\"line\">                &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">                &lt;option ng-selected=&quot;option&quot;&gt;B&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">    &lt;/form&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>js代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;myapp&apos;, [])</span><br><span class=\"line\">    .controller(&apos;formCtrl&apos;, function($scope) &#123;</span><br><span class=\"line\">        $scope.change = &apos;change me&apos;;</span><br><span class=\"line\">        $scope.changeStatus = &apos;no change&apos;;</span><br><span class=\"line\">        $scope.isStatus = false;</span><br><span class=\"line\">        $scope.option = false;</span><br><span class=\"line\"></span><br><span class=\"line\">        $scope.changeEvent = function() &#123;</span><br><span class=\"line\">            $scope.changeStatus = &apos;be changed&apos;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        $scope.btnClickChangeCheckboxEvent = function() &#123;</span><br><span class=\"line\">            $scope.isStatus = !$scope.isStatus;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>DEMO地址：<a href=\"https://jsfiddle.net/Lionney/vLkoz9d3/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/Lionney/vLkoz9d3/</a></p>\n<p>如有问题，请指正。</p>\n","excerpt":"","more":"<p>把Angularjs当中涉及DOM事件的属性整理一下，此文档是基于1.4.8英文文档整理的。</p>\n<blockquote>\n<p>约定：<br>此文中ngXxx表示ng-xxx属性名。</p>\n</blockquote>\n<h3 id=\"ngBlur\"><a href=\"#ngBlur\" class=\"headerlink\" title=\"ngBlur\"></a>ngBlur</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;window, input, select, textarea, a</span><br><span class=\"line\">  ng-blur=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/window, input, select, textarea, a&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngBlur</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在失去焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngFocus\"><a href=\"#ngFocus\" class=\"headerlink\" title=\"ngFocus\"></a>ngFocus</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;window, input, select, textarea, a</span><br><span class=\"line\">  ng-focus=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/window, input, select, textarea, a&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngFocus</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达在获得焦点时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChange\"><a href=\"#ngChange\" class=\"headerlink\" title=\"ngChange\"></a>ngChange</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input</span><br><span class=\"line\">  ng-change=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/input&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChange</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式将在input控件被改变时触发</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngChecked\"><a href=\"#ngChecked\" class=\"headerlink\" title=\"ngChecked\"></a>ngChecked</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;INPUT</span><br><span class=\"line\">  ng-checked=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/INPUT&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngChecked</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">如果表达式为真，那么就会在元素上设置checked属性</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngClick\"><a href=\"#ngClick\" class=\"headerlink\" title=\"ngClick\"></a>ngClick</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-click=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngClick</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">当被点击的时候触发表达式（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngKeydown-ngKeypress-ngKeyup\"><a href=\"#ngKeydown-ngKeypress-ngKeyup\" class=\"headerlink\" title=\"ngKeydown/ngKeypress/ngKeyup\"></a>ngKeydown/ngKeypress/ngKeyup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keydown=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keypress=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-keyup=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngKeydown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeypress</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键按下时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngKeyup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在按键释放时被触发（事件对象与$event一样可获得，并且可以查询keyCode, altKey等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMousedown-ngMouseup\"><a href=\"#ngMousedown-ngMouseup\" class=\"headerlink\" title=\"ngMousedown/ngMouseup\"></a>ngMousedown/ngMouseup</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mousedown=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseup=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMousedown</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标按下时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseup</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标释放时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseenter-ngMousemove\"><a href=\"#ngMouseenter-ngMousemove\" class=\"headerlink\" title=\"ngMouseenter/ngMousemove\"></a>ngMouseenter/ngMousemove</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseenter=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mousemove=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseenter</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标进入元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMousemove</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标在元素上移动时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngMouseover-ngMouseleave\"><a href=\"#ngMouseover-ngMouseleave\" class=\"headerlink\" title=\"ngMouseover/ngMouseleave\"></a>ngMouseover/ngMouseleave</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseover=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br><span class=\"line\">&lt;ANY</span><br><span class=\"line\">  ng-mouseleave=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/ANY&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngMouseover</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标穿过元素时被触发（事件对象与$event一样可获得）</td>\n<td></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ngMouseleave</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式在鼠标离开时被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSelected\"><a href=\"#ngSelected\" class=\"headerlink\" title=\"ngSelected\"></a>ngSelected</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;OPTION</span><br><span class=\"line\">  ng-selected=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/OPTION&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSelected</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">表达式为真时，selected属性将被设置在元素上。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ngSubmit\"><a href=\"#ngSubmit\" class=\"headerlink\" title=\"ngSubmit\"></a>ngSubmit</h3><p><strong>用法</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form</span><br><span class=\"line\">  ng-submit=&quot;expression&quot;&gt;</span><br><span class=\"line\">...</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">详情</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ngSubmit</td>\n<td style=\"text-align:left\">expression</td>\n<td style=\"text-align:left\">提交表单时，表达式被触发（事件对象与$event一样可获得）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"综合实例\"><a href=\"#综合实例\" class=\"headerlink\" title=\"综合实例\"></a>综合实例</h3><p><strong>html代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div ng-app=&quot;myapp&quot;&gt;</span><br><span class=\"line\">    &lt;form name=&quot;form&quot; ng-controller=&quot;formCtrl&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;blur&quot; ng-blur=&quot;blur=&apos;be blured&apos;&quot; ng-focus=&quot;blur=&apos;got focus,click other place&apos;&quot; placeholder=&quot;click me&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;span ng-model=&quot;mouseEvent&quot; ng-mouseenter=&quot;mouseEvent=&apos;mouseenter&apos;&quot; ng-mouseleave=&quot;mouseEvent=&apos;mouseleave&apos;&quot; ng-bind=&quot;mouseEvent&quot; ng-init=&quot;mouseEvent=&apos;touch me&apos;&quot;&gt;touch me&lt;/span&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;text&quot; ng-model=&quot;change&quot; ng-change=&quot;changeEvent()&quot; placeholder=&quot;change me&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            msg1:&#123;&#123;changeStatus&#125;&#125;,content:&#123;&#123;change&#125;&#125;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;button&quot; ng-click=&quot;btnClickChangeCheckboxEvent()&quot; value=&quot;change status of checkbox-&gt;&quot; /&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;checkbox&quot; ng-checked=&quot;isStatus&quot; /&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;</span><br><span class=\"line\">            &lt;input type=&quot;checkbox&quot; ng-model=&quot;option&quot; /&gt;change status of select</span><br><span class=\"line\">            &lt;select&gt;</span><br><span class=\"line\">                &lt;option&gt;A&lt;/option&gt;</span><br><span class=\"line\">                &lt;option ng-selected=&quot;option&quot;&gt;B&lt;/option&gt;</span><br><span class=\"line\">            &lt;/select&gt;</span><br><span class=\"line\">        &lt;/p&gt;</span><br><span class=\"line\">    &lt;/form&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>js代码</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">angular.module(&apos;myapp&apos;, [])</span><br><span class=\"line\">    .controller(&apos;formCtrl&apos;, function($scope) &#123;</span><br><span class=\"line\">        $scope.change = &apos;change me&apos;;</span><br><span class=\"line\">        $scope.changeStatus = &apos;no change&apos;;</span><br><span class=\"line\">        $scope.isStatus = false;</span><br><span class=\"line\">        $scope.option = false;</span><br><span class=\"line\"></span><br><span class=\"line\">        $scope.changeEvent = function() &#123;</span><br><span class=\"line\">            $scope.changeStatus = &apos;be changed&apos;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        $scope.btnClickChangeCheckboxEvent = function() &#123;</span><br><span class=\"line\">            $scope.isStatus = !$scope.isStatus;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>DEMO地址：<a href=\"https://jsfiddle.net/Lionney/vLkoz9d3/\">https://jsfiddle.net/Lionney/vLkoz9d3/</a></p>\n<p>如有问题，请指正。</p>\n"},{"title":"学会享受孤独是通往成功的第一步","date":"2016-03-01T16:00:00.000Z","_content":"\n\n\n我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。\n\n所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？\n\n> 人类所有的不幸都来源于害怕和厌恶孤独。\n> –拉布吕耶尔（Jean de la Bruyere）\n\n一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。\n\n能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：\n\n### 1、有助恢复精力\n\n我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。\n\n### 2、可以做任何你想做的事情\n\n和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。\n\n### 3、学会相信自己\n\n自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。\n\n### 4、提高自己的情商\n\n情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。\n\n### 5、可以提升自信\n\n学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。\n\n### 6、可以更会欣赏别人\n\n独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。\n\n### 7、提升效率\n\n俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。\n\n### 总结一下\n\n独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。\n\n附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。\n\n作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。\n\n[http://www.codeceo.com/article/learn-alone-for-success.html](http://www.codeceo.com/article/learn-alone-for-success.html)\n","source":"_posts/学会享受孤独是通往成功的第一步.md","raw":"---\ntitle: 学会享受孤独是通往成功的第一步\ntags: [其它]\ndate: 2016/03/02\n---\n\n\n\n我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。\n\n所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？\n\n> 人类所有的不幸都来源于害怕和厌恶孤独。\n> –拉布吕耶尔（Jean de la Bruyere）\n\n一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。\n\n能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：\n\n### 1、有助恢复精力\n\n我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。\n\n### 2、可以做任何你想做的事情\n\n和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。\n\n### 3、学会相信自己\n\n自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。\n\n### 4、提高自己的情商\n\n情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。\n\n### 5、可以提升自信\n\n学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。\n\n### 6、可以更会欣赏别人\n\n独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。\n\n### 7、提升效率\n\n俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。\n\n### 总结一下\n\n独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。\n\n附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。\n\n作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。\n\n[http://www.codeceo.com/article/learn-alone-for-success.html](http://www.codeceo.com/article/learn-alone-for-success.html)\n","slug":"学会享受孤独是通往成功的第一步","published":1,"updated":"2016-05-12T06:49:12.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3url0015tsqbjmw013j5","content":"<p>我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。</p>\n<p>所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？</p>\n<blockquote>\n<p>人类所有的不幸都来源于害怕和厌恶孤独。<br>–拉布吕耶尔（Jean de la Bruyere）</p>\n</blockquote>\n<p>一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。</p>\n<p>能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：</p>\n<h3 id=\"1、有助恢复精力\"><a href=\"#1、有助恢复精力\" class=\"headerlink\" title=\"1、有助恢复精力\"></a>1、有助恢复精力</h3><p>我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。</p>\n<h3 id=\"2、可以做任何你想做的事情\"><a href=\"#2、可以做任何你想做的事情\" class=\"headerlink\" title=\"2、可以做任何你想做的事情\"></a>2、可以做任何你想做的事情</h3><p>和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。</p>\n<h3 id=\"3、学会相信自己\"><a href=\"#3、学会相信自己\" class=\"headerlink\" title=\"3、学会相信自己\"></a>3、学会相信自己</h3><p>自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。</p>\n<h3 id=\"4、提高自己的情商\"><a href=\"#4、提高自己的情商\" class=\"headerlink\" title=\"4、提高自己的情商\"></a>4、提高自己的情商</h3><p>情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。</p>\n<h3 id=\"5、可以提升自信\"><a href=\"#5、可以提升自信\" class=\"headerlink\" title=\"5、可以提升自信\"></a>5、可以提升自信</h3><p>学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。</p>\n<h3 id=\"6、可以更会欣赏别人\"><a href=\"#6、可以更会欣赏别人\" class=\"headerlink\" title=\"6、可以更会欣赏别人\"></a>6、可以更会欣赏别人</h3><p>独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。</p>\n<h3 id=\"7、提升效率\"><a href=\"#7、提升效率\" class=\"headerlink\" title=\"7、提升效率\"></a>7、提升效率</h3><p>俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&amp;M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。</p>\n<p>附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。</p>\n<p>作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。</p>\n<p><a href=\"http://www.codeceo.com/article/learn-alone-for-success.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/learn-alone-for-success.html</a></p>\n","excerpt":"","more":"<p>我们生活在一个社交异常活跃的世界，在这个世界里，人们渐渐地忽视独处的重要性。办公室的设计都正在抛弃以往的那种小隔板间，而采用那种开放的办公区域；学校的学生也不再坐在自己独立拥有的桌椅前，而是成组地呆在一起。持续不断的消息提示音是我们现代文明里的噪音，不断地提醒我们每一条短信、每一条微博和每一条各种通知。即使是平淡无奇的烧菜做饭，人们也乐于在朋友圈里发图分享。</p>\n<p>所有这些社交活动有一个直接的后果就是，我们基本不再拥有独处的时间。是的，人们都在说，融入社交圈是好事，与其他人交往可以丰富我们的生活，但是任何好的事情都应该有个度，不是吗？</p>\n<blockquote>\n<p>人类所有的不幸都来源于害怕和厌恶孤独。<br>–拉布吕耶尔（Jean de la Bruyere）</p>\n</blockquote>\n<p>一项涉及92个公司总共600名程序员的调查表明，每个公司内部的效率水平大致是稳定的，但是不同的公司效率却有高有低。效率较高的公司在这一点上是一致的：他们都不使用时尚的开放办公区，而使用能免于被打扰的私人办公区。效率最高的公司中，有62%声称自己在工作时拥有足够的个人空间，而反过来，效率比较低的公司中只有19%的人持相同观点。并且，在最低效的那些公司中，有76%的人说自己经常被人打扰，以致工作中断。</p>\n<p>能够享受孤独并不仅仅可以带来工作质量的提升，对于维护精神和心情的良好状态也是有用的。为了让生活更加充实，你必须学会享受独处的时光。孤独可以带来太多太多的好处，这里举一些最明显的：</p>\n<h3 id=\"1、有助恢复精力\"><a href=\"#1、有助恢复精力\" class=\"headerlink\" title=\"1、有助恢复精力\"></a>1、有助恢复精力</h3><p>我们任何人都需要时间去恢复精力，即使是那些无可救药的性格外向的人也是一样。除了静静一个人呆着，没有其他办法有这种效果。当你自己独处的时候，通过慢慢品尝精神上的安静和孤独可以帮你从一天的压力中获得解脱。</p>\n<h3 id=\"2、可以做任何你想做的事情\"><a href=\"#2、可以做任何你想做的事情\" class=\"headerlink\" title=\"2、可以做任何你想做的事情\"></a>2、可以做任何你想做的事情</h3><p>和其他人呆在一起是很有趣，但是同时，我们也更倾向于隐藏真实的自我。你总是需要不断地调整自己的想法，以此来适应其他人的喜好。但是当你自己独处的时候，你可以做你自己真正想做的事情。你可以毫不犹豫穿上自己爱穿的衣服，吃想吃的东西，把时间花在自己认为值得的事情上。</p>\n<h3 id=\"3、学会相信自己\"><a href=\"#3、学会相信自己\" class=\"headerlink\" title=\"3、学会相信自己\"></a>3、学会相信自己</h3><p>自由并不仅仅是做自己想做的事情，更是相信自己的直觉、了解自己直觉的能力，并且不考虑任何外界的影响或者压力。独处可以帮助你对自己建立一个更真实的了解，教会你相信自己：了解自己是谁，自己知道些什么，什么样的事情是适合自己的。当和其他人在一起的时候，你总是不断地去观察其他人的反应，并且以此来调整自己的感想和行为，更好地融入大家。有时，甚至你自己也对此没有察觉。当你自己独处的时候，这一切都由你来做主。你可以培养自己的思想和喜好，并且不用担心被别人左右。一旦你习惯于享受孤独，那么你就会发现自己真正有能力做到什么，不再在意别人对你的限定。</p>\n<h3 id=\"4、提高自己的情商\"><a href=\"#4、提高自己的情商\" class=\"headerlink\" title=\"4、提高自己的情商\"></a>4、提高自己的情商</h3><p>情商是指发现并且理解自己和他人的心情的能力，并且凭借这种了解来指导自己的行动、与他人建立适当的联系。TalentSmart公司曾经对100万人做过一次调查，发现90%最优秀的人的情商都非常高。学会了解自我是具备高情商的必备基础，如果做不到了解自我，那么情商不可能提高。因为了解自我需要理解自己的情绪以及如何来应对不同的人和处境，这就需要你能够多多反思，而在自己独处的时候可以更好地反思。</p>\n<h3 id=\"5、可以提升自信\"><a href=\"#5、可以提升自信\" class=\"headerlink\" title=\"5、可以提升自信\"></a>5、可以提升自信</h3><p>学会享受独处可以极大地提升自信。当你独处的时候如果发生烦躁不安的情绪，那么这时你会很容易地去考虑自己为什么在烦躁，或者是因为有别人在场所以才强言欢笑。学会享受独处可以足够地了解自己，因此提升自信。</p>\n<h3 id=\"6、可以更会欣赏别人\"><a href=\"#6、可以更会欣赏别人\" class=\"headerlink\" title=\"6、可以更会欣赏别人\"></a>6、可以更会欣赏别人</h3><p>独处让人的心变得更柔软。让你更容易用全新的眼光去看待他人，帮助你培养感恩的情怀，对他人他事也有了更好的认识。</p>\n<h3 id=\"7、提升效率\"><a href=\"#7、提升效率\" class=\"headerlink\" title=\"7、提升效率\"></a>7、提升效率</h3><p>俗话说人多力量大，这话如果对于扫树叶的活儿可能是真的，但是对于创造性的工作来说，可完全不是这么回事。即使对于头脑风暴这样的会议，所带来的效果也经常是愿望大于现实。德克萨斯州工农大学（Texas A&amp;M）的研究人员发现，头脑风暴会因为“认知固化”的原因而阻碍提高生产率。认知固化指的是人们一起工作的时候经常被别人的想法所牵绊，以致于没法想出真正创新的点子。并且越多的人一起参与，这种固化的坏处越明显。让自己静静一个人工作不仅可以减少不必要的纷扰，也不会因为“厨子太多”而陷入麻烦。</p>\n<h3 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h3><p>独处对每个人都大有裨益，趁着周末让自己一个人呆呆吧。</p>\n<p>附记：通过独处自己有了什么样的收获呢？请把您的心得通过评论区分享给我吧，因为我通过你也能学到我所不了解的。</p>\n<p>作者：Travis Bradberry博士与人合著了畅销书《情商2.0》，创办的TalentSmart公司，是世界领先的提供情商培训和测试的服务机构，客户涵盖世界500强中的75%。他的书被翻译成25种语言在超过150个国家发售。博士为《新闻周刊》、《泰晤士报》、《时代周刊》、《商业周刊》、《财富》、《福布斯》等媒体撰写文章或者被选为封面人物。</p>\n<p><a href=\"http://www.codeceo.com/article/learn-alone-for-success.html\">http://www.codeceo.com/article/learn-alone-for-success.html</a></p>\n"},{"title":"毁灭程序员的15个障碍","date":"2016-01-01T16:00:00.000Z","_content":"\n\n\n会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。\n\n昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。\n\n没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。\n\n下面就是现实世界中的15个编程障碍。\n\n### 编程效率障碍No.1：会议\n\n最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。\n\n虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。\n\n### 编程效率障碍No.2：答复所有的电子邮件\n\n如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。\n\n有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？\n\n### 编程效率障碍No.3：试图衡量生产力\n\n总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。\n\n但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。\n\n衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。\n\n对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。\n\n### 编程效率障碍No.4：妄自尊大的开发人员\n\n对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。\n\n当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。\n\n妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。\n\n### 编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\n\n我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。\n\n每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。\n\n### 编程效率障碍No.6：非程序员经理\n\n总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。\n\n有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。\n\n### 编程效率障碍No.7：程序员经理\n\n虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。\n\n他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。\n\n### 编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\n\n虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。\n\n程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。\n\n尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。\n\n### 编程效率障碍No.9：自私或牛仔程序员\n\n你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。\n\n牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。\n\n很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。\n\n### 编程效率障碍No.10：可怜的文档\n\n写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。\n\n有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。\n\n### 编程效率障碍No.11：成为文档的奴隶\n\n虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。\n\n程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。\n\n### 编程效率障碍No.12：很容易导致分心的环境\n\n有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。\n\n虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。\n\n有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。\n\n虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。\n\n### 编程效率障碍No.13：“文化契合”\n\n你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？\n\n如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。\n\n### 编程效率障碍No.14：死守传统技术\n\n很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。\n\n他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。\n\n当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。\n\n### 编程效率障碍No.15：对最新的渴望\n\n最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。\n\n在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。\n","source":"_posts/毁灭程序员的15个障碍.md","raw":"---\ntitle: 毁灭程序员的15个障碍\ntags: [其它]\ndate: 2016/01/02\n---\n\n\n\n会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。\n\n昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。\n\n没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。\n\n下面就是现实世界中的15个编程障碍。\n\n### 编程效率障碍No.1：会议\n\n最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。\n\n虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。\n\n### 编程效率障碍No.2：答复所有的电子邮件\n\n如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。\n\n有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？\n\n### 编程效率障碍No.3：试图衡量生产力\n\n总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。\n\n但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。\n\n衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。\n\n对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。\n\n### 编程效率障碍No.4：妄自尊大的开发人员\n\n对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。\n\n当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。\n\n妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。\n\n### 编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\n\n我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。\n\n每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。\n\n### 编程效率障碍No.6：非程序员经理\n\n总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。\n\n有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。\n\n### 编程效率障碍No.7：程序员经理\n\n虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。\n\n他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。\n\n### 编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\n\n虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。\n\n程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。\n\n尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。\n\n### 编程效率障碍No.9：自私或牛仔程序员\n\n你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。\n\n牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。\n\n很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。\n\n### 编程效率障碍No.10：可怜的文档\n\n写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。\n\n有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。\n\n### 编程效率障碍No.11：成为文档的奴隶\n\n虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。\n\n程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。\n\n### 编程效率障碍No.12：很容易导致分心的环境\n\n有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。\n\n虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。\n\n有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。\n\n虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。\n\n### 编程效率障碍No.13：“文化契合”\n\n你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？\n\n如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。\n\n### 编程效率障碍No.14：死守传统技术\n\n很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。\n\n他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。\n\n当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。\n\n### 编程效率障碍No.15：对最新的渴望\n\n最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。\n\n在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。\n","slug":"毁灭程序员的15个障碍","published":1,"updated":"2016-05-12T07:04:25.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3urq0017tsqbvjgzv0yo","content":"<p>会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。</p>\n<p>昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。</p>\n<p>没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。</p>\n<p>下面就是现实世界中的15个编程障碍。</p>\n<h3 id=\"编程效率障碍No-1：会议\"><a href=\"#编程效率障碍No-1：会议\" class=\"headerlink\" title=\"编程效率障碍No.1：会议\"></a>编程效率障碍No.1：会议</h3><p>最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。</p>\n<p>虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。</p>\n<h3 id=\"编程效率障碍No-2：答复所有的电子邮件\"><a href=\"#编程效率障碍No-2：答复所有的电子邮件\" class=\"headerlink\" title=\"编程效率障碍No.2：答复所有的电子邮件\"></a>编程效率障碍No.2：答复所有的电子邮件</h3><p>如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。</p>\n<p>有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？</p>\n<h3 id=\"编程效率障碍No-3：试图衡量生产力\"><a href=\"#编程效率障碍No-3：试图衡量生产力\" class=\"headerlink\" title=\"编程效率障碍No.3：试图衡量生产力\"></a>编程效率障碍No.3：试图衡量生产力</h3><p>总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。</p>\n<p>但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。</p>\n<p>衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。</p>\n<p>对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。</p>\n<h3 id=\"编程效率障碍No-4：妄自尊大的开发人员\"><a href=\"#编程效率障碍No-4：妄自尊大的开发人员\" class=\"headerlink\" title=\"编程效率障碍No.4：妄自尊大的开发人员\"></a>编程效率障碍No.4：妄自尊大的开发人员</h3><p>对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。</p>\n<p>当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。</p>\n<p>妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。</p>\n<h3 id=\"编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\"><a href=\"#编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\" class=\"headerlink\" title=\"编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\"></a>编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”</h3><p>我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。</p>\n<p>每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。</p>\n<h3 id=\"编程效率障碍No-6：非程序员经理\"><a href=\"#编程效率障碍No-6：非程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.6：非程序员经理\"></a>编程效率障碍No.6：非程序员经理</h3><p>总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。</p>\n<p>有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。</p>\n<h3 id=\"编程效率障碍No-7：程序员经理\"><a href=\"#编程效率障碍No-7：程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.7：程序员经理\"></a>编程效率障碍No.7：程序员经理</h3><p>虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。</p>\n<p>他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。</p>\n<h3 id=\"编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\"><a href=\"#编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\" class=\"headerlink\" title=\"编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\"></a>编程效率障碍No.8：善于社交的程序员，又名“brogrammer”</h3><p>虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。</p>\n<p>程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。</p>\n<p>尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。</p>\n<h3 id=\"编程效率障碍No-9：自私或牛仔程序员\"><a href=\"#编程效率障碍No-9：自私或牛仔程序员\" class=\"headerlink\" title=\"编程效率障碍No.9：自私或牛仔程序员\"></a>编程效率障碍No.9：自私或牛仔程序员</h3><p>你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。</p>\n<p>牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。</p>\n<p>很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。</p>\n<h3 id=\"编程效率障碍No-10：可怜的文档\"><a href=\"#编程效率障碍No-10：可怜的文档\" class=\"headerlink\" title=\"编程效率障碍No.10：可怜的文档\"></a>编程效率障碍No.10：可怜的文档</h3><p>写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。</p>\n<p>有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。</p>\n<h3 id=\"编程效率障碍No-11：成为文档的奴隶\"><a href=\"#编程效率障碍No-11：成为文档的奴隶\" class=\"headerlink\" title=\"编程效率障碍No.11：成为文档的奴隶\"></a>编程效率障碍No.11：成为文档的奴隶</h3><p>虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。</p>\n<p>程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。</p>\n<h3 id=\"编程效率障碍No-12：很容易导致分心的环境\"><a href=\"#编程效率障碍No-12：很容易导致分心的环境\" class=\"headerlink\" title=\"编程效率障碍No.12：很容易导致分心的环境\"></a>编程效率障碍No.12：很容易导致分心的环境</h3><p>有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。</p>\n<p>虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。</p>\n<p>有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。</p>\n<p>虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。</p>\n<h3 id=\"编程效率障碍No-13：“文化契合”\"><a href=\"#编程效率障碍No-13：“文化契合”\" class=\"headerlink\" title=\"编程效率障碍No.13：“文化契合”\"></a>编程效率障碍No.13：“文化契合”</h3><p>你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？</p>\n<p>如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。</p>\n<h3 id=\"编程效率障碍No-14：死守传统技术\"><a href=\"#编程效率障碍No-14：死守传统技术\" class=\"headerlink\" title=\"编程效率障碍No.14：死守传统技术\"></a>编程效率障碍No.14：死守传统技术</h3><p>很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。</p>\n<p>他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。</p>\n<p>当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。</p>\n<h3 id=\"编程效率障碍No-15：对最新的渴望\"><a href=\"#编程效率障碍No-15：对最新的渴望\" class=\"headerlink\" title=\"编程效率障碍No.15：对最新的渴望\"></a>编程效率障碍No.15：对最新的渴望</h3><p>最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。</p>\n<p>在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。</p>\n","excerpt":"","more":"<p>会议，什么都不懂的经理，生产效率指标——这就是你和下一个伟大软件之间的天堑。</p>\n<p>昨天必须得发布产品。用户争闹和咆哮某个缺失的功能。老板的老板说，我们最好迅速行动起来否则就炒我们的鱿鱼。感觉一切都有心无力。</p>\n<p>没有人满意开发人员这种已经“竭尽全力”改变世界的速度，每个人都希望代码像消防水管里的水一样能够源源不断地流出来，但没有人愿意提供给开发人员更好地完成工作的条件。正如那个想要我们昨天就完成工作的老板，他不愿意雇佣更多的人，不愿意购买速度更快的机器，也不愿意做任何其他可以让程序员专注于编程的事情，又想马儿跑，又不给马儿吃草。</p>\n<p>下面就是现实世界中的15个编程障碍。</p>\n<h3 id=\"编程效率障碍No-1：会议\"><a href=\"#编程效率障碍No-1：会议\" class=\"headerlink\" title=\"编程效率障碍No.1：会议\"></a>编程效率障碍No.1：会议</h3><p>最常见的抱怨是打断开发人员编码思绪的会议。如果老板信任该程序员，就会要求他们时不时地去那间数周甚至数年昏昏暗暗的会议室闲聊有关细节。尽管程序员通常归咎于是管理人员毁了会议，但他们偶尔也会指责其他的程序员老是跑过来询问有关或bug或功能或架构策略的问题。</p>\n<p>虽然有些抱怨是愚蠢的——但程序员依然会埋怨，如果老板让他们自己在黑暗中摸索，没有一点沟通——任他们自己在软件的抽象世界里埋头苦干，自己去面对各种困境。快餐厨师和咖啡调配师或许还能够兼顾不同的需求，但如果是切换大脑到正确的模式来操作抽象算法则通常需要时间。从会议模式中切换回编码模式，可能会浪费一个小时左右的工作时间。</p>\n<h3 id=\"编程效率障碍No-2：答复所有的电子邮件\"><a href=\"#编程效率障碍No-2：答复所有的电子邮件\" class=\"headerlink\" title=\"编程效率障碍No.2：答复所有的电子邮件\"></a>编程效率障碍No.2：答复所有的电子邮件</h3><p>如果说会议很糟糕，那么这一种可能更糟糕：需要查看发来的无穷无尽的邮件。回复邮件需要时间，而且没人会对回复结果表示满意。然后那些最不耐烦的开发人员或许会选择简单的回复——“tl;dr”(即too long，didn’t read。篇幅过长，没有阅读)。</p>\n<p>有的团队试图开设每周一天的禁邮日。还有的团队就完全不用邮件。虽然解决了邮件过载的问题，但却是以沟通为代价的。要是突然不在一起工作。这还能算是好办法吗？</p>\n<h3 id=\"编程效率障碍No-3：试图衡量生产力\"><a href=\"#编程效率障碍No-3：试图衡量生产力\" class=\"headerlink\" title=\"编程效率障碍No.3：试图衡量生产力\"></a>编程效率障碍No.3：试图衡量生产力</h3><p>总会有管理团队受那些所谓“你不能管理你无法衡量的东西”的书籍启发，于是开始衡量提交的或代码库或软件代码行或bug修复。他们认为，计数就是衡量，而且衡量一定是好事。</p>\n<p>但是程序员并不是砌砖工，不能数数砌了多少砖就知道其效率。相反，为了写出更好的代码，程序员需要或专注于编写的代码行，或解决bug，或提交到代码仓库，或做一些无法计数的事情。如果bug修复可以加分，那么一些微小bug的报告就会激增，bug修复也会如此。有人因为报告bug得到了奖励，然后另一个人因为修复它也能得到奖励。或者，如果是计数代码行数，那么那些可以用10行代码解决问题的程序员，可能就会转而表示5000行的代码将更灵活或功能更兼容——任何可以添加到5000行中的都加进去。</p>\n<p>衡量效率实际上会因为鼓励功能丰富，代码过度设计的长文件，而让代码库变得更糟。</p>\n<p>对于此问题还没有真正的解决方法。我们需要跟踪bug。我们需要组织工作流程，协调软件的创建。这种优雅是无法衡量的。</p>\n<h3 id=\"编程效率障碍No-4：妄自尊大的开发人员\"><a href=\"#编程效率障碍No-4：妄自尊大的开发人员\" class=\"headerlink\" title=\"编程效率障碍No.4：妄自尊大的开发人员\"></a>编程效率障碍No.4：妄自尊大的开发人员</h3><p>对于程序员而言，有这样一个同事比Boss更难以忍受：创建了代码的最后一次迭代，却不再工作于这个项目。正如每个房屋装修承包商会贬低上一个木匠的技能，每个程序员也会快速指出可怕的，不可原谅的，完全是死脑筋的上一代的行为。</p>\n<p>当然，这可能是事实，但它很少像程序员说得那么糟糕。如果有什么区别的话，问题通常也不是由于技能匮乏而引起的。主要还是风格的不同，并且风格还会随着时间而改变。上一代和我们今天访问的库不同。他们也不曾阅读过有关最佳做法的最新著作。</p>\n<p>妄自尊大的编程态度往往会减缓项目。骄傲和利己主义的混合发酵会导致程序员抛弃完全能够胜任的代码，只为了按照他们认为的“正确方式”重建。</p>\n<h3 id=\"编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\"><a href=\"#编程效率障碍No-5：“以后修复”的思维定式，又名“技术债”\" class=\"headerlink\" title=\"编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”\"></a>编程效率障碍No.5：“以后修复”的思维定式，又名“技术债”</h3><p>我们总感觉不够时间在项目中按计划构建我们想要构建的东西。于是，我们偷工减料，给代码打补丁，缠满了虚拟胶带。曾有明智的经理将此称为是“技术债”，因为“债”是以后必须要还的。即使他们不理解代码，也知道“债”的含义。</p>\n<p>每个项目都有一定的技术债务。有时它会快速见效，但通常直到下一代才会发现这已经成为了一个坑。他们需要构建上一代没有做到的东西。就像滚雪球一样，越滚越大。</p>\n<h3 id=\"编程效率障碍No-6：非程序员经理\"><a href=\"#编程效率障碍No-6：非程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.6：非程序员经理\"></a>编程效率障碍No.6：非程序员经理</h3><p>总会有那些面带微笑，西装笔挺，却不是主修计算机科学，也不懂编程项目的家伙成为了经理。也许他们娶了老板的女儿；也许他们正好在“正确”的时间出现在了“正确”的地方。但是，老板让他们担任了经理，即使他们一窍不通。更糟的是，他们会用外行人的眼光来看待问题，哪怕不伦不类，文不对题。</p>\n<p>有一些程序员表示很欢迎这样的经理，因为愚弄他们很容易。而且他们还承担了来自于更高管理层的炮火。但也有人承认，这些人只会不断地开会，只会妨碍编程。他们几乎给不了任何有用的指导，他们可以提供的只是那么一点质量检测。</p>\n<h3 id=\"编程效率障碍No-7：程序员经理\"><a href=\"#编程效率障碍No-7：程序员经理\" class=\"headerlink\" title=\"编程效率障碍No.7：程序员经理\"></a>编程效率障碍No.7：程序员经理</h3><p>虽然程序员可能会因为不得不与非程序员经理打交道而抱怨，但他们经常悄悄地表示，编程人员去做管理人员更糟糕——有时甚至更糟糕得多。</p>\n<p>他们是前任的天才，可能会决定微观管理项目，然后果决地撕裂大片的代码，因为他们有了一个新的展望。或者，也许他们会闲谈，对于同样的事情，他们是如何用8080汇编或C或Java编程写了一半的代码。在任何情况下，他们更痴迷于技术细节而不是大局，虽然他们被雇来的目的是盯牢后者。</p>\n<h3 id=\"编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\"><a href=\"#编程效率障碍No-8：善于社交的程序员，又名“brogrammer”\" class=\"headerlink\" title=\"编程效率障碍No.8：善于社交的程序员，又名“brogrammer”\"></a>编程效率障碍No.8：善于社交的程序员，又名“brogrammer”</h3><p>虽然程序员可以将每个问题和任何中断的责任归咎于巧言令色的销售团队，但编程人员也必须承认，有一些问题在于他们自己。程序员被聘请的目的在于他们的计算机技术，而不是他们的人际交往能力。</p>\n<p>程序员通常不善于沟通，不知道如何表达他们的感受和思维。他们可以准确抓住技术参数，就像庖丁解牛一样迎刃有余。无论客户想要改变什么都不要紧：程序员总是时刻思索着技术参数，即使是在公司野餐上也不外如是。</p>\n<p>尽管程序员通常可以过滤掉对方的特质，但当程序员之间发生磕磕绊绊时也会让团队失败。当同一个团队中两个人有着不同的政治观点，比方说，动态语言或NoSQL，那么团队就会永无宁日。一切都像是在战场一样，战火纷飞，硝烟弥漫。</p>\n<h3 id=\"编程效率障碍No-9：自私或牛仔程序员\"><a href=\"#编程效率障碍No-9：自私或牛仔程序员\" class=\"headerlink\" title=\"编程效率障碍No.9：自私或牛仔程序员\"></a>编程效率障碍No.9：自私或牛仔程序员</h3><p>你从他的代码里发现一个空指针？捕捉空指针于是成为了你的工作。你最好多想一遍要不要传递一个零，因为自私的程序员不会检查除以零错误。这也成为了你的工作。</p>\n<p>牛仔程序员的工作又酷又快，但这是因为他的代码中遗留了许多漏洞，并且没有经过测试。于是这也成为了你的工作，因为如果你不处理这些琐事的话，代码就会崩溃。</p>\n<p>很多团队在最终认识到这一点的时候已经为时已晚。代码块在早期测试中运行良好，但当输入真正的数据之后，各种问题就开始暴露出来。真是一场灾难。</p>\n<h3 id=\"编程效率障碍No-10：可怜的文档\"><a href=\"#编程效率障碍No-10：可怜的文档\" class=\"headerlink\" title=\"编程效率障碍No.10：可怜的文档\"></a>编程效率障碍No.10：可怜的文档</h3><p>写文档需要时间。但由于老板雇我们来是来写代码的，并且通常通过我们写的代码行数来衡量我们的效率。因此既然你想要结果，那么我们就只做你想要的那部分。当然最终我们还是会写文档的，但质量的好坏就不论了。</p>\n<p>有时候，文档虽然很多，但却是几个月或几年前老代码的版本。我们只是还没来得及修改这些旧文档而已，但是，以后我们会同步的——相信我。</p>\n<h3 id=\"编程效率障碍No-11：成为文档的奴隶\"><a href=\"#编程效率障碍No-11：成为文档的奴隶\" class=\"headerlink\" title=\"编程效率障碍No.11：成为文档的奴隶\"></a>编程效率障碍No.11：成为文档的奴隶</h3><p>虽然我们都经历过没有文档的项目，但是空话太多、编码太少反而导致项目失败也很常见。曾有几个人指着满满一书架的文件夹，向我炫耀说：“我专门请人来写文档。”然而要读完这么多文档需要一年的时间。</p>\n<p>程序员通常在处理需求时，会写一些评论和注释，之后充作文档。因此这样的文档，都是一些微小的细节，没有经过认真地总结或没有说到要点上。这在文档中将可能是致命的，当他们没有提供太多的抽象和理解，就只写代码流水账的时候。这样的文档并不具启发性，只是翻译下代码而已。</p>\n<h3 id=\"编程效率障碍No-12：很容易导致分心的环境\"><a href=\"#编程效率障碍No-12：很容易导致分心的环境\" class=\"headerlink\" title=\"编程效率障碍No.12：很容易导致分心的环境\"></a>编程效率障碍No.12：很容易导致分心的环境</h3><p>有一个客户坚持要我每天去他们的办公室，坚持要我使用他们的电脑。然后，他们没有提供任何的办公空间，所以我只能和六个实习生在会议室写代码，此外，这些实习生还需要我用半天的时间回答他们前一天晚上碰到的问题。另外半天的时间则用来指示今天晚上做什么。于是，我基本上做不来自己的工作。</p>\n<p>虽然销售和营销团队可以在背景噪音的环境下茁壮成长，但程序员通常需要图书馆般安静的背景。闲聊，令人心烦意乱的敲击声，或铃声将驱逐程序员的思维走出抽象的工作区，回到现实中。然后，需要几分钟的时间才能重新沉浸于工作区。</p>\n<p>有一位开发人员告诉我，他恨他的新办公桌，因为它靠拢空调出风口，噪音令人难以置信的响，使得他真的很难集中注意力。这可能略有夸张，但的确是一个事实。</p>\n<p>虽然许多企业会提供程序员类似乒乓球桌的娱乐活动，但他们往往忘记了开发人员需要在安静的氛围中集中精神。甚至，他们还将程序员转移到大房间，认为这可以促进合作，殊不知却会导致一有风吹草动，整个房间的程序员都受到干扰。</p>\n<h3 id=\"编程效率障碍No-13：“文化契合”\"><a href=\"#编程效率障碍No-13：“文化契合”\" class=\"headerlink\" title=\"编程效率障碍No.13：“文化契合”\"></a>编程效率障碍No.13：“文化契合”</h3><p>你想拥有自己的办公室？或者你更喜欢团队化的办公室，这样你就可以直接喊出你的问题？你喜欢在清晨开始工作，亦或是你更喜欢熬夜？</p>\n<p>如果团队成员之间的风格相似。那么这支团队往往才能更好地工作。无法找到共同点的团队很快就会失败。没有沟通，最后只会南辕北辙，不知所谓。</p>\n<h3 id=\"编程效率障碍No-14：死守传统技术\"><a href=\"#编程效率障碍No-14：死守传统技术\" class=\"headerlink\" title=\"编程效率障碍No.14：死守传统技术\"></a>编程效率障碍No.14：死守传统技术</h3><p>很多捍卫者认为古老的技术依然很伟大，依然能够完成任务。因此对于为什么要重写代码表示疑虑重重。</p>\n<p>他们想得没错，但他们忘记了保持这些古老代码的成本。所有一切通常都需要用自定义代码进行翻译。某些代码甚至写在ASCII之前，这意味着需要转换输入和输出。旧系统经常会计数空格字符只是为了在数据库中指出这是什么。这就更加需要转换了。</p>\n<p>当然程序员可以通过屏幕抓取，重新格式化，临时构建系统来做大量的工作，但一段时间以后，他们往往需要花费更多的工作来清理混沌的逻辑，以致于腾不出时间来写新的逻辑。</p>\n<h3 id=\"编程效率障碍No-15：对最新的渴望\"><a href=\"#编程效率障碍No-15：对最新的渴望\" class=\"headerlink\" title=\"编程效率障碍No.15：对最新的渴望\"></a>编程效率障碍No.15：对最新的渴望</h3><p>最新的工具自然有意思，但却在没有经过大量时间再次编码以往的工作之前，是不会被开发工作室采用的。走在时代尖端的人总是会扔掉API的整个部分，并重新编写，从而迫使我们这些下游的程序员不得不跟着一起改写代码。我厌烦过，当我不得尽力用Python 2.7的代码对付Python 3.0的代码时，因为依现在的情况，Python已经是一种相对稳定的代码库。</p>\n<p>在许多情况下，新的工具并没有战斗化。例如，Node.js，虽然说相当快，但是只有当你重新学习所有关于死锁的经验教训之后，知道线程优先的时候才能发挥作用。世上没有免费的午餐，工具虽好但都是有代价的。</p>\n"},{"title":"程序员累了怎么办？","date":"2015-10-09T16:00:00.000Z","_content":"\n\n\n程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。\n\n很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。\n\n### 倦怠发生的原因\n\n程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。\n\n+ 第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。\n+ 第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。\n+ 第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。\n+ 第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。\n\n我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。\n\n#### 先从基本的开始。\n\n+ 吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。\n+ 睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。\n+ 不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。\n+ 番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。\n+ 保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。\n\n#### 更具体化的要点\n\n+ 实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。\n+ 参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。\n+ 打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。\n+ 掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。\n+ 休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。\n+ 考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。\n+ 将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。\n\n### 结论\n\n世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。\n\n诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。\n\n所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！\n\n译文链接：[http://www.codeceo.com/article/programmer-tied.html](http://www.codeceo.com/article/programmer-tied.html)\n\n英文原文：[Preventing burnout for programmers](https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa)\n\n翻译作者：[码农网](http://www.codeceo.com/) – 小峰","source":"_posts/程序员累了怎么办？.md","raw":"---\ntitle: 程序员累了怎么办？\ntags: [其它]\ndate: 2015/10/10\n---\n\n\n\n程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。\n\n很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。\n\n### 倦怠发生的原因\n\n程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。\n\n+ 第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。\n+ 第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。\n+ 第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。\n+ 第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。\n\n我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。\n\n#### 先从基本的开始。\n\n+ 吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。\n+ 睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。\n+ 不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。\n+ 番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。\n+ 保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。\n\n#### 更具体化的要点\n\n+ 实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。\n+ 参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。\n+ 打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。\n+ 掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。\n+ 休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。\n+ 考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。\n+ 将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。\n\n### 结论\n\n世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。\n\n诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。\n\n所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！\n\n译文链接：[http://www.codeceo.com/article/programmer-tied.html](http://www.codeceo.com/article/programmer-tied.html)\n\n英文原文：[Preventing burnout for programmers](https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa)\n\n翻译作者：[码农网](http://www.codeceo.com/) – 小峰","slug":"程序员累了怎么办？","published":1,"updated":"2016-05-12T06:47:59.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3use001wtsqb2k8b26cs","content":"<p>程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。</p>\n<p>很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。</p>\n<h3 id=\"倦怠发生的原因\"><a href=\"#倦怠发生的原因\" class=\"headerlink\" title=\"倦怠发生的原因\"></a>倦怠发生的原因</h3><p>程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。</p>\n<ul>\n<li>第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。</li>\n<li>第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。</li>\n<li>第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。</li>\n<li>第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。</li>\n</ul>\n<p>我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。</p>\n<h4 id=\"先从基本的开始。\"><a href=\"#先从基本的开始。\" class=\"headerlink\" title=\"先从基本的开始。\"></a>先从基本的开始。</h4><ul>\n<li>吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。</li>\n<li>睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。</li>\n<li>不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。</li>\n<li>番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。</li>\n<li>保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。</li>\n</ul>\n<h4 id=\"更具体化的要点\"><a href=\"#更具体化的要点\" class=\"headerlink\" title=\"更具体化的要点\"></a>更具体化的要点</h4><ul>\n<li>实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。</li>\n<li>参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。</li>\n<li>打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。</li>\n<li>掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。</li>\n<li>休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。</li>\n<li>考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。</li>\n<li>将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。</p>\n<p>诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。</p>\n<p>所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！</p>\n<p>译文链接：<a href=\"http://www.codeceo.com/article/programmer-tied.html\" target=\"_blank\" rel=\"external\">http://www.codeceo.com/article/programmer-tied.html</a></p>\n<p>英文原文：<a href=\"https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa\" target=\"_blank\" rel=\"external\">Preventing burnout for programmers</a></p>\n<p>翻译作者：<a href=\"http://www.codeceo.com/\" target=\"_blank\" rel=\"external\">码农网</a> – 小峰</p>\n","excerpt":"","more":"<p>程序员在编程的时候因为心力交瘁，从而失去工作热情的现象并不罕见。</p>\n<p>很多文章都可以成为这一方面的证据，证明这已经是IT行业一个普遍现象。因为我已经有处理过职业倦怠的经验，所以我想要更深入地探索这个问题，帮助大家解决甚至预防它。</p>\n<h3 id=\"倦怠发生的原因\"><a href=\"#倦怠发生的原因\" class=\"headerlink\" title=\"倦怠发生的原因\"></a>倦怠发生的原因</h3><p>程序员比其他领域的专业人士更容易产生职业倦怠。至于为什么会出现这种情况，我也没有一个明确的答案，但我认为有四个主要原因。</p>\n<ul>\n<li>第一个是生理原因。每天坐在办公桌前，面对着电脑，是不健康的，会让人更加无精打采、昏昏欲睡。嗜睡还可能导致其他不良的生活习惯，如吃零食，抽烟，熬夜等。然后最终导致郁结于心，产生倦怠感。</li>\n<li>第二个原因是，编程是认知高度密集并且压力非常大的工作，会导致心理疲劳和损伤。</li>\n<li>第三，有可能你现在已经精疲力竭了，因为正在做的工作耗尽了你的力量，并且收获甚微。对此，唯一的解决办法是离开一段时间，好好反省下——如果不考虑钱的因素，你希望做什么样的工作。</li>\n<li>第四个原因不是我想出来的，是我在《Hacker News》的评论部分发现的。有一个人准确地描述了，“职业倦怠是由反复做大量牺牲，或努力完成高风险问题最后却以失败告终而导致的。这是伏隔核（nucleus accumbens）负面预测落差的结果。你的大脑需要理智地应对失败。这一条说得真的太对了。在创建软件的过程中，基本上没有一天不是处在各种失败和挫折中。</li>\n</ul>\n<p>我本身也经历过好几次职业倦怠。虽然我没有一次放弃编程，但偶尔我也会怀疑我选择的职业是否正确。所以，从那时起，我开始注重策略化的工作方法，以保持长效的动力和生产力。我将在这篇文章中介绍我的一些开发习惯，以及一些可以预防或甚至消除倦怠的技术手段。</p>\n<h4 id=\"先从基本的开始。\"><a href=\"#先从基本的开始。\" class=\"headerlink\" title=\"先从基本的开始。\"></a>先从基本的开始。</h4><ul>\n<li>吃好。不要以为做个素食主义者就万事大吉了。试着逐渐用白开水代替苏打，低糖饮食，多吃蔬菜，不要吃得过饱。还有最重要的是要持续下去。</li>\n<li>睡好。这包括良好的睡眠质量和充足的睡眠时间。更好的睡眠环境，能够让我们一觉醒来倍感清爽。具体的一个技巧就是减少会让人彻夜难眠的蓝光照射。这可以通过安装Flux，来调整计算机显示器的色彩。</li>\n<li>不要劳累过度。已经有很多证据表明，生产效率，即输出，会在经过4个小时聚精会神的工作之后，急剧降低。像程序员这类认知高度密集的职业，要想长期保持高效，那是不可能的。</li>\n<li>番茄工作法。这对于既要保持生产力，又要获得一些必要休息的程序员，是一个既简单又有效的方法。番茄工作法，即集中精神工作25分钟，然后休息5分钟，然后循环。如果在每次的工作时间都有一个特定目标，效果会更好。理想情况下，在休息时间里，应该去做一些远离计算机的活动。如散步，俯卧撑等。当然你还可以在三次番茄工作法后，休息个30分钟，效果也很好。</li>\n<li>保持活性，保持前进。我本来想说的是——运动，但很多人有一种误解就是，认为运动必须包括去健身房，或其他。但是在现实中，保持活性也可以通过用爬楼梯代替乘电梯，或者将汽车停放在一角，而选择骑车上班，总之，其他在日常中就能运动的方式更易于实现，而不是让人整天沉溺在电脑前。</li>\n</ul>\n<h4 id=\"更具体化的要点\"><a href=\"#更具体化的要点\" class=\"headerlink\" title=\"更具体化的要点\"></a>更具体化的要点</h4><ul>\n<li>实验，玩，学，原型。这些事情能让你在短期内获益匪浅，并且迅速输出。例如，以同样的你惯用的方式，不断地建立网站。但是，随着时间的推移这会逐渐变得乏味，让人提不起一点兴趣。编程有部分也是工程，需要使用经过充分验证的技术用于生产软件。但它也可以让你玩乐、实验和尝试新想法。将20％的时间消磨在技术上是避免职业倦怠最有效的策略之一。所谓消磨在技术上可以是尝试新的库，也可以是创造一些有趣的但与工作无关的东西，又或是学习一些自己以前不曾涉猎的内容，如函数式编程。</li>\n<li>参加聚会，会议和收听播客。编程会让人感到孤单。和其他开发人员碰面，或在播客上听他们的经验，能让你更在意和注重自己的工作。没有人喜欢抱怨，但是分享或聆听来自于其他程序员的奋斗经历，以及他们如何克服困难的过程，能够激励你继续前进。</li>\n<li>打造良好的工作环境，千万不要在工具上吝啬。能快速编译的PC，能让你的时间不必浪费在没有必要的等待上。确保有一个舒适的椅子、桌子和显示器以及设置。如果你在嘈杂的环境中工作，那么买一个高品质的耳机，将噪音隔离开来。</li>\n<li>掌握工具。良好的工具可以使得编程更加愉快，掌握这些工具能让工作更加高效。这是众所周知的一点，但我还是要再重复一遍。了解工具，如编辑器，操作系统，命令行中的所有快捷方式，可以为你节省很多时间。自动化日常任务可以加快进程，进一步远离倦怠。</li>\n<li>休息，涉猎其他方面。除了编程之外，还有许多有趣的活动。例如：体育运动，文化活动，sex，阅读，乐高积木，社交活动，钓鱼，烘焙，摄影等。如果你总是持续做一件事，如编程，那么总有一天你会不可避免地心力交瘁。所以，做一些看似无关但实际可以重新点燃激情的工作，这些工作或许还能激发你新的想法和思路，就像那位传奇的诺贝尔奖获得者理查德·费曼学习板摆动一样。</li>\n<li>考虑更换工作或启动一个不同的项目。职业倦怠也有可能是因为你总是在做无趣，又耗费心力的工作，如整天微调现有的代码库。也有可能是因为你现在工作的项目已经不符合你的兴趣，或你的价值标准。此外，如果你发现编码再也激发不了你的激情，那么也可以考虑相关领域，如信息架构，系统管理等，也许可以再次点燃你的激情。</li>\n<li>将那些你可以顺利完成的工作，整合为日常任务。这些工作包括测试代码，写注释，改善变量命名等等，这些都可以释放内啡肽，有助于恢复工作行为。这条技巧意在让我们的大脑对我们做的工作更有积极性。</li>\n</ul>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>世上并没有治愈职业倦怠的仙丹妙药，而且每个人的情况都不尽相同。所以，希望我上面列出来的这些我觉得有效的小贴士也能为你所用。</p>\n<p>诚然，我们需要时间来培养新的习惯。但是吃得好，睡得好，锻炼和好好照顾自己，能让你感觉更好，从而帮助你在完成工作的时候做得更好，并保持对编程的热爱。</p>\n<p>所以，come on。不要强迫自己必须工作10小时/天，6天/周的工作量。科学证明，输出一定数量聚精会神的工作小时后，注意力会急剧下降。因此，上班时间集中注意力高效地使用番茄工作法工作，下班之后就彻底弃之脑后吧。学会说不，除了编程之外，做点自己喜欢的事情。这才是真正重要的一点，加油吧，骚年！</p>\n<p>译文链接：<a href=\"http://www.codeceo.com/article/programmer-tied.html\">http://www.codeceo.com/article/programmer-tied.html</a></p>\n<p>英文原文：<a href=\"https://medium.com/@karolisram/preventing-burnout-for-programmers-12b4968adbaa\">Preventing burnout for programmers</a></p>\n<p>翻译作者：<a href=\"http://www.codeceo.com/\">码农网</a> – 小峰</p>\n"},{"title":"糟糕程序员的编程风格","date":"2016-02-16T16:00:00.000Z","_content":"\n\n\n> 有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？\n\n### 糟糕的开发人员\n\n如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。\n\n首先让我们先来了解关于糟糕的开发人员的两种主要类型：\n\n**平庸的开发人员**\n\n从本质来看，这两者是相同的，但是它们通常表现出不同的行为。\n\n**牛仔程序员**\n\n牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。\n\n那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？\n\n1、编码速度非常快\n\n通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。\n\n牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……\n\n2、凌乱、不可读的代码\n\n快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。\n\n凌乱的代码会导致……\n\n3、Bug，无处不在的bug\n\n如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。\n\n更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。\n\n总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。\n\n如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。\n\n### 自大\n\n有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。\n\n这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。\n\n只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。\n\n使得这些程序员变得糟糕的最重要的属性，是自大。\n\n糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。\n\n更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。\n\n最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。\n\n请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。\n\n### 平庸的开发者\n\n这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。\n\n不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。\n\n也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。\n\n关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。\n\n### 问题的核心\n\n促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。\n\n更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。\n\n这也是为什么在糟糕程序员的代码上经常可以发现大量复制&粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&粘贴本身并不是坏事，但只有在下面这些情况下：\n\n你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）\n\n确信复制＆粘贴的代码会有效工作\n\n只用于测试/检验\n\n糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。\n\n此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。\n\n总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。\n\n糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。\n\n每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。\n\n### 优秀的开发人员\n\n经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。\n\n有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。\n\n的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。\n\n那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。\n\n### 真正优秀的开发人员\n\n下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：\n\n> 乐于助人的开发人员\n\nMVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。\n\n由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。\n\nMVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。\n\n最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。\n\n### 总结\n\n要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。\n\n[转载自：http://www.codeceo.com/article/bad-programming-style.html](http://www.codeceo.com/article/bad-programming-style.html)\n","source":"_posts/糟糕程序员的编程风格.md","raw":"---\ntitle: 糟糕程序员的编程风格\ntags: [其它]\ndate: 2016/02/17\n---\n\n\n\n> 有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？\n\n### 糟糕的开发人员\n\n如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。\n\n首先让我们先来了解关于糟糕的开发人员的两种主要类型：\n\n**平庸的开发人员**\n\n从本质来看，这两者是相同的，但是它们通常表现出不同的行为。\n\n**牛仔程序员**\n\n牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。\n\n那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？\n\n1、编码速度非常快\n\n通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。\n\n牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……\n\n2、凌乱、不可读的代码\n\n快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。\n\n凌乱的代码会导致……\n\n3、Bug，无处不在的bug\n\n如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。\n\n更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。\n\n总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。\n\n如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。\n\n### 自大\n\n有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。\n\n这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。\n\n只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。\n\n使得这些程序员变得糟糕的最重要的属性，是自大。\n\n糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。\n\n更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。\n\n最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。\n\n请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。\n\n### 平庸的开发者\n\n这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。\n\n不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。\n\n也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。\n\n关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。\n\n### 问题的核心\n\n促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。\n\n更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。\n\n这也是为什么在糟糕程序员的代码上经常可以发现大量复制&粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&粘贴本身并不是坏事，但只有在下面这些情况下：\n\n你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）\n\n确信复制＆粘贴的代码会有效工作\n\n只用于测试/检验\n\n糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。\n\n此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。\n\n总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。\n\n糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。\n\n每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。\n\n### 优秀的开发人员\n\n经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。\n\n有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。\n\n的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。\n\n那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。\n\n### 真正优秀的开发人员\n\n下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：\n\n> 乐于助人的开发人员\n\nMVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。\n\n由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。\n\nMVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。\n\n最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。\n\n### 总结\n\n要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。\n\n[转载自：http://www.codeceo.com/article/bad-programming-style.html](http://www.codeceo.com/article/bad-programming-style.html)\n","slug":"糟糕程序员的编程风格","published":1,"updated":"2016-05-12T06:46:52.263Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciozi3usg001xtsqb11mwk8rx","content":"<blockquote>\n<p>有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？</p>\n</blockquote>\n<h3 id=\"糟糕的开发人员\"><a href=\"#糟糕的开发人员\" class=\"headerlink\" title=\"糟糕的开发人员\"></a>糟糕的开发人员</h3><p>如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。</p>\n<p>首先让我们先来了解关于糟糕的开发人员的两种主要类型：</p>\n<p><strong>平庸的开发人员</strong></p>\n<p>从本质来看，这两者是相同的，但是它们通常表现出不同的行为。</p>\n<p><strong>牛仔程序员</strong></p>\n<p>牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。</p>\n<p>那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？</p>\n<p>1、编码速度非常快</p>\n<p>通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。</p>\n<p>牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……</p>\n<p>2、凌乱、不可读的代码</p>\n<p>快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。</p>\n<p>凌乱的代码会导致……</p>\n<p>3、Bug，无处不在的bug</p>\n<p>如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。</p>\n<p>更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。</p>\n<p>总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。</p>\n<p>如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。</p>\n<h3 id=\"自大\"><a href=\"#自大\" class=\"headerlink\" title=\"自大\"></a>自大</h3><p>有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。</p>\n<p>这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。</p>\n<p>只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。</p>\n<p>使得这些程序员变得糟糕的最重要的属性，是自大。</p>\n<p>糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。</p>\n<p>更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。</p>\n<p>最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。</p>\n<p>请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。</p>\n<h3 id=\"平庸的开发者\"><a href=\"#平庸的开发者\" class=\"headerlink\" title=\"平庸的开发者\"></a>平庸的开发者</h3><p>这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。</p>\n<p>不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。</p>\n<p>也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。</p>\n<p>关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。</p>\n<h3 id=\"问题的核心\"><a href=\"#问题的核心\" class=\"headerlink\" title=\"问题的核心\"></a>问题的核心</h3><p>促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。</p>\n<p>更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。</p>\n<p>这也是为什么在糟糕程序员的代码上经常可以发现大量复制&amp;粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&amp;粘贴本身并不是坏事，但只有在下面这些情况下：</p>\n<p>你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）</p>\n<p>确信复制＆粘贴的代码会有效工作</p>\n<p>只用于测试/检验</p>\n<p>糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。</p>\n<p>此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。</p>\n<p>总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。</p>\n<p>糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。</p>\n<p>每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。</p>\n<h3 id=\"优秀的开发人员\"><a href=\"#优秀的开发人员\" class=\"headerlink\" title=\"优秀的开发人员\"></a>优秀的开发人员</h3><p>经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。</p>\n<p>有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。</p>\n<p>的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。</p>\n<p>那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。</p>\n<h3 id=\"真正优秀的开发人员\"><a href=\"#真正优秀的开发人员\" class=\"headerlink\" title=\"真正优秀的开发人员\"></a>真正优秀的开发人员</h3><p>下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：</p>\n<blockquote>\n<p>乐于助人的开发人员</p>\n</blockquote>\n<p>MVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。</p>\n<p>由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。</p>\n<p>MVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。</p>\n<p>最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。</p>\n<p><a href=\"http://www.codeceo.com/article/bad-programming-style.html\" target=\"_blank\" rel=\"external\">转载自：http://www.codeceo.com/article/bad-programming-style.html</a></p>\n","excerpt":"","more":"<blockquote>\n<p>有一种说法是，“一个伟大的程序员相当于10个平庸的程序员”。没有人愿意被贴上了糟糕程序员的标签，但一个可悲的事实是，很多开发人员没有意识到他们自己就属于这一群体。没有人愿意问自己：我是一个糟糕的开发人员吗？</p>\n</blockquote>\n<h3 id=\"糟糕的开发人员\"><a href=\"#糟糕的开发人员\" class=\"headerlink\" title=\"糟糕的开发人员\"></a>糟糕的开发人员</h3><p>如果你还是编程新手，并且担心自己编写的是糟糕的代码，那么可能你还不是高手。不过，你也不用因此灰心丧气，因为只要你不是无可救药的，那就都还有改进的余地。</p>\n<p>首先让我们先来了解关于糟糕的开发人员的两种主要类型：</p>\n<p><strong>平庸的开发人员</strong></p>\n<p>从本质来看，这两者是相同的，但是它们通常表现出不同的行为。</p>\n<p><strong>牛仔程序员</strong></p>\n<p>牛仔程序员会毁掉一个团队，他们喜欢单枪匹马的做项目，并且项目往往都很短命。</p>\n<p>那些从来没有受到过任何编写可用代码的指导，自学成才的程序员通常会有成为牛仔程序员的危险，并且很多优秀的，有经验的程序员有可能在他们的编码职业生涯的初期，就是一个牛仔程序员。那么，什么是牛仔程序员的关键属性呢？</p>\n<p>1、编码速度非常快</p>\n<p>通常，这种类型的不良开发者开发新功能的速度要远远快过平均值，然而，不幸的是，那么不懂代码的人，因此会认为这些“快枪手”很牛掰（这只会进一步让这些牛仔程序员在自我膨胀的道路上越走越远）。这类开发人员在独自工作的时候最佳，在客户对时间要求特别紧迫只要尽快实现功能的时候最适合。</p>\n<p>牛仔程序员编码速度非常快——这意味着，他们的代码没有对可维护性有任何规划。所以这就会导致……</p>\n<p>2、凌乱、不可读的代码</p>\n<p>快速代码设计创建出来的项目常常会乱得一塌糊涂（或者更确切地说，他们就没有进行代码设计）。这种混乱的代码，通常被称为“意大利面条式代码”，这指的是它的形状，而不是味道。意大利面条式代码难于理解，并且通常没有必要那么庞大和复杂，从而导致了其他人难于理解程序员的所作所为，因此这种代码通常是维护的噩梦。这意味着如果有人不幸和一个牛仔程序员一起工作，那么整体生产力就会大幅度下降。</p>\n<p>凌乱的代码会导致……</p>\n<p>3、Bug，无处不在的bug</p>\n<p>如果一家公司的软件在变大和变得更加复杂之后，他们的代码仍然是一堆意大利面条，那么它就会成为一个等待爆炸的定时炸弹。在最坏的情况下，其后果甚至会像丰田汽车意外加速一样严重。众所周知，丰田汽车召回是一场灾难。</p>\n<p>更重要的是，意大利面条式代码是不可扩展的。这意味着如果增加新功能，那么这种代码就像行走在雷区上——不知道什么时候，就会爆炸。这通常是因为牛仔程序员将每个功能都混合在一起，于是任何变化都可能会破坏软件。如果有更好的代码设计和/或单元测试，或许就能阻止这种情况，但是，牛仔程序员不在乎他们的代码是否是可用的，也不想编写测试（因为需要时间）。更甚者，从糟糕的设计决策衍生出的代码结构方式，通常是不可测试的，甚至是无法调试的。在牛仔程序员身上，还有一种常见的情况是，在他们迅速“修复”一些bug的同时，创造出了更多的bug。因此他们总是感觉很忙，就像英勇的消防员，疲于到处灭火。</p>\n<p>总而言之，每一个糟糕开发人员创造的bug和错误都会导致消耗生产力。哪怕刚开始的时候，他们看上去很牛，总是能按时完成其他开发人员不敢轻易允诺的编码任务，但是这是以各种意外错误频频降临为代价的，而这原本可以通过优秀开发人员的精心设计和简洁代码编程扼杀在襁褓中。</p>\n<p>如果你超过80％的开发时间都花在了调试自己的代码上，并且调试过程像一场噩梦的话（即这边解决了一个bug，那边又出来了另一个bug），那么说明代码库不佳，并且你需要改进你的代码。</p>\n<h3 id=\"自大\"><a href=\"#自大\" class=\"headerlink\" title=\"自大\"></a>自大</h3><p>有的牛仔程序员并不坏，因为他们只是根据管理/客户不可能的期限要求，才生产出了意大利面条式代码（但是，那些重视自己代码的开发人员会选择离开这样的公司或拒绝这样的客户）。很多初学者和初级开发人员是因为没有编码计划，因而生产出了一堆有bug的代码，但有时是因为他们缺乏问题的经验，从而做出了错误的决定。</p>\n<p>这些初学者通过接受来自于资深的优秀的开发者的指导，是可以改正的。但是，如果他们的身边尽是和他们一样或平庸的开发人员，那么他们就会陷入自我感觉良好的错觉中。</p>\n<p>只要你愿意为自己的错误承担责任，只要你愿意从错误中学习，那么你就不算是一个糟糕的开发人员。</p>\n<p>使得这些程序员变得糟糕的最重要的属性，是自大。</p>\n<p>糟糕的程序员认为他们的代码是完美的，只会归咎于是客户的愚蠢导致了程序的崩溃，而不是反思——为什么他们做的软件会崩溃。牛仔程序员通常是自私的开发者，因为他们不会对那些不得不为他们“擦屁股”的开发人员抱有一丝同情心。</p>\n<p>更为重要的是，这些自大的程序员总是认为自己的智力高人一等，总是自认为别人没有注释不行，总是认为那些不明白他们代码的人是因为太愚蠢，但从来不曾想想为什么大家不理解他们的代码。这种一直坚定不移地认为他们自己是对的，总是认为自己高人一等的结果就是，没有与人好好沟通就自作主张地构建了可能会给团队带来很多问题和麻烦的功能。还有的人由于（毫无正当理由地）深信自己的代码更好，因而有时候甚至会回避“最佳做法”或“标准”。</p>\n<p>最糟的是，糟糕的程序员都不愿意听别人说教，不愿意从错误中学习，因为他们不承认他们犯了错误，正如前面提到的，他们通常会推卸责任。</p>\n<p>请注意，这并不意味着牛仔程序员在现实中就是难相处或低智商的人——也许他们就是你遇到过的最和蔼亲切的人——但是，在他们面对批评的时候，却有着一种根深蒂固的自大和不愿意承担过错责任的心态。</p>\n<h3 id=\"平庸的开发者\"><a href=\"#平庸的开发者\" class=\"headerlink\" title=\"平庸的开发者\"></a>平庸的开发者</h3><p>这里我指的平庸意味着“不能胜任”。在某些方面，平庸的开发者比牛仔程序员更糟，因为他们知道自己不能够胜任，却不愿意去努力，满足于停留在技能阶梯的底层。</p>\n<p>不像牛仔程序员，平庸的开发者通常对编程缺乏兴趣，因此在理解编程概念方面有困难。他们需要很长的时间来创建一些东西，同时生产的代码欠佳并且充满问题。他们通常对编码毫无没有激情/兴趣可言，他们在学习新技术时进展缓慢，或通常没有实际的操作经验。</p>\n<p>也许平庸的开发者不像牛仔程序员那样具有破坏性，这是因为他们处在一个团队中，但他们绝对不会为团队带来任何好处，并且他们提出的解决办法总是劣于优秀的开发人员（他们常常会因为错误的决策，导致满是bug/低效的代码）。</p>\n<p>关于平庸的开发者，我就不再多说什么了。最差的估计是，他们可能会拖累整个团队，最好的情况是，他们勉勉强强也算是在最后期限内完成了任务。</p>\n<h3 id=\"问题的核心\"><a href=\"#问题的核心\" class=\"headerlink\" title=\"问题的核心\"></a>问题的核心</h3><p>促使开发者盘踞“糟糕”宝座的核心是因为他们缺乏成为一个更好的程序员的愿望。糟糕的程序员对目前的行为方式感到满意和舒适。更糟的是，牛仔程序员和平庸的程序员通常自认为知道那些其实他们不知道的东西。</p>\n<p>更重要的是，糟糕程序员往往对学习新事物不感兴趣，因此不会有意地去改进自己。</p>\n<p>这也是为什么在糟糕程序员的代码上经常可以发现大量复制&amp;粘贴的东西，因为他们基本上不会去搞清楚为什么有些地方这些代码奏效而有些地方不奏效。复制&amp;粘贴本身并不是坏事，但只有在下面这些情况下：</p>\n<p>你知道你正在在做什么（很多糟糕的开发人员会自以为他们知道自己在做什么）</p>\n<p>确信复制＆粘贴的代码会有效工作</p>\n<p>只用于测试/检验</p>\n<p>糟糕的开发者通常只会复制粘贴StackOverflow代码，而不是去理解它，或者调整解决方案以匹配他们自己的代码。</p>\n<p>此外，那些始终坚持所谓的“最佳做法”而不去理解为什么这些做法会被认为是“最好”的程序员也可以被归类为糟糕的程序员。</p>\n<p>总而言之，也许你并不需要知道一个大型的复杂框架的每一个细节的工作原理。但是，你至少应该弄清楚你使用的部分是如何工作的。</p>\n<p>糟糕的程序员从来不会从自己的错误中吸取教训，要么是因为不承认他们犯了错误，要么是因为他们缺乏学习的欲望，要么两者皆有。</p>\n<p>每个人都会犯错，每个程序员都会制造bug，这没有什么大不了。但是，如果你总是在重复相同的错误，那就意味着你是一个不学习的糟糕的开发者。</p>\n<h3 id=\"优秀的开发人员\"><a href=\"#优秀的开发人员\" class=\"headerlink\" title=\"优秀的开发人员\"></a>优秀的开发人员</h3><p>经过漫谈有关与糟糕开发者的相关特征，你可能对是什么造就了优秀开发人员已经有了一个模糊的想法。优秀的开发人员是开发队伍的中坚力量，并且他们通常具有以下特征。</p>\n<p>有着一种山外有山人外有人的谦逊认识，愿意为错误承担责任，从错误中学习，写出的代码是可读的、结构化的、经过可靠设计的、可被轻松调试的，努力理解事物的工作原理，和团队中的其他人有着良好的沟通/协作，虚心接受批评和开放对待不同的方法，保持学习新技术的心态，乐于解决问题等等。</p>\n<p>的确，关于何为高质量代码是很难衡量的（这就是为什么我没有将它包含在特征中，但是这确实是组成开发人员“优秀”的一个重要方面）。</p>\n<p>那么我们怎么知道自己写的代码是否良好呢？请看漫画中的完美解释。</p>\n<h3 id=\"真正优秀的开发人员\"><a href=\"#真正优秀的开发人员\" class=\"headerlink\" title=\"真正优秀的开发人员\"></a>真正优秀的开发人员</h3><p>下面这两种类型的开发人员，才是真正能够帮助团队的开发人员：</p>\n<blockquote>\n<p>乐于助人的开发人员</p>\n</blockquote>\n<p>MVP型开发者不希望只是简单地解决问题，他们会努力寻找解决问题的最佳方法。他们能应付挑战，因此在困难的任务面前总是表现出色——这也是为什么MVP型开发者比大多数开发人员更富有生产力的原因。正是由于这种爱挑战的冒险心态，所以如果雇主分配给他们的工作太容易或太平庸的话，可能会留不住他们，因为一旦他们感到厌倦的话，可能就会选择离开。</p>\n<p>由于MVP型开发者对自己工作的自豪感，因此他们常常会在质量和性能上吹毛求疵。事实上，他们会考虑很多边缘情况，在发生之前就仔细斟酌。在某些情况下，他们是自己的QA工程师，会在用户之前先检验自己的代码。他们不会因为所谓的“最佳实践”，就盲目地去做TDD，但是他们会设计程序，从而大大减少调试的时间。因此，一个MVP型程序员的生产效率至少是一个糟糕程序员的10倍。</p>\n<p>MVP型开发者有着强烈的好奇心，会不惜一切代价地去寻找事物“为什么”工作或不工作的原因。他们会花很多时间来阅读有关编程的内容，以便于跟上新技术，但却不会随大流，因为他们更感兴趣的是靠自己去找出问题的根源。他们非常热爱编码，所以经常在业余时间编程，或者是捣鼓业务项目，或者是尝试新的技术、工具和语言。</p>\n<p>最后，MVP型开发者自信且谦逊，因为他们始终牢记，三人行必有我师，他们喜欢和更优秀的人才一起合作，因为他们能从这些更好的开发人员身上学习。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>要想成为一个优秀的，甚至是伟大的开发人员，最重要的因素是自己。也许这需要天赋和一种真正与生俱来的激情，才能成为顶尖的程序员，但只要对编程有兴趣，任何人都可以是一个“好”的程序员。如果你不想成为一个优秀的程序员，那么没有人，可以帮你实现。你才是自己最大的敌人和对手，你的目标应该始终是成为一个比现在更好的程序员。</p>\n<p><a href=\"http://www.codeceo.com/article/bad-programming-style.html\">转载自：http://www.codeceo.com/article/bad-programming-style.html</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciozi3up10000tsqbauix0i63","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3upq0007tsqb2g5le2ft"},{"post_id":"ciozi3upl0006tsqb9makq0yh","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3upt0009tsqbxj07plur"},{"post_id":"ciozi3upr0008tsqbgopa130q","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3upx000ctsqb3ba7a8tm"},{"post_id":"ciozi3up90001tsqbn0m5mytn","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3uqh000htsqbo433txo0"},{"post_id":"ciozi3up90001tsqbn0m5mytn","tag_id":"ciozi3upw000btsqb3v3v7vi4","_id":"ciozi3uqk000jtsqbsmwa14ru"},{"post_id":"ciozi3uqc000etsqbnaza1us2","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3uqq000mtsqbrqtfnidu"},{"post_id":"ciozi3upg0003tsqb12i4u864","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3uqu000otsqbsxaql61n"},{"post_id":"ciozi3uqo000ltsqbwjt8cjdg","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3uqy000rtsqbadvyk7gh"},{"post_id":"ciozi3uqo000ltsqbwjt8cjdg","tag_id":"ciozi3upw000btsqb3v3v7vi4","_id":"ciozi3ur0000ttsqbnqffunc0"},{"post_id":"ciozi3uqo000ltsqbwjt8cjdg","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3ur7000wtsqbqnpugan3"},{"post_id":"ciozi3upj0004tsqbjf0qr6kw","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3urb000ytsqb18k9yhrd"},{"post_id":"ciozi3uqr000ntsqbwesaaoop","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3urg0011tsqbstxameeu"},{"post_id":"ciozi3uqw000qtsqbsj33smx3","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3urj0013tsqbz67hepha"},{"post_id":"ciozi3upu000atsqb28ic6xve","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3urn0016tsqb3uiwx553"},{"post_id":"ciozi3upu000atsqb28ic6xve","tag_id":"ciozi3uqu000ptsqbtc0rcrac","_id":"ciozi3urt0018tsqbca16mng3"},{"post_id":"ciozi3uqz000stsqbhtxloz71","tag_id":"ciozi3upd0002tsqbrvpnopky","_id":"ciozi3urv001atsqb2ou8zv5u"},{"post_id":"ciozi3upy000dtsqbxrrzxkwr","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3urv001btsqbm7st2b9h"},{"post_id":"ciozi3upy000dtsqbxrrzxkwr","tag_id":"ciozi3uqu000ptsqbtc0rcrac","_id":"ciozi3urx001dtsqbitnvrnwt"},{"post_id":"ciozi3uqg000gtsqbje6m8mn9","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3urx001etsqb9bq7usbo"},{"post_id":"ciozi3uqg000gtsqbje6m8mn9","tag_id":"ciozi3uqu000ptsqbtc0rcrac","_id":"ciozi3ury001gtsqb3hqb3zms"},{"post_id":"ciozi3urg0012tsqbwdei135s","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3us0001htsqb6zdm12ac"},{"post_id":"ciozi3urg0012tsqbwdei135s","tag_id":"ciozi3uqu000ptsqbtc0rcrac","_id":"ciozi3us1001jtsqb79v93fg4"},{"post_id":"ciozi3uqi000itsqbmn1euw92","tag_id":"ciozi3upl0005tsqbzizrlvyp","_id":"ciozi3us1001ktsqbbuz11zcd"},{"post_id":"ciozi3uqi000itsqbmn1euw92","tag_id":"ciozi3uqu000ptsqbtc0rcrac","_id":"ciozi3us3001mtsqb0njyvfgo"},{"post_id":"ciozi3ur2000vtsqbzwv89sbu","tag_id":"ciozi3urt0019tsqbi0xu3q7e","_id":"ciozi3us3001ntsqbrjhsq9b2"},{"post_id":"ciozi3ur2000vtsqbzwv89sbu","tag_id":"ciozi3urw001ctsqbeosicd75","_id":"ciozi3us4001otsqbaxvuoo9h"},{"post_id":"ciozi3ur9000xtsqbiogqfy48","tag_id":"ciozi3urt0019tsqbi0xu3q7e","_id":"ciozi3us5001qtsqbbgpox7do"},{"post_id":"ciozi3ur9000xtsqbiogqfy48","tag_id":"ciozi3urw001ctsqbeosicd75","_id":"ciozi3us5001rtsqb0t38y6d0"},{"post_id":"ciozi3urd0010tsqby6f3l132","tag_id":"ciozi3us2001ltsqbfmdgrgur","_id":"ciozi3us6001ttsqbnj5uvp54"},{"post_id":"ciozi3url0015tsqbjmw013j5","tag_id":"ciozi3us2001ltsqbfmdgrgur","_id":"ciozi3us7001utsqbqvq81ija"},{"post_id":"ciozi3urq0017tsqbvjgzv0yo","tag_id":"ciozi3us2001ltsqbfmdgrgur","_id":"ciozi3us9001vtsqbp7ejph72"},{"post_id":"ciozi3use001wtsqb2k8b26cs","tag_id":"ciozi3us2001ltsqbfmdgrgur","_id":"ciozi3usi001ytsqbkxqo76wf"},{"post_id":"ciozi3usg001xtsqb11mwk8rx","tag_id":"ciozi3us2001ltsqbfmdgrgur","_id":"ciozi3usj001ztsqbz7svqmi7"}],"Tag":[{"name":"css","_id":"ciozi3upd0002tsqbrvpnopky"},{"name":"javascript","_id":"ciozi3upl0005tsqbzizrlvyp"},{"name":"jquery","_id":"ciozi3upw000btsqb3v3v7vi4"},{"name":"angularjs","_id":"ciozi3uqu000ptsqbtc0rcrac"},{"name":"database","_id":"ciozi3urt0019tsqbi0xu3q7e"},{"name":"mongodb","_id":"ciozi3urw001ctsqbeosicd75"},{"name":"其它","_id":"ciozi3us2001ltsqbfmdgrgur"}]}}